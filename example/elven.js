var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x3) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x3, {
  get: (a3, b4) => (typeof require !== "undefined" ? require : a3)[b4]
}) : x3)(function(x3) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x3 + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod2) => function __require2() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from3, except, desc) => {
  if (from3 && typeof from3 === "object" || typeof from3 === "function") {
    for (let key of __getOwnPropNames(from3))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod2, secondTarget) => (__copyProps(target, mod2, "default"), secondTarget && __copyProps(secondTarget, mod2, "default"));
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports2) {
    "use strict";
    init_shim();
    exports2.byteLength = byteLength;
    exports2.toByteArray = toByteArray;
    exports2.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i2 = 0, len = code2.length; i2 < len; ++i2) {
      lookup[i2] = code2[i2];
      revLookup[code2.charCodeAt(i2)] = i2;
    }
    var i2;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i3;
      for (i3 = 0; i3 < len2; i3 += 4) {
        tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i3 = start; i3 < end; i3 += 3) {
        tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports2) {
    init_shim();
    exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e2, m3;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i2 = isLE ? nBytes - 1 : 0;
      var d3 = isLE ? -1 : 1;
      var s2 = buffer[offset + i2];
      i2 += d3;
      e2 = s2 & (1 << -nBits) - 1;
      s2 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e2 = e2 * 256 + buffer[offset + i2], i2 += d3, nBits -= 8) {
      }
      m3 = e2 & (1 << -nBits) - 1;
      e2 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m3 = m3 * 256 + buffer[offset + i2], i2 += d3, nBits -= 8) {
      }
      if (e2 === 0) {
        e2 = 1 - eBias;
      } else if (e2 === eMax) {
        return m3 ? NaN : (s2 ? -1 : 1) * Infinity;
      } else {
        m3 = m3 + Math.pow(2, mLen);
        e2 = e2 - eBias;
      }
      return (s2 ? -1 : 1) * m3 * Math.pow(2, e2 - mLen);
    };
    exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e2, m3, c4;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i2 = isLE ? 0 : nBytes - 1;
      var d3 = isLE ? 1 : -1;
      var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m3 = isNaN(value) ? 1 : 0;
        e2 = eMax;
      } else {
        e2 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c4 = Math.pow(2, -e2)) < 1) {
          e2--;
          c4 *= 2;
        }
        if (e2 + eBias >= 1) {
          value += rt / c4;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c4 >= 2) {
          e2++;
          c4 /= 2;
        }
        if (e2 + eBias >= eMax) {
          m3 = 0;
          e2 = eMax;
        } else if (e2 + eBias >= 1) {
          m3 = (value * c4 - 1) * Math.pow(2, mLen);
          e2 = e2 + eBias;
        } else {
          m3 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e2 = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i2] = m3 & 255, i2 += d3, m3 /= 256, mLen -= 8) {
      }
      e2 = e2 << mLen | m3;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i2] = e2 & 255, i2 += d3, e2 /= 256, eLen -= 8) {
      }
      buffer[offset + i2 - d3] |= s2 * 128;
    };
  }
});

// node_modules/node-stdlib-browser/node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/node-stdlib-browser/node_modules/buffer/index.js"(exports2) {
    "use strict";
    init_shim();
    var base642 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports2.Buffer = Buffer2;
    exports2.SlowBuffer = SlowBuffer;
    exports2.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports2.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e2) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length2) {
      if (length2 > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length2 + '" is invalid for option "size"');
      }
      var buf = new Uint8Array(length2);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length2) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe2(arg);
      }
      return from3(arg, encodingOrOffset, length2);
    }
    Buffer2.poolSize = 8192;
    function from3(value, encodingOrOffset, length2) {
      if (typeof value === "string") {
        return fromString3(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length2);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length2);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length2);
      }
      var b4 = fromObject(value);
      if (b4)
        return b4;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(
          value[Symbol.toPrimitive]("string"),
          encodingOrOffset,
          length2
        );
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length2) {
      return from3(value, encodingOrOffset, length2);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe2(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe2(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe2(size);
    };
    function fromString3(string2, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length2 = byteLength(string2, encoding) | 0;
      var buf = createBuffer(length2);
      var actual = buf.write(string2, encoding);
      if (actual !== length2) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      var length2 = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length2);
      for (var i2 = 0; i2 < length2; i2 += 1) {
        buf[i2] = array[i2] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length2) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length2 || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length2 === void 0) {
        buf = new Uint8Array(array);
      } else if (length2 === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length2);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length2) {
      if (length2 >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length2 | 0;
    }
    function SlowBuffer(length2) {
      if (+length2 != length2) {
        length2 = 0;
      }
      return Buffer2.alloc(+length2);
    }
    Buffer2.isBuffer = function isBuffer(b4) {
      return b4 != null && b4._isBuffer === true && b4 !== Buffer2.prototype;
    };
    Buffer2.compare = function compare3(a3, b4) {
      if (isInstance(a3, Uint8Array))
        a3 = Buffer2.from(a3, a3.offset, a3.byteLength);
      if (isInstance(b4, Uint8Array))
        b4 = Buffer2.from(b4, b4.offset, b4.byteLength);
      if (!Buffer2.isBuffer(a3) || !Buffer2.isBuffer(b4)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a3 === b4)
        return 0;
      var x3 = a3.length;
      var y4 = b4.length;
      for (var i2 = 0, len = Math.min(x3, y4); i2 < len; ++i2) {
        if (a3[i2] !== b4[i2]) {
          x3 = a3[i2];
          y4 = b4[i2];
          break;
        }
      }
      if (x3 < y4)
        return -1;
      if (y4 < x3)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat2(list, length2) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      var i2;
      if (length2 === void 0) {
        length2 = 0;
        for (i2 = 0; i2 < list.length; ++i2) {
          length2 += list[i2].length;
        }
      }
      var buffer = Buffer2.allocUnsafe(length2);
      var pos = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        var buf = list[i2];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            Buffer2.from(buf).copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string2, encoding) {
      if (Buffer2.isBuffer(string2)) {
        return string2.length;
      }
      if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
        return string2.byteLength;
      }
      if (typeof string2 !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
        );
      }
      var len = string2.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string2).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string2).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string2).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b4, n3, m3) {
      var i2 = b4[n3];
      b4[n3] = b4[m3];
      b4[m3] = i2;
    }
    Buffer2.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i2 = 0; i2 < len; i2 += 2) {
        swap(this, i2, i2 + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i2 = 0; i2 < len; i2 += 4) {
        swap(this, i2, i2 + 3);
        swap(this, i2 + 1, i2 + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i2 = 0; i2 < len; i2 += 8) {
        swap(this, i2, i2 + 7);
        swap(this, i2 + 1, i2 + 6);
        swap(this, i2 + 2, i2 + 5);
        swap(this, i2 + 3, i2 + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString3() {
      var length2 = this.length;
      if (length2 === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length2);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals4(b4) {
      if (!Buffer2.isBuffer(b4))
        throw new TypeError("Argument must be a Buffer");
      if (this === b4)
        return true;
      return Buffer2.compare(this, b4) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      var str = "";
      var max = exports2.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare3(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x3 = thisEnd - thisStart;
      var y4 = end - start;
      var len = Math.min(x3, y4);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i2 = 0; i2 < len; ++i2) {
        if (thisCopy[i2] !== targetCopy[i2]) {
          x3 = thisCopy[i2];
          y4 = targetCopy[i2];
          break;
        }
      }
      if (x3 < y4)
        return -1;
      if (y4 < x3)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read2(buf, i3) {
        if (indexSize === 1) {
          return buf[i3];
        } else {
          return buf.readUInt16BE(i3 * indexSize);
        }
      }
      var i2;
      if (dir) {
        var foundIndex = -1;
        for (i2 = byteOffset; i2 < arrLength; i2++) {
          if (read2(arr, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i2;
            if (i2 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i2 -= i2 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i2 = byteOffset; i2 >= 0; i2--) {
          var found = true;
          for (var j2 = 0; j2 < valLength; j2++) {
            if (read2(arr, i2 + j2) !== read2(val, j2)) {
              found = false;
              break;
            }
          }
          if (found)
            return i2;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string2, offset, length2) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length2) {
        length2 = remaining;
      } else {
        length2 = Number(length2);
        if (length2 > remaining) {
          length2 = remaining;
        }
      }
      var strLen = string2.length;
      if (length2 > strLen / 2) {
        length2 = strLen / 2;
      }
      for (var i2 = 0; i2 < length2; ++i2) {
        var parsed = parseInt(string2.substr(i2 * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i2;
        buf[offset + i2] = parsed;
      }
      return i2;
    }
    function utf8Write(buf, string2, offset, length2) {
      return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length2);
    }
    function asciiWrite(buf, string2, offset, length2) {
      return blitBuffer(asciiToBytes(string2), buf, offset, length2);
    }
    function base64Write(buf, string2, offset, length2) {
      return blitBuffer(base64ToBytes(string2), buf, offset, length2);
    }
    function ucs2Write(buf, string2, offset, length2) {
      return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length2);
    }
    Buffer2.prototype.write = function write(string2, offset, length2, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length2 = this.length;
        offset = 0;
      } else if (length2 === void 0 && typeof offset === "string") {
        encoding = offset;
        length2 = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length2)) {
          length2 = length2 >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length2;
          length2 = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length2 === void 0 || length2 > remaining)
        length2 = remaining;
      if (string2.length > 0 && (length2 < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string2, offset, length2);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string2, offset, length2);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string2, offset, length2);
          case "base64":
            return base64Write(this, string2, offset, length2);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string2, offset, length2);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base642.fromByteArray(buf);
      } else {
        return base642.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i2 = start;
      while (i2 < end) {
        var firstByte = buf[i2];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i2 + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i2 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              fourthByte = buf[i2 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i2 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i2 = 0;
      while (i2 < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      var out = "";
      for (var i2 = start; i2 < end; ++i2) {
        out += hexSliceLookupTable[buf[i2]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i2 = 0; i2 < bytes.length - 1; i2 += 2) {
        res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length2) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length2)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i2 = 0;
      while (++i2 < byteLength2 && (mul *= 256)) {
        val += this[offset + i2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i2 = 0;
      while (++i2 < byteLength2 && (mul *= 256)) {
        val += this[offset + i2] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var i2 = byteLength2;
      var mul = 1;
      var val = this[offset + --i2];
      while (i2 > 0 && (mul *= 256)) {
        val += this[offset + --i2] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i2 = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength2 && (mul *= 256)) {
        this[offset + i2] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i2 = byteLength2 - 1;
      var mul = 1;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        this[offset + i2] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i2 = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i2 = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          var code2 = val.charCodeAt(0);
          if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
            val = code2;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i2;
      if (typeof val === "number") {
        for (i2 = start; i2 < end; ++i2) {
          this[i2] = val;
        }
      } else {
        var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i2 = 0; i2 < end - start; ++i2) {
          this[i2 + start] = bytes[i2 % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string2, units) {
      units = units || Infinity;
      var codePoint;
      var length2 = string2.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i2 = 0; i2 < length2; ++i2) {
        codePoint = string2.charCodeAt(i2);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i2 + 1 === length2) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i2 = 0; i2 < str.length; ++i2) {
        byteArray.push(str.charCodeAt(i2) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c4, hi, lo;
      var byteArray = [];
      for (var i2 = 0; i2 < str.length; ++i2) {
        if ((units -= 2) < 0)
          break;
        c4 = str.charCodeAt(i2);
        hi = c4 >> 8;
        lo = c4 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base642.toByteArray(base64clean(str));
    }
    function blitBuffer(src2, dst, offset, length2) {
      for (var i2 = 0; i2 < length2; ++i2) {
        if (i2 + offset >= dst.length || i2 >= src2.length)
          break;
        dst[i2 + offset] = src2[i2];
      }
      return i2;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      var alphabet2 = "0123456789abcdef";
      var table = new Array(256);
      for (var i2 = 0; i2 < 16; ++i2) {
        var i16 = i2 * 16;
        for (var j2 = 0; j2 < 16; ++j2) {
          table[i16 + j2] = alphabet2[i2] + alphabet2[j2];
        }
      }
      return table;
    }();
  }
});

// node_modules/process/browser.js
var require_browser = __commonJS({
  "node_modules/process/browser.js"(exports2, module2) {
    init_shim();
    var process2 = module2.exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        if (typeof setTimeout === "function") {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e2) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === "function") {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e2) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e2) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e3) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e2) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e3) {
          return cachedClearTimeout.call(this, marker);
        }
      }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }
    process2.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          args[i2 - 1] = arguments[i2];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };
    function Item(fun, array) {
      this.fun = fun;
      this.array = array;
    }
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    process2.title = "browser";
    process2.browser = true;
    process2.env = {};
    process2.argv = [];
    process2.version = "";
    process2.versions = {};
    function noop() {
    }
    process2.on = noop;
    process2.addListener = noop;
    process2.once = noop;
    process2.off = noop;
    process2.removeListener = noop;
    process2.removeAllListeners = noop;
    process2.emit = noop;
    process2.prependListener = noop;
    process2.prependOnceListener = noop;
    process2.listeners = function(name2) {
      return [];
    };
    process2.binding = function(name2) {
      throw new Error("process.binding is not supported");
    };
    process2.cwd = function() {
      return "/";
    };
    process2.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process2.umask = function() {
      return 0;
    };
  }
});

// node_modules/node-stdlib-browser/helpers/esbuild/shim.js
var import_buffer, import_process, _globalThis, global;
var init_shim = __esm({
  "node_modules/node-stdlib-browser/helpers/esbuild/shim.js"() {
    import_buffer = __toESM(require_buffer());
    import_process = __toESM(require_browser());
    _globalThis = function(Object2) {
      function get2() {
        var _global2 = this || self;
        delete Object2.prototype.__magic__;
        return _global2;
      }
      if (typeof globalThis === "object") {
        return globalThis;
      }
      if (this) {
        return get2();
      } else {
        Object2.defineProperty(Object2.prototype, "__magic__", {
          configurable: true,
          get: get2
        });
        var _global = __magic__;
        return _global;
      }
    }(Object);
    global = _globalThis;
  }
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/bignumber.js/bignumber.js"(exports2, module2) {
    init_shim();
    (function(globalObject) {
      "use strict";
      var BigNumber2, isNumeric2 = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil2 = Math.ceil, mathfloor2 = Math.floor, bignumberError2 = "[BigNumber Error] ", tooManyDigits2 = bignumberError2 + "Number primitive has more than 15 significant digits: ", BASE2 = 1e14, LOG_BASE2 = 14, MAX_SAFE_INTEGER2 = 9007199254740991, POWS_TEN2 = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE2 = 1e7, MAX2 = 1e9;
      function clone2(configObject) {
        var div, convertBase, parseNumeric, P2 = BigNumber3.prototype = { constructor: BigNumber3, toString: null, valueOf: null }, ONE = new BigNumber3(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: "\xA0",
          // non-breaking space
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber3(v2, b4) {
          var alphabet2, c4, caseChanged, e2, i2, isNum, len, str, x3 = this;
          if (!(x3 instanceof BigNumber3))
            return new BigNumber3(v2, b4);
          if (b4 == null) {
            if (v2 && v2._isBigNumber === true) {
              x3.s = v2.s;
              if (!v2.c || v2.e > MAX_EXP) {
                x3.c = x3.e = null;
              } else if (v2.e < MIN_EXP) {
                x3.c = [x3.e = 0];
              } else {
                x3.e = v2.e;
                x3.c = v2.c.slice();
              }
              return;
            }
            if ((isNum = typeof v2 == "number") && v2 * 0 == 0) {
              x3.s = 1 / v2 < 0 ? (v2 = -v2, -1) : 1;
              if (v2 === ~~v2) {
                for (e2 = 0, i2 = v2; i2 >= 10; i2 /= 10, e2++)
                  ;
                if (e2 > MAX_EXP) {
                  x3.c = x3.e = null;
                } else {
                  x3.e = e2;
                  x3.c = [v2];
                }
                return;
              }
              str = String(v2);
            } else {
              if (!isNumeric2.test(str = String(v2)))
                return parseNumeric(x3, str, isNum);
              x3.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e2 = str.indexOf(".")) > -1)
              str = str.replace(".", "");
            if ((i2 = str.search(/e/i)) > 0) {
              if (e2 < 0)
                e2 = i2;
              e2 += +str.slice(i2 + 1);
              str = str.substring(0, i2);
            } else if (e2 < 0) {
              e2 = str.length;
            }
          } else {
            intCheck2(b4, 2, ALPHABET.length, "Base");
            if (b4 == 10 && alphabetHasNormalDecimalDigits) {
              x3 = new BigNumber3(v2);
              return round(x3, DECIMAL_PLACES + x3.e + 1, ROUNDING_MODE);
            }
            str = String(v2);
            if (isNum = typeof v2 == "number") {
              if (v2 * 0 != 0)
                return parseNumeric(x3, str, isNum, b4);
              x3.s = 1 / v2 < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber3.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits2 + v2);
              }
            } else {
              x3.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet2 = ALPHABET.slice(0, b4);
            e2 = i2 = 0;
            for (len = str.length; i2 < len; i2++) {
              if (alphabet2.indexOf(c4 = str.charAt(i2)) < 0) {
                if (c4 == ".") {
                  if (i2 > e2) {
                    e2 = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i2 = -1;
                    e2 = 0;
                    continue;
                  }
                }
                return parseNumeric(x3, String(v2), isNum, b4);
              }
            }
            isNum = false;
            str = convertBase(str, b4, 10, x3.s);
            if ((e2 = str.indexOf(".")) > -1)
              str = str.replace(".", "");
            else
              e2 = str.length;
          }
          for (i2 = 0; str.charCodeAt(i2) === 48; i2++)
            ;
          for (len = str.length; str.charCodeAt(--len) === 48; )
            ;
          if (str = str.slice(i2, ++len)) {
            len -= i2;
            if (isNum && BigNumber3.DEBUG && len > 15 && (v2 > MAX_SAFE_INTEGER2 || v2 !== mathfloor2(v2))) {
              throw Error(tooManyDigits2 + x3.s * v2);
            }
            if ((e2 = e2 - i2 - 1) > MAX_EXP) {
              x3.c = x3.e = null;
            } else if (e2 < MIN_EXP) {
              x3.c = [x3.e = 0];
            } else {
              x3.e = e2;
              x3.c = [];
              i2 = (e2 + 1) % LOG_BASE2;
              if (e2 < 0)
                i2 += LOG_BASE2;
              if (i2 < len) {
                if (i2)
                  x3.c.push(+str.slice(0, i2));
                for (len -= LOG_BASE2; i2 < len; ) {
                  x3.c.push(+str.slice(i2, i2 += LOG_BASE2));
                }
                i2 = LOG_BASE2 - (str = str.slice(i2)).length;
              } else {
                i2 -= len;
              }
              for (; i2--; str += "0")
                ;
              x3.c.push(+str);
            }
          } else {
            x3.c = [x3.e = 0];
          }
        }
        BigNumber3.clone = clone2;
        BigNumber3.ROUND_UP = 0;
        BigNumber3.ROUND_DOWN = 1;
        BigNumber3.ROUND_CEIL = 2;
        BigNumber3.ROUND_FLOOR = 3;
        BigNumber3.ROUND_HALF_UP = 4;
        BigNumber3.ROUND_HALF_DOWN = 5;
        BigNumber3.ROUND_HALF_EVEN = 6;
        BigNumber3.ROUND_HALF_CEIL = 7;
        BigNumber3.ROUND_HALF_FLOOR = 8;
        BigNumber3.EUCLID = 9;
        BigNumber3.config = BigNumber3.set = function(obj) {
          var p3, v2;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p3 = "DECIMAL_PLACES")) {
                v2 = obj[p3];
                intCheck2(v2, 0, MAX2, p3);
                DECIMAL_PLACES = v2;
              }
              if (obj.hasOwnProperty(p3 = "ROUNDING_MODE")) {
                v2 = obj[p3];
                intCheck2(v2, 0, 8, p3);
                ROUNDING_MODE = v2;
              }
              if (obj.hasOwnProperty(p3 = "EXPONENTIAL_AT")) {
                v2 = obj[p3];
                if (v2 && v2.pop) {
                  intCheck2(v2[0], -MAX2, 0, p3);
                  intCheck2(v2[1], 0, MAX2, p3);
                  TO_EXP_NEG = v2[0];
                  TO_EXP_POS = v2[1];
                } else {
                  intCheck2(v2, -MAX2, MAX2, p3);
                  TO_EXP_NEG = -(TO_EXP_POS = v2 < 0 ? -v2 : v2);
                }
              }
              if (obj.hasOwnProperty(p3 = "RANGE")) {
                v2 = obj[p3];
                if (v2 && v2.pop) {
                  intCheck2(v2[0], -MAX2, -1, p3);
                  intCheck2(v2[1], 1, MAX2, p3);
                  MIN_EXP = v2[0];
                  MAX_EXP = v2[1];
                } else {
                  intCheck2(v2, -MAX2, MAX2, p3);
                  if (v2) {
                    MIN_EXP = -(MAX_EXP = v2 < 0 ? -v2 : v2);
                  } else {
                    throw Error(bignumberError2 + p3 + " cannot be zero: " + v2);
                  }
                }
              }
              if (obj.hasOwnProperty(p3 = "CRYPTO")) {
                v2 = obj[p3];
                if (v2 === !!v2) {
                  if (v2) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v2;
                    } else {
                      CRYPTO = !v2;
                      throw Error(bignumberError2 + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v2;
                  }
                } else {
                  throw Error(bignumberError2 + p3 + " not true or false: " + v2);
                }
              }
              if (obj.hasOwnProperty(p3 = "MODULO_MODE")) {
                v2 = obj[p3];
                intCheck2(v2, 0, 9, p3);
                MODULO_MODE = v2;
              }
              if (obj.hasOwnProperty(p3 = "POW_PRECISION")) {
                v2 = obj[p3];
                intCheck2(v2, 0, MAX2, p3);
                POW_PRECISION = v2;
              }
              if (obj.hasOwnProperty(p3 = "FORMAT")) {
                v2 = obj[p3];
                if (typeof v2 == "object")
                  FORMAT = v2;
                else
                  throw Error(bignumberError2 + p3 + " not an object: " + v2);
              }
              if (obj.hasOwnProperty(p3 = "ALPHABET")) {
                v2 = obj[p3];
                if (typeof v2 == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v2)) {
                  alphabetHasNormalDecimalDigits = v2.slice(0, 10) == "0123456789";
                  ALPHABET = v2;
                } else {
                  throw Error(bignumberError2 + p3 + " invalid: " + v2);
                }
              }
            } else {
              throw Error(bignumberError2 + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber3.isBigNumber = function(v2) {
          if (!v2 || v2._isBigNumber !== true)
            return false;
          if (!BigNumber3.DEBUG)
            return true;
          var i2, n3, c4 = v2.c, e2 = v2.e, s2 = v2.s;
          out:
            if ({}.toString.call(c4) == "[object Array]") {
              if ((s2 === 1 || s2 === -1) && e2 >= -MAX2 && e2 <= MAX2 && e2 === mathfloor2(e2)) {
                if (c4[0] === 0) {
                  if (e2 === 0 && c4.length === 1)
                    return true;
                  break out;
                }
                i2 = (e2 + 1) % LOG_BASE2;
                if (i2 < 1)
                  i2 += LOG_BASE2;
                if (String(c4[0]).length == i2) {
                  for (i2 = 0; i2 < c4.length; i2++) {
                    n3 = c4[i2];
                    if (n3 < 0 || n3 >= BASE2 || n3 !== mathfloor2(n3))
                      break out;
                  }
                  if (n3 !== 0)
                    return true;
                }
              }
            } else if (c4 === null && e2 === null && (s2 === null || s2 === 1 || s2 === -1)) {
              return true;
            }
          throw Error(bignumberError2 + "Invalid BigNumber: " + v2);
        };
        BigNumber3.maximum = BigNumber3.max = function() {
          return maxOrMin(arguments, -1);
        };
        BigNumber3.minimum = BigNumber3.min = function() {
          return maxOrMin(arguments, 1);
        };
        BigNumber3.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor2(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a3, b4, e2, k4, v2, i2 = 0, c4 = [], rand = new BigNumber3(ONE);
            if (dp == null)
              dp = DECIMAL_PLACES;
            else
              intCheck2(dp, 0, MAX2);
            k4 = mathceil2(dp / LOG_BASE2);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a3 = crypto.getRandomValues(new Uint32Array(k4 *= 2));
                for (; i2 < k4; ) {
                  v2 = a3[i2] * 131072 + (a3[i2 + 1] >>> 11);
                  if (v2 >= 9e15) {
                    b4 = crypto.getRandomValues(new Uint32Array(2));
                    a3[i2] = b4[0];
                    a3[i2 + 1] = b4[1];
                  } else {
                    c4.push(v2 % 1e14);
                    i2 += 2;
                  }
                }
                i2 = k4 / 2;
              } else if (crypto.randomBytes) {
                a3 = crypto.randomBytes(k4 *= 7);
                for (; i2 < k4; ) {
                  v2 = (a3[i2] & 31) * 281474976710656 + a3[i2 + 1] * 1099511627776 + a3[i2 + 2] * 4294967296 + a3[i2 + 3] * 16777216 + (a3[i2 + 4] << 16) + (a3[i2 + 5] << 8) + a3[i2 + 6];
                  if (v2 >= 9e15) {
                    crypto.randomBytes(7).copy(a3, i2);
                  } else {
                    c4.push(v2 % 1e14);
                    i2 += 7;
                  }
                }
                i2 = k4 / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError2 + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i2 < k4; ) {
                v2 = random53bitInt();
                if (v2 < 9e15)
                  c4[i2++] = v2 % 1e14;
              }
            }
            k4 = c4[--i2];
            dp %= LOG_BASE2;
            if (k4 && dp) {
              v2 = POWS_TEN2[LOG_BASE2 - dp];
              c4[i2] = mathfloor2(k4 / v2) * v2;
            }
            for (; c4[i2] === 0; c4.pop(), i2--)
              ;
            if (i2 < 0) {
              c4 = [e2 = 0];
            } else {
              for (e2 = -1; c4[0] === 0; c4.splice(0, 1), e2 -= LOG_BASE2)
                ;
              for (i2 = 1, v2 = c4[0]; v2 >= 10; v2 /= 10, i2++)
                ;
              if (i2 < LOG_BASE2)
                e2 -= LOG_BASE2 - i2;
            }
            rand.e = e2;
            rand.c = c4;
            return rand;
          };
        }();
        BigNumber3.sum = function() {
          var i2 = 1, args = arguments, sum = new BigNumber3(args[0]);
          for (; i2 < args.length; )
            sum = sum.plus(args[i2++]);
          return sum;
        };
        convertBase = /* @__PURE__ */ function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet2) {
            var j2, arr = [0], arrL, i2 = 0, len = str.length;
            for (; i2 < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
                ;
              arr[0] += alphabet2.indexOf(str.charAt(i2++));
              for (j2 = 0; j2 < arr.length; j2++) {
                if (arr[j2] > baseOut - 1) {
                  if (arr[j2 + 1] == null)
                    arr[j2 + 1] = 0;
                  arr[j2 + 1] += arr[j2] / baseOut | 0;
                  arr[j2] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign2, callerIsToString) {
            var alphabet2, d3, e2, k4, r, x3, xc, y4, i2 = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i2 >= 0) {
              k4 = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y4 = new BigNumber3(baseIn);
              x3 = y4.pow(str.length - i2);
              POW_PRECISION = k4;
              y4.c = toBaseOut(
                toFixedPoint2(coeffToString2(x3.c), x3.e, "0"),
                10,
                baseOut,
                decimal
              );
              y4.e = y4.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet2 = ALPHABET, decimal) : (alphabet2 = decimal, ALPHABET));
            e2 = k4 = xc.length;
            for (; xc[--k4] == 0; xc.pop())
              ;
            if (!xc[0])
              return alphabet2.charAt(0);
            if (i2 < 0) {
              --e2;
            } else {
              x3.c = xc;
              x3.e = e2;
              x3.s = sign2;
              x3 = div(x3, y4, dp, rm, baseOut);
              xc = x3.c;
              r = x3.r;
              e2 = x3.e;
            }
            d3 = e2 + dp + 1;
            i2 = xc[d3];
            k4 = baseOut / 2;
            r = r || d3 < 0 || xc[d3 + 1] != null;
            r = rm < 4 ? (i2 != null || r) && (rm == 0 || rm == (x3.s < 0 ? 3 : 2)) : i2 > k4 || i2 == k4 && (rm == 4 || r || rm == 6 && xc[d3 - 1] & 1 || rm == (x3.s < 0 ? 8 : 7));
            if (d3 < 1 || !xc[0]) {
              str = r ? toFixedPoint2(alphabet2.charAt(1), -dp, alphabet2.charAt(0)) : alphabet2.charAt(0);
            } else {
              xc.length = d3;
              if (r) {
                for (--baseOut; ++xc[--d3] > baseOut; ) {
                  xc[d3] = 0;
                  if (!d3) {
                    ++e2;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k4 = xc.length; !xc[--k4]; )
                ;
              for (i2 = 0, str = ""; i2 <= k4; str += alphabet2.charAt(xc[i2++]))
                ;
              str = toFixedPoint2(str, e2, alphabet2.charAt(0));
            }
            return str;
          };
        }();
        div = /* @__PURE__ */ function() {
          function multiply(x3, k4, base3) {
            var m3, temp, xlo, xhi, carry = 0, i2 = x3.length, klo = k4 % SQRT_BASE2, khi = k4 / SQRT_BASE2 | 0;
            for (x3 = x3.slice(); i2--; ) {
              xlo = x3[i2] % SQRT_BASE2;
              xhi = x3[i2] / SQRT_BASE2 | 0;
              m3 = khi * xlo + xhi * klo;
              temp = klo * xlo + m3 % SQRT_BASE2 * SQRT_BASE2 + carry;
              carry = (temp / base3 | 0) + (m3 / SQRT_BASE2 | 0) + khi * xhi;
              x3[i2] = temp % base3;
            }
            if (carry)
              x3 = [carry].concat(x3);
            return x3;
          }
          function compare4(a3, b4, aL, bL) {
            var i2, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i2 = cmp = 0; i2 < aL; i2++) {
                if (a3[i2] != b4[i2]) {
                  cmp = a3[i2] > b4[i2] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a3, b4, aL, base3) {
            var i2 = 0;
            for (; aL--; ) {
              a3[aL] -= i2;
              i2 = a3[aL] < b4[aL] ? 1 : 0;
              a3[aL] = i2 * base3 + a3[aL] - b4[aL];
            }
            for (; !a3[0] && a3.length > 1; a3.splice(0, 1))
              ;
          }
          return function(x3, y4, dp, rm, base3) {
            var cmp, e2, i2, more, n3, prod, prodL, q2, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s2 = x3.s == y4.s ? 1 : -1, xc = x3.c, yc = y4.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber3(
                // Return NaN if either NaN, or both Infinity or 0.
                !x3.s || !y4.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                  // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                  xc && xc[0] == 0 || !yc ? s2 * 0 : s2 / 0
                )
              );
            }
            q2 = new BigNumber3(s2);
            qc = q2.c = [];
            e2 = x3.e - y4.e;
            s2 = dp + e2 + 1;
            if (!base3) {
              base3 = BASE2;
              e2 = bitFloor2(x3.e / LOG_BASE2) - bitFloor2(y4.e / LOG_BASE2);
              s2 = s2 / LOG_BASE2 | 0;
            }
            for (i2 = 0; yc[i2] == (xc[i2] || 0); i2++)
              ;
            if (yc[i2] > (xc[i2] || 0))
              e2--;
            if (s2 < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i2 = 0;
              s2 += 2;
              n3 = mathfloor2(base3 / (yc[0] + 1));
              if (n3 > 1) {
                yc = multiply(yc, n3, base3);
                xc = multiply(xc, n3, base3);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0)
                ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base3 / 2)
                yc0++;
              do {
                n3 = 0;
                cmp = compare4(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL)
                    rem0 = rem0 * base3 + (rem[1] || 0);
                  n3 = mathfloor2(rem0 / yc0);
                  if (n3 > 1) {
                    if (n3 >= base3)
                      n3 = base3 - 1;
                    prod = multiply(yc, n3, base3);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare4(prod, rem, prodL, remL) == 1) {
                      n3--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base3);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n3 == 0) {
                      cmp = n3 = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL)
                    prod = [0].concat(prod);
                  subtract(rem, prod, remL, base3);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare4(yc, rem, yL, remL) < 1) {
                      n3++;
                      subtract(rem, yL < remL ? yz : yc, remL, base3);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n3++;
                  rem = [0];
                }
                qc[i2++] = n3;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s2--);
              more = rem[0] != null;
              if (!qc[0])
                qc.splice(0, 1);
            }
            if (base3 == BASE2) {
              for (i2 = 1, s2 = qc[0]; s2 >= 10; s2 /= 10, i2++)
                ;
              round(q2, dp + (q2.e = i2 + e2 * LOG_BASE2 - 1) + 1, rm, more);
            } else {
              q2.e = e2;
              q2.r = +more;
            }
            return q2;
          };
        }();
        function format(n3, i2, rm, id) {
          var c0, e2, ne, len, str;
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck2(rm, 0, 8);
          if (!n3.c)
            return n3.toString();
          c0 = n3.c[0];
          ne = n3.e;
          if (i2 == null) {
            str = coeffToString2(n3.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential2(str, ne) : toFixedPoint2(str, ne, "0");
          } else {
            n3 = round(new BigNumber3(n3), i2, rm);
            e2 = n3.e;
            str = coeffToString2(n3.c);
            len = str.length;
            if (id == 1 || id == 2 && (i2 <= e2 || e2 <= TO_EXP_NEG)) {
              for (; len < i2; str += "0", len++)
                ;
              str = toExponential2(str, e2);
            } else {
              i2 -= ne;
              str = toFixedPoint2(str, e2, "0");
              if (e2 + 1 > len) {
                if (--i2 > 0)
                  for (str += "."; i2--; str += "0")
                    ;
              } else {
                i2 += e2 - len;
                if (i2 > 0) {
                  if (e2 + 1 == len)
                    str += ".";
                  for (; i2--; str += "0")
                    ;
                }
              }
            }
          }
          return n3.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, n3) {
          var k4, y4, i2 = 1, x3 = new BigNumber3(args[0]);
          for (; i2 < args.length; i2++) {
            y4 = new BigNumber3(args[i2]);
            if (!y4.s || (k4 = compare3(x3, y4)) === n3 || k4 === 0 && x3.s === n3) {
              x3 = y4;
            }
          }
          return x3;
        }
        function normalise(n3, c4, e2) {
          var i2 = 1, j2 = c4.length;
          for (; !c4[--j2]; c4.pop())
            ;
          for (j2 = c4[0]; j2 >= 10; j2 /= 10, i2++)
            ;
          if ((e2 = i2 + e2 * LOG_BASE2 - 1) > MAX_EXP) {
            n3.c = n3.e = null;
          } else if (e2 < MIN_EXP) {
            n3.c = [n3.e = 0];
          } else {
            n3.e = e2;
            n3.c = c4;
          }
          return n3;
        }
        parseNumeric = /* @__PURE__ */ function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x3, str, isNum, b4) {
            var base3, s2 = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s2)) {
              x3.s = isNaN(s2) ? null : s2 < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s2 = s2.replace(basePrefix, function(m3, p1, p22) {
                  base3 = (p22 = p22.toLowerCase()) == "x" ? 16 : p22 == "b" ? 2 : 8;
                  return !b4 || b4 == base3 ? p1 : m3;
                });
                if (b4) {
                  base3 = b4;
                  s2 = s2.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s2)
                  return new BigNumber3(s2, base3);
              }
              if (BigNumber3.DEBUG) {
                throw Error(bignumberError2 + "Not a" + (b4 ? " base " + b4 : "") + " number: " + str);
              }
              x3.s = null;
            }
            x3.c = x3.e = null;
          };
        }();
        function round(x3, sd, rm, r) {
          var d3, i2, j2, k4, n3, ni, rd, xc = x3.c, pows10 = POWS_TEN2;
          if (xc) {
            out: {
              for (d3 = 1, k4 = xc[0]; k4 >= 10; k4 /= 10, d3++)
                ;
              i2 = sd - d3;
              if (i2 < 0) {
                i2 += LOG_BASE2;
                j2 = sd;
                n3 = xc[ni = 0];
                rd = mathfloor2(n3 / pows10[d3 - j2 - 1] % 10);
              } else {
                ni = mathceil2((i2 + 1) / LOG_BASE2);
                if (ni >= xc.length) {
                  if (r) {
                    for (; xc.length <= ni; xc.push(0))
                      ;
                    n3 = rd = 0;
                    d3 = 1;
                    i2 %= LOG_BASE2;
                    j2 = i2 - LOG_BASE2 + 1;
                  } else {
                    break out;
                  }
                } else {
                  n3 = k4 = xc[ni];
                  for (d3 = 1; k4 >= 10; k4 /= 10, d3++)
                    ;
                  i2 %= LOG_BASE2;
                  j2 = i2 - LOG_BASE2 + d3;
                  rd = j2 < 0 ? 0 : mathfloor2(n3 / pows10[d3 - j2 - 1] % 10);
                }
              }
              r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              xc[ni + 1] != null || (j2 < 0 ? n3 : n3 % pows10[d3 - j2 - 1]);
              r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x3.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (i2 > 0 ? j2 > 0 ? n3 / pows10[d3 - j2] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x3.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r) {
                  sd -= x3.e + 1;
                  xc[0] = pows10[(LOG_BASE2 - sd % LOG_BASE2) % LOG_BASE2];
                  x3.e = -sd || 0;
                } else {
                  xc[0] = x3.e = 0;
                }
                return x3;
              }
              if (i2 == 0) {
                xc.length = ni;
                k4 = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k4 = pows10[LOG_BASE2 - i2];
                xc[ni] = j2 > 0 ? mathfloor2(n3 / pows10[d3 - j2] % pows10[j2]) * k4 : 0;
              }
              if (r) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i2 = 1, j2 = xc[0]; j2 >= 10; j2 /= 10, i2++)
                      ;
                    j2 = xc[0] += k4;
                    for (k4 = 1; j2 >= 10; j2 /= 10, k4++)
                      ;
                    if (i2 != k4) {
                      x3.e++;
                      if (xc[0] == BASE2)
                        xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k4;
                    if (xc[ni] != BASE2)
                      break;
                    xc[ni--] = 0;
                    k4 = 1;
                  }
                }
              }
              for (i2 = xc.length; xc[--i2] === 0; xc.pop())
                ;
            }
            if (x3.e > MAX_EXP) {
              x3.c = x3.e = null;
            } else if (x3.e < MIN_EXP) {
              x3.c = [x3.e = 0];
            }
          }
          return x3;
        }
        function valueOf(n3) {
          var str, e2 = n3.e;
          if (e2 === null)
            return n3.toString();
          str = coeffToString2(n3.c);
          str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential2(str, e2) : toFixedPoint2(str, e2, "0");
          return n3.s < 0 ? "-" + str : str;
        }
        P2.absoluteValue = P2.abs = function() {
          var x3 = new BigNumber3(this);
          if (x3.s < 0)
            x3.s = 1;
          return x3;
        };
        P2.comparedTo = function(y4, b4) {
          return compare3(this, new BigNumber3(y4, b4));
        };
        P2.decimalPlaces = P2.dp = function(dp, rm) {
          var c4, n3, v2, x3 = this;
          if (dp != null) {
            intCheck2(dp, 0, MAX2);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck2(rm, 0, 8);
            return round(new BigNumber3(x3), dp + x3.e + 1, rm);
          }
          if (!(c4 = x3.c))
            return null;
          n3 = ((v2 = c4.length - 1) - bitFloor2(this.e / LOG_BASE2)) * LOG_BASE2;
          if (v2 = c4[v2])
            for (; v2 % 10 == 0; v2 /= 10, n3--)
              ;
          if (n3 < 0)
            n3 = 0;
          return n3;
        };
        P2.dividedBy = P2.div = function(y4, b4) {
          return div(this, new BigNumber3(y4, b4), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P2.dividedToIntegerBy = P2.idiv = function(y4, b4) {
          return div(this, new BigNumber3(y4, b4), 0, 1);
        };
        P2.exponentiatedBy = P2.pow = function(n3, m3) {
          var half, isModExp, i2, k4, more, nIsBig, nIsNeg, nIsOdd, y4, x3 = this;
          n3 = new BigNumber3(n3);
          if (n3.c && !n3.isInteger()) {
            throw Error(bignumberError2 + "Exponent not an integer: " + valueOf(n3));
          }
          if (m3 != null)
            m3 = new BigNumber3(m3);
          nIsBig = n3.e > 14;
          if (!x3.c || !x3.c[0] || x3.c[0] == 1 && !x3.e && x3.c.length == 1 || !n3.c || !n3.c[0]) {
            y4 = new BigNumber3(Math.pow(+valueOf(x3), nIsBig ? n3.s * (2 - isOdd2(n3)) : +valueOf(n3)));
            return m3 ? y4.mod(m3) : y4;
          }
          nIsNeg = n3.s < 0;
          if (m3) {
            if (m3.c ? !m3.c[0] : !m3.s)
              return new BigNumber3(NaN);
            isModExp = !nIsNeg && x3.isInteger() && m3.isInteger();
            if (isModExp)
              x3 = x3.mod(m3);
          } else if (n3.e > 9 && (x3.e > 0 || x3.e < -1 || (x3.e == 0 ? x3.c[0] > 1 || nIsBig && x3.c[1] >= 24e7 : x3.c[0] < 8e13 || nIsBig && x3.c[0] <= 9999975e7))) {
            k4 = x3.s < 0 && isOdd2(n3) ? -0 : 0;
            if (x3.e > -1)
              k4 = 1 / k4;
            return new BigNumber3(nIsNeg ? 1 / k4 : k4);
          } else if (POW_PRECISION) {
            k4 = mathceil2(POW_PRECISION / LOG_BASE2 + 2);
          }
          if (nIsBig) {
            half = new BigNumber3(0.5);
            if (nIsNeg)
              n3.s = 1;
            nIsOdd = isOdd2(n3);
          } else {
            i2 = Math.abs(+valueOf(n3));
            nIsOdd = i2 % 2;
          }
          y4 = new BigNumber3(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y4 = y4.times(x3);
              if (!y4.c)
                break;
              if (k4) {
                if (y4.c.length > k4)
                  y4.c.length = k4;
              } else if (isModExp) {
                y4 = y4.mod(m3);
              }
            }
            if (i2) {
              i2 = mathfloor2(i2 / 2);
              if (i2 === 0)
                break;
              nIsOdd = i2 % 2;
            } else {
              n3 = n3.times(half);
              round(n3, n3.e + 1, 1);
              if (n3.e > 14) {
                nIsOdd = isOdd2(n3);
              } else {
                i2 = +valueOf(n3);
                if (i2 === 0)
                  break;
                nIsOdd = i2 % 2;
              }
            }
            x3 = x3.times(x3);
            if (k4) {
              if (x3.c && x3.c.length > k4)
                x3.c.length = k4;
            } else if (isModExp) {
              x3 = x3.mod(m3);
            }
          }
          if (isModExp)
            return y4;
          if (nIsNeg)
            y4 = ONE.div(y4);
          return m3 ? y4.mod(m3) : k4 ? round(y4, POW_PRECISION, ROUNDING_MODE, more) : y4;
        };
        P2.integerValue = function(rm) {
          var n3 = new BigNumber3(this);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck2(rm, 0, 8);
          return round(n3, n3.e + 1, rm);
        };
        P2.isEqualTo = P2.eq = function(y4, b4) {
          return compare3(this, new BigNumber3(y4, b4)) === 0;
        };
        P2.isFinite = function() {
          return !!this.c;
        };
        P2.isGreaterThan = P2.gt = function(y4, b4) {
          return compare3(this, new BigNumber3(y4, b4)) > 0;
        };
        P2.isGreaterThanOrEqualTo = P2.gte = function(y4, b4) {
          return (b4 = compare3(this, new BigNumber3(y4, b4))) === 1 || b4 === 0;
        };
        P2.isInteger = function() {
          return !!this.c && bitFloor2(this.e / LOG_BASE2) > this.c.length - 2;
        };
        P2.isLessThan = P2.lt = function(y4, b4) {
          return compare3(this, new BigNumber3(y4, b4)) < 0;
        };
        P2.isLessThanOrEqualTo = P2.lte = function(y4, b4) {
          return (b4 = compare3(this, new BigNumber3(y4, b4))) === -1 || b4 === 0;
        };
        P2.isNaN = function() {
          return !this.s;
        };
        P2.isNegative = function() {
          return this.s < 0;
        };
        P2.isPositive = function() {
          return this.s > 0;
        };
        P2.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P2.minus = function(y4, b4) {
          var i2, j2, t, xLTy, x3 = this, a3 = x3.s;
          y4 = new BigNumber3(y4, b4);
          b4 = y4.s;
          if (!a3 || !b4)
            return new BigNumber3(NaN);
          if (a3 != b4) {
            y4.s = -b4;
            return x3.plus(y4);
          }
          var xe = x3.e / LOG_BASE2, ye = y4.e / LOG_BASE2, xc = x3.c, yc = y4.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return xc ? (y4.s = -b4, y4) : new BigNumber3(yc ? x3 : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y4.s = -b4, y4) : new BigNumber3(xc[0] ? x3 : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0
              ));
            }
          }
          xe = bitFloor2(xe);
          ye = bitFloor2(ye);
          xc = xc.slice();
          if (a3 = xe - ye) {
            if (xLTy = a3 < 0) {
              a3 = -a3;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }
            t.reverse();
            for (b4 = a3; b4--; t.push(0))
              ;
            t.reverse();
          } else {
            j2 = (xLTy = (a3 = xc.length) < (b4 = yc.length)) ? a3 : b4;
            for (a3 = b4 = 0; b4 < j2; b4++) {
              if (xc[b4] != yc[b4]) {
                xLTy = xc[b4] < yc[b4];
                break;
              }
            }
          }
          if (xLTy) {
            t = xc;
            xc = yc;
            yc = t;
            y4.s = -y4.s;
          }
          b4 = (j2 = yc.length) - (i2 = xc.length);
          if (b4 > 0)
            for (; b4--; xc[i2++] = 0)
              ;
          b4 = BASE2 - 1;
          for (; j2 > a3; ) {
            if (xc[--j2] < yc[j2]) {
              for (i2 = j2; i2 && !xc[--i2]; xc[i2] = b4)
                ;
              --xc[i2];
              xc[j2] += BASE2;
            }
            xc[j2] -= yc[j2];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye)
            ;
          if (!xc[0]) {
            y4.s = ROUNDING_MODE == 3 ? -1 : 1;
            y4.c = [y4.e = 0];
            return y4;
          }
          return normalise(y4, xc, ye);
        };
        P2.modulo = P2.mod = function(y4, b4) {
          var q2, s2, x3 = this;
          y4 = new BigNumber3(y4, b4);
          if (!x3.c || !y4.s || y4.c && !y4.c[0]) {
            return new BigNumber3(NaN);
          } else if (!y4.c || x3.c && !x3.c[0]) {
            return new BigNumber3(x3);
          }
          if (MODULO_MODE == 9) {
            s2 = y4.s;
            y4.s = 1;
            q2 = div(x3, y4, 0, 3);
            y4.s = s2;
            q2.s *= s2;
          } else {
            q2 = div(x3, y4, 0, MODULO_MODE);
          }
          y4 = x3.minus(q2.times(y4));
          if (!y4.c[0] && MODULO_MODE == 1)
            y4.s = x3.s;
          return y4;
        };
        P2.multipliedBy = P2.times = function(y4, b4) {
          var c4, e2, i2, j2, k4, m3, xcL, xlo, xhi, ycL, ylo, yhi, zc, base3, sqrtBase, x3 = this, xc = x3.c, yc = (y4 = new BigNumber3(y4, b4)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x3.s || !y4.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y4.c = y4.e = y4.s = null;
            } else {
              y4.s *= x3.s;
              if (!xc || !yc) {
                y4.c = y4.e = null;
              } else {
                y4.c = [0];
                y4.e = 0;
              }
            }
            return y4;
          }
          e2 = bitFloor2(x3.e / LOG_BASE2) + bitFloor2(y4.e / LOG_BASE2);
          y4.s *= x3.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i2 = xcL;
            xcL = ycL;
            ycL = i2;
          }
          for (i2 = xcL + ycL, zc = []; i2--; zc.push(0))
            ;
          base3 = BASE2;
          sqrtBase = SQRT_BASE2;
          for (i2 = ycL; --i2 >= 0; ) {
            c4 = 0;
            ylo = yc[i2] % sqrtBase;
            yhi = yc[i2] / sqrtBase | 0;
            for (k4 = xcL, j2 = i2 + k4; j2 > i2; ) {
              xlo = xc[--k4] % sqrtBase;
              xhi = xc[k4] / sqrtBase | 0;
              m3 = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m3 % sqrtBase * sqrtBase + zc[j2] + c4;
              c4 = (xlo / base3 | 0) + (m3 / sqrtBase | 0) + yhi * xhi;
              zc[j2--] = xlo % base3;
            }
            zc[j2] = c4;
          }
          if (c4) {
            ++e2;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y4, zc, e2);
        };
        P2.negated = function() {
          var x3 = new BigNumber3(this);
          x3.s = -x3.s || null;
          return x3;
        };
        P2.plus = function(y4, b4) {
          var t, x3 = this, a3 = x3.s;
          y4 = new BigNumber3(y4, b4);
          b4 = y4.s;
          if (!a3 || !b4)
            return new BigNumber3(NaN);
          if (a3 != b4) {
            y4.s = -b4;
            return x3.minus(y4);
          }
          var xe = x3.e / LOG_BASE2, ye = y4.e / LOG_BASE2, xc = x3.c, yc = y4.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return new BigNumber3(a3 / 0);
            if (!xc[0] || !yc[0])
              return yc[0] ? y4 : new BigNumber3(xc[0] ? x3 : a3 * 0);
          }
          xe = bitFloor2(xe);
          ye = bitFloor2(ye);
          xc = xc.slice();
          if (a3 = xe - ye) {
            if (a3 > 0) {
              ye = xe;
              t = yc;
            } else {
              a3 = -a3;
              t = xc;
            }
            t.reverse();
            for (; a3--; t.push(0))
              ;
            t.reverse();
          }
          a3 = xc.length;
          b4 = yc.length;
          if (a3 - b4 < 0) {
            t = yc;
            yc = xc;
            xc = t;
            b4 = a3;
          }
          for (a3 = 0; b4; ) {
            a3 = (xc[--b4] = xc[b4] + yc[b4] + a3) / BASE2 | 0;
            xc[b4] = BASE2 === xc[b4] ? 0 : xc[b4] % BASE2;
          }
          if (a3) {
            xc = [a3].concat(xc);
            ++ye;
          }
          return normalise(y4, xc, ye);
        };
        P2.precision = P2.sd = function(sd, rm) {
          var c4, n3, v2, x3 = this;
          if (sd != null && sd !== !!sd) {
            intCheck2(sd, 1, MAX2);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck2(rm, 0, 8);
            return round(new BigNumber3(x3), sd, rm);
          }
          if (!(c4 = x3.c))
            return null;
          v2 = c4.length - 1;
          n3 = v2 * LOG_BASE2 + 1;
          if (v2 = c4[v2]) {
            for (; v2 % 10 == 0; v2 /= 10, n3--)
              ;
            for (v2 = c4[0]; v2 >= 10; v2 /= 10, n3++)
              ;
          }
          if (sd && x3.e + 1 > n3)
            n3 = x3.e + 1;
          return n3;
        };
        P2.shiftedBy = function(k4) {
          intCheck2(k4, -MAX_SAFE_INTEGER2, MAX_SAFE_INTEGER2);
          return this.times("1e" + k4);
        };
        P2.squareRoot = P2.sqrt = function() {
          var m3, n3, r, rep, t, x3 = this, c4 = x3.c, s2 = x3.s, e2 = x3.e, dp = DECIMAL_PLACES + 4, half = new BigNumber3("0.5");
          if (s2 !== 1 || !c4 || !c4[0]) {
            return new BigNumber3(!s2 || s2 < 0 && (!c4 || c4[0]) ? NaN : c4 ? x3 : 1 / 0);
          }
          s2 = Math.sqrt(+valueOf(x3));
          if (s2 == 0 || s2 == 1 / 0) {
            n3 = coeffToString2(c4);
            if ((n3.length + e2) % 2 == 0)
              n3 += "0";
            s2 = Math.sqrt(+n3);
            e2 = bitFloor2((e2 + 1) / 2) - (e2 < 0 || e2 % 2);
            if (s2 == 1 / 0) {
              n3 = "5e" + e2;
            } else {
              n3 = s2.toExponential();
              n3 = n3.slice(0, n3.indexOf("e") + 1) + e2;
            }
            r = new BigNumber3(n3);
          } else {
            r = new BigNumber3(s2 + "");
          }
          if (r.c[0]) {
            e2 = r.e;
            s2 = e2 + dp;
            if (s2 < 3)
              s2 = 0;
            for (; ; ) {
              t = r;
              r = half.times(t.plus(div(x3, t, dp, 1)));
              if (coeffToString2(t.c).slice(0, s2) === (n3 = coeffToString2(r.c)).slice(0, s2)) {
                if (r.e < e2)
                  --s2;
                n3 = n3.slice(s2 - 3, s2 + 1);
                if (n3 == "9999" || !rep && n3 == "4999") {
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x3)) {
                      r = t;
                      break;
                    }
                  }
                  dp += 4;
                  s2 += 4;
                  rep = 1;
                } else {
                  if (!+n3 || !+n3.slice(1) && n3.charAt(0) == "5") {
                    round(r, r.e + DECIMAL_PLACES + 2, 1);
                    m3 = !r.times(r).eq(x3);
                  }
                  break;
                }
              }
            }
          }
          return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m3);
        };
        P2.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck2(dp, 0, MAX2);
            dp++;
          }
          return format(this, dp, rm, 1);
        };
        P2.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck2(dp, 0, MAX2);
            dp = dp + this.e + 1;
          }
          return format(this, dp, rm);
        };
        P2.toFormat = function(dp, rm, format2) {
          var str, x3 = this;
          if (format2 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format2 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format2 = dp;
              dp = rm = null;
            } else {
              format2 = FORMAT;
            }
          } else if (typeof format2 != "object") {
            throw Error(bignumberError2 + "Argument not an object: " + format2);
          }
          str = x3.toFixed(dp, rm);
          if (x3.c) {
            var i2, arr = str.split("."), g1 = +format2.groupSize, g22 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x3.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g22) {
              i2 = g1;
              g1 = g22;
              g22 = i2;
              len -= i2;
            }
            if (g1 > 0 && len > 0) {
              i2 = len % g1 || g1;
              intPart = intDigits.substr(0, i2);
              for (; i2 < len; i2 += g1)
                intPart += groupSeparator + intDigits.substr(i2, g1);
              if (g22 > 0)
                intPart += groupSeparator + intDigits.slice(i2);
              if (isNeg)
                intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g22 = +format2.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g22 + "}\\B", "g"),
              "$&" + (format2.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format2.prefix || "") + str + (format2.suffix || "");
        };
        P2.toFraction = function(md) {
          var d3, d0, d1, d22, e2, exp, n3, n0, n1, q2, r, s2, x3 = this, xc = x3.c;
          if (md != null) {
            n3 = new BigNumber3(md);
            if (!n3.isInteger() && (n3.c || n3.s !== 1) || n3.lt(ONE)) {
              throw Error(bignumberError2 + "Argument " + (n3.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n3));
            }
          }
          if (!xc)
            return new BigNumber3(x3);
          d3 = new BigNumber3(ONE);
          n1 = d0 = new BigNumber3(ONE);
          d1 = n0 = new BigNumber3(ONE);
          s2 = coeffToString2(xc);
          e2 = d3.e = s2.length - x3.e - 1;
          d3.c[0] = POWS_TEN2[(exp = e2 % LOG_BASE2) < 0 ? LOG_BASE2 + exp : exp];
          md = !md || n3.comparedTo(d3) > 0 ? e2 > 0 ? d3 : n1 : n3;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n3 = new BigNumber3(s2);
          n0.c[0] = 0;
          for (; ; ) {
            q2 = div(n3, d3, 0, 1);
            d22 = d0.plus(q2.times(d1));
            if (d22.comparedTo(md) == 1)
              break;
            d0 = d1;
            d1 = d22;
            n1 = n0.plus(q2.times(d22 = n1));
            n0 = d22;
            d3 = n3.minus(q2.times(d22 = d3));
            n3 = d22;
          }
          d22 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d22.times(n1));
          d0 = d0.plus(d22.times(d1));
          n0.s = n1.s = x3.s;
          e2 = e2 * 2;
          r = div(n1, d1, e2, ROUNDING_MODE).minus(x3).abs().comparedTo(
            div(n0, d0, e2, ROUNDING_MODE).minus(x3).abs()
          ) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp;
          return r;
        };
        P2.toNumber = function() {
          return +valueOf(this);
        };
        P2.toPrecision = function(sd, rm) {
          if (sd != null)
            intCheck2(sd, 1, MAX2);
          return format(this, sd, rm, 2);
        };
        P2.toString = function(b4) {
          var str, n3 = this, s2 = n3.s, e2 = n3.e;
          if (e2 === null) {
            if (s2) {
              str = "Infinity";
              if (s2 < 0)
                str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b4 == null) {
              str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential2(coeffToString2(n3.c), e2) : toFixedPoint2(coeffToString2(n3.c), e2, "0");
            } else if (b4 === 10 && alphabetHasNormalDecimalDigits) {
              n3 = round(new BigNumber3(n3), DECIMAL_PLACES + e2 + 1, ROUNDING_MODE);
              str = toFixedPoint2(coeffToString2(n3.c), n3.e, "0");
            } else {
              intCheck2(b4, 2, ALPHABET.length, "Base");
              str = convertBase(toFixedPoint2(coeffToString2(n3.c), e2, "0"), 10, b4, s2, true);
            }
            if (s2 < 0 && n3.c[0])
              str = "-" + str;
          }
          return str;
        };
        P2.valueOf = P2.toJSON = function() {
          return valueOf(this);
        };
        P2._isBigNumber = true;
        if (configObject != null)
          BigNumber3.set(configObject);
        return BigNumber3;
      }
      function bitFloor2(n3) {
        var i2 = n3 | 0;
        return n3 > 0 || n3 === i2 ? i2 : i2 - 1;
      }
      function coeffToString2(a3) {
        var s2, z3, i2 = 1, j2 = a3.length, r = a3[0] + "";
        for (; i2 < j2; ) {
          s2 = a3[i2++] + "";
          z3 = LOG_BASE2 - s2.length;
          for (; z3--; s2 = "0" + s2)
            ;
          r += s2;
        }
        for (j2 = r.length; r.charCodeAt(--j2) === 48; )
          ;
        return r.slice(0, j2 + 1 || 1);
      }
      function compare3(x3, y4) {
        var a3, b4, xc = x3.c, yc = y4.c, i2 = x3.s, j2 = y4.s, k4 = x3.e, l4 = y4.e;
        if (!i2 || !j2)
          return null;
        a3 = xc && !xc[0];
        b4 = yc && !yc[0];
        if (a3 || b4)
          return a3 ? b4 ? 0 : -j2 : i2;
        if (i2 != j2)
          return i2;
        a3 = i2 < 0;
        b4 = k4 == l4;
        if (!xc || !yc)
          return b4 ? 0 : !xc ^ a3 ? 1 : -1;
        if (!b4)
          return k4 > l4 ^ a3 ? 1 : -1;
        j2 = (k4 = xc.length) < (l4 = yc.length) ? k4 : l4;
        for (i2 = 0; i2 < j2; i2++)
          if (xc[i2] != yc[i2])
            return xc[i2] > yc[i2] ^ a3 ? 1 : -1;
        return k4 == l4 ? 0 : k4 > l4 ^ a3 ? 1 : -1;
      }
      function intCheck2(n3, min, max, name2) {
        if (n3 < min || n3 > max || n3 !== mathfloor2(n3)) {
          throw Error(bignumberError2 + (name2 || "Argument") + (typeof n3 == "number" ? n3 < min || n3 > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n3));
        }
      }
      function isOdd2(n3) {
        var k4 = n3.c.length - 1;
        return bitFloor2(n3.e / LOG_BASE2) == k4 && n3.c[k4] % 2 != 0;
      }
      function toExponential2(str, e2) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e2 < 0 ? "e" : "e+") + e2;
      }
      function toFixedPoint2(str, e2, z3) {
        var len, zs;
        if (e2 < 0) {
          for (zs = z3 + "."; ++e2; zs += z3)
            ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e2 > len) {
            for (zs = z3, e2 -= len; --e2; zs += z3)
              ;
            str += zs;
          } else if (e2 < len) {
            str = str.slice(0, e2) + "." + str.slice(e2);
          }
        }
        return str;
      }
      BigNumber2 = clone2();
      BigNumber2["default"] = BigNumber2.BigNumber = BigNumber2;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber2;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = BigNumber2;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber2;
      }
    })(exports2);
  }
});

// node_modules/@multiversx/sdk-core/out/errors.js
var require_errors = __commonJS({
  "node_modules/@multiversx/sdk-core/out/errors.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ErrParseTransactionOutcome = exports2.ErrInvalidInnerTransaction = exports2.ErrBadUsage = exports2.ErrInvalidTokenIdentifier = exports2.ErrIsCompletedFieldIsMissingOnTransaction = exports2.ErrGasLimitShouldBe0ForInnerTransaction = exports2.ErrInvalidRelayedV2BuilderArguments = exports2.ErrInvalidRelayedV1BuilderArguments = exports2.ErrNotImplemented = exports2.ErrContractInteraction = exports2.ErrCodec = exports2.ErrCannotParseTransactionOutcome = exports2.ErrCannotParseContractResults = exports2.ErrMissingFieldOnEnum = exports2.ErrMissingFieldOnStruct = exports2.ErrTypingSystem = exports2.ErrMock = exports2.ErrContractHasNoAddress = exports2.ErrContract = exports2.ErrExpectedTransactionEventsNotFound = exports2.ErrExpectedTransactionStatusNotReached = exports2.ErrTransactionWatcherTimeout = exports2.ErrAsyncTimerAborted = exports2.ErrAsyncTimerAlreadyRunning = exports2.ErrInvalidFunctionName = exports2.ErrSignatureCannotCreate = exports2.ErrTransactionOptionsInvalid = exports2.ErrTransactionVersionInvalid = exports2.ErrNonceInvalid = exports2.ErrNotEnoughGas = exports2.ErrAddressEmpty = exports2.ErrAddressBadHrp = exports2.ErrAddressCannotCreate = exports2.ErrUnexpectedCondition = exports2.ErrInvariantFailed = exports2.ErrBadType = exports2.ErrUnsupportedOperation = exports2.ErrInvalidArgument = exports2.Err = void 0;
    var Err = class extends Error {
      constructor(message, inner) {
        super(message);
        this.inner = void 0;
        this.inner = inner;
      }
      /**
       * Returns a pretty, friendly summary for the error or for the chain of errros (if appropriate).
       */
      summary() {
        let result = [];
        result.push({ name: this.name, message: this.message });
        let inner = this.inner;
        while (inner) {
          result.push({ name: inner.name, message: inner.message });
          inner = inner.inner;
        }
        return result;
      }
    };
    exports2.Err = Err;
    var ErrInvalidArgument = class extends Err {
      constructor(message, inner) {
        super(`Invalid argument: ${message}`, inner);
      }
    };
    exports2.ErrInvalidArgument = ErrInvalidArgument;
    var ErrUnsupportedOperation = class extends Err {
      constructor(operation, reason = "not specified") {
        super(`Operation "${operation}" not supported. Reason: ${reason}`);
      }
    };
    exports2.ErrUnsupportedOperation = ErrUnsupportedOperation;
    var ErrBadType = class extends Err {
      constructor(name2, type, value) {
        super(`Bad type of "${name2}": ${value}. Expected type: ${type}`);
      }
    };
    exports2.ErrBadType = ErrBadType;
    var ErrInvariantFailed = class extends Err {
      constructor(message) {
        super(`Invariant failed: [${message}]`);
      }
    };
    exports2.ErrInvariantFailed = ErrInvariantFailed;
    var ErrUnexpectedCondition = class extends Err {
      constructor(message) {
        super(`Unexpected condition: [${message}]`);
      }
    };
    exports2.ErrUnexpectedCondition = ErrUnexpectedCondition;
    var ErrAddressCannotCreate = class extends Err {
      constructor(input, inner) {
        let message = `Cannot create address from: ${input}`;
        super(message, inner);
      }
    };
    exports2.ErrAddressCannotCreate = ErrAddressCannotCreate;
    var ErrAddressBadHrp = class extends Err {
      constructor(expected, got) {
        super(`Wrong address HRP. Expected: ${expected}, got ${got}`);
      }
    };
    exports2.ErrAddressBadHrp = ErrAddressBadHrp;
    var ErrAddressEmpty = class extends Err {
      constructor() {
        super(`Address is empty`);
      }
    };
    exports2.ErrAddressEmpty = ErrAddressEmpty;
    var ErrNotEnoughGas = class extends Err {
      constructor(value) {
        super(`Not enough gas provided: ${value}`);
      }
    };
    exports2.ErrNotEnoughGas = ErrNotEnoughGas;
    var ErrNonceInvalid = class extends Err {
      constructor(value) {
        super(`Invalid nonce: ${value}`);
      }
    };
    exports2.ErrNonceInvalid = ErrNonceInvalid;
    var ErrTransactionVersionInvalid = class extends Err {
      constructor(value) {
        super(`Invalid transaction version: ${value}`);
      }
    };
    exports2.ErrTransactionVersionInvalid = ErrTransactionVersionInvalid;
    var ErrTransactionOptionsInvalid = class extends Err {
      constructor(value) {
        super(`Invalid transaction options: ${value}`);
      }
    };
    exports2.ErrTransactionOptionsInvalid = ErrTransactionOptionsInvalid;
    var ErrSignatureCannotCreate = class extends Err {
      constructor(input, inner) {
        let message = `Cannot create signature from: ${input}`;
        super(message, inner);
      }
    };
    exports2.ErrSignatureCannotCreate = ErrSignatureCannotCreate;
    var ErrInvalidFunctionName = class extends Err {
      constructor() {
        super(`Invalid function name`);
      }
    };
    exports2.ErrInvalidFunctionName = ErrInvalidFunctionName;
    var ErrAsyncTimerAlreadyRunning = class extends Err {
      constructor() {
        super("Async timer already running");
      }
    };
    exports2.ErrAsyncTimerAlreadyRunning = ErrAsyncTimerAlreadyRunning;
    var ErrAsyncTimerAborted = class extends Err {
      constructor() {
        super("Async timer aborted");
      }
    };
    exports2.ErrAsyncTimerAborted = ErrAsyncTimerAborted;
    var ErrTransactionWatcherTimeout = class extends Err {
      constructor() {
        super(`TransactionWatcher has timed out`);
      }
    };
    exports2.ErrTransactionWatcherTimeout = ErrTransactionWatcherTimeout;
    var ErrExpectedTransactionStatusNotReached = class extends Err {
      constructor() {
        super(`Expected transaction status not reached`);
      }
    };
    exports2.ErrExpectedTransactionStatusNotReached = ErrExpectedTransactionStatusNotReached;
    var ErrExpectedTransactionEventsNotFound = class extends Err {
      constructor() {
        super(`Expected transaction events not found`);
      }
    };
    exports2.ErrExpectedTransactionEventsNotFound = ErrExpectedTransactionEventsNotFound;
    var ErrContract = class extends Err {
      constructor(message) {
        super(message);
      }
    };
    exports2.ErrContract = ErrContract;
    var ErrContractHasNoAddress = class extends ErrContract {
      constructor() {
        super(`
The smart contract has no address set. Make sure you provide the address in the constructor, or call setAddress() appropriately.
If you need to recompute the address of the contract, make use of SmartContract.computeAddress() (static method). 
`);
      }
    };
    exports2.ErrContractHasNoAddress = ErrContractHasNoAddress;
    var ErrMock = class extends Err {
      constructor(message) {
        super(message);
      }
    };
    exports2.ErrMock = ErrMock;
    var ErrTypingSystem = class extends Err {
      constructor(message) {
        super(message);
      }
    };
    exports2.ErrTypingSystem = ErrTypingSystem;
    var ErrMissingFieldOnStruct = class extends Err {
      constructor(fieldName, structName) {
        super(`field ${fieldName} does not exist on struct ${structName}`);
      }
    };
    exports2.ErrMissingFieldOnStruct = ErrMissingFieldOnStruct;
    var ErrMissingFieldOnEnum = class extends Err {
      constructor(fieldName, enumName) {
        super(`field ${fieldName} does not exist on enum ${enumName}`);
      }
    };
    exports2.ErrMissingFieldOnEnum = ErrMissingFieldOnEnum;
    var ErrCannotParseContractResults = class extends Err {
      constructor(details) {
        super(`cannot parse contract results: ${details}`);
      }
    };
    exports2.ErrCannotParseContractResults = ErrCannotParseContractResults;
    var ErrCannotParseTransactionOutcome = class extends Err {
      constructor(transactionHash, message) {
        super(`cannot parse outcome of transaction ${transactionHash}: ${message}`);
      }
    };
    exports2.ErrCannotParseTransactionOutcome = ErrCannotParseTransactionOutcome;
    var ErrCodec = class extends Err {
      constructor(message) {
        super(message);
      }
    };
    exports2.ErrCodec = ErrCodec;
    var ErrContractInteraction = class extends Err {
      constructor(message) {
        super(message);
      }
    };
    exports2.ErrContractInteraction = ErrContractInteraction;
    var ErrNotImplemented = class extends Err {
      constructor() {
        super("Method not yet implemented");
      }
    };
    exports2.ErrNotImplemented = ErrNotImplemented;
    var ErrInvalidRelayedV1BuilderArguments = class extends Err {
      constructor() {
        super("invalid arguments for relayed v1 builder");
      }
    };
    exports2.ErrInvalidRelayedV1BuilderArguments = ErrInvalidRelayedV1BuilderArguments;
    var ErrInvalidRelayedV2BuilderArguments = class extends Err {
      constructor() {
        super("invalid arguments for relayed v2 builder");
      }
    };
    exports2.ErrInvalidRelayedV2BuilderArguments = ErrInvalidRelayedV2BuilderArguments;
    var ErrGasLimitShouldBe0ForInnerTransaction = class extends Err {
      constructor() {
        super("gas limit must be 0 for the inner transaction for relayed v2");
      }
    };
    exports2.ErrGasLimitShouldBe0ForInnerTransaction = ErrGasLimitShouldBe0ForInnerTransaction;
    var ErrIsCompletedFieldIsMissingOnTransaction = class extends Err {
      constructor() {
        super("The transaction watcher requires the `isCompleted` property to be defined on the transaction object. Perhaps you've used the sdk-network-provider's `ProxyNetworkProvider.getTransaction()` and in that case you should also pass `withProcessStatus=true`.");
      }
    };
    exports2.ErrIsCompletedFieldIsMissingOnTransaction = ErrIsCompletedFieldIsMissingOnTransaction;
    var ErrInvalidTokenIdentifier = class extends Err {
      constructor(message) {
        super(message);
      }
    };
    exports2.ErrInvalidTokenIdentifier = ErrInvalidTokenIdentifier;
    var ErrBadUsage = class extends Err {
      constructor(message) {
        super(message);
      }
    };
    exports2.ErrBadUsage = ErrBadUsage;
    var ErrInvalidInnerTransaction = class extends Err {
      constructor(message) {
        super(message);
      }
    };
    exports2.ErrInvalidInnerTransaction = ErrInvalidInnerTransaction;
    var ErrParseTransactionOutcome = class extends Err {
      constructor(message) {
        super(message);
      }
    };
    exports2.ErrParseTransactionOutcome = ErrParseTransactionOutcome;
  }
});

// node_modules/@multiversx/sdk-core/out/tokens.js
var require_tokens = __commonJS({
  "node_modules/@multiversx/sdk-core/out/tokens.js"(exports2) {
    "use strict";
    init_shim();
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TokenPayment = exports2.TokenComputer = exports2.TokenTransfer = exports2.Token = void 0;
    var bignumber_js_1 = __importDefault2(require_bignumber());
    var errors_1 = require_errors();
    var EGLDTokenIdentifier = "EGLD";
    var EGLDNumDecimals = 18;
    bignumber_js_1.default.set({ ROUNDING_MODE: 1 });
    var Token2 = class {
      constructor(options) {
        this.identifier = options.identifier;
        this.nonce = options.nonce || 0n;
      }
    };
    exports2.Token = Token2;
    var TokenTransfer2 = class _TokenTransfer {
      constructor(options) {
        if (this.isLegacyTokenTransferOptions(options)) {
          const amount = new bignumber_js_1.default(options.amountAsBigInteger);
          if (!amount.isInteger() || amount.isNegative()) {
            throw new errors_1.ErrInvalidArgument(`bad amountAsBigInteger: ${options.amountAsBigInteger}`);
          }
          this.tokenIdentifier = options.tokenIdentifier;
          this.nonce = options.nonce;
          this.amountAsBigInteger = amount;
          this.numDecimals = options.numDecimals || 0;
          this.token = new Token2({
            identifier: options.tokenIdentifier,
            nonce: BigInt(options.nonce)
          });
          this.amount = BigInt(this.amountAsBigInteger.toFixed(0));
        } else {
          this.token = options.token;
          this.amount = options.amount;
          this.tokenIdentifier = options.token.identifier;
          this.nonce = Number(options.token.nonce);
          this.amountAsBigInteger = new bignumber_js_1.default(this.amount.toString());
          this.numDecimals = 0;
        }
      }
      isLegacyTokenTransferOptions(options) {
        return options.tokenIdentifier !== void 0;
      }
      /**
       * Legacy function. Use the constructor instead: new TokenTransfer({ token, amount });
       */
      static egldFromAmount(amount) {
        const amountAsBigInteger = new bignumber_js_1.default(amount).shiftedBy(EGLDNumDecimals).decimalPlaces(0);
        return this.egldFromBigInteger(amountAsBigInteger);
      }
      /**
       * Legacy function. Use the constructor instead: new TokenTransfer({ token, amount });
       */
      static egldFromBigInteger(amountAsBigInteger) {
        return new _TokenTransfer({
          tokenIdentifier: EGLDTokenIdentifier,
          nonce: 0,
          amountAsBigInteger,
          numDecimals: EGLDNumDecimals
        });
      }
      /**
       * Legacy function. Use the constructor instead: new TokenTransfer({ token, amount });
       */
      static fungibleFromAmount(tokenIdentifier, amount, numDecimals) {
        const amountAsBigInteger = new bignumber_js_1.default(amount).shiftedBy(numDecimals).decimalPlaces(0);
        return this.fungibleFromBigInteger(tokenIdentifier, amountAsBigInteger, numDecimals);
      }
      /**
       * Legacy function. Use the constructor instead: new TokenTransfer({ token, amount });
       */
      static fungibleFromBigInteger(tokenIdentifier, amountAsBigInteger, numDecimals = 0) {
        return new _TokenTransfer({
          tokenIdentifier,
          nonce: 0,
          amountAsBigInteger,
          numDecimals
        });
      }
      /**
       * Legacy function. Use the constructor instead: new TokenTransfer({ token, amount });
       */
      static nonFungible(tokenIdentifier, nonce) {
        return new _TokenTransfer({
          tokenIdentifier,
          nonce,
          amountAsBigInteger: 1,
          numDecimals: 0
        });
      }
      /**
       * Legacy function. Use the constructor instead: new TokenTransfer({ token, amount });
       */
      static semiFungible(tokenIdentifier, nonce, quantity) {
        return new _TokenTransfer({
          tokenIdentifier,
          nonce,
          amountAsBigInteger: quantity,
          numDecimals: 0
        });
      }
      /**
       * Legacy function. Use the constructor instead: new TokenTransfer({ token, amount });
       */
      static metaEsdtFromAmount(tokenIdentifier, nonce, amount, numDecimals) {
        const amountAsBigInteger = new bignumber_js_1.default(amount).shiftedBy(numDecimals).decimalPlaces(0);
        return this.metaEsdtFromBigInteger(tokenIdentifier, nonce, amountAsBigInteger, numDecimals);
      }
      /**
       * Legacy function. Use the constructor instead: new TokenTransfer({ token, amount });
       */
      static metaEsdtFromBigInteger(tokenIdentifier, nonce, amountAsBigInteger, numDecimals = 0) {
        return new _TokenTransfer({
          tokenIdentifier,
          nonce,
          amountAsBigInteger,
          numDecimals
        });
      }
      toString() {
        return this.amount.toString();
      }
      /**
       * Legacy function. Use the "amount" field instead.
       */
      valueOf() {
        return new bignumber_js_1.default(this.amount.toString());
      }
      /**
       * Legacy function. For formatting and parsing amounts, use "sdk-dapp" or "bignumber.js" directly.
       */
      toPrettyString() {
        return `${this.toAmount()} ${this.tokenIdentifier}`;
      }
      toAmount() {
        return this.amountAsBigInteger.shiftedBy(-this.numDecimals).toFixed(this.numDecimals);
      }
      /**
       * Legacy function. Within your code, don't mix native values (EGLD) and custom (ESDT) tokens.
       * See "TransferTransactionsFactory.createTransactionForNativeTokenTransfer()" vs. "TransferTransactionsFactory.createTransactionForESDTTokenTransfer()".
       */
      isEgld() {
        return this.token.identifier == EGLDTokenIdentifier;
      }
      /**
       * Legacy function. Use "TokenComputer.isFungible(token)" instead.
       */
      isFungible() {
        return this.token.nonce == 0n;
      }
    };
    exports2.TokenTransfer = TokenTransfer2;
    var TokenComputer2 = class {
      constructor() {
      }
      isFungible(token) {
        return token.nonce === 0n;
      }
      extractNonceFromExtendedIdentifier(identifier) {
        const parts = identifier.split("-");
        this.checkIfExtendedIdentifierWasProvided(parts);
        this.checkLengthOfRandomSequence(parts[1]);
        if (parts.length == 2) {
          return 0;
        }
        const hexNonce = import_buffer.Buffer.from(parts[2], "hex");
        return decodeUnsignedNumber(hexNonce);
      }
      extractIdentifierFromExtendedIdentifier(identifier) {
        const parts = identifier.split("-");
        this.checkIfExtendedIdentifierWasProvided(parts);
        this.ensureTokenTickerValidity(parts[0]);
        this.checkLengthOfRandomSequence(parts[1]);
        return parts[0] + "-" + parts[1];
      }
      checkIfExtendedIdentifierWasProvided(tokenParts) {
        const MIN_EXTENDED_IDENTIFIER_LENGTH_IF_SPLITTED = 2;
        const MAX_EXTENDED_IDENTIFIER_LENGTH_IF_SPLITTED = 3;
        if (tokenParts.length < MIN_EXTENDED_IDENTIFIER_LENGTH_IF_SPLITTED || tokenParts.length > MAX_EXTENDED_IDENTIFIER_LENGTH_IF_SPLITTED) {
          throw new errors_1.ErrInvalidTokenIdentifier("Invalid extended token identifier provided");
        }
      }
      checkLengthOfRandomSequence(randomSequence) {
        const TOKEN_RANDOM_SEQUENCE_LENGTH = 6;
        if (randomSequence.length !== TOKEN_RANDOM_SEQUENCE_LENGTH) {
          throw new errors_1.ErrInvalidTokenIdentifier("The identifier is not valid. The random sequence does not have the right length");
        }
      }
      ensureTokenTickerValidity(ticker) {
        const MIN_TICKER_LENGTH = 3;
        const MAX_TICKER_LENGTH = 10;
        if (ticker.length < MIN_TICKER_LENGTH || ticker.length > MAX_TICKER_LENGTH) {
          throw new errors_1.ErrInvalidTokenIdentifier(`The token ticker should be between ${MIN_TICKER_LENGTH} and ${MAX_TICKER_LENGTH} characters`);
        }
        if (!ticker.match(/^[a-zA-Z0-9]+$/)) {
          throw new errors_1.ErrInvalidTokenIdentifier("The token ticker should only contain alphanumeric characters");
        }
        if (!(ticker == ticker.toUpperCase())) {
          throw new errors_1.ErrInvalidTokenIdentifier("The token ticker should be upper case");
        }
      }
    };
    exports2.TokenComputer = TokenComputer2;
    function decodeUnsignedNumber(arg) {
      return arg.readUIntBE(0, arg.length);
    }
    var TokenPayment = class extends TokenTransfer2 {
      constructor(tokenIdentifier, nonce, amountAsBigInteger, numDecimals) {
        super({
          tokenIdentifier,
          nonce,
          amountAsBigInteger,
          numDecimals
        });
      }
    };
    exports2.TokenPayment = TokenPayment;
  }
});

// node_modules/@multiversx/sdk-core/out/constants.js
var require_constants = __commonJS({
  "node_modules/@multiversx/sdk-core/out/constants.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UNKNOWN_SIGNER = exports2.SDK_JS_SIGNER = exports2.METACHAIN_ID = exports2.WasmVirtualMachine = exports2.CURRENT_NUMBER_OF_SHARDS_WITHOUT_META = exports2.BECH32_ADDRESS_LENGTH = exports2.HEX_TRANSACTION_HASH_LENGTH = exports2.MESSAGE_PREFIX = exports2.DEFAULT_MESSAGE_VERSION = exports2.ESDT_CONTRACT_ADDRESS = exports2.DEFAULT_HRP = exports2.DELEGATION_MANAGER_SC_ADDRESS = exports2.CONTRACT_DEPLOY_ADDRESS = exports2.VM_TYPE_WASM_VM = exports2.ARGUMENTS_SEPARATOR = exports2.ESDT_TRANSFER_VALUE = exports2.MULTI_ESDTNFT_TRANSFER_FUNCTION_NAME = exports2.ESDTNFT_TRANSFER_FUNCTION_NAME = exports2.ESDT_TRANSFER_FUNCTION_NAME = exports2.ESDT_TRANSFER_GAS_LIMIT = exports2.MIN_TRANSACTION_VERSION_THAT_SUPPORTS_OPTIONS = exports2.TRANSACTION_VERSION_DEFAULT = exports2.TRANSACTION_OPTIONS_TX_GUARDED = exports2.TRANSACTION_OPTIONS_TX_HASH_SIGN = exports2.TRANSACTION_OPTIONS_DEFAULT = exports2.TRANSACTION_MIN_GAS_PRICE = void 0;
    exports2.TRANSACTION_MIN_GAS_PRICE = 1e9;
    exports2.TRANSACTION_OPTIONS_DEFAULT = 0;
    exports2.TRANSACTION_OPTIONS_TX_HASH_SIGN = 1;
    exports2.TRANSACTION_OPTIONS_TX_GUARDED = 2;
    exports2.TRANSACTION_VERSION_DEFAULT = 2;
    exports2.MIN_TRANSACTION_VERSION_THAT_SUPPORTS_OPTIONS = 2;
    exports2.ESDT_TRANSFER_GAS_LIMIT = 5e5;
    exports2.ESDT_TRANSFER_FUNCTION_NAME = "ESDTTransfer";
    exports2.ESDTNFT_TRANSFER_FUNCTION_NAME = "ESDTNFTTransfer";
    exports2.MULTI_ESDTNFT_TRANSFER_FUNCTION_NAME = "MultiESDTNFTTransfer";
    exports2.ESDT_TRANSFER_VALUE = "0";
    exports2.ARGUMENTS_SEPARATOR = "@";
    exports2.VM_TYPE_WASM_VM = new Uint8Array([5, 0]);
    exports2.CONTRACT_DEPLOY_ADDRESS = "erd1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq6gq4hu";
    exports2.DELEGATION_MANAGER_SC_ADDRESS = "erd1qqqqqqqqqqqqqqqpqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqylllslmq6y6";
    exports2.DEFAULT_HRP = "erd";
    exports2.ESDT_CONTRACT_ADDRESS = "erd1qqqqqqqqqqqqqqqpqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqzllls8a5w6u";
    exports2.DEFAULT_MESSAGE_VERSION = 1;
    exports2.MESSAGE_PREFIX = "Elrond Signed Message:\n";
    exports2.HEX_TRANSACTION_HASH_LENGTH = 64;
    exports2.BECH32_ADDRESS_LENGTH = 62;
    exports2.CURRENT_NUMBER_OF_SHARDS_WITHOUT_META = 3;
    exports2.WasmVirtualMachine = "0500";
    exports2.METACHAIN_ID = 4294967295;
    exports2.SDK_JS_SIGNER = "sdk-js";
    exports2.UNKNOWN_SIGNER = "unknown";
  }
});

// node_modules/@multiversx/sdk-core/out/logger.js
var require_logger = __commonJS({
  "node_modules/@multiversx/sdk-core/out/logger.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Logger = exports2.LogLevel = void 0;
    var LogLevel;
    (function(LogLevel2) {
      LogLevel2[LogLevel2["Trace"] = 0] = "Trace";
      LogLevel2[LogLevel2["Debug"] = 1] = "Debug";
      LogLevel2[LogLevel2["Info"] = 2] = "Info";
      LogLevel2[LogLevel2["Warn"] = 3] = "Warn";
      LogLevel2[LogLevel2["Error"] = 4] = "Error";
      LogLevel2[LogLevel2["None"] = 5] = "None";
    })(LogLevel = exports2.LogLevel || (exports2.LogLevel = {}));
    var Logger = class _Logger {
      static setLevel(logLevel) {
        _Logger.logLevel = logLevel;
      }
      static trace(message, ...optionalParams) {
        if (_Logger.logLevel >= LogLevel.Debug) {
          return;
        }
        console.debug(message, optionalParams);
      }
      static debug(message, ...optionalParams) {
        if (_Logger.logLevel >= LogLevel.Debug) {
          return;
        }
        console.debug(message, optionalParams);
      }
      static info(message, ...optionalParams) {
        if (_Logger.logLevel >= LogLevel.Info) {
          return;
        }
        console.log(message, optionalParams);
      }
      static warn(message, ...optionalParams) {
        if (_Logger.logLevel >= LogLevel.Warn) {
          return;
        }
        console.warn(message, optionalParams);
      }
      static error(message, ...optionalParams) {
        if (_Logger.logLevel >= LogLevel.Error) {
          return;
        }
        console.error(message, optionalParams);
      }
    };
    exports2.Logger = Logger;
    Logger.logLevel = LogLevel.Debug;
  }
});

// node_modules/@multiversx/sdk-core/out/networkParams.js
var require_networkParams = __commonJS({
  "node_modules/@multiversx/sdk-core/out/networkParams.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k4 in mod2)
          if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k4))
            __createBinding2(result, mod2, k4);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransactionOptions = exports2.TransactionVersion = void 0;
    var constants_1 = require_constants();
    var errors = __importStar2(require_errors());
    var TransactionVersion2 = class _TransactionVersion {
      /**
       * Creates a TransactionVersion object given a value.
       */
      constructor(value) {
        value = Number(value);
        if (value < 1) {
          throw new errors.ErrTransactionVersionInvalid(value);
        }
        this.value = value;
      }
      /**
       * Creates a TransactionVersion object with the default version setting
       */
      static withDefaultVersion() {
        return new _TransactionVersion(constants_1.TRANSACTION_VERSION_DEFAULT);
      }
      /**
       * Creates a TransactionVersion object with the VERSION setting for enabling options
       */
      static withTxOptions() {
        return new _TransactionVersion(constants_1.TRANSACTION_VERSION_DEFAULT);
      }
      valueOf() {
        return this.value;
      }
    };
    exports2.TransactionVersion = TransactionVersion2;
    var TransactionOptions2 = class _TransactionOptions {
      /**
       * Creates a TransactionOptions from a numeric value.
       */
      constructor(value) {
        value = Number(value);
        if (value < 0) {
          throw new errors.ErrTransactionOptionsInvalid(value);
        }
        this.value = value;
      }
      /**
       * Creates a TransactionOptions object with the default options.
       */
      static withDefaultOptions() {
        return new _TransactionOptions(constants_1.TRANSACTION_OPTIONS_DEFAULT);
      }
      /**
       * Creates a TransactionOptions object from a set of options.
       */
      static withOptions(options) {
        let value = 0;
        if (options.hashSign) {
          value |= constants_1.TRANSACTION_OPTIONS_TX_HASH_SIGN;
        }
        if (options.guarded) {
          value |= constants_1.TRANSACTION_OPTIONS_TX_GUARDED;
        }
        return new _TransactionOptions(value);
      }
      /**
       * Returns true if the "hash sign" option is set.
       */
      isWithHashSign() {
        return (this.value & constants_1.TRANSACTION_OPTIONS_TX_HASH_SIGN) == constants_1.TRANSACTION_OPTIONS_TX_HASH_SIGN;
      }
      /**
       * Returns true if the "guarded transaction" option is set.
       */
      isWithGuardian() {
        return (this.value & constants_1.TRANSACTION_OPTIONS_TX_GUARDED) == constants_1.TRANSACTION_OPTIONS_TX_GUARDED;
      }
      /**
       * Sets the "hash sign" option.
       */
      setWithHashSign() {
        this.value |= constants_1.TRANSACTION_OPTIONS_TX_HASH_SIGN;
      }
      /**
       * Sets the "guarded transaction" option.
       */
      setWithGuardian() {
        this.value |= constants_1.TRANSACTION_OPTIONS_TX_GUARDED;
      }
      valueOf() {
        return this.value;
      }
    };
    exports2.TransactionOptions = TransactionOptions2;
  }
});

// node_modules/bech32/index.js
var require_bech32 = __commonJS({
  "node_modules/bech32/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
    var ALPHABET_MAP = {};
    for (z3 = 0; z3 < ALPHABET.length; z3++) {
      x3 = ALPHABET.charAt(z3);
      if (ALPHABET_MAP[x3] !== void 0)
        throw new TypeError(x3 + " is ambiguous");
      ALPHABET_MAP[x3] = z3;
    }
    var x3;
    var z3;
    function polymodStep(pre) {
      var b4 = pre >> 25;
      return (pre & 33554431) << 5 ^ -(b4 >> 0 & 1) & 996825010 ^ -(b4 >> 1 & 1) & 642813549 ^ -(b4 >> 2 & 1) & 513874426 ^ -(b4 >> 3 & 1) & 1027748829 ^ -(b4 >> 4 & 1) & 705979059;
    }
    function prefixChk(prefix) {
      var chk = 1;
      for (var i2 = 0; i2 < prefix.length; ++i2) {
        var c4 = prefix.charCodeAt(i2);
        if (c4 < 33 || c4 > 126)
          return "Invalid prefix (" + prefix + ")";
        chk = polymodStep(chk) ^ c4 >> 5;
      }
      chk = polymodStep(chk);
      for (i2 = 0; i2 < prefix.length; ++i2) {
        var v2 = prefix.charCodeAt(i2);
        chk = polymodStep(chk) ^ v2 & 31;
      }
      return chk;
    }
    function encode5(prefix, words, LIMIT) {
      LIMIT = LIMIT || 90;
      if (prefix.length + 7 + words.length > LIMIT)
        throw new TypeError("Exceeds length limit");
      prefix = prefix.toLowerCase();
      var chk = prefixChk(prefix);
      if (typeof chk === "string")
        throw new Error(chk);
      var result = prefix + "1";
      for (var i2 = 0; i2 < words.length; ++i2) {
        var x4 = words[i2];
        if (x4 >> 5 !== 0)
          throw new Error("Non 5-bit word");
        chk = polymodStep(chk) ^ x4;
        result += ALPHABET.charAt(x4);
      }
      for (i2 = 0; i2 < 6; ++i2) {
        chk = polymodStep(chk);
      }
      chk ^= 1;
      for (i2 = 0; i2 < 6; ++i2) {
        var v2 = chk >> (5 - i2) * 5 & 31;
        result += ALPHABET.charAt(v2);
      }
      return result;
    }
    function __decode(str, LIMIT) {
      LIMIT = LIMIT || 90;
      if (str.length < 8)
        return str + " too short";
      if (str.length > LIMIT)
        return "Exceeds length limit";
      var lowered = str.toLowerCase();
      var uppered = str.toUpperCase();
      if (str !== lowered && str !== uppered)
        return "Mixed-case string " + str;
      str = lowered;
      var split = str.lastIndexOf("1");
      if (split === -1)
        return "No separator character for " + str;
      if (split === 0)
        return "Missing prefix for " + str;
      var prefix = str.slice(0, split);
      var wordChars = str.slice(split + 1);
      if (wordChars.length < 6)
        return "Data too short";
      var chk = prefixChk(prefix);
      if (typeof chk === "string")
        return chk;
      var words = [];
      for (var i2 = 0; i2 < wordChars.length; ++i2) {
        var c4 = wordChars.charAt(i2);
        var v2 = ALPHABET_MAP[c4];
        if (v2 === void 0)
          return "Unknown character " + c4;
        chk = polymodStep(chk) ^ v2;
        if (i2 + 6 >= wordChars.length)
          continue;
        words.push(v2);
      }
      if (chk !== 1)
        return "Invalid checksum for " + str;
      return { prefix, words };
    }
    function decodeUnsafe() {
      var res = __decode.apply(null, arguments);
      if (typeof res === "object")
        return res;
    }
    function decode6(str) {
      var res = __decode.apply(null, arguments);
      if (typeof res === "object")
        return res;
      throw new Error(res);
    }
    function convert(data, inBits, outBits, pad) {
      var value = 0;
      var bits = 0;
      var maxV = (1 << outBits) - 1;
      var result = [];
      for (var i2 = 0; i2 < data.length; ++i2) {
        value = value << inBits | data[i2];
        bits += inBits;
        while (bits >= outBits) {
          bits -= outBits;
          result.push(value >> bits & maxV);
        }
      }
      if (pad) {
        if (bits > 0) {
          result.push(value << outBits - bits & maxV);
        }
      } else {
        if (bits >= inBits)
          return "Excess padding";
        if (value << outBits - bits & maxV)
          return "Non-zero padding";
      }
      return result;
    }
    function toWordsUnsafe(bytes) {
      var res = convert(bytes, 8, 5, true);
      if (Array.isArray(res))
        return res;
    }
    function toWords(bytes) {
      var res = convert(bytes, 8, 5, true);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    function fromWordsUnsafe(words) {
      var res = convert(words, 5, 8, false);
      if (Array.isArray(res))
        return res;
    }
    function fromWords(words) {
      var res = convert(words, 5, 8, false);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    module2.exports = {
      decodeUnsafe,
      decode: decode6,
      encode: encode5,
      toWordsUnsafe,
      toWords,
      fromWordsUnsafe,
      fromWords
    };
  }
});

// node_modules/@multiversx/sdk-core/out/utils.codec.js
var require_utils_codec = __commonJS({
  "node_modules/@multiversx/sdk-core/out/utils.codec.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k4 in mod2)
          if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k4))
            __createBinding2(result, mod2, k4);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addressToHex = exports2.bigIntToHex = exports2.byteArrayToHex = exports2.boolToHex = exports2.utf8ToHex = exports2.zeroPadStringIfOddLength = exports2.isPaddedHex = exports2.numberToPaddedHex = void 0;
    var bignumber_js_1 = __importDefault2(require_bignumber());
    var address_1 = require_address();
    var contractsCodecUtils = __importStar2(require_utils());
    function numberToPaddedHex(value) {
      let hexableNumber;
      if (typeof value === "bigint" || typeof value === "number") {
        hexableNumber = value;
      } else {
        hexableNumber = new bignumber_js_1.default(value);
      }
      const hex = hexableNumber.toString(16);
      return zeroPadStringIfOddLength(hex);
    }
    exports2.numberToPaddedHex = numberToPaddedHex;
    function isPaddedHex(input) {
      input = input || "";
      let decodedThenEncoded = import_buffer.Buffer.from(input, "hex").toString("hex");
      return input.toUpperCase() == decodedThenEncoded.toUpperCase();
    }
    exports2.isPaddedHex = isPaddedHex;
    function zeroPadStringIfOddLength(input) {
      input = input || "";
      if (input.length % 2 == 1) {
        return "0" + input;
      }
      return input;
    }
    exports2.zeroPadStringIfOddLength = zeroPadStringIfOddLength;
    function utf8ToHex(value) {
      const hex = import_buffer.Buffer.from(value).toString("hex");
      return zeroPadStringIfOddLength(hex);
    }
    exports2.utf8ToHex = utf8ToHex;
    function boolToHex(value) {
      return utf8ToHex(value.toString());
    }
    exports2.boolToHex = boolToHex;
    function byteArrayToHex(byteArray) {
      const hexString = import_buffer.Buffer.from(byteArray).toString("hex");
      return zeroPadStringIfOddLength(hexString);
    }
    exports2.byteArrayToHex = byteArrayToHex;
    function bigIntToHex(value) {
      if (value == 0) {
        return "";
      }
      return contractsCodecUtils.getHexMagnitudeOfBigInt(value);
    }
    exports2.bigIntToHex = bigIntToHex;
    function addressToHex(address) {
      const buffer = address_1.Address.fromBech32(address.toString()).pubkey();
      return buffer.toString("hex");
    }
    exports2.addressToHex = addressToHex;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/codec/utils.js
var require_utils = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/codec/utils.js"(exports2) {
    "use strict";
    init_shim();
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.prependByteToBuffer = exports2.flipBufferBitsInPlace = exports2.getHexMagnitudeOfBigInt = exports2.bigIntToBuffer = exports2.bufferToBigInt = exports2.cloneBuffer = exports2.isMsbZero = exports2.isMsbOne = void 0;
    var bignumber_js_1 = __importDefault2(require_bignumber());
    var utils_codec_1 = require_utils_codec();
    function isMsbOne(buffer, byteIndex = 0) {
      let byte = buffer[byteIndex];
      let bit = byte >> 7;
      let isSet = bit == 1;
      return isSet;
    }
    exports2.isMsbOne = isMsbOne;
    function isMsbZero(buffer, byteIndex = 0) {
      return !isMsbOne(buffer, byteIndex);
    }
    exports2.isMsbZero = isMsbZero;
    function cloneBuffer(buffer) {
      let clone2 = import_buffer.Buffer.alloc(buffer.length);
      buffer.copy(clone2);
      return clone2;
    }
    exports2.cloneBuffer = cloneBuffer;
    function bufferToBigInt(buffer) {
      let hex = buffer.toString("hex");
      return new bignumber_js_1.default(`0x${hex}`, 16);
    }
    exports2.bufferToBigInt = bufferToBigInt;
    function bigIntToBuffer(value) {
      let hex = getHexMagnitudeOfBigInt(value);
      return import_buffer.Buffer.from(hex, "hex");
    }
    exports2.bigIntToBuffer = bigIntToBuffer;
    function getHexMagnitudeOfBigInt(value) {
      value = new bignumber_js_1.default(value);
      if (!value) {
        return "";
      }
      if (value.isNegative()) {
        value = value.multipliedBy(new bignumber_js_1.default(-1));
      }
      return utils_codec_1.numberToPaddedHex(value);
    }
    exports2.getHexMagnitudeOfBigInt = getHexMagnitudeOfBigInt;
    function flipBufferBitsInPlace(buffer) {
      for (let i2 = 0; i2 < buffer.length; i2++) {
        buffer[i2] = ~buffer[i2];
      }
    }
    exports2.flipBufferBitsInPlace = flipBufferBitsInPlace;
    function prependByteToBuffer(buffer, byte) {
      return import_buffer.Buffer.concat([import_buffer.Buffer.from([byte]), buffer]);
    }
    exports2.prependByteToBuffer = prependByteToBuffer;
  }
});

// node_modules/@multiversx/sdk-core/out/tokenOperations/codec.js
var require_codec = __commonJS({
  "node_modules/@multiversx/sdk-core/out/tokenOperations/codec.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k4 in mod2)
          if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k4))
            __createBinding2(result, mod2, k4);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bufferToHex = exports2.addressToHex = exports2.bigIntToHex = exports2.utf8ToHex = exports2.bigIntToBuffer = exports2.bufferToBigInt = exports2.stringToBuffer = void 0;
    var bignumber_js_1 = __importDefault2(require_bignumber());
    var contractsCodecUtils = __importStar2(require_utils());
    var codecUtils = __importStar2(require_utils_codec());
    function stringToBuffer(value) {
      return import_buffer.Buffer.from(value);
    }
    exports2.stringToBuffer = stringToBuffer;
    function bufferToBigInt(buffer) {
      if (buffer.length == 0) {
        return new bignumber_js_1.default(0);
      }
      return contractsCodecUtils.bufferToBigInt(buffer);
    }
    exports2.bufferToBigInt = bufferToBigInt;
    function bigIntToBuffer(value) {
      if (value == 0) {
        return import_buffer.Buffer.from([]);
      }
      return contractsCodecUtils.bigIntToBuffer(value);
    }
    exports2.bigIntToBuffer = bigIntToBuffer;
    var utils_codec_1 = require_utils_codec();
    Object.defineProperty(exports2, "utf8ToHex", { enumerable: true, get: function() {
      return utils_codec_1.utf8ToHex;
    } });
    Object.defineProperty(exports2, "bigIntToHex", { enumerable: true, get: function() {
      return utils_codec_1.bigIntToHex;
    } });
    Object.defineProperty(exports2, "addressToHex", { enumerable: true, get: function() {
      return utils_codec_1.addressToHex;
    } });
    function bufferToHex(value) {
      const hex = value.toString("hex");
      return codecUtils.zeroPadStringIfOddLength(hex);
    }
    exports2.bufferToHex = bufferToHex;
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports2, module2) {
    "use strict";
    init_shim();
    var R2 = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R2 && typeof R2.apply === "function" ? R2.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R2 && typeof R2.ownKeys === "function") {
      ReflectOwnKeys = R2.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter2() {
      EventEmitter2.init.call(this);
    }
    module2.exports = EventEmitter2;
    module2.exports.once = once;
    EventEmitter2.EventEmitter = EventEmitter2;
    EventEmitter2.prototype._events = void 0;
    EventEmitter2.prototype._eventsCount = 0;
    EventEmitter2.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter2, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter2.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter2.prototype.setMaxListeners = function setMaxListeners(n3) {
      if (typeof n3 !== "number" || n3 < 0 || NumberIsNaN(n3)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n3 + ".");
      }
      this._maxListeners = n3;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter2.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter2.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter2.prototype.emit = function emit(type) {
      var args = [];
      for (var i2 = 1; i2 < arguments.length; i2++)
        args.push(arguments[i2]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i2 = 0; i2 < len; ++i2)
          ReflectApply(listeners[i2], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m3;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m3 = _getMaxListeners(target);
        if (m3 > 0 && existing.length > m3 && !existing.warned) {
          existing.warned = true;
          var w4 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w4.name = "MaxListenersExceededWarning";
          w4.emitter = target;
          w4.type = type;
          w4.count = existing.length;
          ProcessEmitWarning(w4);
        }
      }
      return target;
    }
    EventEmitter2.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
    EventEmitter2.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter2.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter2.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter2.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i2, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i2 = list.length - 1; i2 >= 0; i2--) {
          if (list[i2] === listener || list[i2].listener === listener) {
            originalListener = list[i2].listener;
            position = i2;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i2;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys2 = Object.keys(events);
        var key;
        for (i2 = 0; i2 < keys2.length; ++i2) {
          key = keys2[i2];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i2 = listeners.length - 1; i2 >= 0; i2--) {
          this.removeListener(type, listeners[i2]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter2.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter2.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter2.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter2.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n3) {
      var copy = new Array(n3);
      for (var i2 = 0; i2 < n3; ++i2)
        copy[i2] = arr[i2];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i2 = 0; i2 < ret.length; ++i2) {
        ret[i2] = arr[i2].listener || arr[i2];
      }
      return ret;
    }
    function once(emitter, name2) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name2, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name2, resolver, { once: true });
        if (name2 !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name2, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name2, listener);
        } else {
          emitter.on(name2, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name2, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name2, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports2, module2) {
    init_shim();
    module2.exports = require_events().EventEmitter;
  }
});

// node_modules/buffer/index.js
var require_buffer2 = __commonJS({
  "node_modules/buffer/index.js"(exports2) {
    "use strict";
    init_shim();
    var base642 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports2.Buffer = Buffer2;
    exports2.SlowBuffer = SlowBuffer;
    exports2.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports2.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e2) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length2) {
      if (length2 > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length2 + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length2);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length2) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe2(arg);
      }
      return from3(arg, encodingOrOffset, length2);
    }
    Buffer2.poolSize = 8192;
    function from3(value, encodingOrOffset, length2) {
      if (typeof value === "string") {
        return fromString3(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length2);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length2);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length2);
      }
      const b4 = fromObject(value);
      if (b4)
        return b4;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length2);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length2) {
      return from3(value, encodingOrOffset, length2);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe2(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe2(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe2(size);
    };
    function fromString3(string2, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length2 = byteLength(string2, encoding) | 0;
      let buf = createBuffer(length2);
      const actual = buf.write(string2, encoding);
      if (actual !== length2) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length2 = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length2);
      for (let i2 = 0; i2 < length2; i2 += 1) {
        buf[i2] = array[i2] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length2) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length2 || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length2 === void 0) {
        buf = new Uint8Array(array);
      } else if (length2 === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length2);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length2) {
      if (length2 >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length2 | 0;
    }
    function SlowBuffer(length2) {
      if (+length2 != length2) {
        length2 = 0;
      }
      return Buffer2.alloc(+length2);
    }
    Buffer2.isBuffer = function isBuffer(b4) {
      return b4 != null && b4._isBuffer === true && b4 !== Buffer2.prototype;
    };
    Buffer2.compare = function compare3(a3, b4) {
      if (isInstance(a3, Uint8Array))
        a3 = Buffer2.from(a3, a3.offset, a3.byteLength);
      if (isInstance(b4, Uint8Array))
        b4 = Buffer2.from(b4, b4.offset, b4.byteLength);
      if (!Buffer2.isBuffer(a3) || !Buffer2.isBuffer(b4)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a3 === b4)
        return 0;
      let x3 = a3.length;
      let y4 = b4.length;
      for (let i2 = 0, len = Math.min(x3, y4); i2 < len; ++i2) {
        if (a3[i2] !== b4[i2]) {
          x3 = a3[i2];
          y4 = b4[i2];
          break;
        }
      }
      if (x3 < y4)
        return -1;
      if (y4 < x3)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat2(list, length2) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i2;
      if (length2 === void 0) {
        length2 = 0;
        for (i2 = 0; i2 < list.length; ++i2) {
          length2 += list[i2].length;
        }
      }
      const buffer = Buffer2.allocUnsafe(length2);
      let pos = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        let buf = list[i2];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer2.isBuffer(buf))
              buf = Buffer2.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string2, encoding) {
      if (Buffer2.isBuffer(string2)) {
        return string2.length;
      }
      if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
        return string2.byteLength;
      }
      if (typeof string2 !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
        );
      }
      const len = string2.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string2).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string2).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string2).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b4, n3, m3) {
      const i2 = b4[n3];
      b4[n3] = b4[m3];
      b4[m3] = i2;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i2 = 0; i2 < len; i2 += 2) {
        swap(this, i2, i2 + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i2 = 0; i2 < len; i2 += 4) {
        swap(this, i2, i2 + 3);
        swap(this, i2 + 1, i2 + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i2 = 0; i2 < len; i2 += 8) {
        swap(this, i2, i2 + 7);
        swap(this, i2 + 1, i2 + 6);
        swap(this, i2 + 2, i2 + 5);
        swap(this, i2 + 3, i2 + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString3() {
      const length2 = this.length;
      if (length2 === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length2);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals4(b4) {
      if (!Buffer2.isBuffer(b4))
        throw new TypeError("Argument must be a Buffer");
      if (this === b4)
        return true;
      return Buffer2.compare(this, b4) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      let str = "";
      const max = exports2.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare3(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x3 = thisEnd - thisStart;
      let y4 = end - start;
      const len = Math.min(x3, y4);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i2 = 0; i2 < len; ++i2) {
        if (thisCopy[i2] !== targetCopy[i2]) {
          x3 = thisCopy[i2];
          y4 = targetCopy[i2];
          break;
        }
      }
      if (x3 < y4)
        return -1;
      if (y4 < x3)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read2(buf, i3) {
        if (indexSize === 1) {
          return buf[i3];
        } else {
          return buf.readUInt16BE(i3 * indexSize);
        }
      }
      let i2;
      if (dir) {
        let foundIndex = -1;
        for (i2 = byteOffset; i2 < arrLength; i2++) {
          if (read2(arr, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i2;
            if (i2 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i2 -= i2 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i2 = byteOffset; i2 >= 0; i2--) {
          let found = true;
          for (let j2 = 0; j2 < valLength; j2++) {
            if (read2(arr, i2 + j2) !== read2(val, j2)) {
              found = false;
              break;
            }
          }
          if (found)
            return i2;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string2, offset, length2) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length2) {
        length2 = remaining;
      } else {
        length2 = Number(length2);
        if (length2 > remaining) {
          length2 = remaining;
        }
      }
      const strLen = string2.length;
      if (length2 > strLen / 2) {
        length2 = strLen / 2;
      }
      let i2;
      for (i2 = 0; i2 < length2; ++i2) {
        const parsed = parseInt(string2.substr(i2 * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i2;
        buf[offset + i2] = parsed;
      }
      return i2;
    }
    function utf8Write(buf, string2, offset, length2) {
      return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length2);
    }
    function asciiWrite(buf, string2, offset, length2) {
      return blitBuffer(asciiToBytes(string2), buf, offset, length2);
    }
    function base64Write(buf, string2, offset, length2) {
      return blitBuffer(base64ToBytes(string2), buf, offset, length2);
    }
    function ucs2Write(buf, string2, offset, length2) {
      return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length2);
    }
    Buffer2.prototype.write = function write(string2, offset, length2, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length2 = this.length;
        offset = 0;
      } else if (length2 === void 0 && typeof offset === "string") {
        encoding = offset;
        length2 = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length2)) {
          length2 = length2 >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length2;
          length2 = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length2 === void 0 || length2 > remaining)
        length2 = remaining;
      if (string2.length > 0 && (length2 < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string2, offset, length2);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string2, offset, length2);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string2, offset, length2);
          case "base64":
            return base64Write(this, string2, offset, length2);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string2, offset, length2);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base642.fromByteArray(buf);
      } else {
        return base642.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i2 = start;
      while (i2 < end) {
        const firstByte = buf[i2];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i2 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i2 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              fourthByte = buf[i2 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i2 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i2 = 0;
      while (i2 < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i2 = start; i2 < end; ++i2) {
        out += hexSliceLookupTable[buf[i2]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i2 = 0; i2 < bytes.length - 1; i2 += 2) {
        res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length2) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length2)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i2 = 0;
      while (++i2 < byteLength2 && (mul *= 256)) {
        val += this[offset + i2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i2 = 0;
      while (++i2 < byteLength2 && (mul *= 256)) {
        val += this[offset + i2] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i2 = byteLength2;
      let mul = 1;
      let val = this[offset + --i2];
      while (i2 > 0 && (mul *= 256)) {
        val += this[offset + --i2] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i2 = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength2 && (mul *= 256)) {
        this[offset + i2] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i2 = byteLength2 - 1;
      let mul = 1;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        this[offset + i2] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i2 = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i2 = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code2 = val.charCodeAt(0);
          if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
            val = code2;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i2;
      if (typeof val === "number") {
        for (i2 = start; i2 < end; ++i2) {
          this[i2] = val;
        }
      } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i2 = 0; i2 < end - start; ++i2) {
          this[i2 + start] = bytes[i2 % len];
        }
      }
      return this;
    };
    var errors = {};
    function E4(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E4(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name2) {
        if (name2) {
          return `${name2} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E4(
      "ERR_INVALID_ARG_TYPE",
      function(name2, actual) {
        return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E4(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i2 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i2 >= start + 4; i2 -= 3) {
        res = `_${val.slice(i2 - 3, i2)}${res}`;
      }
      return `${val.slice(0, i2)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n3 = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n3} and < 2${n3} ** ${(byteLength2 + 1) * 8}${n3}`;
          } else {
            range = `>= -(2${n3} ** ${(byteLength2 + 1) * 8 - 1}${n3}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n3}`;
          }
        } else {
          range = `>= ${min}${n3} and <= ${max}${n3}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name2) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value);
      }
    }
    function boundsError(value, length2, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length2 < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length2}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string2, units) {
      units = units || Infinity;
      let codePoint;
      const length2 = string2.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i2 = 0; i2 < length2; ++i2) {
        codePoint = string2.charCodeAt(i2);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i2 + 1 === length2) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i2 = 0; i2 < str.length; ++i2) {
        byteArray.push(str.charCodeAt(i2) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c4, hi, lo;
      const byteArray = [];
      for (let i2 = 0; i2 < str.length; ++i2) {
        if ((units -= 2) < 0)
          break;
        c4 = str.charCodeAt(i2);
        hi = c4 >> 8;
        lo = c4 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base642.toByteArray(base64clean(str));
    }
    function blitBuffer(src2, dst, offset, length2) {
      let i2;
      for (i2 = 0; i2 < length2; ++i2) {
        if (i2 + offset >= dst.length || i2 >= src2.length)
          break;
        dst[i2 + offset] = src2[i2];
      }
      return i2;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet2 = "0123456789abcdef";
      const table = new Array(256);
      for (let i2 = 0; i2 < 16; ++i2) {
        const i16 = i2 * 16;
        for (let j2 = 0; j2 < 16; ++j2) {
          table[i16 + j2] = alphabet2[i2] + alphabet2[j2];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// (disabled):node_modules/util/util.js
var require_util = __commonJS({
  "(disabled):node_modules/util/util.js"() {
    init_shim();
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    init_shim();
    function ownKeys(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require_buffer2();
    var Buffer2 = _require.Buffer;
    var _require2 = require_util();
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src2, target, offset) {
      Buffer2.prototype.copy.call(src2, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v2) {
          var entry = {
            data: v2,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v2) {
          var entry = {
            data: v2,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear2() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s2) {
          if (this.length === 0)
            return "";
          var p3 = this.head;
          var ret = "" + p3.data;
          while (p3 = p3.next)
            ret += s2 + p3.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat2(n3) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n3 >>> 0);
          var p3 = this.head;
          var i2 = 0;
          while (p3) {
            copyBuffer(p3.data, ret, i2);
            i2 += p3.data.length;
            p3 = p3.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n3, hasStrings) {
          var ret;
          if (n3 < this.head.data.length) {
            ret = this.head.data.slice(0, n3);
            this.head.data = this.head.data.slice(n3);
          } else if (n3 === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n3) : this._getBuffer(n3);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n3) {
          var p3 = this.head;
          var c4 = 1;
          var ret = p3.data;
          n3 -= ret.length;
          while (p3 = p3.next) {
            var str = p3.data;
            var nb = n3 > str.length ? str.length : n3;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n3);
            n3 -= nb;
            if (n3 === 0) {
              if (nb === str.length) {
                ++c4;
                if (p3.next)
                  this.head = p3.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p3;
                p3.data = str.slice(nb);
              }
              break;
            }
            ++c4;
          }
          this.length -= c4;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n3) {
          var ret = Buffer2.allocUnsafe(n3);
          var p3 = this.head;
          var c4 = 1;
          p3.data.copy(ret);
          n3 -= p3.data.length;
          while (p3 = p3.next) {
            var buf = p3.data;
            var nb = n3 > buf.length ? buf.length : n3;
            buf.copy(ret, ret.length - n3, 0, nb);
            n3 -= nb;
            if (n3 === 0) {
              if (nb === buf.length) {
                ++c4;
                if (p3.next)
                  this.head = p3.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p3;
                p3.data = buf.slice(nb);
              }
              break;
            }
            ++c4;
          }
          this.length -= c4;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_4, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    init_shim();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            import_process.default.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            import_process.default.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            import_process.default.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          import_process.default.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          import_process.default.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/errors-browser.js
var require_errors_browser = __commonJS({
  "node_modules/readable-stream/errors-browser.js"(exports2, module2) {
    "use strict";
    init_shim();
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes = {};
    function createErrorType(code2, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = /* @__PURE__ */ function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      }(Base);
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code2;
      codes[code2] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i2) {
          return String(i2);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name2, value) {
      return 'The value "' + value + '" is invalid for option "' + name2 + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name2, " argument")) {
        msg = "The ".concat(name2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = includes(name2, ".") ? "property" : "argument";
        msg = 'The "'.concat(name2, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name2) {
      return "The " + name2 + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name2) {
      return "Cannot call " + name2 + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    init_shim();
    var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name2 = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name2, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    init_shim();
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/util-deprecate/browser.js
var require_browser2 = __commonJS({
  "node_modules/util-deprecate/browser.js"(exports2, module2) {
    init_shim();
    module2.exports = deprecate2;
    function deprecate2(fn, msg) {
      if (config("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config("throwDeprecation")) {
            throw new Error(msg);
          } else if (config("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    }
    function config(name2) {
      try {
        if (!global.localStorage)
          return false;
      } catch (_4) {
        return false;
      }
      var val = global.localStorage[name2];
      if (null == val)
        return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    init_shim();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_browser2()
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_buffer2().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits_browser()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_4) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      import_process.default.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        import_process.default.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        import_process.default.nextTick(cb, er);
        import_process.default.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          import_process.default.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l4 = state.bufferedRequestCount;
        var buffer = new Array(l4);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          import_process.default.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          import_process.default.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set2(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    init_shim();
    var objectKeys = Object.keys || function(obj) {
      var keys3 = [];
      for (var key in obj)
        keys3.push(key);
      return keys3;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits_browser()(Duplex, Readable);
    {
      keys2 = objectKeys(Writable.prototype);
      for (v2 = 0; v2 < keys2.length; v2++) {
        method = keys2[v2];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys2;
    var method;
    var v2;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      import_process.default.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set2(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    init_shim();
    var buffer = require_buffer2();
    var Buffer2 = buffer.Buffer;
    function copyProps(src2, dst) {
      for (var key in src2) {
        dst[key] = src2[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length2) {
      return Buffer2(arg, encodingOrOffset, length2);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length2) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length2);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    init_shim();
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i2;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i2 = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i2 = 0;
      }
      if (i2 < buf.length)
        return r ? r + this.text(buf, i2) : this.text(buf, i2);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i2) {
      var j2 = buf.length - 1;
      if (j2 < i2)
        return 0;
      var nb = utf8CheckByte(buf[j2]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j2 < i2 || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j2]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j2 < i2 || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j2]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p3) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p3 = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p3);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p3, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p3, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i2) {
      var total = utf8CheckIncomplete(this, buf, i2);
      if (!this.lastNeed)
        return buf.toString("utf8", i2);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i2, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i2) {
      if ((buf.length - i2) % 2 === 0) {
        var r = buf.toString("utf16le", i2);
        if (r) {
          var c4 = r.charCodeAt(r.length - 1);
          if (c4 >= 55296 && c4 <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i2, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i2) {
      var n3 = (buf.length - i2) % 3;
      if (n3 === 0)
        return buf.toString("base64", i2);
      this.lastNeed = 3 - n3;
      this.lastTotal = 3;
      if (n3 === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i2, buf.length - n3);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    init_shim();
    var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    init_shim();
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      import_process.default.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            import_process.default.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports2, module2) {
    init_shim();
    module2.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    init_shim();
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_buffer2().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require_util();
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from3;
    require_inherits_browser()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set2(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p3 = this._readableState.buffer.head;
      var content = "";
      while (p3 !== null) {
        content += decoder.write(p3.data);
        p3 = p3.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n3) {
      if (n3 >= MAX_HWM) {
        n3 = MAX_HWM;
      } else {
        n3--;
        n3 |= n3 >>> 1;
        n3 |= n3 >>> 2;
        n3 |= n3 >>> 4;
        n3 |= n3 >>> 8;
        n3 |= n3 >>> 16;
        n3++;
      }
      return n3;
    }
    function howMuchToRead(n3, state) {
      if (n3 <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n3 !== n3) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n3 > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n3);
      if (n3 <= state.length)
        return n3;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n3) {
      debug("read", n3);
      n3 = parseInt(n3, 10);
      var state = this._readableState;
      var nOrig = n3;
      if (n3 !== 0)
        state.emittedReadable = false;
      if (n3 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n3 = howMuchToRead(n3, state);
      if (n3 === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n3 < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n3 = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n3 > 0)
        ret = fromList(n3, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n3 = 0;
      } else {
        state.length -= n3;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n3 && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        import_process.default.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        import_process.default.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n3) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src2 = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== import_process.default.stdout && dest !== import_process.default.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        import_process.default.nextTick(endFn);
      else
        src2.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src2) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src2);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src2.removeListener("end", onend);
        src2.removeListener("end", unpipe);
        src2.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src2.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src2.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src2.unpipe(dest);
      }
      dest.emit("pipe", src2);
      if (!state.flowing) {
        debug("pipe resume");
        src2.resume();
      }
      return dest;
    };
    function pipeOnDrain(src2) {
      return function pipeOnDrainFunctionResult() {
        var state = src2._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src2, "data")) {
          state.flowing = true;
          flow(src2);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i2 = 0; i2 < len; i2++)
          dests[i2].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            import_process.default.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        import_process.default.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        import_process.default.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        import_process.default.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i2 in stream) {
        if (this[i2] === void 0 && typeof stream[i2] === "function") {
          this[i2] = /* @__PURE__ */ function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i2);
        }
      }
      for (var n3 = 0; n3 < kProxyEvents.length; n3++) {
        stream.on(kProxyEvents[n3], this.emit.bind(this, kProxyEvents[n3]));
      }
      this._read = function(n4) {
        debug("wrapped _read", n4);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._readableState.flowing;
      },
      set: function set2(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._readableState.length;
      }
    });
    function fromList(n3, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n3 || n3 >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n3, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        import_process.default.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from3 === void 0) {
          from3 = require_from_browser();
        }
        return from3(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x3) {
      for (var i2 = 0, l4 = xs.length; i2 < l4; i2++) {
        if (xs[i2] === x3)
          return i2;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    init_shim();
    module2.exports = Transform;
    var _require$codes = require_errors_browser().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits_browser()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n3) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    init_shim();
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits_browser()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    init_shim();
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors_browser().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from3, to) {
      return from3.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop;
      if (typeof streams[streams.length - 1] !== "function")
        return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i2) {
        var reading = i2 < streams.length - 1;
        var writing = i2 > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS({
  "node_modules/readable-stream/readable-browser.js"(exports2, module2) {
    init_shim();
    exports2 = module2.exports = require_stream_readable();
    exports2.Stream = exports2;
    exports2.Readable = exports2;
    exports2.Writable = require_stream_writable();
    exports2.Duplex = require_stream_duplex();
    exports2.Transform = require_stream_transform();
    exports2.PassThrough = require_stream_passthrough();
    exports2.finished = require_end_of_stream();
    exports2.pipeline = require_pipeline();
  }
});

// node_modules/keccak/lib/api/keccak.js
var require_keccak = __commonJS({
  "node_modules/keccak/lib/api/keccak.js"(exports2, module2) {
    init_shim();
    var { Transform } = require_readable_browser();
    module2.exports = (KeccakState) => class Keccak extends Transform {
      constructor(rate, capacity, delimitedSuffix, hashBitLength, options) {
        super(options);
        this._rate = rate;
        this._capacity = capacity;
        this._delimitedSuffix = delimitedSuffix;
        this._hashBitLength = hashBitLength;
        this._options = options;
        this._state = new KeccakState();
        this._state.initialize(rate, capacity);
        this._finalized = false;
      }
      _transform(chunk, encoding, callback) {
        let error = null;
        try {
          this.update(chunk, encoding);
        } catch (err) {
          error = err;
        }
        callback(error);
      }
      _flush(callback) {
        let error = null;
        try {
          this.push(this.digest());
        } catch (err) {
          error = err;
        }
        callback(error);
      }
      update(data, encoding) {
        if (!import_buffer.Buffer.isBuffer(data) && typeof data !== "string")
          throw new TypeError("Data must be a string or a buffer");
        if (this._finalized)
          throw new Error("Digest already called");
        if (!import_buffer.Buffer.isBuffer(data))
          data = import_buffer.Buffer.from(data, encoding);
        this._state.absorb(data);
        return this;
      }
      digest(encoding) {
        if (this._finalized)
          throw new Error("Digest already called");
        this._finalized = true;
        if (this._delimitedSuffix)
          this._state.absorbLastFewBits(this._delimitedSuffix);
        let digest2 = this._state.squeeze(this._hashBitLength / 8);
        if (encoding !== void 0)
          digest2 = digest2.toString(encoding);
        this._resetState();
        return digest2;
      }
      // remove result from memory
      _resetState() {
        this._state.initialize(this._rate, this._capacity);
        return this;
      }
      // because sometimes we need hash right now and little later
      _clone() {
        const clone2 = new Keccak(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);
        this._state.copy(clone2._state);
        clone2._finalized = this._finalized;
        return clone2;
      }
    };
  }
});

// node_modules/keccak/lib/api/shake.js
var require_shake = __commonJS({
  "node_modules/keccak/lib/api/shake.js"(exports2, module2) {
    init_shim();
    var { Transform } = require_readable_browser();
    module2.exports = (KeccakState) => class Shake extends Transform {
      constructor(rate, capacity, delimitedSuffix, options) {
        super(options);
        this._rate = rate;
        this._capacity = capacity;
        this._delimitedSuffix = delimitedSuffix;
        this._options = options;
        this._state = new KeccakState();
        this._state.initialize(rate, capacity);
        this._finalized = false;
      }
      _transform(chunk, encoding, callback) {
        let error = null;
        try {
          this.update(chunk, encoding);
        } catch (err) {
          error = err;
        }
        callback(error);
      }
      _flush() {
      }
      _read(size) {
        this.push(this.squeeze(size));
      }
      update(data, encoding) {
        if (!import_buffer.Buffer.isBuffer(data) && typeof data !== "string")
          throw new TypeError("Data must be a string or a buffer");
        if (this._finalized)
          throw new Error("Squeeze already called");
        if (!import_buffer.Buffer.isBuffer(data))
          data = import_buffer.Buffer.from(data, encoding);
        this._state.absorb(data);
        return this;
      }
      squeeze(dataByteLength, encoding) {
        if (!this._finalized) {
          this._finalized = true;
          this._state.absorbLastFewBits(this._delimitedSuffix);
        }
        let data = this._state.squeeze(dataByteLength);
        if (encoding !== void 0)
          data = data.toString(encoding);
        return data;
      }
      _resetState() {
        this._state.initialize(this._rate, this._capacity);
        return this;
      }
      _clone() {
        const clone2 = new Shake(this._rate, this._capacity, this._delimitedSuffix, this._options);
        this._state.copy(clone2._state);
        clone2._finalized = this._finalized;
        return clone2;
      }
    };
  }
});

// node_modules/keccak/lib/api/index.js
var require_api = __commonJS({
  "node_modules/keccak/lib/api/index.js"(exports2, module2) {
    init_shim();
    var createKeccak = require_keccak();
    var createShake = require_shake();
    module2.exports = function(KeccakState) {
      const Keccak = createKeccak(KeccakState);
      const Shake = createShake(KeccakState);
      return function(algorithm, options) {
        const hash = typeof algorithm === "string" ? algorithm.toLowerCase() : algorithm;
        switch (hash) {
          case "keccak224":
            return new Keccak(1152, 448, null, 224, options);
          case "keccak256":
            return new Keccak(1088, 512, null, 256, options);
          case "keccak384":
            return new Keccak(832, 768, null, 384, options);
          case "keccak512":
            return new Keccak(576, 1024, null, 512, options);
          case "sha3-224":
            return new Keccak(1152, 448, 6, 224, options);
          case "sha3-256":
            return new Keccak(1088, 512, 6, 256, options);
          case "sha3-384":
            return new Keccak(832, 768, 6, 384, options);
          case "sha3-512":
            return new Keccak(576, 1024, 6, 512, options);
          case "shake128":
            return new Shake(1344, 256, 31, options);
          case "shake256":
            return new Shake(1088, 512, 31, options);
          default:
            throw new Error("Invald algorithm: " + algorithm);
        }
      };
    };
  }
});

// node_modules/keccak/lib/keccak-state-unroll.js
var require_keccak_state_unroll = __commonJS({
  "node_modules/keccak/lib/keccak-state-unroll.js"(exports2) {
    init_shim();
    var P1600_ROUND_CONSTANTS = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
    exports2.p1600 = function(s2) {
      for (let round = 0; round < 24; ++round) {
        const lo0 = s2[0] ^ s2[10] ^ s2[20] ^ s2[30] ^ s2[40];
        const hi0 = s2[1] ^ s2[11] ^ s2[21] ^ s2[31] ^ s2[41];
        const lo1 = s2[2] ^ s2[12] ^ s2[22] ^ s2[32] ^ s2[42];
        const hi1 = s2[3] ^ s2[13] ^ s2[23] ^ s2[33] ^ s2[43];
        const lo2 = s2[4] ^ s2[14] ^ s2[24] ^ s2[34] ^ s2[44];
        const hi2 = s2[5] ^ s2[15] ^ s2[25] ^ s2[35] ^ s2[45];
        const lo3 = s2[6] ^ s2[16] ^ s2[26] ^ s2[36] ^ s2[46];
        const hi3 = s2[7] ^ s2[17] ^ s2[27] ^ s2[37] ^ s2[47];
        const lo4 = s2[8] ^ s2[18] ^ s2[28] ^ s2[38] ^ s2[48];
        const hi4 = s2[9] ^ s2[19] ^ s2[29] ^ s2[39] ^ s2[49];
        let lo = lo4 ^ (lo1 << 1 | hi1 >>> 31);
        let hi = hi4 ^ (hi1 << 1 | lo1 >>> 31);
        const t1slo0 = s2[0] ^ lo;
        const t1shi0 = s2[1] ^ hi;
        const t1slo5 = s2[10] ^ lo;
        const t1shi5 = s2[11] ^ hi;
        const t1slo10 = s2[20] ^ lo;
        const t1shi10 = s2[21] ^ hi;
        const t1slo15 = s2[30] ^ lo;
        const t1shi15 = s2[31] ^ hi;
        const t1slo20 = s2[40] ^ lo;
        const t1shi20 = s2[41] ^ hi;
        lo = lo0 ^ (lo2 << 1 | hi2 >>> 31);
        hi = hi0 ^ (hi2 << 1 | lo2 >>> 31);
        const t1slo1 = s2[2] ^ lo;
        const t1shi1 = s2[3] ^ hi;
        const t1slo6 = s2[12] ^ lo;
        const t1shi6 = s2[13] ^ hi;
        const t1slo11 = s2[22] ^ lo;
        const t1shi11 = s2[23] ^ hi;
        const t1slo16 = s2[32] ^ lo;
        const t1shi16 = s2[33] ^ hi;
        const t1slo21 = s2[42] ^ lo;
        const t1shi21 = s2[43] ^ hi;
        lo = lo1 ^ (lo3 << 1 | hi3 >>> 31);
        hi = hi1 ^ (hi3 << 1 | lo3 >>> 31);
        const t1slo2 = s2[4] ^ lo;
        const t1shi2 = s2[5] ^ hi;
        const t1slo7 = s2[14] ^ lo;
        const t1shi7 = s2[15] ^ hi;
        const t1slo12 = s2[24] ^ lo;
        const t1shi12 = s2[25] ^ hi;
        const t1slo17 = s2[34] ^ lo;
        const t1shi17 = s2[35] ^ hi;
        const t1slo22 = s2[44] ^ lo;
        const t1shi22 = s2[45] ^ hi;
        lo = lo2 ^ (lo4 << 1 | hi4 >>> 31);
        hi = hi2 ^ (hi4 << 1 | lo4 >>> 31);
        const t1slo3 = s2[6] ^ lo;
        const t1shi3 = s2[7] ^ hi;
        const t1slo8 = s2[16] ^ lo;
        const t1shi8 = s2[17] ^ hi;
        const t1slo13 = s2[26] ^ lo;
        const t1shi13 = s2[27] ^ hi;
        const t1slo18 = s2[36] ^ lo;
        const t1shi18 = s2[37] ^ hi;
        const t1slo23 = s2[46] ^ lo;
        const t1shi23 = s2[47] ^ hi;
        lo = lo3 ^ (lo0 << 1 | hi0 >>> 31);
        hi = hi3 ^ (hi0 << 1 | lo0 >>> 31);
        const t1slo4 = s2[8] ^ lo;
        const t1shi4 = s2[9] ^ hi;
        const t1slo9 = s2[18] ^ lo;
        const t1shi9 = s2[19] ^ hi;
        const t1slo14 = s2[28] ^ lo;
        const t1shi14 = s2[29] ^ hi;
        const t1slo19 = s2[38] ^ lo;
        const t1shi19 = s2[39] ^ hi;
        const t1slo24 = s2[48] ^ lo;
        const t1shi24 = s2[49] ^ hi;
        const t2slo0 = t1slo0;
        const t2shi0 = t1shi0;
        const t2slo16 = t1shi5 << 4 | t1slo5 >>> 28;
        const t2shi16 = t1slo5 << 4 | t1shi5 >>> 28;
        const t2slo7 = t1slo10 << 3 | t1shi10 >>> 29;
        const t2shi7 = t1shi10 << 3 | t1slo10 >>> 29;
        const t2slo23 = t1shi15 << 9 | t1slo15 >>> 23;
        const t2shi23 = t1slo15 << 9 | t1shi15 >>> 23;
        const t2slo14 = t1slo20 << 18 | t1shi20 >>> 14;
        const t2shi14 = t1shi20 << 18 | t1slo20 >>> 14;
        const t2slo10 = t1slo1 << 1 | t1shi1 >>> 31;
        const t2shi10 = t1shi1 << 1 | t1slo1 >>> 31;
        const t2slo1 = t1shi6 << 12 | t1slo6 >>> 20;
        const t2shi1 = t1slo6 << 12 | t1shi6 >>> 20;
        const t2slo17 = t1slo11 << 10 | t1shi11 >>> 22;
        const t2shi17 = t1shi11 << 10 | t1slo11 >>> 22;
        const t2slo8 = t1shi16 << 13 | t1slo16 >>> 19;
        const t2shi8 = t1slo16 << 13 | t1shi16 >>> 19;
        const t2slo24 = t1slo21 << 2 | t1shi21 >>> 30;
        const t2shi24 = t1shi21 << 2 | t1slo21 >>> 30;
        const t2slo20 = t1shi2 << 30 | t1slo2 >>> 2;
        const t2shi20 = t1slo2 << 30 | t1shi2 >>> 2;
        const t2slo11 = t1slo7 << 6 | t1shi7 >>> 26;
        const t2shi11 = t1shi7 << 6 | t1slo7 >>> 26;
        const t2slo2 = t1shi12 << 11 | t1slo12 >>> 21;
        const t2shi2 = t1slo12 << 11 | t1shi12 >>> 21;
        const t2slo18 = t1slo17 << 15 | t1shi17 >>> 17;
        const t2shi18 = t1shi17 << 15 | t1slo17 >>> 17;
        const t2slo9 = t1shi22 << 29 | t1slo22 >>> 3;
        const t2shi9 = t1slo22 << 29 | t1shi22 >>> 3;
        const t2slo5 = t1slo3 << 28 | t1shi3 >>> 4;
        const t2shi5 = t1shi3 << 28 | t1slo3 >>> 4;
        const t2slo21 = t1shi8 << 23 | t1slo8 >>> 9;
        const t2shi21 = t1slo8 << 23 | t1shi8 >>> 9;
        const t2slo12 = t1slo13 << 25 | t1shi13 >>> 7;
        const t2shi12 = t1shi13 << 25 | t1slo13 >>> 7;
        const t2slo3 = t1slo18 << 21 | t1shi18 >>> 11;
        const t2shi3 = t1shi18 << 21 | t1slo18 >>> 11;
        const t2slo19 = t1shi23 << 24 | t1slo23 >>> 8;
        const t2shi19 = t1slo23 << 24 | t1shi23 >>> 8;
        const t2slo15 = t1slo4 << 27 | t1shi4 >>> 5;
        const t2shi15 = t1shi4 << 27 | t1slo4 >>> 5;
        const t2slo6 = t1slo9 << 20 | t1shi9 >>> 12;
        const t2shi6 = t1shi9 << 20 | t1slo9 >>> 12;
        const t2slo22 = t1shi14 << 7 | t1slo14 >>> 25;
        const t2shi22 = t1slo14 << 7 | t1shi14 >>> 25;
        const t2slo13 = t1slo19 << 8 | t1shi19 >>> 24;
        const t2shi13 = t1shi19 << 8 | t1slo19 >>> 24;
        const t2slo4 = t1slo24 << 14 | t1shi24 >>> 18;
        const t2shi4 = t1shi24 << 14 | t1slo24 >>> 18;
        s2[0] = t2slo0 ^ ~t2slo1 & t2slo2;
        s2[1] = t2shi0 ^ ~t2shi1 & t2shi2;
        s2[10] = t2slo5 ^ ~t2slo6 & t2slo7;
        s2[11] = t2shi5 ^ ~t2shi6 & t2shi7;
        s2[20] = t2slo10 ^ ~t2slo11 & t2slo12;
        s2[21] = t2shi10 ^ ~t2shi11 & t2shi12;
        s2[30] = t2slo15 ^ ~t2slo16 & t2slo17;
        s2[31] = t2shi15 ^ ~t2shi16 & t2shi17;
        s2[40] = t2slo20 ^ ~t2slo21 & t2slo22;
        s2[41] = t2shi20 ^ ~t2shi21 & t2shi22;
        s2[2] = t2slo1 ^ ~t2slo2 & t2slo3;
        s2[3] = t2shi1 ^ ~t2shi2 & t2shi3;
        s2[12] = t2slo6 ^ ~t2slo7 & t2slo8;
        s2[13] = t2shi6 ^ ~t2shi7 & t2shi8;
        s2[22] = t2slo11 ^ ~t2slo12 & t2slo13;
        s2[23] = t2shi11 ^ ~t2shi12 & t2shi13;
        s2[32] = t2slo16 ^ ~t2slo17 & t2slo18;
        s2[33] = t2shi16 ^ ~t2shi17 & t2shi18;
        s2[42] = t2slo21 ^ ~t2slo22 & t2slo23;
        s2[43] = t2shi21 ^ ~t2shi22 & t2shi23;
        s2[4] = t2slo2 ^ ~t2slo3 & t2slo4;
        s2[5] = t2shi2 ^ ~t2shi3 & t2shi4;
        s2[14] = t2slo7 ^ ~t2slo8 & t2slo9;
        s2[15] = t2shi7 ^ ~t2shi8 & t2shi9;
        s2[24] = t2slo12 ^ ~t2slo13 & t2slo14;
        s2[25] = t2shi12 ^ ~t2shi13 & t2shi14;
        s2[34] = t2slo17 ^ ~t2slo18 & t2slo19;
        s2[35] = t2shi17 ^ ~t2shi18 & t2shi19;
        s2[44] = t2slo22 ^ ~t2slo23 & t2slo24;
        s2[45] = t2shi22 ^ ~t2shi23 & t2shi24;
        s2[6] = t2slo3 ^ ~t2slo4 & t2slo0;
        s2[7] = t2shi3 ^ ~t2shi4 & t2shi0;
        s2[16] = t2slo8 ^ ~t2slo9 & t2slo5;
        s2[17] = t2shi8 ^ ~t2shi9 & t2shi5;
        s2[26] = t2slo13 ^ ~t2slo14 & t2slo10;
        s2[27] = t2shi13 ^ ~t2shi14 & t2shi10;
        s2[36] = t2slo18 ^ ~t2slo19 & t2slo15;
        s2[37] = t2shi18 ^ ~t2shi19 & t2shi15;
        s2[46] = t2slo23 ^ ~t2slo24 & t2slo20;
        s2[47] = t2shi23 ^ ~t2shi24 & t2shi20;
        s2[8] = t2slo4 ^ ~t2slo0 & t2slo1;
        s2[9] = t2shi4 ^ ~t2shi0 & t2shi1;
        s2[18] = t2slo9 ^ ~t2slo5 & t2slo6;
        s2[19] = t2shi9 ^ ~t2shi5 & t2shi6;
        s2[28] = t2slo14 ^ ~t2slo10 & t2slo11;
        s2[29] = t2shi14 ^ ~t2shi10 & t2shi11;
        s2[38] = t2slo19 ^ ~t2slo15 & t2slo16;
        s2[39] = t2shi19 ^ ~t2shi15 & t2shi16;
        s2[48] = t2slo24 ^ ~t2slo20 & t2slo21;
        s2[49] = t2shi24 ^ ~t2shi20 & t2shi21;
        s2[0] ^= P1600_ROUND_CONSTANTS[round * 2];
        s2[1] ^= P1600_ROUND_CONSTANTS[round * 2 + 1];
      }
    };
  }
});

// node_modules/keccak/lib/keccak.js
var require_keccak2 = __commonJS({
  "node_modules/keccak/lib/keccak.js"(exports2, module2) {
    init_shim();
    var keccakState = require_keccak_state_unroll();
    function Keccak() {
      this.state = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      this.blockSize = null;
      this.count = 0;
      this.squeezing = false;
    }
    Keccak.prototype.initialize = function(rate, capacity) {
      for (let i2 = 0; i2 < 50; ++i2)
        this.state[i2] = 0;
      this.blockSize = rate / 8;
      this.count = 0;
      this.squeezing = false;
    };
    Keccak.prototype.absorb = function(data) {
      for (let i2 = 0; i2 < data.length; ++i2) {
        this.state[~~(this.count / 4)] ^= data[i2] << 8 * (this.count % 4);
        this.count += 1;
        if (this.count === this.blockSize) {
          keccakState.p1600(this.state);
          this.count = 0;
        }
      }
    };
    Keccak.prototype.absorbLastFewBits = function(bits) {
      this.state[~~(this.count / 4)] ^= bits << 8 * (this.count % 4);
      if ((bits & 128) !== 0 && this.count === this.blockSize - 1)
        keccakState.p1600(this.state);
      this.state[~~((this.blockSize - 1) / 4)] ^= 128 << 8 * ((this.blockSize - 1) % 4);
      keccakState.p1600(this.state);
      this.count = 0;
      this.squeezing = true;
    };
    Keccak.prototype.squeeze = function(length2) {
      if (!this.squeezing)
        this.absorbLastFewBits(1);
      const output = import_buffer.Buffer.alloc(length2);
      for (let i2 = 0; i2 < length2; ++i2) {
        output[i2] = this.state[~~(this.count / 4)] >>> 8 * (this.count % 4) & 255;
        this.count += 1;
        if (this.count === this.blockSize) {
          keccakState.p1600(this.state);
          this.count = 0;
        }
      }
      return output;
    };
    Keccak.prototype.copy = function(dest) {
      for (let i2 = 0; i2 < 50; ++i2)
        dest.state[i2] = this.state[i2];
      dest.blockSize = this.blockSize;
      dest.count = this.count;
      dest.squeezing = this.squeezing;
    };
    module2.exports = Keccak;
  }
});

// node_modules/keccak/js.js
var require_js = __commonJS({
  "node_modules/keccak/js.js"(exports2, module2) {
    init_shim();
    module2.exports = require_api()(require_keccak2());
  }
});

// node_modules/@multiversx/sdk-core/out/address.js
var require_address = __commonJS({
  "node_modules/@multiversx/sdk-core/out/address.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k4 in mod2)
          if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k4))
            __createBinding2(result, mod2, k4);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AddressComputer = exports2.Address = void 0;
    var bech32 = __importStar2(require_bech32());
    var bignumber_js_1 = __importDefault2(require_bignumber());
    var constants_1 = require_constants();
    var errors = __importStar2(require_errors());
    var codec_1 = require_codec();
    var createKeccakHash = require_js();
    var HRP = "erd";
    var PUBKEY_LENGTH = 32;
    var SMART_CONTRACT_HEX_PUBKEY_PREFIX = "0".repeat(16);
    var Address5 = class _Address {
      /**
       * Creates an address object, given a raw string (whether a hex pubkey or a Bech32 address), a sequence of bytes, or another Address object.
       */
      constructor(value) {
        this.valueHex = "";
        if (!value) {
          return;
        }
        if (value instanceof _Address) {
          return _Address.fromAddress(value);
        }
        if (ArrayBuffer.isView(value)) {
          return _Address.fromBuffer(import_buffer.Buffer.from(value));
        }
        if (typeof value === "string") {
          return _Address.fromString(value);
        }
        throw new errors.ErrAddressCannotCreate(value);
      }
      /**
       * Creates an address object from another address object
       */
      static fromAddress(address) {
        return _Address.fromValidHex(address.valueHex);
      }
      static fromValidHex(value) {
        let result = _Address.empty();
        result.valueHex = value;
        return result;
      }
      /**
       * Creates an address object from a Buffer
       */
      static fromBuffer(buffer) {
        if (buffer.length != PUBKEY_LENGTH) {
          throw new errors.ErrAddressCannotCreate(buffer);
        }
        return _Address.fromValidHex(buffer.toString("hex"));
      }
      /**
       * Creates an address object from a string (hex or bech32)
       */
      static fromString(value) {
        if (_Address.isValidHex(value)) {
          return _Address.fromValidHex(value);
        }
        return _Address.fromBech32(value);
      }
      static isValidHex(value) {
        return import_buffer.Buffer.from(value, "hex").length == PUBKEY_LENGTH;
      }
      /**
       * Creates an address object from a hex-encoded string
       */
      static fromHex(value) {
        if (!_Address.isValidHex(value)) {
          throw new errors.ErrAddressCannotCreate(value);
        }
        return _Address.fromValidHex(value);
      }
      /**
       * Creates an empty address object.
       * Generally speaking, this should not be used by client code (internal use only).
       */
      static empty() {
        return new _Address("");
      }
      /**
       * Creates an address object from a bech32-encoded string
       */
      static fromBech32(value) {
        let decoded;
        try {
          decoded = bech32.decode(value);
        } catch (err) {
          throw new errors.ErrAddressCannotCreate(value, err);
        }
        const prefix = decoded.prefix;
        if (prefix != HRP) {
          throw new errors.ErrAddressBadHrp(HRP, prefix);
        }
        const pubkey = import_buffer.Buffer.from(bech32.fromWords(decoded.words));
        if (pubkey.length != PUBKEY_LENGTH) {
          throw new errors.ErrAddressCannotCreate(value);
        }
        return _Address.fromValidHex(pubkey.toString("hex"));
      }
      /**
       * Performs address validation without throwing errors
       */
      static isValid(value) {
        const decoded = bech32.decodeUnsafe(value);
        const prefix = decoded?.prefix;
        const pubkey = decoded ? import_buffer.Buffer.from(bech32.fromWords(decoded.words)) : void 0;
        if (prefix !== HRP || pubkey?.length !== PUBKEY_LENGTH) {
          return false;
        }
        return true;
      }
      /**
       * Use {@link toHex} instead.
       */
      hex() {
        return this.toHex();
      }
      /**
       * Returns the hex representation of the address (pubkey)
       */
      toHex() {
        if (this.isEmpty()) {
          return "";
        }
        return this.valueHex;
      }
      /**
       * Use {@link toBech32} instead.
       */
      bech32() {
        return this.toBech32();
      }
      /**
       * Returns the bech32 representation of the address
       */
      toBech32() {
        if (this.isEmpty()) {
          return "";
        }
        let words = bech32.toWords(this.pubkey());
        let address = bech32.encode(HRP, words);
        return address;
      }
      /**
       * Use {@link getPublicKey} instead.
       */
      pubkey() {
        return this.getPublicKey();
      }
      /**
       * Returns the pubkey as raw bytes (buffer)
       */
      getPublicKey() {
        if (this.isEmpty()) {
          return import_buffer.Buffer.from([]);
        }
        return import_buffer.Buffer.from(this.valueHex, "hex");
      }
      /**
       * Returns the human-readable-part of the bech32 addresses.
       * The HRP is currently hardcoded to "erd".
       */
      getHrp() {
        return HRP;
      }
      /**
       * Returns whether the address is empty.
       */
      isEmpty() {
        return !this.valueHex;
      }
      /**
       * Compares the address to another address
       */
      equals(other) {
        if (!other) {
          return false;
        }
        return this.valueHex == other.valueHex;
      }
      /**
       * Returns the bech32 representation of the address
       */
      toString() {
        return this.toBech32();
      }
      /**
       * Converts the address to a pretty, plain JavaScript object.
       */
      toJSON() {
        return {
          bech32: this.toBech32(),
          pubkey: this.toHex()
        };
      }
      /**
       * Creates the Zero address (the one that should be used when deploying smart contracts).
       * Generally speaking, this should not be used by client code (internal use only).
       */
      static Zero() {
        return new _Address("0".repeat(64));
      }
      /**
       * Use {@link isSmartContract} instead.
       */
      isContractAddress() {
        return this.isSmartContract();
      }
      /**
       * Returns whether the address is a smart contract address.
       */
      isSmartContract() {
        return this.toHex().startsWith(SMART_CONTRACT_HEX_PUBKEY_PREFIX);
      }
    };
    exports2.Address = Address5;
    var AddressComputer = class {
      constructor(numberOfShardsWithoutMeta) {
        this.numberOfShardsWithoutMeta = numberOfShardsWithoutMeta || constants_1.CURRENT_NUMBER_OF_SHARDS_WITHOUT_META;
      }
      computeContractAddress(deployer, deploymentNonce) {
        const initialPadding = import_buffer.Buffer.alloc(8, 0);
        const ownerPubkey = deployer.getPublicKey();
        const shardSelector = ownerPubkey.slice(30);
        const ownerNonceBytes = import_buffer.Buffer.alloc(8);
        const bigNonce = new bignumber_js_1.default(deploymentNonce.toString());
        const bigNonceBuffer = codec_1.bigIntToBuffer(bigNonce);
        ownerNonceBytes.write(bigNonceBuffer.reverse().toString("hex"), "hex");
        const bytesToHash = import_buffer.Buffer.concat([ownerPubkey, ownerNonceBytes]);
        const hash = createKeccakHash("keccak256").update(bytesToHash).digest();
        const vmTypeBytes = import_buffer.Buffer.from(constants_1.WasmVirtualMachine, "hex");
        const addressBytes = import_buffer.Buffer.concat([initialPadding, vmTypeBytes, hash.slice(10, 30), shardSelector]);
        return new Address5(addressBytes);
      }
      getShardOfAddress(address) {
        return this.getShardOfPubkey(address.getPublicKey(), this.numberOfShardsWithoutMeta);
      }
      getShardOfPubkey(pubkey, numberOfShards) {
        const maskHigh = parseInt("11", 2);
        const maskLow = parseInt("01", 2);
        const lastByteOfPubkey = pubkey[31];
        if (this.isPubkeyOfMetachain(pubkey)) {
          return constants_1.METACHAIN_ID;
        }
        let shard = lastByteOfPubkey & maskHigh;
        if (shard > numberOfShards - 1) {
          shard = lastByteOfPubkey & maskLow;
        }
        return shard;
      }
      isPubkeyOfMetachain(pubkey) {
        const metachainPrefix = import_buffer.Buffer.from([
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]);
        const pubkeyPrefix = import_buffer.Buffer.from(pubkey).slice(0, metachainPrefix.length);
        if (metachainPrefix.equals(pubkeyPrefix)) {
          return true;
        }
        const zeroAddress = import_buffer.Buffer.alloc(32);
        if (zeroAddress.equals(import_buffer.Buffer.from(pubkey))) {
          return true;
        }
        return false;
      }
    };
    exports2.AddressComputer = AddressComputer;
  }
});

// node_modules/@multiversx/sdk-core/out/utils.js
var require_utils2 = __commonJS({
  "node_modules/@multiversx/sdk-core/out/utils.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k4 in mod2)
          if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k4))
            __createBinding2(result, mod2, k4);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isEmpty = exports2.guardEmpty = exports2.guardNotEmpty = exports2.guardLength = exports2.guardSameLength = exports2.guardValueIsSetWithMessage = exports2.guardValueIsSet = exports2.guardTrue = void 0;
    var errors = __importStar2(require_errors());
    function guardTrue(value, what) {
      if (!value) {
        throw new errors.ErrInvariantFailed(`[<${what}>] isn't true`);
      }
    }
    exports2.guardTrue = guardTrue;
    function guardValueIsSet(name2, value) {
      guardValueIsSetWithMessage(`${name2} isn't set (null or undefined)`, value);
    }
    exports2.guardValueIsSet = guardValueIsSet;
    function guardValueIsSetWithMessage(message, value) {
      if (value == null || value === void 0) {
        throw new errors.ErrInvariantFailed(message);
      }
    }
    exports2.guardValueIsSetWithMessage = guardValueIsSetWithMessage;
    function guardSameLength(a3, b4) {
      a3 = a3 || [];
      b4 = b4 || [];
      if (a3.length != b4.length) {
        throw new errors.ErrInvariantFailed("arrays do not have the same length");
      }
    }
    exports2.guardSameLength = guardSameLength;
    function guardLength(withLength, expectedLength) {
      let actualLength = withLength.length || 0;
      if (actualLength != expectedLength) {
        throw new errors.ErrInvariantFailed(`wrong length, expected: ${expectedLength}, actual: ${actualLength}`);
      }
    }
    exports2.guardLength = guardLength;
    function guardNotEmpty(value, what) {
      if (isEmpty(value)) {
        throw new errors.ErrInvariantFailed(`${what} is empty`);
      }
    }
    exports2.guardNotEmpty = guardNotEmpty;
    function guardEmpty(value, what) {
      if (!isEmpty(value)) {
        throw new errors.ErrInvariantFailed(`${what} is not empty`);
      }
    }
    exports2.guardEmpty = guardEmpty;
    function isEmpty(value) {
      if (value.isEmpty) {
        return value.isEmpty();
      }
      return value.length === 0;
    }
    exports2.isEmpty = isEmpty;
  }
});

// node_modules/@multiversx/sdk-core/out/abi/typeFormula.js
var require_typeFormula = __commonJS({
  "node_modules/@multiversx/sdk-core/out/abi/typeFormula.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeFormula = void 0;
    var TypeFormula = class {
      constructor(name2, typeParameters) {
        this.name = name2;
        this.typeParameters = typeParameters;
      }
      toString() {
        if (this.typeParameters.length > 0) {
          const typeParameters = this.typeParameters.map((typeParameter) => typeParameter.toString()).join(", ");
          return `${this.name}<${typeParameters}>`;
        } else {
          return this.name;
        }
      }
    };
    exports2.TypeFormula = TypeFormula;
  }
});

// node_modules/@multiversx/sdk-core/out/abi/typeFormulaParser.js
var require_typeFormulaParser = __commonJS({
  "node_modules/@multiversx/sdk-core/out/abi/typeFormulaParser.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeFormulaParser = void 0;
    var typeFormula_1 = require_typeFormula();
    var TypeFormulaParser = class _TypeFormulaParser {
      parseExpression(expression) {
        expression = expression.trim();
        const tokens = this.tokenizeExpression(expression).filter((token) => token !== _TypeFormulaParser.COMMA);
        const stack = [];
        for (const token of tokens) {
          if (this.isPunctuation(token)) {
            if (this.isEndOfTypeParameters(token)) {
              const typeFormula = this.acquireTypeWithParameters(stack);
              stack.push(typeFormula);
            } else if (this.isBeginningOfTypeParameters(token)) {
              stack.push(token);
            } else {
              throw new Error(`Unexpected token (punctuation): ${token}`);
            }
          } else {
            stack.push(token);
          }
        }
        if (stack.length !== 1) {
          throw new Error(`Unexpected stack length at end of parsing: ${stack.length}`);
        }
        if (_TypeFormulaParser.PUNCTUATION.includes(stack[0])) {
          throw new Error("Unexpected root element.");
        }
        const item = stack[0];
        if (item instanceof typeFormula_1.TypeFormula) {
          return item;
        } else if (typeof item === "string") {
          return new typeFormula_1.TypeFormula(item, []);
        } else {
          throw new Error(`Unexpected item on stack: ${item}`);
        }
      }
      tokenizeExpression(expression) {
        const tokens = [];
        let currentToken = "";
        for (const character of expression) {
          if (this.isPunctuation(character)) {
            if (currentToken) {
              tokens.push(currentToken.trim());
              currentToken = "";
            }
            tokens.push(character);
          } else {
            currentToken += character;
          }
        }
        if (currentToken) {
          tokens.push(currentToken.trim());
        }
        return tokens;
      }
      acquireTypeWithParameters(stack) {
        const typeParameters = this.acquireTypeParameters(stack);
        const typeName = stack.pop();
        const typeFormula = new typeFormula_1.TypeFormula(typeName, typeParameters.reverse());
        return typeFormula;
      }
      acquireTypeParameters(stack) {
        const typeParameters = [];
        while (true) {
          const item = stack.pop();
          if (item === void 0) {
            throw new Error("Badly specified type parameters");
          }
          if (this.isBeginningOfTypeParameters(item)) {
            break;
          }
          if (item instanceof typeFormula_1.TypeFormula) {
            typeParameters.push(item);
          } else if (typeof item === "string") {
            typeParameters.push(new typeFormula_1.TypeFormula(item, []));
          } else {
            throw new Error(`Unexpected type parameter object in stack: ${item}`);
          }
        }
        return typeParameters;
      }
      isPunctuation(token) {
        return _TypeFormulaParser.PUNCTUATION.includes(token);
      }
      isEndOfTypeParameters(token) {
        return token === _TypeFormulaParser.END_TYPE_PARAMETERS;
      }
      isBeginningOfTypeParameters(token) {
        return token === _TypeFormulaParser.BEGIN_TYPE_PARAMETERS;
      }
    };
    exports2.TypeFormulaParser = TypeFormulaParser;
    TypeFormulaParser.BEGIN_TYPE_PARAMETERS = "<";
    TypeFormulaParser.END_TYPE_PARAMETERS = ">";
    TypeFormulaParser.COMMA = ",";
    TypeFormulaParser.PUNCTUATION = [
      TypeFormulaParser.COMMA,
      TypeFormulaParser.BEGIN_TYPE_PARAMETERS,
      TypeFormulaParser.END_TYPE_PARAMETERS
    ];
  }
});

// node_modules/@multiversx/sdk-core/out/reflection.js
var require_reflection = __commonJS({
  "node_modules/@multiversx/sdk-core/out/reflection.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getJavascriptPrototypesInHierarchy = void 0;
    function getJavascriptPrototypesInHierarchy(obj, filter) {
      let prototypes = [];
      let prototype = Object.getPrototypeOf(obj);
      while (prototype && filter(prototype)) {
        prototypes.push(prototype);
        prototype = Object.getPrototypeOf(prototype);
      }
      return prototypes;
    }
    exports2.getJavascriptPrototypesInHierarchy = getJavascriptPrototypesInHierarchy;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/types.js
var require_types = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/types.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NullType = exports2.TypePlaceholder = exports2.isTyped = exports2.PrimitiveValue = exports2.TypedValue = exports2.CustomType = exports2.PrimitiveType = exports2.TypeCardinality = exports2.Type = void 0;
    var reflection_1 = require_reflection();
    var utils_1 = require_utils2();
    var Type = class _Type {
      constructor(name2, typeParameters = [], cardinality = TypeCardinality.fixed(1)) {
        utils_1.guardValueIsSet("name", name2);
        this.name = name2;
        this.typeParameters = typeParameters;
        this.cardinality = cardinality;
      }
      getName() {
        return this.name;
      }
      getClassName() {
        return _Type.ClassName;
      }
      getClassHierarchy() {
        let prototypes = reflection_1.getJavascriptPrototypesInHierarchy(this, (prototype) => prototype.belongsToTypesystem);
        let classNames = prototypes.map((prototype) => prototype.getClassName()).reverse();
        return classNames;
      }
      /**
       * Gets the fully qualified name of the type, to allow for better (efficient and non-ambiguous) type comparison within the custom typesystem.
       */
      getFullyQualifiedName() {
        let joinedTypeParameters = this.getTypeParameters().map((type) => type.getFullyQualifiedName()).join(", ");
        return this.isGenericType() ? `multiversx:types:${this.getName()}<${joinedTypeParameters}>` : `multiversx:types:${this.getName()}`;
      }
      hasExactClass(className) {
        return this.getClassName() == className;
      }
      hasClassOrSuperclass(className) {
        let hierarchy = this.getClassHierarchy();
        return hierarchy.includes(className);
      }
      getTypeParameters() {
        return this.typeParameters;
      }
      isGenericType() {
        return this.typeParameters.length > 0;
      }
      getFirstTypeParameter() {
        utils_1.guardTrue(this.typeParameters.length > 0, "type parameters length > 0");
        return this.typeParameters[0];
      }
      /**
       * Generates type expressions similar to mx-sdk-rs.
       */
      toString() {
        let typeParameters = this.getTypeParameters().map((type) => type.toString()).join(", ");
        let typeParametersExpression = typeParameters ? `<${typeParameters}>` : "";
        return `${this.name}${typeParametersExpression}`;
      }
      equals(other) {
        return _Type.equals(this, other);
      }
      static equals(a3, b4) {
        return a3.getFullyQualifiedName() == b4.getFullyQualifiedName();
      }
      static equalsMany(a3, b4) {
        return a3.every((type, i2) => type.equals(b4[i2]));
      }
      static isAssignableFromMany(a3, b4) {
        return a3.every((type, i2) => type.isAssignableFrom(b4[i2]));
      }
      differs(other) {
        return !this.equals(other);
      }
      valueOf() {
        return this.name;
      }
      /**
       * Inspired from: https://docs.microsoft.com/en-us/dotnet/api/system.type.isassignablefrom
       * For (most) generics, type invariance is expected (assumed) - neither covariance, nor contravariance are supported yet (will be supported in a next release).
       *
       * One exception though: for {@link OptionType}, we simulate covariance for missing (not provided) values.
       * For example, Option<u32> is assignable from Option<?>.
       * For more details, see the implementation of {@link OptionType} and @{@link OptionalType}.
       *
       * Also see:
       *  - https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)
       *  - https://docs.microsoft.com/en-us/dotnet/standard/generics/covariance-and-contravariance
       */
      isAssignableFrom(other) {
        let invariantTypeParameters = _Type.equalsMany(this.getTypeParameters(), other.getTypeParameters());
        if (!invariantTypeParameters) {
          return false;
        }
        let fullyQualifiedNameOfThis = this.getFullyQualifiedName();
        let fullyQualifiedNamesInHierarchyOfOther = _Type.getFullyQualifiedNamesInHierarchy(other);
        if (fullyQualifiedNamesInHierarchyOfOther.includes(fullyQualifiedNameOfThis)) {
          return true;
        }
        return other.hasClassOrSuperclass(this.getClassName());
      }
      static getFullyQualifiedNamesInHierarchy(type) {
        let prototypes = reflection_1.getJavascriptPrototypesInHierarchy(type, (prototype) => prototype.belongsToTypesystem);
        let fullyQualifiedNames = prototypes.map((prototype) => prototype.getFullyQualifiedName.call(type));
        return fullyQualifiedNames;
      }
      getNamesOfDependencies() {
        const dependencies = [];
        for (const type of this.typeParameters) {
          dependencies.push(type.getName());
          dependencies.push(...type.getNamesOfDependencies());
        }
        return [...new Set(dependencies)];
      }
      /**
       * Converts the account to a pretty, plain JavaScript object.
       */
      toJSON() {
        return {
          name: this.name,
          typeParameters: this.typeParameters.map((item) => item.toJSON())
        };
      }
      getCardinality() {
        return this.cardinality;
      }
      /**
       * A special marker for types within the custom typesystem.
       */
      belongsToTypesystem() {
      }
    };
    exports2.Type = Type;
    Type.ClassName = "Type";
    var TypeCardinality = class _TypeCardinality {
      constructor(lowerBound, upperBound) {
        this.lowerBound = lowerBound;
        this.upperBound = upperBound;
      }
      static fixed(value) {
        return new _TypeCardinality(value, value);
      }
      static variable(value) {
        return new _TypeCardinality(0, value);
      }
      isSingular() {
        return this.lowerBound == 1 && this.upperBound == 1;
      }
      isSingularOrNone() {
        return this.lowerBound == 0 && this.upperBound == 1;
      }
      isComposite() {
        return this.upperBound != 1;
      }
      isFixed() {
        return this.lowerBound == this.upperBound;
      }
      getLowerBound() {
        return this.lowerBound;
      }
      getUpperBound() {
        return this.upperBound || _TypeCardinality.MaxCardinality;
      }
    };
    exports2.TypeCardinality = TypeCardinality;
    TypeCardinality.MaxCardinality = 4096;
    var PrimitiveType = class _PrimitiveType extends Type {
      constructor(name2) {
        super(name2);
      }
      getClassName() {
        return _PrimitiveType.ClassName;
      }
    };
    exports2.PrimitiveType = PrimitiveType;
    PrimitiveType.ClassName = "PrimitiveType";
    var CustomType = class _CustomType extends Type {
      getClassName() {
        return _CustomType.ClassName;
      }
    };
    exports2.CustomType = CustomType;
    CustomType.ClassName = "CustomType";
    var TypedValue = class _TypedValue {
      constructor(type) {
        this.type = type;
      }
      getClassName() {
        return _TypedValue.ClassName;
      }
      getClassHierarchy() {
        let prototypes = reflection_1.getJavascriptPrototypesInHierarchy(this, (prototype) => prototype.belongsToTypesystem);
        let classNames = prototypes.map((prototype) => prototype.getClassName()).reverse();
        return classNames;
      }
      getType() {
        return this.type;
      }
      hasExactClass(className) {
        return this.getClassName() == className;
      }
      hasClassOrSuperclass(className) {
        let hierarchy = this.getClassHierarchy();
        return hierarchy.includes(className);
      }
      /**
       * A special marker for values within the custom typesystem.
       */
      belongsToTypesystem() {
      }
    };
    exports2.TypedValue = TypedValue;
    TypedValue.ClassName = "TypedValue";
    var PrimitiveValue = class _PrimitiveValue extends TypedValue {
      constructor(type) {
        super(type);
      }
      getClassName() {
        return _PrimitiveValue.ClassName;
      }
    };
    exports2.PrimitiveValue = PrimitiveValue;
    PrimitiveValue.ClassName = "PrimitiveValue";
    function isTyped(value) {
      return value.belongsToTypesystem !== void 0;
    }
    exports2.isTyped = isTyped;
    var TypePlaceholder = class _TypePlaceholder extends Type {
      constructor() {
        super("...");
      }
      getClassName() {
        return _TypePlaceholder.ClassName;
      }
    };
    exports2.TypePlaceholder = TypePlaceholder;
    TypePlaceholder.ClassName = "TypePlaceholder";
    var NullType = class _NullType extends Type {
      constructor() {
        super("?");
      }
      getClassName() {
        return _NullType.ClassName;
      }
    };
    exports2.NullType = NullType;
    NullType.ClassName = "NullType";
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/typeExpressionParser.js
var require_typeExpressionParser = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/typeExpressionParser.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeExpressionParser = void 0;
    var typeFormulaParser_1 = require_typeFormulaParser();
    var errors_1 = require_errors();
    var types_1 = require_types();
    var TypeExpressionParser = class {
      constructor() {
        this.backingTypeFormulaParser = new typeFormulaParser_1.TypeFormulaParser();
      }
      parse(expression) {
        try {
          return this.doParse(expression);
        } catch (e2) {
          throw new errors_1.ErrTypingSystem(`Failed to parse type expression: ${expression}. Error: ${e2}`);
        }
      }
      doParse(expression) {
        const typeFormula = this.backingTypeFormulaParser.parseExpression(expression);
        const type = this.typeFormulaToType(typeFormula);
        return type;
      }
      typeFormulaToType(typeFormula) {
        const typeParameters = typeFormula.typeParameters.map((typeFormula2) => this.typeFormulaToType(typeFormula2));
        return new types_1.Type(typeFormula.name, typeParameters);
      }
    };
    exports2.TypeExpressionParser = TypeExpressionParser;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/endpoint.js
var require_endpoint = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/endpoint.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EndpointParameterDefinition = exports2.EndpointModifiers = exports2.EndpointDefinition = void 0;
    var typeExpressionParser_1 = require_typeExpressionParser();
    var NamePlaceholder = "?";
    var DescriptionPlaceholder = "N / A";
    var EndpointDefinition = class _EndpointDefinition {
      constructor(name2, input, output, modifiers) {
        this.input = [];
        this.output = [];
        this.name = name2;
        this.input = input || [];
        this.output = output || [];
        this.modifiers = modifiers;
      }
      isConstructor() {
        return this.name == "constructor";
      }
      static fromJSON(json) {
        json.name = json.name == null ? NamePlaceholder : json.name;
        json.onlyOwner = json.onlyOwner || false;
        json.payableInTokens = json.payableInTokens || [];
        json.inputs = json.inputs || [];
        json.outputs = json.outputs || [];
        let input = json.inputs.map((param) => EndpointParameterDefinition.fromJSON(param));
        let output = json.outputs.map((param) => EndpointParameterDefinition.fromJSON(param));
        let modifiers = new EndpointModifiers(json.mutability, json.payableInTokens, json.onlyOwner);
        return new _EndpointDefinition(json.name, input, output, modifiers);
      }
    };
    exports2.EndpointDefinition = EndpointDefinition;
    var EndpointModifiers = class {
      constructor(mutability, payableInTokens, onlyOwner) {
        this.mutability = mutability || "";
        this.payableInTokens = payableInTokens || [];
        this.onlyOwner = onlyOwner || false;
      }
      isPayableInEGLD() {
        return this.isPayableInToken("EGLD");
      }
      isPayableInToken(token) {
        if (this.payableInTokens.includes(token)) {
          return true;
        }
        if (this.payableInTokens.includes(`!${token}`)) {
          return false;
        }
        if (this.payableInTokens.includes("*")) {
          return true;
        }
        return false;
      }
      isPayable() {
        return this.payableInTokens.length != 0;
      }
      isReadonly() {
        return this.mutability == "readonly";
      }
      isOnlyOwner() {
        return this.onlyOwner;
      }
    };
    exports2.EndpointModifiers = EndpointModifiers;
    var EndpointParameterDefinition = class _EndpointParameterDefinition {
      constructor(name2, description, type) {
        this.name = name2;
        this.description = description;
        this.type = type;
      }
      static fromJSON(json) {
        let parsedType = new typeExpressionParser_1.TypeExpressionParser().parse(json.type);
        return new _EndpointParameterDefinition(json.name || NamePlaceholder, json.description || DescriptionPlaceholder, parsedType);
      }
    };
    exports2.EndpointParameterDefinition = EndpointParameterDefinition;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/fields.js
var require_fields = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/fields.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k4 in mod2)
          if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k4))
            __createBinding2(result, mod2, k4);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Fields = exports2.Field = exports2.FieldDefinition = void 0;
    var errors = __importStar2(require_errors());
    var typeExpressionParser_1 = require_typeExpressionParser();
    var FieldDefinition = class _FieldDefinition {
      constructor(name2, description, type) {
        this.name = name2;
        this.description = description;
        this.type = type;
      }
      static fromJSON(json) {
        let parsedType = new typeExpressionParser_1.TypeExpressionParser().parse(json.type);
        return new _FieldDefinition(json.name, json.description, parsedType);
      }
    };
    exports2.FieldDefinition = FieldDefinition;
    var Field = class {
      constructor(value, name2 = "") {
        this.value = value;
        this.name = name2;
      }
      checkTyping(expectedDefinition) {
        const actualType = this.value.getType();
        if (!actualType.equals(expectedDefinition.type)) {
          throw new errors.ErrTypingSystem(`check type of field "${expectedDefinition.name}; expected: ${expectedDefinition.type}, actual: ${actualType}"`);
        }
        if (this.name != expectedDefinition.name) {
          throw new errors.ErrTypingSystem(`check name of field "${expectedDefinition.name}"`);
        }
      }
      equals(other) {
        return this.name == other.name && this.value.equals(other.value);
      }
    };
    exports2.Field = Field;
    var Fields = class {
      static checkTyping(fields, definitions) {
        if (fields.length != definitions.length) {
          throw new errors.ErrTypingSystem("fields length vs. field definitions length");
        }
        for (let i2 = 0; i2 < fields.length; i2++) {
          let field = fields[i2];
          let definition = definitions[i2];
          field.checkTyping(definition);
        }
      }
      static equals(actual, expected) {
        if (actual.length != expected.length) {
          return false;
        }
        for (let i2 = 0; i2 < actual.length; i2++) {
          let selfField = actual[i2];
          let otherField = expected[i2];
          if (!selfField.equals(otherField)) {
            return false;
          }
        }
        return true;
      }
      static getNamesOfTypeDependencies(definitions) {
        const dependencies = [];
        for (const definition of definitions) {
          dependencies.push(definition.type.getName());
          dependencies.push(...definition.type.getNamesOfDependencies());
        }
        return [...new Set(dependencies)];
      }
    };
    exports2.Fields = Fields;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/enum.js
var require_enum = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/enum.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnumValue = exports2.EnumVariantDefinition = exports2.EnumType = void 0;
    var errors_1 = require_errors();
    var utils_1 = require_utils2();
    var fields_1 = require_fields();
    var types_1 = require_types();
    var SimpleEnumMaxDiscriminant = 256;
    var EnumType = class _EnumType extends types_1.CustomType {
      constructor(name2, variants) {
        super(name2);
        this.variants = [];
        this.variants = variants;
      }
      getClassName() {
        return _EnumType.ClassName;
      }
      static fromJSON(json) {
        const rawVariants = _EnumType.assignMissingDiscriminants(json.variants || []);
        const variants = rawVariants.map((variant) => EnumVariantDefinition.fromJSON(variant));
        return new _EnumType(json.name, variants);
      }
      // For some enums (e.g. some "explicit-enum" types), the discriminants are missing.
      static assignMissingDiscriminants(variants) {
        const allDiscriminantsAreMissing = variants.every((variant) => variant.discriminant == void 0);
        if (!allDiscriminantsAreMissing) {
          return variants;
        }
        return variants.map((variant, index) => {
          return {
            ...variant,
            discriminant: index
          };
        });
      }
      getVariantByDiscriminant(discriminant) {
        let result = this.variants.find((e2) => e2.discriminant == discriminant);
        utils_1.guardValueIsSet(`variant by discriminant (${discriminant})`, result);
        return result;
      }
      getVariantByName(name2) {
        let result = this.variants.find((e2) => e2.name == name2);
        utils_1.guardValueIsSet(`variant by name (${name2})`, result);
        return result;
      }
      getNamesOfDependencies() {
        const dependencies = [];
        for (const variant of this.variants) {
          dependencies.push(...variant.getNamesOfDependencies());
        }
        return [...new Set(dependencies)];
      }
    };
    exports2.EnumType = EnumType;
    EnumType.ClassName = "EnumType";
    var EnumVariantDefinition = class _EnumVariantDefinition {
      constructor(name2, discriminant, fieldsDefinitions = []) {
        this.fieldsDefinitions = [];
        utils_1.guardTrue(discriminant < SimpleEnumMaxDiscriminant, `discriminant for simple enum should be less than ${SimpleEnumMaxDiscriminant}`);
        this.name = name2;
        this.discriminant = discriminant;
        this.fieldsDefinitions = fieldsDefinitions;
      }
      static fromJSON(json) {
        let definitions = (json.fields || []).map((definition) => fields_1.FieldDefinition.fromJSON(definition));
        return new _EnumVariantDefinition(json.name, json.discriminant, definitions);
      }
      getFieldsDefinitions() {
        return this.fieldsDefinitions;
      }
      getFieldDefinition(name2) {
        return this.fieldsDefinitions.find((item) => item.name == name2);
      }
      getNamesOfDependencies() {
        return fields_1.Fields.getNamesOfTypeDependencies(this.fieldsDefinitions);
      }
    };
    exports2.EnumVariantDefinition = EnumVariantDefinition;
    var EnumValue = class _EnumValue extends types_1.TypedValue {
      constructor(type, variant, fields) {
        super(type);
        this.fields = [];
        this.name = variant.name;
        this.discriminant = variant.discriminant;
        this.fields = fields;
        this.fieldsByName = new Map(fields.map((field) => [field.name, field]));
        let definitions = variant.getFieldsDefinitions();
        fields_1.Fields.checkTyping(this.fields, definitions);
      }
      getClassName() {
        return _EnumValue.ClassName;
      }
      /**
       * Utility (named constructor) to create a simple (i.e. without fields) enum value.
       */
      static fromName(type, name2) {
        let variant = type.getVariantByName(name2);
        return new _EnumValue(type, variant, []);
      }
      /**
       * Utility (named constructor) to create a simple (i.e. without fields) enum value.
       */
      static fromDiscriminant(type, discriminant) {
        let variant = type.getVariantByDiscriminant(discriminant);
        return new _EnumValue(type, variant, []);
      }
      equals(other) {
        if (!this.getType().equals(other.getType())) {
          return false;
        }
        let selfFields = this.getFields();
        let otherFields = other.getFields();
        const nameIsSame = this.name == other.name;
        const discriminantIsSame = this.discriminant == other.discriminant;
        const fieldsAreSame = fields_1.Fields.equals(selfFields, otherFields);
        return nameIsSame && discriminantIsSame && fieldsAreSame;
      }
      getFields() {
        return this.fields;
      }
      getFieldValue(name2) {
        let field = this.fieldsByName.get(name2);
        if (field) {
          return field.value.valueOf();
        }
        throw new errors_1.ErrMissingFieldOnEnum(name2, this.getType().getName());
      }
      valueOf() {
        let result = { name: this.name, fields: [] };
        this.fields.forEach((field, index) => result.fields[index] = field.value.valueOf());
        return result;
      }
    };
    exports2.EnumValue = EnumValue;
    EnumValue.ClassName = "EnumValue";
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/event.js
var require_event = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/event.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EventTopicDefinition = exports2.EventDefinition = void 0;
    var typeExpressionParser_1 = require_typeExpressionParser();
    var NamePlaceholder = "?";
    var EventDefinition = class _EventDefinition {
      constructor(identifier, inputs) {
        this.inputs = [];
        this.identifier = identifier;
        this.inputs = inputs || [];
      }
      static fromJSON(json) {
        json.identifier = json.identifier == null ? NamePlaceholder : json.identifier;
        json.inputs = json.inputs || [];
        const inputs = json.inputs.map((param) => EventTopicDefinition.fromJSON(param));
        return new _EventDefinition(json.identifier, inputs);
      }
    };
    exports2.EventDefinition = EventDefinition;
    var EventTopicDefinition = class _EventTopicDefinition {
      constructor(options) {
        this.name = options.name;
        this.type = options.type;
        this.indexed = options.indexed;
      }
      static fromJSON(json) {
        const parsedType = new typeExpressionParser_1.TypeExpressionParser().parse(json.type);
        return new _EventTopicDefinition({
          name: json.name || NamePlaceholder,
          type: parsedType,
          indexed: json.indexed
        });
      }
    };
    exports2.EventTopicDefinition = EventTopicDefinition;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/struct.js
var require_struct = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/struct.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Struct = exports2.StructType = void 0;
    var errors_1 = require_errors();
    var fields_1 = require_fields();
    var types_1 = require_types();
    var StructType = class _StructType extends types_1.CustomType {
      constructor(name2, fieldsDefinitions) {
        super(name2);
        this.fieldsDefinitions = [];
        this.fieldsDefinitions = fieldsDefinitions;
      }
      getClassName() {
        return _StructType.ClassName;
      }
      static fromJSON(json) {
        let definitions = (json.fields || []).map((definition) => fields_1.FieldDefinition.fromJSON(definition));
        return new _StructType(json.name, definitions);
      }
      getFieldsDefinitions() {
        return this.fieldsDefinitions;
      }
      getFieldDefinition(name2) {
        return this.fieldsDefinitions.find((item) => item.name == name2);
      }
      getNamesOfDependencies() {
        return fields_1.Fields.getNamesOfTypeDependencies(this.fieldsDefinitions);
      }
    };
    exports2.StructType = StructType;
    StructType.ClassName = "StructType";
    var Struct = class _Struct extends types_1.TypedValue {
      /**
       * One can only set fields at initialization time.
       */
      constructor(type, fields) {
        super(type);
        this.fields = fields;
        this.fieldsByName = new Map(fields.map((field) => [field.name, field]));
        this.checkTyping();
      }
      getClassName() {
        return _Struct.ClassName;
      }
      checkTyping() {
        let type = this.getType();
        let definitions = type.getFieldsDefinitions();
        fields_1.Fields.checkTyping(this.fields, definitions);
      }
      getFields() {
        return this.fields;
      }
      getFieldValue(name2) {
        let field = this.fieldsByName.get(name2);
        if (field) {
          return field.value.valueOf();
        }
        throw new errors_1.ErrMissingFieldOnStruct(name2, this.getType().getName());
      }
      valueOf() {
        let result = {};
        for (const field of this.fields) {
          result[field.name] = field.value.valueOf();
        }
        return result;
      }
      equals(other) {
        if (!this.getType().equals(other.getType())) {
          return false;
        }
        let selfFields = this.getFields();
        let otherFields = other.getFields();
        return fields_1.Fields.equals(selfFields, otherFields);
      }
    };
    exports2.Struct = Struct;
    Struct.ClassName = "Struct";
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/address.js
var require_address2 = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/address.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AddressValue = exports2.AddressType = void 0;
    var address_1 = require_address();
    var types_1 = require_types();
    var AddressType2 = class _AddressType extends types_1.PrimitiveType {
      constructor() {
        super("Address");
      }
      getClassName() {
        return _AddressType.ClassName;
      }
    };
    exports2.AddressType = AddressType2;
    AddressType2.ClassName = "AddressType";
    var AddressValue2 = class _AddressValue extends types_1.PrimitiveValue {
      constructor(value) {
        super(new AddressType2());
        this.value = new address_1.Address(value.bech32());
      }
      getClassName() {
        return _AddressValue.ClassName;
      }
      /**
       * Returns whether two objects have the same value.
       *
       * @param other another AddressValue
       */
      equals(other) {
        return this.value.equals(other.value);
      }
      valueOf() {
        return this.value;
      }
    };
    exports2.AddressValue = AddressValue2;
    AddressValue2.ClassName = "AddressValue";
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/algebraic.js
var require_algebraic = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/algebraic.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OptionalValue = exports2.OptionalType = void 0;
    var utils_1 = require_utils2();
    var types_1 = require_types();
    var OptionalType = class _OptionalType extends types_1.Type {
      constructor(typeParameter) {
        super("Optional", [typeParameter], types_1.TypeCardinality.variable(1));
      }
      getClassName() {
        return _OptionalType.ClassName;
      }
      isAssignableFrom(type) {
        if (!type.hasExactClass(_OptionalType.ClassName)) {
          return false;
        }
        let invariantTypeParameters = this.getFirstTypeParameter().equals(type.getFirstTypeParameter());
        let fakeCovarianceToNull = type.getFirstTypeParameter().hasExactClass(types_1.NullType.ClassName);
        return invariantTypeParameters || fakeCovarianceToNull;
      }
    };
    exports2.OptionalType = OptionalType;
    OptionalType.ClassName = "OptionalType";
    var OptionalValue = class _OptionalValue extends types_1.TypedValue {
      constructor(type, value = null) {
        super(type);
        this.value = value;
      }
      getClassName() {
        return _OptionalValue.ClassName;
      }
      /**
       * Creates an OptionalValue, as not provided (missing).
       */
      static newMissing() {
        let type = new OptionalType(new types_1.NullType());
        return new _OptionalValue(type);
      }
      isSet() {
        return this.value ? true : false;
      }
      getTypedValue() {
        utils_1.guardValueIsSet("value", this.value);
        return this.value;
      }
      valueOf() {
        return this.value ? this.value.valueOf() : null;
      }
      equals(other) {
        return this.value?.equals(other.value) || false;
      }
    };
    exports2.OptionalValue = OptionalValue;
    OptionalValue.ClassName = "OptionalValue";
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/boolean.js
var require_boolean = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/boolean.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BooleanValue = exports2.BooleanType = void 0;
    var types_1 = require_types();
    var BooleanType2 = class _BooleanType extends types_1.PrimitiveType {
      constructor() {
        super("bool");
      }
      getClassName() {
        return _BooleanType.ClassName;
      }
    };
    exports2.BooleanType = BooleanType2;
    BooleanType2.ClassName = "BooleanType";
    var BooleanValue2 = class _BooleanValue extends types_1.PrimitiveValue {
      constructor(value) {
        super(new BooleanType2());
        this.value = value;
      }
      getClassName() {
        return _BooleanValue.ClassName;
      }
      /**
       * Returns whether two objects have the same value.
       *
       * @param other another BooleanValue
       */
      equals(other) {
        return this.value === other.value;
      }
      isTrue() {
        return this.value === true;
      }
      isFalse() {
        return !this.isTrue();
      }
      valueOf() {
        return this.value;
      }
    };
    exports2.BooleanValue = BooleanValue2;
    BooleanValue2.ClassName = "BooleanValue";
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/bytes.js
var require_bytes = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/bytes.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BytesValue = exports2.BytesType = void 0;
    var types_1 = require_types();
    var BytesType2 = class _BytesType extends types_1.PrimitiveType {
      constructor() {
        super("bytes");
      }
      getClassName() {
        return _BytesType.ClassName;
      }
    };
    exports2.BytesType = BytesType2;
    BytesType2.ClassName = "BytesType";
    var BytesValue2 = class _BytesValue extends types_1.PrimitiveValue {
      constructor(value) {
        super(new BytesType2());
        this.value = value;
      }
      getClassName() {
        return _BytesValue.ClassName;
      }
      /**
       * Creates a BytesValue from a utf-8 string.
       */
      static fromUTF8(value) {
        let buffer = import_buffer.Buffer.from(value, "utf-8");
        return new _BytesValue(buffer);
      }
      /**
       * Creates a BytesValue from a hex-encoded string.
       */
      static fromHex(value) {
        let buffer = import_buffer.Buffer.from(value, "hex");
        return new _BytesValue(buffer);
      }
      getLength() {
        return this.value.length;
      }
      /**
       * Returns whether two objects have the same value.
       */
      equals(other) {
        if (this.getLength() != other.getLength()) {
          return false;
        }
        return this.value.equals(other.value);
      }
      valueOf() {
        return this.value;
      }
      toString() {
        return this.value.toString();
      }
    };
    exports2.BytesValue = BytesValue2;
    BytesValue2.ClassName = "BytesValue";
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/codeMetadata.js
var require_codeMetadata = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/codeMetadata.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CodeMetadataValue = exports2.CodeMetadataType = void 0;
    var types_1 = require_types();
    var CodeMetadataType = class extends types_1.PrimitiveType {
      constructor() {
        super("CodeMetadata");
      }
    };
    exports2.CodeMetadataType = CodeMetadataType;
    var CodeMetadataValue = class extends types_1.PrimitiveValue {
      constructor(value) {
        super(new CodeMetadataType());
        this.value = value;
      }
      equals(other) {
        return this.value.equals(other.value);
      }
      valueOf() {
        return this.value;
      }
    };
    exports2.CodeMetadataValue = CodeMetadataValue;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/composite.js
var require_composite = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/composite.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CompositeValue = exports2.CompositeType = void 0;
    var utils_1 = require_utils2();
    var types_1 = require_types();
    var CompositeType = class _CompositeType extends types_1.Type {
      constructor(...typeParameters) {
        super("Composite", typeParameters, types_1.TypeCardinality.variable(typeParameters.length));
      }
      getClassName() {
        return _CompositeType.ClassName;
      }
    };
    exports2.CompositeType = CompositeType;
    CompositeType.ClassName = "CompositeType";
    var CompositeValue = class _CompositeValue extends types_1.TypedValue {
      constructor(type, items) {
        super(type);
        utils_1.guardLength(items, type.getTypeParameters().length);
        this.items = items;
      }
      getClassName() {
        return _CompositeValue.ClassName;
      }
      static fromItems(...items) {
        let typeParameters = items.map((value) => value.getType());
        let type = new CompositeType(...typeParameters);
        return new _CompositeValue(type, items);
      }
      getItems() {
        return this.items;
      }
      valueOf() {
        return this.items.map((item) => item?.valueOf());
      }
      equals(other) {
        if (this.getType().differs(other.getType())) {
          return false;
        }
        for (let i2 = 0; i2 < this.items.length; i2++) {
          let selfItem = this.items[i2];
          let otherItem = other.items[i2];
          if (!selfItem.equals(otherItem)) {
            return false;
          }
        }
        return true;
      }
    };
    exports2.CompositeValue = CompositeValue;
    CompositeValue.ClassName = "CompositeValue";
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/collections.js
var require_collections = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/collections.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CollectionOfTypedValues = void 0;
    var CollectionOfTypedValues = class {
      constructor(items) {
        this.items = items;
      }
      getLength() {
        return this.items.length;
      }
      getItems() {
        return this.items;
      }
      valueOf() {
        return this.items.map((item) => item.valueOf());
      }
      equals(other) {
        if (this.getLength() != other.getLength()) {
          return false;
        }
        for (let i2 = 0; i2 < this.getLength(); i2++) {
          let selfItem = this.items[i2];
          let otherItem = other.items[i2];
          if (!selfItem.equals(otherItem)) {
            return false;
          }
        }
        return true;
      }
    };
    exports2.CollectionOfTypedValues = CollectionOfTypedValues;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/generic.js
var require_generic = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/generic.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.List = exports2.OptionValue = exports2.ListType = exports2.OptionType = void 0;
    var utils_1 = require_utils2();
    var collections_1 = require_collections();
    var types_1 = require_types();
    var OptionType = class _OptionType extends types_1.Type {
      constructor(typeParameter) {
        super("Option", [typeParameter]);
      }
      getClassName() {
        return _OptionType.ClassName;
      }
      isAssignableFrom(type) {
        if (!type.hasExactClass(_OptionType.ClassName)) {
          return false;
        }
        let invariantTypeParameters = this.getFirstTypeParameter().equals(type.getFirstTypeParameter());
        let fakeCovarianceToNull = type.getFirstTypeParameter().hasExactClass(types_1.NullType.ClassName);
        return invariantTypeParameters || fakeCovarianceToNull;
      }
    };
    exports2.OptionType = OptionType;
    OptionType.ClassName = "OptionType";
    var ListType = class _ListType extends types_1.Type {
      constructor(typeParameter) {
        super("List", [typeParameter]);
      }
      getClassName() {
        return _ListType.ClassName;
      }
    };
    exports2.ListType = ListType;
    ListType.ClassName = "ListType";
    var OptionValue = class _OptionValue extends types_1.TypedValue {
      constructor(type, value = null) {
        super(type);
        this.value = value;
      }
      getClassName() {
        return _OptionValue.ClassName;
      }
      /**
       * Creates an OptionValue, as a missing option argument.
       */
      static newMissing() {
        let type = new OptionType(new types_1.NullType());
        return new _OptionValue(type);
      }
      static newMissingTyped(type) {
        return new _OptionValue(new OptionType(type));
      }
      /**
       * Creates an OptionValue, as a provided option argument.
       */
      static newProvided(typedValue) {
        let type = new OptionType(typedValue.getType());
        return new _OptionValue(type, typedValue);
      }
      isSet() {
        return this.value ? true : false;
      }
      getTypedValue() {
        utils_1.guardValueIsSet("value", this.value);
        return this.value;
      }
      valueOf() {
        return this.value ? this.value.valueOf() : null;
      }
      equals(other) {
        return this.value?.equals(other.value) || false;
      }
    };
    exports2.OptionValue = OptionValue;
    OptionValue.ClassName = "OptionValue";
    var List = class _List extends types_1.TypedValue {
      /**
       *
       * @param type the type of this TypedValue (an instance of ListType), not the type parameter of the ListType
       * @param items the items, having the type type.getFirstTypeParameter()
       */
      constructor(type, items) {
        super(type);
        this.backingCollection = new collections_1.CollectionOfTypedValues(items);
      }
      getClassName() {
        return _List.ClassName;
      }
      static fromItems(items) {
        if (items.length == 0) {
          return new _List(new types_1.TypePlaceholder(), []);
        }
        let typeParameter = items[0].getType();
        let listType = new ListType(typeParameter);
        return new _List(listType, items);
      }
      getLength() {
        return this.backingCollection.getLength();
      }
      getItems() {
        return this.backingCollection.getItems();
      }
      valueOf() {
        return this.backingCollection.valueOf();
      }
      equals(other) {
        return this.backingCollection.equals(other.backingCollection);
      }
    };
    exports2.List = List;
    List.ClassName = "List";
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/genericArray.js
var require_genericArray = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/genericArray.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ArrayVec = exports2.ArrayVecType = void 0;
    var utils_1 = require_utils2();
    var collections_1 = require_collections();
    var types_1 = require_types();
    var ArrayVecType = class _ArrayVecType extends types_1.Type {
      constructor(length2, typeParameter) {
        super("Array", [typeParameter]);
        utils_1.guardTrue(length2 > 0, "array length > 0");
        this.length = length2;
      }
      getClassName() {
        return _ArrayVecType.ClassName;
      }
    };
    exports2.ArrayVecType = ArrayVecType;
    ArrayVecType.ClassName = "ArrayVecType";
    var ArrayVec = class _ArrayVec extends types_1.TypedValue {
      constructor(type, items) {
        super(type);
        utils_1.guardLength(items, type.length);
        this.backingCollection = new collections_1.CollectionOfTypedValues(items);
      }
      getClassName() {
        return _ArrayVec.ClassName;
      }
      getLength() {
        return this.backingCollection.getLength();
      }
      getItems() {
        return this.backingCollection.getItems();
      }
      valueOf() {
        return this.backingCollection.valueOf();
      }
      equals(other) {
        return this.backingCollection.equals(other.backingCollection);
      }
    };
    exports2.ArrayVec = ArrayVec;
    ArrayVec.ClassName = "ArrayVec";
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/h256.js
var require_h256 = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/h256.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.H256Value = exports2.H256Type = void 0;
    var types_1 = require_types();
    var H256Type = class _H256Type extends types_1.PrimitiveType {
      constructor() {
        super("H256");
      }
      getClassName() {
        return _H256Type.ClassName;
      }
    };
    exports2.H256Type = H256Type;
    H256Type.ClassName = "H256Type";
    var H256Value = class _H256Value extends types_1.PrimitiveValue {
      constructor(value) {
        super(new H256Type());
        this.value = value;
      }
      getClassName() {
        return _H256Value.ClassName;
      }
      /**
       * Returns whether two objects have the same value.
       */
      equals(other) {
        return this.value.equals(other.value);
      }
      valueOf() {
        return this.value;
      }
    };
    exports2.H256Value = H256Value;
    H256Value.ClassName = "H256Value";
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/nothing.js
var require_nothing = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/nothing.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NothingValue = exports2.NothingType = void 0;
    var types_1 = require_types();
    var NothingType = class _NothingType extends types_1.PrimitiveType {
      constructor() {
        super("nothing");
      }
      getClassName() {
        return _NothingType.ClassName;
      }
    };
    exports2.NothingType = NothingType;
    NothingType.ClassName = "NothingType";
    var NothingValue = class _NothingValue extends types_1.PrimitiveValue {
      constructor() {
        super(new NothingType());
      }
      getClassName() {
        return _NothingValue.ClassName;
      }
      equals(_other) {
        return false;
      }
      valueOf() {
        return {};
      }
    };
    exports2.NothingValue = NothingValue;
    NothingValue.ClassName = "NothingValue";
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/numerical.js
var require_numerical = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/numerical.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k4 in mod2)
          if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k4))
            __createBinding2(result, mod2, k4);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BigIntValue = exports2.BigUIntValue = exports2.I64Value = exports2.U64Value = exports2.I32Value = exports2.U32Value = exports2.I16Value = exports2.U16Value = exports2.I8Value = exports2.U8Value = exports2.NumericalValue = exports2.BigIntType = exports2.BigUIntType = exports2.I64Type = exports2.U64Type = exports2.I32Type = exports2.U32Type = exports2.I16Type = exports2.U16Type = exports2.I8Type = exports2.U8Type = exports2.NumericalType = void 0;
    var bignumber_js_1 = __importDefault2(require_bignumber());
    var errors = __importStar2(require_errors());
    var types_1 = require_types();
    var NumericalType = class _NumericalType extends types_1.PrimitiveType {
      constructor(name2, sizeInBytes, withSign) {
        super(name2);
        this.sizeInBytes = sizeInBytes;
        this.withSign = withSign;
      }
      getClassName() {
        return _NumericalType.ClassName;
      }
      hasFixedSize() {
        return this.sizeInBytes ? true : false;
      }
      hasArbitrarySize() {
        return !this.hasFixedSize();
      }
    };
    exports2.NumericalType = NumericalType;
    NumericalType.ClassName = "NumericalType";
    var U8Type2 = class _U8Type extends NumericalType {
      constructor() {
        super("u8", 1, false);
      }
      getClassName() {
        return _U8Type.ClassName;
      }
    };
    exports2.U8Type = U8Type2;
    U8Type2.ClassName = "U8Type";
    var I8Type = class _I8Type extends NumericalType {
      constructor() {
        super("i8", 1, true);
      }
      getClassName() {
        return _I8Type.ClassName;
      }
    };
    exports2.I8Type = I8Type;
    I8Type.ClassName = "I8Type";
    var U16Type2 = class _U16Type extends NumericalType {
      constructor() {
        super("u16", 2, false);
      }
      getClassName() {
        return _U16Type.ClassName;
      }
    };
    exports2.U16Type = U16Type2;
    U16Type2.ClassName = "U16Type";
    var I16Type = class _I16Type extends NumericalType {
      constructor() {
        super("i16", 2, true);
      }
      getClassName() {
        return _I16Type.ClassName;
      }
    };
    exports2.I16Type = I16Type;
    I16Type.ClassName = "I16Type";
    var U32Type2 = class _U32Type extends NumericalType {
      constructor() {
        super("u32", 4, false);
      }
      getClassName() {
        return _U32Type.ClassName;
      }
    };
    exports2.U32Type = U32Type2;
    U32Type2.ClassName = "U32Type";
    var I32Type = class _I32Type extends NumericalType {
      constructor() {
        super("i32", 4, true);
      }
      getClassName() {
        return _I32Type.ClassName;
      }
    };
    exports2.I32Type = I32Type;
    I32Type.ClassName = "I32Type";
    var U64Type2 = class _U64Type extends NumericalType {
      constructor() {
        super("u64", 8, false);
      }
      getClassName() {
        return _U64Type.ClassName;
      }
    };
    exports2.U64Type = U64Type2;
    U64Type2.ClassName = "U64Type";
    var I64Type = class _I64Type extends NumericalType {
      constructor() {
        super("i64", 8, true);
      }
      getClassName() {
        return _I64Type.ClassName;
      }
    };
    exports2.I64Type = I64Type;
    I64Type.ClassName = "I64Type";
    var BigUIntType2 = class _BigUIntType extends NumericalType {
      constructor() {
        super("BigUint", 0, false);
      }
      getClassName() {
        return _BigUIntType.ClassName;
      }
    };
    exports2.BigUIntType = BigUIntType2;
    BigUIntType2.ClassName = "BigUIntType";
    var BigIntType = class _BigIntType extends NumericalType {
      constructor() {
        super("Bigint", 0, true);
      }
      getClassName() {
        return _BigIntType.ClassName;
      }
    };
    exports2.BigIntType = BigIntType;
    BigIntType.ClassName = "BigIntType";
    var NumericalValue = class _NumericalValue extends types_1.PrimitiveValue {
      constructor(type, value) {
        super(type);
        if (typeof value === "bigint") {
          value = value.toString();
        }
        this.value = new bignumber_js_1.default(value);
        this.sizeInBytes = type.sizeInBytes;
        this.withSign = type.withSign;
        if (this.value.isNaN()) {
          throw new errors.ErrInvalidArgument(`not a number: ${value}`);
        }
        if (!this.withSign && this.value.isNegative()) {
          throw new errors.ErrInvalidArgument(`negative, but type is unsigned: ${value}`);
        }
      }
      getClassName() {
        return _NumericalValue.ClassName;
      }
      /**
       * Returns whether two objects have the same value.
       *
       * @param other another NumericalValue
       */
      equals(other) {
        return this.value.isEqualTo(other.value);
      }
      valueOf() {
        return this.value;
      }
      toString() {
        return this.value.toString();
      }
    };
    exports2.NumericalValue = NumericalValue;
    NumericalValue.ClassName = "NumericalValue";
    var U8Value2 = class _U8Value extends NumericalValue {
      constructor(value) {
        super(new U8Type2(), value);
      }
      getClassName() {
        return _U8Value.ClassName;
      }
    };
    exports2.U8Value = U8Value2;
    U8Value2.ClassName = "U8Value";
    var I8Value = class _I8Value extends NumericalValue {
      constructor(value) {
        super(new I8Type(), value);
      }
      getClassName() {
        return _I8Value.ClassName;
      }
    };
    exports2.I8Value = I8Value;
    I8Value.ClassName = "I8Value";
    var U16Value2 = class _U16Value extends NumericalValue {
      constructor(value) {
        super(new U16Type2(), value);
      }
      getClassName() {
        return _U16Value.ClassName;
      }
    };
    exports2.U16Value = U16Value2;
    U16Value2.ClassName = "U16Value";
    var I16Value = class _I16Value extends NumericalValue {
      constructor(value) {
        super(new I16Type(), value);
      }
      getClassName() {
        return _I16Value.ClassName;
      }
    };
    exports2.I16Value = I16Value;
    I16Value.ClassName = "I16Value";
    var U32Value2 = class _U32Value extends NumericalValue {
      constructor(value) {
        super(new U32Type2(), value);
      }
      getClassName() {
        return _U32Value.ClassName;
      }
    };
    exports2.U32Value = U32Value2;
    U32Value2.ClassName = "U32Value";
    var I32Value = class _I32Value extends NumericalValue {
      constructor(value) {
        super(new I32Type(), value);
      }
      getClassName() {
        return _I32Value.ClassName;
      }
    };
    exports2.I32Value = I32Value;
    I32Value.ClassName = "I32Value";
    var U64Value2 = class _U64Value extends NumericalValue {
      constructor(value) {
        super(new U64Type2(), value);
      }
      getClassName() {
        return _U64Value.ClassName;
      }
    };
    exports2.U64Value = U64Value2;
    U64Value2.ClassName = "U64Value";
    var I64Value = class _I64Value extends NumericalValue {
      constructor(value) {
        super(new I64Type(), value);
      }
      getClassName() {
        return _I64Value.ClassName;
      }
    };
    exports2.I64Value = I64Value;
    I64Value.ClassName = "I64Value";
    var BigUIntValue2 = class _BigUIntValue extends NumericalValue {
      constructor(value) {
        super(new BigUIntType2(), value);
      }
      getClassName() {
        return _BigUIntValue.ClassName;
      }
    };
    exports2.BigUIntValue = BigUIntValue2;
    BigUIntValue2.ClassName = "BigUIntValue";
    var BigIntValue = class _BigIntValue extends NumericalValue {
      constructor(value) {
        super(new BigIntType(), value);
      }
      getClassName() {
        return _BigIntValue.ClassName;
      }
    };
    exports2.BigIntValue = BigIntValue;
    BigIntValue.ClassName = "BigIntValue";
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/string.js
var require_string = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/string.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StringValue = exports2.StringType = void 0;
    var types_1 = require_types();
    var StringType = class _StringType extends types_1.PrimitiveType {
      constructor() {
        super("utf-8 string");
      }
      getClassName() {
        return _StringType.ClassName;
      }
    };
    exports2.StringType = StringType;
    StringType.ClassName = "StringType";
    var StringValue = class _StringValue extends types_1.PrimitiveValue {
      constructor(value) {
        super(new StringType());
        this.value = value;
      }
      getClassName() {
        return _StringValue.ClassName;
      }
      /**
       * Creates a StringValue from a utf-8 string.
       */
      static fromUTF8(value) {
        return new _StringValue(value);
      }
      /**
       * Creates a StringValue from a hex-encoded string.
       */
      static fromHex(value) {
        let decodedValue = import_buffer.Buffer.from(value, "hex").toString();
        return new _StringValue(decodedValue);
      }
      getLength() {
        return this.value.length;
      }
      /**
       * Returns whether two objects have the same value.
       */
      equals(other) {
        return this.value === other.value;
      }
      valueOf() {
        return this.value;
      }
    };
    exports2.StringValue = StringValue;
    StringValue.ClassName = "StringValue";
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/tokenIdentifier.js
var require_tokenIdentifier = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/tokenIdentifier.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TokenIdentifierValue = exports2.TokenIdentifierType = void 0;
    var types_1 = require_types();
    var EGLDTokenIdentifier = "EGLD";
    var TokenIdentifierType = class _TokenIdentifierType extends types_1.PrimitiveType {
      constructor() {
        super("TokenIdentifier");
      }
      getClassName() {
        return _TokenIdentifierType.ClassName;
      }
    };
    exports2.TokenIdentifierType = TokenIdentifierType;
    TokenIdentifierType.ClassName = "TokenIdentifierType";
    var TokenIdentifierValue = class _TokenIdentifierValue extends types_1.PrimitiveValue {
      constructor(value) {
        super(new TokenIdentifierType());
        this.value = value;
      }
      static egld() {
        return new _TokenIdentifierValue(EGLDTokenIdentifier);
      }
      static esdtTokenIdentifier(identifier) {
        return new _TokenIdentifierValue(identifier);
      }
      getClassName() {
        return _TokenIdentifierValue.ClassName;
      }
      getLength() {
        return this.value.length;
      }
      /**
       * Returns whether two objects have the same value.
       */
      equals(other) {
        if (this.getLength() != other.getLength()) {
          return false;
        }
        return this.value == other.value;
      }
      valueOf() {
        return this.value;
      }
      toString() {
        return this.value.toString();
      }
    };
    exports2.TokenIdentifierValue = TokenIdentifierValue;
    TokenIdentifierValue.ClassName = "TokenIdentifierValue";
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/tuple.js
var require_tuple = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/tuple.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k4 in mod2)
          if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k4))
            __createBinding2(result, mod2, k4);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Tuple = exports2.TupleType = void 0;
    var errors = __importStar2(require_errors());
    var fields_1 = require_fields();
    var struct_1 = require_struct();
    var TupleType = class _TupleType extends struct_1.StructType {
      constructor(...typeParameters) {
        super(_TupleType.prepareName(typeParameters), _TupleType.prepareFieldDefinitions(typeParameters));
      }
      getClassName() {
        return _TupleType.ClassName;
      }
      static prepareName(typeParameters) {
        let fields = typeParameters.map((type) => type.toString()).join(", ");
        let result = `tuple<${fields}>`;
        return result;
      }
      static prepareFieldDefinitions(typeParameters) {
        let result = typeParameters.map((type, i2) => new fields_1.FieldDefinition(prepareFieldName(i2), "anonymous tuple field", type));
        return result;
      }
    };
    exports2.TupleType = TupleType;
    TupleType.ClassName = "TupleType";
    function prepareFieldName(fieldIndex) {
      return `field${fieldIndex}`;
    }
    var Tuple = class _Tuple extends struct_1.Struct {
      constructor(type, fields) {
        super(type, fields);
      }
      getClassName() {
        return _Tuple.ClassName;
      }
      static fromItems(items) {
        if (items.length < 1) {
          throw new errors.ErrTypingSystem("bad tuple items");
        }
        let fieldsTypes = items.map((item) => item.getType());
        let tupleType = new TupleType(...fieldsTypes);
        let fields = items.map((item, i2) => new fields_1.Field(item, prepareFieldName(i2)));
        return new _Tuple(tupleType, fields);
      }
    };
    exports2.Tuple = Tuple;
    Tuple.ClassName = "Tuple";
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/variadic.js
var require_variadic = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/variadic.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VariadicValue = exports2.CountedVariadicType = exports2.VariadicType = void 0;
    var types_1 = require_types();
    var VariadicType = class _VariadicType extends types_1.Type {
      constructor(typeParameter, isCounted = false) {
        super("Variadic", [typeParameter], types_1.TypeCardinality.variable());
        this.isCounted = isCounted;
      }
      getClassName() {
        return _VariadicType.ClassName;
      }
    };
    exports2.VariadicType = VariadicType;
    VariadicType.ClassName = "VariadicType";
    var CountedVariadicType = class extends types_1.Type {
      constructor(typeParameter) {
        super("Variadic", [typeParameter], types_1.TypeCardinality.variable());
      }
      getClassName() {
        return VariadicType.ClassName;
      }
    };
    exports2.CountedVariadicType = CountedVariadicType;
    CountedVariadicType.ClassName = "VariadicType";
    var VariadicValue = class _VariadicValue extends types_1.TypedValue {
      /**
       *
       * @param type the type of this TypedValue (an instance of VariadicType), not the type parameter of the VariadicType
       * @param items the items, having the type type.getFirstTypeParameter()
       */
      constructor(type, items) {
        super(type);
        this.items = items;
      }
      getClassName() {
        return _VariadicValue.ClassName;
      }
      static fromItems(...items) {
        return this.createFromItems(items, false);
      }
      static fromItemsCounted(...items) {
        return this.createFromItems(items, true);
      }
      static createFromItems(items, isCounted) {
        if (items.length == 0) {
          return new _VariadicValue(new VariadicType(new types_1.TypePlaceholder(), isCounted), []);
        }
        const typeParameter = items[0].getType();
        return new _VariadicValue(new VariadicType(typeParameter, isCounted), items);
      }
      getItems() {
        return this.items;
      }
      valueOf() {
        return this.items.map((item) => item.valueOf());
      }
      equals(other) {
        if (this.getType().differs(other.getType())) {
          return false;
        }
        for (let i2 = 0; i2 < this.items.length; i2++) {
          let selfItem = this.items[i2];
          let otherItem = other.items[i2];
          if (!selfItem.equals(otherItem)) {
            return false;
          }
        }
        return true;
      }
    };
    exports2.VariadicValue = VariadicValue;
    VariadicValue.ClassName = "VariadicValue";
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/typeMapper.js
var require_typeMapper = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/typeMapper.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k4 in mod2)
          if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k4))
            __createBinding2(result, mod2, k4);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeMapper = void 0;
    var errors = __importStar2(require_errors());
    var address_1 = require_address2();
    var algebraic_1 = require_algebraic();
    var boolean_1 = require_boolean();
    var bytes_1 = require_bytes();
    var codeMetadata_1 = require_codeMetadata();
    var composite_1 = require_composite();
    var enum_1 = require_enum();
    var fields_1 = require_fields();
    var generic_1 = require_generic();
    var genericArray_1 = require_genericArray();
    var h256_1 = require_h256();
    var nothing_1 = require_nothing();
    var numerical_1 = require_numerical();
    var string_1 = require_string();
    var struct_1 = require_struct();
    var tokenIdentifier_1 = require_tokenIdentifier();
    var tuple_1 = require_tuple();
    var variadic_1 = require_variadic();
    var TypeMapper = class {
      constructor(learnedTypes = []) {
        this.openTypesFactories = /* @__PURE__ */ new Map([
          ["Option", (...typeParameters) => new generic_1.OptionType(typeParameters[0])],
          ["List", (...typeParameters) => new generic_1.ListType(typeParameters[0])],
          // For the following open generics, we use a slightly different typing than the one defined by mx-sdk-rs (temporary workaround).
          ["VarArgs", (...typeParameters) => new variadic_1.VariadicType(typeParameters[0])],
          ["MultiResultVec", (...typeParameters) => new variadic_1.VariadicType(typeParameters[0])],
          ["variadic", (...typeParameters) => new variadic_1.VariadicType(typeParameters[0])],
          ["counted-variadic", (...typeParameters) => new variadic_1.VariadicType(typeParameters[0], true)],
          ["OptionalArg", (...typeParameters) => new algebraic_1.OptionalType(typeParameters[0])],
          ["optional", (...typeParameters) => new algebraic_1.OptionalType(typeParameters[0])],
          ["OptionalResult", (...typeParameters) => new algebraic_1.OptionalType(typeParameters[0])],
          ["multi", (...typeParameters) => new composite_1.CompositeType(...typeParameters)],
          ["MultiArg", (...typeParameters) => new composite_1.CompositeType(...typeParameters)],
          ["MultiResult", (...typeParameters) => new composite_1.CompositeType(...typeParameters)],
          ["multi", (...typeParameters) => new composite_1.CompositeType(...typeParameters)],
          // Perhaps we can adjust the ABI generator to only output "tuple", instead of "tupleN"?
          ["tuple", (...typeParameters) => new tuple_1.TupleType(...typeParameters)],
          ["tuple2", (...typeParameters) => new tuple_1.TupleType(...typeParameters)],
          ["tuple3", (...typeParameters) => new tuple_1.TupleType(...typeParameters)],
          ["tuple4", (...typeParameters) => new tuple_1.TupleType(...typeParameters)],
          ["tuple5", (...typeParameters) => new tuple_1.TupleType(...typeParameters)],
          ["tuple6", (...typeParameters) => new tuple_1.TupleType(...typeParameters)],
          ["tuple7", (...typeParameters) => new tuple_1.TupleType(...typeParameters)],
          ["tuple8", (...typeParameters) => new tuple_1.TupleType(...typeParameters)],
          // Known-length arrays.
          // TODO: Handle these in typeExpressionParser!
          ["array2", (...typeParameters) => new genericArray_1.ArrayVecType(2, typeParameters[0])],
          ["array8", (...typeParameters) => new genericArray_1.ArrayVecType(8, typeParameters[0])],
          ["array16", (...typeParameters) => new genericArray_1.ArrayVecType(16, typeParameters[0])],
          ["array20", (...typeParameters) => new genericArray_1.ArrayVecType(20, typeParameters[0])],
          ["array32", (...typeParameters) => new genericArray_1.ArrayVecType(32, typeParameters[0])],
          ["array46", (...typeParameters) => new genericArray_1.ArrayVecType(46, typeParameters[0])],
          ["array48", (...typeParameters) => new genericArray_1.ArrayVecType(48, typeParameters[0])],
          ["array64", (...typeParameters) => new genericArray_1.ArrayVecType(64, typeParameters[0])],
          ["array128", (...typeParameters) => new genericArray_1.ArrayVecType(128, typeParameters[0])],
          ["array256", (...typeParameters) => new genericArray_1.ArrayVecType(256, typeParameters[0])]
        ]);
        this.closedTypesMap = /* @__PURE__ */ new Map([
          ["u8", new numerical_1.U8Type()],
          ["u16", new numerical_1.U16Type()],
          ["u32", new numerical_1.U32Type()],
          ["u64", new numerical_1.U64Type()],
          ["U64", new numerical_1.U64Type()],
          ["BigUint", new numerical_1.BigUIntType()],
          ["i8", new numerical_1.I8Type()],
          ["i16", new numerical_1.I16Type()],
          ["i32", new numerical_1.I32Type()],
          ["i64", new numerical_1.I64Type()],
          ["Bigint", new numerical_1.BigIntType()],
          ["BigInt", new numerical_1.BigIntType()],
          ["bool", new boolean_1.BooleanType()],
          ["bytes", new bytes_1.BytesType()],
          ["Address", new address_1.AddressType()],
          ["H256", new h256_1.H256Type()],
          ["utf-8 string", new string_1.StringType()],
          ["TokenIdentifier", new tokenIdentifier_1.TokenIdentifierType()],
          ["EgldOrEsdtTokenIdentifier", new tokenIdentifier_1.TokenIdentifierType()],
          ["CodeMetadata", new codeMetadata_1.CodeMetadataType()],
          ["nothing", new nothing_1.NothingType()],
          ["AsyncCall", new nothing_1.NothingType()]
        ]);
        this.learnedTypesMap = /* @__PURE__ */ new Map();
        for (const type of learnedTypes) {
          this.learnedTypesMap.set(type.getName(), type);
        }
      }
      /**
       * Maps a "raw type" object to a "known (specific) type" object.
       * In the process, it also learns the new type.
       * Can only map types if their dependencies were previously learned (through mapping).
       */
      mapType(type) {
        let mappedType = this.mapTypeRecursively(type);
        if (mappedType) {
          if (!mappedType.isGenericType()) {
            this.learnType(mappedType);
          }
          return mappedType;
        }
        throw new errors.ErrTypingSystem(`Cannot map the type "${type.getName()}" to a known type`);
      }
      mapTypeRecursively(type) {
        let isGeneric = type.isGenericType();
        let previouslyLearnedType = this.learnedTypesMap.get(type.getName());
        if (previouslyLearnedType) {
          return previouslyLearnedType;
        }
        let knownClosedType = this.closedTypesMap.get(type.getName());
        if (knownClosedType) {
          return knownClosedType;
        }
        if (type.hasExactClass(enum_1.EnumType.ClassName)) {
          return this.mapEnumType(type);
        }
        if (type.hasExactClass(struct_1.StructType.ClassName)) {
          return this.mapStructType(type);
        }
        if (isGeneric) {
          return this.mapGenericType(type);
        }
        return null;
      }
      learnType(type) {
        this.learnedTypesMap.delete(type.getName());
        this.learnedTypesMap.set(type.getName(), type);
      }
      mapStructType(type) {
        let mappedFields = this.mappedFields(type.getFieldsDefinitions());
        let mappedStruct = new struct_1.StructType(type.getName(), mappedFields);
        return mappedStruct;
      }
      mapEnumType(type) {
        let variants = type.variants.map((variant) => new enum_1.EnumVariantDefinition(variant.name, variant.discriminant, this.mappedFields(variant.getFieldsDefinitions())));
        let mappedEnum = new enum_1.EnumType(type.getName(), variants);
        return mappedEnum;
      }
      mappedFields(definitions) {
        return definitions.map((definition) => new fields_1.FieldDefinition(definition.name, definition.description, this.mapType(definition.type)));
      }
      mapGenericType(type) {
        let typeParameters = type.getTypeParameters();
        let mappedTypeParameters = typeParameters.map((item) => this.mapType(item));
        let factory = this.openTypesFactories.get(type.getName());
        if (!factory) {
          throw new errors.ErrTypingSystem(`Cannot map the generic type "${type.getName()}" to a known type`);
        }
        return factory(...mappedTypeParameters);
      }
    };
    exports2.TypeMapper = TypeMapper;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/abiRegistry.js
var require_abiRegistry = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/abiRegistry.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k4 in mod2)
          if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k4))
            __createBinding2(result, mod2, k4);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbiRegistry = void 0;
    var errors = __importStar2(require_errors());
    var utils_1 = require_utils2();
    var endpoint_1 = require_endpoint();
    var enum_1 = require_enum();
    var event_1 = require_event();
    var struct_1 = require_struct();
    var typeMapper_1 = require_typeMapper();
    var interfaceNamePlaceholder = "?";
    var AbiRegistry = class _AbiRegistry {
      constructor(options) {
        this.endpoints = [];
        this.customTypes = [];
        this.events = [];
        this.name = options.name;
        this.constructorDefinition = options.constructorDefinition;
        this.endpoints = options.endpoints;
        this.customTypes = options.customTypes;
        this.events = options.events || [];
      }
      static create(options) {
        const name2 = options.name || interfaceNamePlaceholder;
        const constructor = options.constructor || {};
        const endpoints = options.endpoints || [];
        const types = options.types || {};
        const events = options.events || [];
        const constructorDefinition = endpoint_1.EndpointDefinition.fromJSON({ name: "constructor", ...constructor });
        const endpointDefinitions = endpoints.map((item) => endpoint_1.EndpointDefinition.fromJSON(item));
        const customTypes = [];
        for (const customTypeName in types) {
          const typeDefinition = types[customTypeName];
          if (typeDefinition.type == "struct") {
            customTypes.push(struct_1.StructType.fromJSON({ name: customTypeName, fields: typeDefinition.fields }));
          } else if (typeDefinition.type == "enum" || typeDefinition.type == "explicit-enum") {
            customTypes.push(enum_1.EnumType.fromJSON({ name: customTypeName, variants: typeDefinition.variants }));
          } else {
            throw new errors.ErrTypingSystem(`Cannot handle custom type: ${customTypeName}`);
          }
        }
        const eventDefinitions = events.map((item) => event_1.EventDefinition.fromJSON(item));
        const registry = new _AbiRegistry({
          name: name2,
          constructorDefinition,
          endpoints: endpointDefinitions,
          customTypes,
          events: eventDefinitions
        });
        const remappedRegistry = registry.remapToKnownTypes();
        return remappedRegistry;
      }
      getCustomType(name2) {
        const result = this.customTypes.find((e2) => e2.getName() == name2);
        utils_1.guardValueIsSetWithMessage(`custom type [${name2}] not found`, result);
        return result;
      }
      getStruct(name2) {
        const result = this.customTypes.find((e2) => e2.getName() == name2 && e2.hasExactClass(struct_1.StructType.ClassName));
        utils_1.guardValueIsSetWithMessage(`struct [${name2}] not found`, result);
        return result;
      }
      getStructs(names) {
        return names.map((name2) => this.getStruct(name2));
      }
      getEnum(name2) {
        const result = this.customTypes.find((e2) => e2.getName() == name2 && e2.hasExactClass(enum_1.EnumType.ClassName));
        utils_1.guardValueIsSetWithMessage(`enum [${name2}] not found`, result);
        return result;
      }
      getEnums(names) {
        return names.map((name2) => this.getEnum(name2));
      }
      getEndpoints() {
        return this.endpoints;
      }
      getEndpoint(name2) {
        const result = this.endpoints.find((e2) => e2.name == name2);
        utils_1.guardValueIsSetWithMessage(`endpoint [${name2}] not found`, result);
        return result;
      }
      getEvent(name2) {
        const result = this.events.find((e2) => e2.identifier == name2);
        utils_1.guardValueIsSetWithMessage(`event [${name2}] not found`, result);
        return result;
      }
      /**
       * Right after loading ABI definitions into a registry, the endpoints and the custom types (structs, enums)
       * use raw types for their I/O parameters (in the case of endpoints), or for their fields (in the case of structs).
       *
       * A raw type is merely an instance of {@link Type}, with a given name and type parameters (if it's a generic type).
       *
       * Though, for most (development) purposes, we'd like to operate using known, specific types (e.g. {@link List}, {@link U8Type} etc.).
       * This function increases the specificity of the types used by parameter / field definitions within a registry (on best-efforts basis).
       * The result is an equivalent, more explicit ABI registry.
       */
      remapToKnownTypes() {
        const mapper = new typeMapper_1.TypeMapper([]);
        const newCustomTypes = [];
        for (const type of this.customTypes) {
          this.mapCustomTypeDepthFirst(type, this.customTypes, mapper, newCustomTypes);
        }
        if (this.customTypes.length != newCustomTypes.length) {
          throw new errors.ErrTypingSystem("Did not re-map all custom types");
        }
        const newConstructor = mapEndpoint(this.constructorDefinition, mapper);
        const newEndpoints = [];
        for (const endpoint of this.endpoints) {
          newEndpoints.push(mapEndpoint(endpoint, mapper));
        }
        const newEvents = this.events.map((event) => mapEvent(event, mapper));
        const newRegistry = new _AbiRegistry({
          name: this.name,
          constructorDefinition: newConstructor,
          endpoints: newEndpoints,
          customTypes: newCustomTypes,
          events: newEvents
        });
        return newRegistry;
      }
      mapCustomTypeDepthFirst(typeToMap, allTypesToMap, mapper, mappedTypes) {
        const hasBeenMapped = mappedTypes.findIndex((type) => type.getName() == typeToMap.getName()) >= 0;
        if (hasBeenMapped) {
          return;
        }
        for (const typeName of typeToMap.getNamesOfDependencies()) {
          const dependencyType = allTypesToMap.find((type) => type.getName() == typeName);
          if (!dependencyType) {
            continue;
          }
          this.mapCustomTypeDepthFirst(dependencyType, allTypesToMap, mapper, mappedTypes);
        }
        const mappedType = mapper.mapType(typeToMap);
        mappedTypes.push(mappedType);
      }
    };
    exports2.AbiRegistry = AbiRegistry;
    function mapEndpoint(endpoint, mapper) {
      const newInput = endpoint.input.map((e2) => new endpoint_1.EndpointParameterDefinition(e2.name, e2.description, mapper.mapType(e2.type)));
      const newOutput = endpoint.output.map((e2) => new endpoint_1.EndpointParameterDefinition(e2.name, e2.description, mapper.mapType(e2.type)));
      return new endpoint_1.EndpointDefinition(endpoint.name, newInput, newOutput, endpoint.modifiers);
    }
    function mapEvent(event, mapper) {
      const newInputs = event.inputs.map((e2) => new event_1.EventTopicDefinition({
        name: e2.name,
        type: mapper.mapType(e2.type),
        indexed: e2.indexed
      }));
      return new event_1.EventDefinition(event.identifier, newInputs);
    }
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/factory.js
var require_factory = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/factory.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createListOfTokenIdentifiers = exports2.createListOfAddresses = void 0;
    var address_1 = require_address2();
    var generic_1 = require_generic();
    var tokenIdentifier_1 = require_tokenIdentifier();
    function createListOfAddresses(addresses) {
      let addressesTyped = addresses.map((address) => new address_1.AddressValue(address));
      let list = generic_1.List.fromItems(addressesTyped);
      return list;
    }
    exports2.createListOfAddresses = createListOfAddresses;
    function createListOfTokenIdentifiers(identifiers) {
      let identifiersTyped = identifiers.map((identifier) => new tokenIdentifier_1.TokenIdentifierValue(identifier));
      let list = generic_1.List.fromItems(identifiersTyped);
      return list;
    }
    exports2.createListOfTokenIdentifiers = createListOfTokenIdentifiers;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/matchers.js
var require_matchers = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/matchers.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k4 in mod2)
          if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k4))
            __createBinding2(result, mod2, k4);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.onPrimitiveTypeSelect = exports2.onPrimitiveValueSelect = exports2.onTypedValueSelect = exports2.onTypeSelect = void 0;
    var errors = __importStar2(require_errors());
    var address_1 = require_address2();
    var boolean_1 = require_boolean();
    var bytes_1 = require_bytes();
    var enum_1 = require_enum();
    var generic_1 = require_generic();
    var h256_1 = require_h256();
    var numerical_1 = require_numerical();
    var nothing_1 = require_nothing();
    var struct_1 = require_struct();
    var tokenIdentifier_1 = require_tokenIdentifier();
    var tuple_1 = require_tuple();
    var types_1 = require_types();
    var genericArray_1 = require_genericArray();
    var string_1 = require_string();
    function onTypeSelect(type, selectors) {
      if (type.hasExactClass(generic_1.OptionType.ClassName)) {
        return selectors.onOption();
      }
      if (type.hasExactClass(generic_1.ListType.ClassName)) {
        return selectors.onList();
      }
      if (type.hasExactClass(genericArray_1.ArrayVecType.ClassName)) {
        return selectors.onArray();
      }
      if (type.hasClassOrSuperclass(types_1.PrimitiveType.ClassName)) {
        return selectors.onPrimitive();
      }
      if (type.hasExactClass(struct_1.StructType.ClassName)) {
        return selectors.onStruct();
      }
      if (type.hasExactClass(tuple_1.TupleType.ClassName)) {
        return selectors.onTuple();
      }
      if (type.hasExactClass(enum_1.EnumType.ClassName)) {
        return selectors.onEnum();
      }
      if (selectors.onOther) {
        return selectors.onOther();
      }
      throw new errors.ErrTypingSystem(`type isn't known: ${type}`);
    }
    exports2.onTypeSelect = onTypeSelect;
    function onTypedValueSelect(value, selectors) {
      if (value.hasClassOrSuperclass(types_1.PrimitiveValue.ClassName)) {
        return selectors.onPrimitive();
      }
      if (value.hasExactClass(generic_1.OptionValue.ClassName)) {
        return selectors.onOption();
      }
      if (value.hasExactClass(generic_1.List.ClassName)) {
        return selectors.onList();
      }
      if (value.hasExactClass(genericArray_1.ArrayVec.ClassName)) {
        return selectors.onArray();
      }
      if (value.hasExactClass(struct_1.Struct.ClassName)) {
        return selectors.onStruct();
      }
      if (value.hasExactClass(tuple_1.Tuple.ClassName)) {
        return selectors.onTuple();
      }
      if (value.hasExactClass(enum_1.EnumValue.ClassName)) {
        return selectors.onEnum();
      }
      if (selectors.onOther) {
        return selectors.onOther();
      }
      throw new errors.ErrTypingSystem(`value isn't typed: ${value}`);
    }
    exports2.onTypedValueSelect = onTypedValueSelect;
    function onPrimitiveValueSelect(value, selectors) {
      if (value.hasExactClass(boolean_1.BooleanValue.ClassName)) {
        return selectors.onBoolean();
      }
      if (value.hasClassOrSuperclass(numerical_1.NumericalValue.ClassName)) {
        return selectors.onNumerical();
      }
      if (value.hasExactClass(address_1.AddressValue.ClassName)) {
        return selectors.onAddress();
      }
      if (value.hasExactClass(bytes_1.BytesValue.ClassName)) {
        return selectors.onBytes();
      }
      if (value.hasExactClass(string_1.StringValue.ClassName)) {
        return selectors.onString();
      }
      if (value.hasExactClass(h256_1.H256Value.ClassName)) {
        return selectors.onH256();
      }
      if (value.hasExactClass(tokenIdentifier_1.TokenIdentifierValue.ClassName)) {
        return selectors.onTypeIdentifier();
      }
      if (value.hasExactClass(nothing_1.NothingValue.ClassName)) {
        return selectors.onNothing();
      }
      if (selectors.onOther) {
        return selectors.onOther();
      }
      throw new errors.ErrTypingSystem(`value isn't a primitive: ${value.getType()}`);
    }
    exports2.onPrimitiveValueSelect = onPrimitiveValueSelect;
    function onPrimitiveTypeSelect(type, selectors) {
      if (type.hasExactClass(boolean_1.BooleanType.ClassName)) {
        return selectors.onBoolean();
      }
      if (type.hasClassOrSuperclass(numerical_1.NumericalType.ClassName)) {
        return selectors.onNumerical();
      }
      if (type.hasExactClass(address_1.AddressType.ClassName)) {
        return selectors.onAddress();
      }
      if (type.hasExactClass(bytes_1.BytesType.ClassName)) {
        return selectors.onBytes();
      }
      if (type.hasExactClass(string_1.StringType.ClassName)) {
        return selectors.onString();
      }
      if (type.hasExactClass(h256_1.H256Type.ClassName)) {
        return selectors.onH256();
      }
      if (type.hasExactClass(tokenIdentifier_1.TokenIdentifierType.ClassName)) {
        return selectors.onTokenIndetifier();
      }
      if (type.hasExactClass(nothing_1.NothingType.ClassName)) {
        return selectors.onNothing();
      }
      if (selectors.onOther) {
        return selectors.onOther();
      }
      throw new errors.ErrTypingSystem(`type isn't a known primitive: ${type}`);
    }
    exports2.onPrimitiveTypeSelect = onPrimitiveTypeSelect;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/index.js
var require_typesystem = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/typesystem/index.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m3, exports3) {
      for (var p3 in m3)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3))
          __createBinding2(exports3, m3, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_abiRegistry(), exports2);
    __exportStar2(require_address2(), exports2);
    __exportStar2(require_algebraic(), exports2);
    __exportStar2(require_boolean(), exports2);
    __exportStar2(require_bytes(), exports2);
    __exportStar2(require_composite(), exports2);
    __exportStar2(require_endpoint(), exports2);
    __exportStar2(require_enum(), exports2);
    __exportStar2(require_factory(), exports2);
    __exportStar2(require_fields(), exports2);
    __exportStar2(require_generic(), exports2);
    __exportStar2(require_genericArray(), exports2);
    __exportStar2(require_h256(), exports2);
    __exportStar2(require_matchers(), exports2);
    __exportStar2(require_nothing(), exports2);
    __exportStar2(require_numerical(), exports2);
    __exportStar2(require_string(), exports2);
    __exportStar2(require_struct(), exports2);
    __exportStar2(require_tokenIdentifier(), exports2);
    __exportStar2(require_tuple(), exports2);
    __exportStar2(require_typeExpressionParser(), exports2);
    __exportStar2(require_typeMapper(), exports2);
    __exportStar2(require_types(), exports2);
    __exportStar2(require_variadic(), exports2);
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/codec/option.js
var require_option = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/codec/option.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k4 in mod2)
          if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k4))
            __createBinding2(result, mod2, k4);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OptionValueBinaryCodec = void 0;
    var errors = __importStar2(require_errors());
    var typesystem_1 = require_typesystem();
    var OptionValueBinaryCodec = class {
      constructor(binaryCodec) {
        this.binaryCodec = binaryCodec;
      }
      decodeNested(buffer, type) {
        if (buffer[0] == 0) {
          return [typesystem_1.OptionValue.newMissingTyped(type), 1];
        }
        if (buffer[0] != 1) {
          throw new errors.ErrCodec("invalid buffer for optional value");
        }
        let [decoded, decodedLength] = this.binaryCodec.decodeNested(buffer.slice(1), type);
        return [typesystem_1.OptionValue.newProvided(decoded), decodedLength + 1];
      }
      decodeTopLevel(buffer, type) {
        if (buffer.length == 0) {
          return new typesystem_1.OptionValue(type);
        }
        if (buffer[0] != 1) {
          throw new errors.ErrCodec("invalid buffer for optional value");
        }
        let [decoded, _decodedLength] = this.binaryCodec.decodeNested(buffer.slice(1), type);
        return new typesystem_1.OptionValue(type, decoded);
      }
      encodeNested(optionValue) {
        if (optionValue.isSet()) {
          return import_buffer.Buffer.concat([import_buffer.Buffer.from([1]), this.binaryCodec.encodeNested(optionValue.getTypedValue())]);
        }
        return import_buffer.Buffer.from([0]);
      }
      encodeTopLevel(optionValue) {
        if (optionValue.isSet()) {
          return import_buffer.Buffer.concat([import_buffer.Buffer.from([1]), this.binaryCodec.encodeNested(optionValue.getTypedValue())]);
        }
        return import_buffer.Buffer.from([]);
      }
    };
    exports2.OptionValueBinaryCodec = OptionValueBinaryCodec;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/codec/address.js
var require_address3 = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/codec/address.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AddressBinaryCodec = void 0;
    var address_1 = require_address();
    var typesystem_1 = require_typesystem();
    var AddressBinaryCodec = class {
      /**
       * Reads and decodes an AddressValue from a given buffer.
       *
       * @param buffer the input buffer
       */
      decodeNested(buffer) {
        let slice = buffer.slice(0, 32);
        let value = new address_1.Address(slice);
        return [new typesystem_1.AddressValue(value), 32];
      }
      /**
       * Reads and decodes an AddressValue from a given buffer.
       *
       * @param buffer the input buffer
       */
      decodeTopLevel(buffer) {
        let [decoded, _length] = this.decodeNested(buffer);
        return decoded;
      }
      /**
       * Encodes an AddressValue to a buffer.
       */
      encodeNested(primitive) {
        return primitive.valueOf().pubkey();
      }
      /**
       * Encodes an AddressValue to a buffer.
       */
      encodeTopLevel(primitive) {
        return primitive.valueOf().pubkey();
      }
    };
    exports2.AddressBinaryCodec = AddressBinaryCodec;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/codec/boolean.js
var require_boolean2 = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/codec/boolean.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k4 in mod2)
          if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k4))
            __createBinding2(result, mod2, k4);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BooleanBinaryCodec = void 0;
    var errors = __importStar2(require_errors());
    var typesystem_1 = require_typesystem();
    var BooleanBinaryCodec = class _BooleanBinaryCodec {
      decodeNested(buffer) {
        let byte = buffer.readUInt8(0);
        return [new typesystem_1.BooleanValue(byte == _BooleanBinaryCodec.TRUE), 1];
      }
      decodeTopLevel(buffer) {
        if (buffer.length > 1) {
          throw new errors.ErrInvalidArgument("buffer should be of size <= 1");
        }
        let firstByte = buffer[0];
        return new typesystem_1.BooleanValue(firstByte == _BooleanBinaryCodec.TRUE);
      }
      encodeNested(primitive) {
        if (primitive.isTrue()) {
          return import_buffer.Buffer.from([_BooleanBinaryCodec.TRUE]);
        }
        return import_buffer.Buffer.from([_BooleanBinaryCodec.FALSE]);
      }
      encodeTopLevel(primitive) {
        if (primitive.isTrue()) {
          return import_buffer.Buffer.from([_BooleanBinaryCodec.TRUE]);
        }
        return import_buffer.Buffer.from([]);
      }
    };
    exports2.BooleanBinaryCodec = BooleanBinaryCodec;
    BooleanBinaryCodec.TRUE = 1;
    BooleanBinaryCodec.FALSE = 0;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/codec/constants.js
var require_constants2 = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/codec/constants.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SizeOfU32 = void 0;
    exports2.SizeOfU32 = 4;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/codec/numerical.js
var require_numerical2 = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/codec/numerical.js"(exports2) {
    "use strict";
    init_shim();
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NumericalBinaryCodec = void 0;
    var bignumber_js_1 = __importDefault2(require_bignumber());
    var typesystem_1 = require_typesystem();
    var constants_1 = require_constants2();
    var utils_1 = require_utils();
    var NumericalBinaryCodec = class {
      decodeNested(buffer, type) {
        let offset = 0;
        let length2 = type.sizeInBytes;
        if (!length2) {
          offset = constants_1.SizeOfU32;
          length2 = buffer.readUInt32BE(0);
        }
        let payload = buffer.slice(offset, offset + length2);
        let result = this.decodeTopLevel(payload, type);
        let decodedLength = length2 + offset;
        return [result, decodedLength];
      }
      decodeTopLevel(buffer, type) {
        let payload = utils_1.cloneBuffer(buffer);
        let empty2 = buffer.length == 0;
        if (empty2) {
          return new typesystem_1.NumericalValue(type, new bignumber_js_1.default(0));
        }
        let isPositive = !type.withSign || utils_1.isMsbZero(payload);
        if (isPositive) {
          let value2 = utils_1.bufferToBigInt(payload);
          return new typesystem_1.NumericalValue(type, value2);
        }
        utils_1.flipBufferBitsInPlace(payload);
        let value = utils_1.bufferToBigInt(payload);
        let negativeValue = value.multipliedBy(new bignumber_js_1.default(-1));
        let negativeValueMinusOne = negativeValue.minus(new bignumber_js_1.default(1));
        return new typesystem_1.NumericalValue(type, negativeValueMinusOne);
      }
      encodeNested(primitive) {
        if (primitive.sizeInBytes) {
          return this.encodeNestedFixedSize(primitive, primitive.sizeInBytes);
        }
        let buffer = this.encodeTopLevel(primitive);
        let length2 = import_buffer.Buffer.alloc(constants_1.SizeOfU32);
        length2.writeUInt32BE(buffer.length);
        return import_buffer.Buffer.concat([length2, buffer]);
      }
      encodeNestedFixedSize(primitive, size) {
        if (primitive.value.isZero()) {
          return import_buffer.Buffer.alloc(size, 0);
        }
        if (!primitive.withSign) {
          const buffer2 = utils_1.bigIntToBuffer(primitive.value);
          const paddingBytes2 = import_buffer.Buffer.alloc(size - buffer2.length, 0);
          return import_buffer.Buffer.concat([paddingBytes2, buffer2]);
        }
        if (primitive.value.isPositive()) {
          let buffer2 = utils_1.bigIntToBuffer(primitive.value);
          if (utils_1.isMsbOne(buffer2)) {
            buffer2 = utils_1.prependByteToBuffer(buffer2, 0);
          }
          const paddingBytes2 = import_buffer.Buffer.alloc(size - buffer2.length, 0);
          return import_buffer.Buffer.concat([paddingBytes2, buffer2]);
        }
        let valuePlusOne = primitive.value.plus(new bignumber_js_1.default(1));
        let buffer = utils_1.bigIntToBuffer(valuePlusOne);
        utils_1.flipBufferBitsInPlace(buffer);
        if (utils_1.isMsbZero(buffer)) {
          buffer = utils_1.prependByteToBuffer(buffer, 255);
        }
        const paddingBytes = import_buffer.Buffer.alloc(size - buffer.length, 255);
        return import_buffer.Buffer.concat([paddingBytes, buffer]);
      }
      encodeTopLevel(primitive) {
        let withSign = primitive.withSign;
        if (primitive.value.isZero()) {
          return import_buffer.Buffer.alloc(0);
        }
        if (!withSign) {
          return utils_1.bigIntToBuffer(primitive.value);
        }
        return this.encodePrimitive(primitive);
      }
      encodePrimitive(primitive) {
        if (primitive.value.isPositive()) {
          let buffer2 = utils_1.bigIntToBuffer(primitive.value);
          if (utils_1.isMsbOne(buffer2)) {
            buffer2 = utils_1.prependByteToBuffer(buffer2, 0);
          }
          return buffer2;
        }
        let valuePlusOne = primitive.value.plus(new bignumber_js_1.default(1));
        let buffer = utils_1.bigIntToBuffer(valuePlusOne);
        utils_1.flipBufferBitsInPlace(buffer);
        if (utils_1.isMsbZero(buffer)) {
          buffer = utils_1.prependByteToBuffer(buffer, 255);
        }
        return buffer;
      }
    };
    exports2.NumericalBinaryCodec = NumericalBinaryCodec;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/codec/h256.js
var require_h2562 = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/codec/h256.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.H256BinaryCodec = void 0;
    var h256_1 = require_h256();
    var H256BinaryCodec = class {
      /**
       * Reads and decodes a H256Value from a given buffer.
       *
       * @param buffer the input buffer
       */
      decodeNested(buffer) {
        let slice = buffer.slice(0, 32);
        return [new h256_1.H256Value(slice), 32];
      }
      /**
       * Reads and decodes a H256Value from a given buffer.
       *
       * @param buffer the input buffer
       */
      decodeTopLevel(buffer) {
        let [decoded, _length] = this.decodeNested(buffer);
        return decoded;
      }
      /**
       * Encodes a H256Value to a buffer.
       */
      encodeNested(primitive) {
        return primitive.valueOf();
      }
      /**
       * Encodes a H256Value to a buffer.
       */
      encodeTopLevel(primitive) {
        return primitive.valueOf();
      }
    };
    exports2.H256BinaryCodec = H256BinaryCodec;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/codec/bytes.js
var require_bytes2 = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/codec/bytes.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BytesBinaryCodec = void 0;
    var bytes_1 = require_bytes();
    var constants_1 = require_constants2();
    var BytesBinaryCodec = class {
      decodeNested(buffer) {
        let length2 = buffer.readUInt32BE(0);
        let payload = buffer.slice(constants_1.SizeOfU32, constants_1.SizeOfU32 + length2);
        let result = new bytes_1.BytesValue(payload);
        return [result, constants_1.SizeOfU32 + length2];
      }
      decodeTopLevel(buffer) {
        return new bytes_1.BytesValue(buffer);
      }
      encodeNested(bytes) {
        let lengthBuffer = import_buffer.Buffer.alloc(constants_1.SizeOfU32);
        lengthBuffer.writeUInt32BE(bytes.getLength());
        let buffer = import_buffer.Buffer.concat([lengthBuffer, bytes.valueOf()]);
        return buffer;
      }
      encodeTopLevel(bytes) {
        return bytes.valueOf();
      }
    };
    exports2.BytesBinaryCodec = BytesBinaryCodec;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/codec/tokenIdentifier.js
var require_tokenIdentifier2 = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/codec/tokenIdentifier.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TokenIdentifierCodec = void 0;
    var bytes_1 = require_bytes();
    var tokenIdentifier_1 = require_tokenIdentifier();
    var bytes_2 = require_bytes2();
    var TokenIdentifierCodec = class {
      constructor() {
        this.bytesCodec = new bytes_2.BytesBinaryCodec();
      }
      decodeNested(buffer) {
        let [bytesValue, length2] = this.bytesCodec.decodeNested(buffer);
        return [new tokenIdentifier_1.TokenIdentifierValue(bytesValue.toString()), length2];
      }
      decodeTopLevel(buffer) {
        let bytesValue = this.bytesCodec.decodeTopLevel(buffer);
        return new tokenIdentifier_1.TokenIdentifierValue(bytesValue.toString());
      }
      encodeNested(tokenIdentifier) {
        let bytesValue = bytes_1.BytesValue.fromUTF8(tokenIdentifier.valueOf());
        return this.bytesCodec.encodeNested(bytesValue);
      }
      encodeTopLevel(tokenIdentifier) {
        return import_buffer.Buffer.from(tokenIdentifier.valueOf());
      }
    };
    exports2.TokenIdentifierCodec = TokenIdentifierCodec;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/codec/nothing.js
var require_nothing2 = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/codec/nothing.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NothingCodec = void 0;
    var typesystem_1 = require_typesystem();
    var NothingCodec = class {
      decodeNested() {
        return [new typesystem_1.NothingValue(), 0];
      }
      decodeTopLevel() {
        return new typesystem_1.NothingValue();
      }
      encodeNested() {
        return import_buffer.Buffer.from([]);
      }
      encodeTopLevel() {
        return import_buffer.Buffer.from([]);
      }
    };
    exports2.NothingCodec = NothingCodec;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/codec/string.js
var require_string2 = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/codec/string.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StringBinaryCodec = void 0;
    var typesystem_1 = require_typesystem();
    var bytes_1 = require_bytes();
    var bytes_2 = require_bytes2();
    var StringBinaryCodec = class {
      constructor() {
        this.bytesBinaryCodec = new bytes_2.BytesBinaryCodec();
      }
      decodeNested(buffer) {
        let [decoded, length2] = this.bytesBinaryCodec.decodeNested(buffer);
        let decodedAsString = new typesystem_1.StringValue(decoded.valueOf().toString());
        return [decodedAsString, length2];
      }
      decodeTopLevel(buffer) {
        return new typesystem_1.StringValue(buffer.toString());
      }
      encodeNested(value) {
        let valueAsBytes = bytes_1.BytesValue.fromUTF8(value.valueOf());
        return this.bytesBinaryCodec.encodeNested(valueAsBytes);
      }
      encodeTopLevel(value) {
        return import_buffer.Buffer.from(value.valueOf());
      }
    };
    exports2.StringBinaryCodec = StringBinaryCodec;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/codec/primitive.js
var require_primitive = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/codec/primitive.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PrimitiveBinaryCodec = void 0;
    var typesystem_1 = require_typesystem();
    var address_1 = require_address3();
    var boolean_1 = require_boolean2();
    var numerical_1 = require_numerical2();
    var h256_1 = require_h2562();
    var bytes_1 = require_bytes2();
    var tokenIdentifier_1 = require_tokenIdentifier2();
    var nothing_1 = require_nothing2();
    var string_1 = require_string2();
    var PrimitiveBinaryCodec = class {
      constructor(binaryCodec) {
        this.binaryCodec = binaryCodec;
        this.booleanCodec = new boolean_1.BooleanBinaryCodec();
        this.numericalCodec = new numerical_1.NumericalBinaryCodec();
        this.addressCodec = new address_1.AddressBinaryCodec();
        this.h256Codec = new h256_1.H256BinaryCodec();
        this.bytesCodec = new bytes_1.BytesBinaryCodec();
        this.stringCodec = new string_1.StringBinaryCodec();
        this.tokenIdentifierCodec = new tokenIdentifier_1.TokenIdentifierCodec();
        this.nothingCodec = new nothing_1.NothingCodec();
      }
      decodeNested(buffer, type) {
        return typesystem_1.onPrimitiveTypeSelect(type, {
          onBoolean: () => this.booleanCodec.decodeNested(buffer),
          onNumerical: () => this.numericalCodec.decodeNested(buffer, type),
          onAddress: () => this.addressCodec.decodeNested(buffer),
          onBytes: () => this.bytesCodec.decodeNested(buffer),
          onString: () => this.stringCodec.decodeNested(buffer),
          onH256: () => this.h256Codec.decodeNested(buffer),
          onTokenIndetifier: () => this.tokenIdentifierCodec.decodeNested(buffer),
          onNothing: () => this.nothingCodec.decodeNested()
        });
      }
      decodeTopLevel(buffer, type) {
        return typesystem_1.onPrimitiveTypeSelect(type, {
          onBoolean: () => this.booleanCodec.decodeTopLevel(buffer),
          onNumerical: () => this.numericalCodec.decodeTopLevel(buffer, type),
          onAddress: () => this.addressCodec.decodeTopLevel(buffer),
          onBytes: () => this.bytesCodec.decodeTopLevel(buffer),
          onString: () => this.stringCodec.decodeTopLevel(buffer),
          onH256: () => this.h256Codec.decodeTopLevel(buffer),
          onTokenIndetifier: () => this.tokenIdentifierCodec.decodeTopLevel(buffer),
          onNothing: () => this.nothingCodec.decodeTopLevel()
        });
      }
      encodeNested(value) {
        return typesystem_1.onPrimitiveValueSelect(value, {
          onBoolean: () => this.booleanCodec.encodeNested(value),
          onNumerical: () => this.numericalCodec.encodeNested(value),
          onAddress: () => this.addressCodec.encodeNested(value),
          onBytes: () => this.bytesCodec.encodeNested(value),
          onString: () => this.stringCodec.encodeNested(value),
          onH256: () => this.h256Codec.encodeNested(value),
          onTypeIdentifier: () => this.tokenIdentifierCodec.encodeNested(value),
          onNothing: () => this.nothingCodec.encodeNested()
        });
      }
      encodeTopLevel(value) {
        return typesystem_1.onPrimitiveValueSelect(value, {
          onBoolean: () => this.booleanCodec.encodeTopLevel(value),
          onNumerical: () => this.numericalCodec.encodeTopLevel(value),
          onAddress: () => this.addressCodec.encodeTopLevel(value),
          onBytes: () => this.bytesCodec.encodeTopLevel(value),
          onString: () => this.stringCodec.encodeTopLevel(value),
          onH256: () => this.h256Codec.encodeTopLevel(value),
          onTypeIdentifier: () => this.tokenIdentifierCodec.encodeTopLevel(value),
          onNothing: () => this.nothingCodec.encodeTopLevel()
        });
      }
    };
    exports2.PrimitiveBinaryCodec = PrimitiveBinaryCodec;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/codec/list.js
var require_list = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/codec/list.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ListBinaryCodec = void 0;
    var typesystem_1 = require_typesystem();
    var constants_1 = require_constants2();
    var ListBinaryCodec = class {
      constructor(binaryCodec) {
        this.binaryCodec = binaryCodec;
      }
      decodeNested(buffer, type) {
        let typeParameter = type.getFirstTypeParameter();
        let result = [];
        let numItems = buffer.readUInt32BE(0);
        this.binaryCodec.constraints.checkListLength(numItems);
        let originalBuffer = buffer;
        let offset = constants_1.SizeOfU32;
        buffer = originalBuffer.slice(offset);
        for (let i2 = 0; i2 < numItems; i2++) {
          let [decoded, decodedLength] = this.binaryCodec.decodeNested(buffer, typeParameter);
          result.push(decoded);
          offset += decodedLength;
          buffer = originalBuffer.slice(offset);
        }
        return [new typesystem_1.List(type, result), offset];
      }
      decodeTopLevel(buffer, type) {
        let typeParameter = type.getFirstTypeParameter();
        let result = [];
        let originalBuffer = buffer;
        let offset = 0;
        while (buffer.length > 0) {
          let [decoded, decodedLength] = this.binaryCodec.decodeNested(buffer, typeParameter);
          result.push(decoded);
          offset += decodedLength;
          buffer = originalBuffer.slice(offset);
          this.binaryCodec.constraints.checkListLength(result.length);
        }
        return new typesystem_1.List(type, result);
      }
      encodeNested(list) {
        this.binaryCodec.constraints.checkListLength(list.getLength());
        let lengthBuffer = import_buffer.Buffer.alloc(constants_1.SizeOfU32);
        lengthBuffer.writeUInt32BE(list.getLength());
        let itemsBuffers = [];
        for (const item of list.getItems()) {
          let itemBuffer = this.binaryCodec.encodeNested(item);
          itemsBuffers.push(itemBuffer);
        }
        let buffer = import_buffer.Buffer.concat([lengthBuffer, ...itemsBuffers]);
        return buffer;
      }
      encodeTopLevel(list) {
        this.binaryCodec.constraints.checkListLength(list.getLength());
        let itemsBuffers = [];
        for (const item of list.getItems()) {
          let itemBuffer = this.binaryCodec.encodeNested(item);
          itemsBuffers.push(itemBuffer);
        }
        let buffer = import_buffer.Buffer.concat(itemsBuffers);
        return buffer;
      }
    };
    exports2.ListBinaryCodec = ListBinaryCodec;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/codec/fields.js
var require_fields2 = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/codec/fields.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FieldsBinaryCodec = void 0;
    var typesystem_1 = require_typesystem();
    var FieldsBinaryCodec = class {
      constructor(binaryCodec) {
        this.binaryCodec = binaryCodec;
      }
      decodeNested(buffer, fieldDefinitions) {
        let fields = [];
        let totalLength = 0;
        for (const fieldDefinition of fieldDefinitions) {
          let [decoded, decodedLength] = this.binaryCodec.decodeNested(buffer, fieldDefinition.type);
          buffer = buffer.slice(decodedLength);
          totalLength += decodedLength;
          let field = new typesystem_1.Field(decoded, fieldDefinition.name);
          fields.push(field);
        }
        return [fields, totalLength];
      }
      encodeNested(fields) {
        let buffers = [];
        for (const field of fields) {
          let fieldBuffer = this.binaryCodec.encodeNested(field.value);
          buffers.push(fieldBuffer);
        }
        return import_buffer.Buffer.concat(buffers);
      }
    };
    exports2.FieldsBinaryCodec = FieldsBinaryCodec;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/codec/struct.js
var require_struct2 = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/codec/struct.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StructBinaryCodec = void 0;
    var typesystem_1 = require_typesystem();
    var fields_1 = require_fields2();
    var StructBinaryCodec = class {
      constructor(binaryCodec) {
        this.fieldsCodec = new fields_1.FieldsBinaryCodec(binaryCodec);
      }
      decodeTopLevel(buffer, type) {
        let [decoded] = this.decodeNested(buffer, type);
        return decoded;
      }
      decodeNested(buffer, type) {
        let fieldDefinitions = type.getFieldsDefinitions();
        let [fields, offset] = this.fieldsCodec.decodeNested(buffer, fieldDefinitions);
        let struct = new typesystem_1.Struct(type, fields);
        return [struct, offset];
      }
      encodeNested(struct) {
        let fields = struct.getFields();
        let buffer = this.fieldsCodec.encodeNested(fields);
        return buffer;
      }
      encodeTopLevel(struct) {
        return this.encodeNested(struct);
      }
    };
    exports2.StructBinaryCodec = StructBinaryCodec;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/codec/enum.js
var require_enum2 = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/codec/enum.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnumBinaryCodec = void 0;
    var typesystem_1 = require_typesystem();
    var fields_1 = require_fields2();
    var EnumBinaryCodec = class {
      constructor(binaryCodec) {
        this.binaryCodec = binaryCodec;
        this.fieldsCodec = new fields_1.FieldsBinaryCodec(binaryCodec);
      }
      decodeTopLevel(buffer, type) {
        let [enumValue] = this.decodeNested(buffer, type);
        return enumValue;
      }
      decodeNested(buffer, type) {
        let [discriminant, lengthOfDiscriminant] = this.readDiscriminant(buffer);
        buffer = buffer.slice(lengthOfDiscriminant);
        let variant = type.getVariantByDiscriminant(discriminant);
        let fieldDefinitions = variant.getFieldsDefinitions();
        let [fields, lengthOfFields] = this.fieldsCodec.decodeNested(buffer, fieldDefinitions);
        let enumValue = new typesystem_1.EnumValue(type, variant, fields);
        return [enumValue, lengthOfDiscriminant + lengthOfFields];
      }
      readDiscriminant(buffer) {
        let [value, length2] = this.binaryCodec.decodeNested(buffer, new typesystem_1.U8Type());
        let discriminant = value.valueOf();
        return [discriminant, length2];
      }
      encodeNested(enumValue) {
        let discriminant = new typesystem_1.U8Value(enumValue.discriminant);
        let discriminantBuffer = this.binaryCodec.encodeNested(discriminant);
        let fields = enumValue.getFields();
        let fieldsBuffer = this.fieldsCodec.encodeNested(fields);
        return import_buffer.Buffer.concat([discriminantBuffer, fieldsBuffer]);
      }
      encodeTopLevel(enumValue) {
        let fields = enumValue.getFields();
        let hasFields = fields.length > 0;
        let fieldsBuffer = this.fieldsCodec.encodeNested(fields);
        let discriminant = new typesystem_1.U8Value(enumValue.discriminant);
        let discriminantBuffer = hasFields ? this.binaryCodec.encodeNested(discriminant) : this.binaryCodec.encodeTopLevel(discriminant);
        return import_buffer.Buffer.concat([discriminantBuffer, fieldsBuffer]);
      }
    };
    exports2.EnumBinaryCodec = EnumBinaryCodec;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/codec/tuple.js
var require_tuple2 = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/codec/tuple.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TupleBinaryCodec = void 0;
    var struct_1 = require_struct2();
    var TupleBinaryCodec = class {
      constructor(binaryCodec) {
        this.structCodec = new struct_1.StructBinaryCodec(binaryCodec);
      }
      decodeTopLevel(buffer, type) {
        return this.structCodec.decodeTopLevel(buffer, type);
      }
      decodeNested(buffer, type) {
        return this.structCodec.decodeNested(buffer, type);
      }
      encodeNested(struct) {
        return this.structCodec.encodeNested(struct);
      }
      encodeTopLevel(struct) {
        return this.structCodec.encodeTopLevel(struct);
      }
    };
    exports2.TupleBinaryCodec = TupleBinaryCodec;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/codec/arrayVec.js
var require_arrayVec = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/codec/arrayVec.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ArrayVecBinaryCodec = void 0;
    var typesystem_1 = require_typesystem();
    var ArrayVecBinaryCodec = class {
      constructor(binaryCodec) {
        this.binaryCodec = binaryCodec;
      }
      decodeNested(buffer, type) {
        let arrayLength = type.length;
        let typeParameter = type.getFirstTypeParameter();
        let result = [];
        let totalLength = 0;
        for (let i2 = 0; i2 < arrayLength; i2++) {
          let [decoded, decodedLength] = this.binaryCodec.decodeNested(buffer, typeParameter);
          result.push(decoded);
          totalLength += decodedLength;
          buffer = buffer.slice(decodedLength);
        }
        return [new typesystem_1.ArrayVec(type, result), totalLength];
      }
      decodeTopLevel(buffer, type) {
        let [result, _4] = this.decodeNested(buffer, type);
        return result;
      }
      encodeNested(array) {
        let itemsBuffers = [];
        for (const item of array.getItems()) {
          let itemBuffer = this.binaryCodec.encodeNested(item);
          itemsBuffers.push(itemBuffer);
        }
        return import_buffer.Buffer.concat(itemsBuffers);
      }
      encodeTopLevel(array) {
        return this.encodeNested(array);
      }
    };
    exports2.ArrayVecBinaryCodec = ArrayVecBinaryCodec;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/codec/binary.js
var require_binary = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/codec/binary.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k4 in mod2)
          if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k4))
            __createBinding2(result, mod2, k4);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BinaryCodecConstraints = exports2.BinaryCodec = void 0;
    var errors = __importStar2(require_errors());
    var typesystem_1 = require_typesystem();
    var utils_1 = require_utils2();
    var option_1 = require_option();
    var primitive_1 = require_primitive();
    var list_1 = require_list();
    var struct_1 = require_struct2();
    var enum_1 = require_enum2();
    var tuple_1 = require_tuple2();
    var arrayVec_1 = require_arrayVec();
    var BinaryCodec = class {
      constructor(constraints = null) {
        this.constraints = constraints || new BinaryCodecConstraints();
        this.optionCodec = new option_1.OptionValueBinaryCodec(this);
        this.listCodec = new list_1.ListBinaryCodec(this);
        this.arrayCodec = new arrayVec_1.ArrayVecBinaryCodec(this);
        this.primitiveCodec = new primitive_1.PrimitiveBinaryCodec(this);
        this.structCodec = new struct_1.StructBinaryCodec(this);
        this.tupleCodec = new tuple_1.TupleBinaryCodec(this);
        this.enumCodec = new enum_1.EnumBinaryCodec(this);
      }
      decodeTopLevel(buffer, type) {
        this.constraints.checkBufferLength(buffer);
        let typedValue = typesystem_1.onTypeSelect(type, {
          onOption: () => this.optionCodec.decodeTopLevel(buffer, type.getFirstTypeParameter()),
          onList: () => this.listCodec.decodeTopLevel(buffer, type),
          onArray: () => this.arrayCodec.decodeTopLevel(buffer, type),
          onPrimitive: () => this.primitiveCodec.decodeTopLevel(buffer, type),
          onStruct: () => this.structCodec.decodeTopLevel(buffer, type),
          onTuple: () => this.tupleCodec.decodeTopLevel(buffer, type),
          onEnum: () => this.enumCodec.decodeTopLevel(buffer, type)
        });
        return typedValue;
      }
      decodeNested(buffer, type) {
        this.constraints.checkBufferLength(buffer);
        let [typedResult, decodedLength] = typesystem_1.onTypeSelect(type, {
          onOption: () => this.optionCodec.decodeNested(buffer, type.getFirstTypeParameter()),
          onList: () => this.listCodec.decodeNested(buffer, type),
          onArray: () => this.arrayCodec.decodeNested(buffer, type),
          onPrimitive: () => this.primitiveCodec.decodeNested(buffer, type),
          onStruct: () => this.structCodec.decodeNested(buffer, type),
          onTuple: () => this.tupleCodec.decodeNested(buffer, type),
          onEnum: () => this.enumCodec.decodeNested(buffer, type)
        });
        return [typedResult, decodedLength];
      }
      encodeNested(typedValue) {
        utils_1.guardTrue(typedValue.getType().getCardinality().isSingular(), "singular cardinality, thus encodable type");
        return typesystem_1.onTypedValueSelect(typedValue, {
          onPrimitive: () => this.primitiveCodec.encodeNested(typedValue),
          onOption: () => this.optionCodec.encodeNested(typedValue),
          onList: () => this.listCodec.encodeNested(typedValue),
          onArray: () => this.arrayCodec.encodeNested(typedValue),
          onStruct: () => this.structCodec.encodeNested(typedValue),
          onTuple: () => this.tupleCodec.encodeNested(typedValue),
          onEnum: () => this.enumCodec.encodeNested(typedValue)
        });
      }
      encodeTopLevel(typedValue) {
        utils_1.guardTrue(typedValue.getType().getCardinality().isSingular(), "singular cardinality, thus encodable type");
        return typesystem_1.onTypedValueSelect(typedValue, {
          onPrimitive: () => this.primitiveCodec.encodeTopLevel(typedValue),
          onOption: () => this.optionCodec.encodeTopLevel(typedValue),
          onList: () => this.listCodec.encodeTopLevel(typedValue),
          onArray: () => this.arrayCodec.encodeTopLevel(typedValue),
          onStruct: () => this.structCodec.encodeTopLevel(typedValue),
          onTuple: () => this.tupleCodec.encodeTopLevel(typedValue),
          onEnum: () => this.enumCodec.encodeTopLevel(typedValue)
        });
      }
    };
    exports2.BinaryCodec = BinaryCodec;
    var BinaryCodecConstraints = class {
      constructor(init) {
        this.maxBufferLength = init?.maxBufferLength || 256e3;
        this.maxListLength = init?.maxListLength || 128e3;
      }
      checkBufferLength(buffer) {
        if (buffer.length > this.maxBufferLength) {
          throw new errors.ErrCodec(`Buffer too large: ${buffer.length} > ${this.maxBufferLength}`);
        }
      }
      /**
       * This constraint avoids computer-freezing decode bugs (e.g. due to invalid ABI or struct definitions).
       */
      checkListLength(length2) {
        if (length2 > this.maxListLength) {
          throw new errors.ErrCodec(`List too large: ${length2} > ${this.maxListLength}`);
        }
      }
    };
    exports2.BinaryCodecConstraints = BinaryCodecConstraints;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/codec/binaryCodecUtils.js
var require_binaryCodecUtils = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/codec/binaryCodecUtils.js"(exports2) {
    "use strict";
    init_shim();
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeBigNumber = exports2.decodeString = exports2.decodeBool = exports2.decodeUnsignedNumber = void 0;
    var bignumber_js_1 = __importDefault2(require_bignumber());
    var typesystem_1 = require_typesystem();
    var binary_1 = require_binary();
    var Codec2 = new binary_1.BinaryCodec();
    function decodeUnsignedNumber(buffer) {
      let value = Codec2.decodeTopLevel(buffer, new typesystem_1.BigUIntType());
      let raw = Number(value.valueOf());
      return raw;
    }
    exports2.decodeUnsignedNumber = decodeUnsignedNumber;
    function decodeBool(buffer) {
      let value = Codec2.decodeTopLevel(buffer, new typesystem_1.BooleanType());
      let raw = Boolean(value.valueOf());
      return raw;
    }
    exports2.decodeBool = decodeBool;
    function decodeString(buffer) {
      let value = Codec2.decodeTopLevel(buffer, new typesystem_1.BytesType());
      let raw = String(value.valueOf());
      return raw;
    }
    exports2.decodeString = decodeString;
    function decodeBigNumber(buffer) {
      let value = Codec2.decodeTopLevel(buffer, new typesystem_1.BigUIntType());
      let raw = new bignumber_js_1.default(value.valueOf());
      return raw;
    }
    exports2.decodeBigNumber = decodeBigNumber;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/codec/index.js
var require_codec2 = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/codec/index.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m3, exports3) {
      for (var p3 in m3)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3))
          __createBinding2(exports3, m3, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_binary(), exports2);
    __exportStar2(require_binaryCodecUtils(), exports2);
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/argSerializer.js
var require_argSerializer = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/argSerializer.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ArgSerializer = void 0;
    var constants_1 = require_constants();
    var codec_1 = require_codec2();
    var typesystem_1 = require_typesystem();
    var algebraic_1 = require_algebraic();
    var composite_1 = require_composite();
    var variadic_1 = require_variadic();
    var defaultArgSerializerOptions = {
      codec: new codec_1.BinaryCodec()
    };
    var ArgSerializer = class {
      constructor(options) {
        options = { ...defaultArgSerializerOptions, ...options };
        this.codec = options.codec;
      }
      /**
       * Reads typed values from an arguments string (e.g. aa@bb@@cc), given parameter definitions.
       */
      stringToValues(joinedString, parameters) {
        let buffers = this.stringToBuffers(joinedString);
        let values = this.buffersToValues(buffers, parameters);
        return values;
      }
      /**
       * Reads raw buffers from an arguments string (e.g. aa@bb@@cc).
       */
      stringToBuffers(joinedString) {
        return joinedString.split(constants_1.ARGUMENTS_SEPARATOR).map((item) => import_buffer.Buffer.from(item, "hex"));
      }
      /**
       * Decodes a set of buffers into a set of typed values, given parameter definitions.
       */
      buffersToValues(buffers, parameters) {
        const self2 = this;
        buffers = buffers || [];
        let values = [];
        let bufferIndex = 0;
        let numBuffers = buffers.length;
        for (let i2 = 0; i2 < parameters.length; i2++) {
          let parameter = parameters[i2];
          let type = parameter.type;
          let value = readValue(type);
          values.push(value);
        }
        function readValue(type) {
          if (type.hasExactClass(algebraic_1.OptionalType.ClassName)) {
            const typedValue2 = readValue(type.getFirstTypeParameter());
            return new algebraic_1.OptionalValue(type, typedValue2);
          }
          if (type.hasExactClass(variadic_1.VariadicType.ClassName)) {
            return readVariadicValue(type);
          }
          if (type.hasExactClass(composite_1.CompositeType.ClassName)) {
            const typedValues = [];
            for (const typeParameter of type.getTypeParameters()) {
              typedValues.push(readValue(typeParameter));
            }
            return new composite_1.CompositeValue(type, typedValues);
          }
          const typedValue = decodeNextBuffer(type);
          return typedValue;
        }
        function readVariadicValue(type) {
          const variadicType = type;
          const typedValues = [];
          if (variadicType.isCounted) {
            const count = readValue(new typesystem_1.U32Type()).valueOf().toNumber();
            for (let i2 = 0; i2 < count; i2++) {
              typedValues.push(readValue(type.getFirstTypeParameter()));
            }
          } else {
            while (!hasReachedTheEnd()) {
              typedValues.push(readValue(type.getFirstTypeParameter()));
            }
          }
          return new variadic_1.VariadicValue(variadicType, typedValues);
        }
        function decodeNextBuffer(type) {
          if (hasReachedTheEnd()) {
            return null;
          }
          let buffer = buffers[bufferIndex++];
          let decodedValue = self2.codec.decodeTopLevel(buffer, type);
          return decodedValue;
        }
        function hasReachedTheEnd() {
          return bufferIndex >= numBuffers;
        }
        return values;
      }
      /**
       * Serializes a set of typed values into an arguments string (e.g. aa@bb@@cc).
       */
      valuesToString(values) {
        let strings = this.valuesToStrings(values);
        let argumentsString = strings.join(constants_1.ARGUMENTS_SEPARATOR);
        let count = strings.length;
        return { argumentsString, count };
      }
      /**
       * Serializes a set of typed values into a set of strings.
       */
      valuesToStrings(values) {
        let buffers = this.valuesToBuffers(values);
        let strings = buffers.map((buffer) => buffer.toString("hex"));
        return strings;
      }
      /**
       * Serializes a set of typed values into a set of strings buffers.
       * Variadic types and composite types might result into none, one or more buffers.
       */
      valuesToBuffers(values) {
        const self2 = this;
        const buffers = [];
        for (const value of values) {
          handleValue(value);
        }
        function handleValue(value) {
          if (value.hasExactClass(algebraic_1.OptionalValue.ClassName)) {
            const valueAsOptional = value;
            if (valueAsOptional.isSet()) {
              handleValue(valueAsOptional.getTypedValue());
            }
            return;
          }
          if (value.hasExactClass(variadic_1.VariadicValue.ClassName)) {
            handleVariadicValue(value);
            return;
          }
          if (value.hasExactClass(composite_1.CompositeValue.ClassName)) {
            const valueAsComposite = value;
            for (const item of valueAsComposite.getItems()) {
              handleValue(item);
            }
            return;
          }
          const buffer = self2.codec.encodeTopLevel(value);
          buffers.push(buffer);
        }
        function handleVariadicValue(value) {
          const variadicType = value.getType();
          if (variadicType.isCounted) {
            const countValue = new typesystem_1.U32Value(value.getItems().length);
            buffers.push(self2.codec.encodeTopLevel(countValue));
          }
          for (const item of value.getItems()) {
            handleValue(item);
          }
        }
        return buffers;
      }
    };
    exports2.ArgSerializer = ArgSerializer;
  }
});

// node_modules/nanoassert/index.js
var require_nanoassert = __commonJS({
  "node_modules/nanoassert/index.js"(exports2, module2) {
    init_shim();
    assert.notEqual = notEqual;
    assert.notOk = notOk;
    assert.equal = equal;
    assert.ok = assert;
    module2.exports = assert;
    function equal(a3, b4, m3) {
      assert(a3 == b4, m3);
    }
    function notEqual(a3, b4, m3) {
      assert(a3 != b4, m3);
    }
    function notOk(t, m3) {
      assert(!t, m3);
    }
    function assert(t, m3) {
      if (!t)
        throw new Error(m3 || "AssertionError");
    }
  }
});

// node_modules/blake2b-wasm/blake2b.js
var require_blake2b = __commonJS({
  "node_modules/blake2b-wasm/blake2b.js"(exports2, module2) {
    init_shim();
    module2.exports = loadWebAssembly;
    loadWebAssembly.supported = typeof WebAssembly !== "undefined";
    function loadWebAssembly(opts) {
      if (!loadWebAssembly.supported)
        return null;
      var imp = opts && opts.imports;
      var wasm = toUint8Array("AGFzbQEAAAABEANgAn9/AGADf39/AGABfwADBQQAAQICBQUBAQroBwdNBQZtZW1vcnkCAAxibGFrZTJiX2luaXQAAA5ibGFrZTJiX3VwZGF0ZQABDWJsYWtlMmJfZmluYWwAAhBibGFrZTJiX2NvbXByZXNzAAMK00AElgMAIABCADcDACAAQQhqQgA3AwAgAEEQakIANwMAIABBGGpCADcDACAAQSBqQgA3AwAgAEEoakIANwMAIABBMGpCADcDACAAQThqQgA3AwAgAEHAAGpCADcDACAAQcgAakIANwMAIABB0ABqQgA3AwAgAEHYAGpCADcDACAAQeAAakIANwMAIABB6ABqQgA3AwAgAEHwAGpCADcDACAAQfgAakIANwMAIABBgAFqQoiS853/zPmE6gBBACkDAIU3AwAgAEGIAWpCu86qptjQ67O7f0EIKQMAhTcDACAAQZABakKr8NP0r+68tzxBECkDAIU3AwAgAEGYAWpC8e30+KWn/aelf0EYKQMAhTcDACAAQaABakLRhZrv+s+Uh9EAQSApAwCFNwMAIABBqAFqQp/Y+dnCkdqCm39BKCkDAIU3AwAgAEGwAWpC6/qG2r+19sEfQTApAwCFNwMAIABBuAFqQvnC+JuRo7Pw2wBBOCkDAIU3AwAgAEHAAWpCADcDACAAQcgBakIANwMAIABB0AFqQgA3AwALbQEDfyAAQcABaiEDIABByAFqIQQgBCkDAKchBQJAA0AgASACRg0BIAVBgAFGBEAgAyADKQMAIAWtfDcDAEEAIQUgABADCyAAIAVqIAEtAAA6AAAgBUEBaiEFIAFBAWohAQwACwsgBCAFrTcDAAtkAQN/IABBwAFqIQEgAEHIAWohAiABIAEpAwAgAikDAHw3AwAgAEHQAWpCfzcDACACKQMApyEDAkADQCADQYABRg0BIAAgA2pBADoAACADQQFqIQMMAAsLIAIgA603AwAgABADC+U7AiB+CX8gAEGAAWohISAAQYgBaiEiIABBkAFqISMgAEGYAWohJCAAQaABaiElIABBqAFqISYgAEGwAWohJyAAQbgBaiEoICEpAwAhASAiKQMAIQIgIykDACEDICQpAwAhBCAlKQMAIQUgJikDACEGICcpAwAhByAoKQMAIQhCiJLznf/M+YTqACEJQrvOqqbY0Ouzu38hCkKr8NP0r+68tzwhC0Lx7fT4paf9p6V/IQxC0YWa7/rPlIfRACENQp/Y+dnCkdqCm38hDkLr+obav7X2wR8hD0L5wvibkaOz8NsAIRAgACkDACERIABBCGopAwAhEiAAQRBqKQMAIRMgAEEYaikDACEUIABBIGopAwAhFSAAQShqKQMAIRYgAEEwaikDACEXIABBOGopAwAhGCAAQcAAaikDACEZIABByABqKQMAIRogAEHQAGopAwAhGyAAQdgAaikDACEcIABB4ABqKQMAIR0gAEHoAGopAwAhHiAAQfAAaikDACEfIABB+ABqKQMAISAgDSAAQcABaikDAIUhDSAPIABB0AFqKQMAhSEPIAEgBSARfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgEnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBN8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAUfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgFXx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBZ8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAXfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggGHx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBl8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAafHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgG3x8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBx8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAdfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggHnx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIB98fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAgfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgH3x8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBt8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAVfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGXx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBp8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAgfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggHnx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBd8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiASfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgHXx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBF8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByATfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggHHx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBh8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAWfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgFHx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBx8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAZfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgHXx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBF8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAWfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgE3x8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIICB8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAefHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgG3x8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB98fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAUfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgF3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBh8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCASfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgGnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBV8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAYfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgGnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBR8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiASfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgHnx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIB18fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAcfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggH3x8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBN8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAXfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgFnx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBt8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAVfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggEXx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFICB8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAZfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgGnx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBF8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAWfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGHx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBN8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAVfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggG3x8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIICB8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAffHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgEnx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBx8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAdfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggF3x8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBl8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAUfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgHnx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBN8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAdfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgF3x8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBt8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByARfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgHHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBl8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAUfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgFXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB58fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAYfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgFnx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIICB8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAffHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgEnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBp8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAdfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgFnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBJ8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAgfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgH3x8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIB58fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAVfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggG3x8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBF8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAYfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgF3x8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBR8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAafHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggE3x8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIBl8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAcfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgHnx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBx8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAYfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgH3x8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIB18fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByASfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggFHx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBp8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAWfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgEXx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHICB8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAVfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggGXx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBd8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSATfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgG3x8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBd8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAgfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgH3x8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBp8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAcfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgFHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBF8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAZfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgHXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBN8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAefHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgGHx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBJ8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAVfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgG3x8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBZ8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAbfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgE3x8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBl8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAVfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgGHx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBd8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCASfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggFnx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGICB8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAcfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgGnx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIB98fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAUfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggHXx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIB58fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSARfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgEXx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBJ8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiATfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgFHx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBV8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAWfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggF3x8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBh8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAZfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgGnx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBt8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAcfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggHXx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIB58fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAffHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgIHx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIB98fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAbfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgFXx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBl8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAafHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgIHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIB58fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAXfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgEnx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB18fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByARfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgE3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBx8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAYfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgFnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBR8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFICEgISkDACABIAmFhTcDACAiICIpAwAgAiAKhYU3AwAgIyAjKQMAIAMgC4WFNwMAICQgJCkDACAEIAyFhTcDACAlICUpAwAgBSANhYU3AwAgJiAmKQMAIAYgDoWFNwMAICcgJykDACAHIA+FhTcDACAoICgpAwAgCCAQhYU3AwAL");
      var ready = null;
      var mod2 = {
        buffer: wasm,
        memory: null,
        exports: null,
        realloc,
        onload
      };
      onload(function() {
      });
      return mod2;
      function realloc(size) {
        mod2.exports.memory.grow(Math.ceil(Math.abs(size - mod2.memory.length) / 65536));
        mod2.memory = new Uint8Array(mod2.exports.memory.buffer);
      }
      function onload(cb) {
        if (mod2.exports)
          return cb();
        if (ready) {
          ready.then(cb.bind(null, null)).catch(cb);
          return;
        }
        try {
          if (opts && opts.async)
            throw new Error("async");
          setup({ instance: new WebAssembly.Instance(new WebAssembly.Module(wasm), imp) });
        } catch (err) {
          ready = WebAssembly.instantiate(wasm, imp).then(setup);
        }
        onload(cb);
      }
      function setup(w4) {
        mod2.exports = w4.instance.exports;
        mod2.memory = mod2.exports.memory && mod2.exports.memory.buffer && new Uint8Array(mod2.exports.memory.buffer);
      }
    }
    function toUint8Array(s2) {
      if (typeof atob === "function")
        return new Uint8Array(atob(s2).split("").map(charCodeAt));
      return new (require_buffer2()).Buffer(s2, "base64");
    }
    function charCodeAt(c4) {
      return c4.charCodeAt(0);
    }
  }
});

// node_modules/blake2b-wasm/index.js
var require_blake2b_wasm = __commonJS({
  "node_modules/blake2b-wasm/index.js"(exports2, module2) {
    init_shim();
    var assert = require_nanoassert();
    var wasm = require_blake2b()();
    var head = 64;
    var freeList = [];
    module2.exports = Blake2b;
    var BYTES_MIN = module2.exports.BYTES_MIN = 16;
    var BYTES_MAX = module2.exports.BYTES_MAX = 64;
    var BYTES = module2.exports.BYTES = 32;
    var KEYBYTES_MIN = module2.exports.KEYBYTES_MIN = 16;
    var KEYBYTES_MAX = module2.exports.KEYBYTES_MAX = 64;
    var KEYBYTES = module2.exports.KEYBYTES = 32;
    var SALTBYTES = module2.exports.SALTBYTES = 16;
    var PERSONALBYTES = module2.exports.PERSONALBYTES = 16;
    function Blake2b(digestLength, key, salt, personal, noAssert) {
      if (!(this instanceof Blake2b))
        return new Blake2b(digestLength, key, salt, personal, noAssert);
      if (!(wasm && wasm.exports))
        throw new Error("WASM not loaded. Wait for Blake2b.ready(cb)");
      if (!digestLength)
        digestLength = 32;
      if (noAssert !== true) {
        assert(digestLength >= BYTES_MIN, "digestLength must be at least " + BYTES_MIN + ", was given " + digestLength);
        assert(digestLength <= BYTES_MAX, "digestLength must be at most " + BYTES_MAX + ", was given " + digestLength);
        if (key != null)
          assert(key.length >= KEYBYTES_MIN, "key must be at least " + KEYBYTES_MIN + ", was given " + key.length);
        if (key != null)
          assert(key.length <= KEYBYTES_MAX, "key must be at least " + KEYBYTES_MAX + ", was given " + key.length);
        if (salt != null)
          assert(salt.length === SALTBYTES, "salt must be exactly " + SALTBYTES + ", was given " + salt.length);
        if (personal != null)
          assert(personal.length === PERSONALBYTES, "personal must be exactly " + PERSONALBYTES + ", was given " + personal.length);
      }
      if (!freeList.length) {
        freeList.push(head);
        head += 216;
      }
      this.digestLength = digestLength;
      this.finalized = false;
      this.pointer = freeList.pop();
      wasm.memory.fill(0, 0, 64);
      wasm.memory[0] = this.digestLength;
      wasm.memory[1] = key ? key.length : 0;
      wasm.memory[2] = 1;
      wasm.memory[3] = 1;
      if (salt)
        wasm.memory.set(salt, 32);
      if (personal)
        wasm.memory.set(personal, 48);
      if (this.pointer + 216 > wasm.memory.length)
        wasm.realloc(this.pointer + 216);
      wasm.exports.blake2b_init(this.pointer, this.digestLength);
      if (key) {
        this.update(key);
        wasm.memory.fill(0, head, head + key.length);
        wasm.memory[this.pointer + 200] = 128;
      }
    }
    Blake2b.prototype.update = function(input) {
      assert(this.finalized === false, "Hash instance finalized");
      assert(input, "input must be TypedArray or Buffer");
      if (head + input.length > wasm.memory.length)
        wasm.realloc(head + input.length);
      wasm.memory.set(input, head);
      wasm.exports.blake2b_update(this.pointer, head, head + input.length);
      return this;
    };
    Blake2b.prototype.digest = function(enc) {
      assert(this.finalized === false, "Hash instance finalized");
      this.finalized = true;
      freeList.push(this.pointer);
      wasm.exports.blake2b_final(this.pointer);
      if (!enc || enc === "binary") {
        return wasm.memory.slice(this.pointer + 128, this.pointer + 128 + this.digestLength);
      }
      if (enc === "hex") {
        return hexSlice(wasm.memory, this.pointer + 128, this.digestLength);
      }
      assert(enc.length >= this.digestLength, "input must be TypedArray or Buffer");
      for (var i2 = 0; i2 < this.digestLength; i2++) {
        enc[i2] = wasm.memory[this.pointer + 128 + i2];
      }
      return enc;
    };
    Blake2b.prototype.final = Blake2b.prototype.digest;
    Blake2b.WASM = wasm && wasm.buffer;
    Blake2b.SUPPORTED = typeof WebAssembly !== "undefined";
    Blake2b.ready = function(cb) {
      if (!cb)
        cb = noop;
      if (!wasm)
        return cb(new Error("WebAssembly not supported"));
      var p3 = new Promise(function(reject, resolve) {
        wasm.onload(function(err) {
          if (err)
            resolve();
          else
            reject();
          cb(err);
        });
      });
      return p3;
    };
    Blake2b.prototype.ready = Blake2b.ready;
    function noop() {
    }
    function hexSlice(buf, start, len) {
      var str = "";
      for (var i2 = 0; i2 < len; i2++)
        str += toHex(buf[start + i2]);
      return str;
    }
    function toHex(n3) {
      if (n3 < 16)
        return "0" + n3.toString(16);
      return n3.toString(16);
    }
  }
});

// node_modules/blake2b/index.js
var require_blake2b2 = __commonJS({
  "node_modules/blake2b/index.js"(exports2, module2) {
    init_shim();
    var assert = require_nanoassert();
    var b2wasm = require_blake2b_wasm();
    function ADD64AA(v3, a3, b4) {
      var o0 = v3[a3] + v3[b4];
      var o1 = v3[a3 + 1] + v3[b4 + 1];
      if (o0 >= 4294967296) {
        o1++;
      }
      v3[a3] = o0;
      v3[a3 + 1] = o1;
    }
    function ADD64AC(v3, a3, b0, b1) {
      var o0 = v3[a3] + b0;
      if (b0 < 0) {
        o0 += 4294967296;
      }
      var o1 = v3[a3 + 1] + b1;
      if (o0 >= 4294967296) {
        o1++;
      }
      v3[a3] = o0;
      v3[a3 + 1] = o1;
    }
    function B2B_GET32(arr, i2) {
      return arr[i2] ^ arr[i2 + 1] << 8 ^ arr[i2 + 2] << 16 ^ arr[i2 + 3] << 24;
    }
    function B2B_G(a3, b4, c4, d3, ix, iy) {
      var x0 = m3[ix];
      var x1 = m3[ix + 1];
      var y0 = m3[iy];
      var y1 = m3[iy + 1];
      ADD64AA(v2, a3, b4);
      ADD64AC(v2, a3, x0, x1);
      var xor0 = v2[d3] ^ v2[a3];
      var xor1 = v2[d3 + 1] ^ v2[a3 + 1];
      v2[d3] = xor1;
      v2[d3 + 1] = xor0;
      ADD64AA(v2, c4, d3);
      xor0 = v2[b4] ^ v2[c4];
      xor1 = v2[b4 + 1] ^ v2[c4 + 1];
      v2[b4] = xor0 >>> 24 ^ xor1 << 8;
      v2[b4 + 1] = xor1 >>> 24 ^ xor0 << 8;
      ADD64AA(v2, a3, b4);
      ADD64AC(v2, a3, y0, y1);
      xor0 = v2[d3] ^ v2[a3];
      xor1 = v2[d3 + 1] ^ v2[a3 + 1];
      v2[d3] = xor0 >>> 16 ^ xor1 << 16;
      v2[d3 + 1] = xor1 >>> 16 ^ xor0 << 16;
      ADD64AA(v2, c4, d3);
      xor0 = v2[b4] ^ v2[c4];
      xor1 = v2[b4 + 1] ^ v2[c4 + 1];
      v2[b4] = xor1 >>> 31 ^ xor0 << 1;
      v2[b4 + 1] = xor0 >>> 31 ^ xor1 << 1;
    }
    var BLAKE2B_IV32 = new Uint32Array([
      4089235720,
      1779033703,
      2227873595,
      3144134277,
      4271175723,
      1013904242,
      1595750129,
      2773480762,
      2917565137,
      1359893119,
      725511199,
      2600822924,
      4215389547,
      528734635,
      327033209,
      1541459225
    ]);
    var SIGMA8 = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3,
      11,
      8,
      12,
      0,
      5,
      2,
      15,
      13,
      10,
      14,
      3,
      6,
      7,
      1,
      9,
      4,
      7,
      9,
      3,
      1,
      13,
      12,
      11,
      14,
      2,
      6,
      5,
      10,
      4,
      0,
      15,
      8,
      9,
      0,
      5,
      7,
      2,
      4,
      10,
      15,
      14,
      1,
      11,
      12,
      6,
      8,
      3,
      13,
      2,
      12,
      6,
      10,
      0,
      11,
      8,
      3,
      4,
      13,
      7,
      5,
      15,
      14,
      1,
      9,
      12,
      5,
      1,
      15,
      14,
      13,
      4,
      10,
      0,
      7,
      6,
      3,
      9,
      2,
      8,
      11,
      13,
      11,
      7,
      14,
      12,
      1,
      3,
      9,
      5,
      0,
      15,
      4,
      8,
      6,
      2,
      10,
      6,
      15,
      14,
      9,
      11,
      3,
      0,
      8,
      12,
      2,
      13,
      7,
      1,
      4,
      10,
      5,
      10,
      2,
      8,
      4,
      7,
      6,
      1,
      5,
      15,
      11,
      9,
      14,
      3,
      12,
      13,
      0,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3
    ];
    var SIGMA82 = new Uint8Array(SIGMA8.map(function(x3) {
      return x3 * 2;
    }));
    var v2 = new Uint32Array(32);
    var m3 = new Uint32Array(32);
    function blake2bCompress(ctx, last) {
      var i2 = 0;
      for (i2 = 0; i2 < 16; i2++) {
        v2[i2] = ctx.h[i2];
        v2[i2 + 16] = BLAKE2B_IV32[i2];
      }
      v2[24] = v2[24] ^ ctx.t;
      v2[25] = v2[25] ^ ctx.t / 4294967296;
      if (last) {
        v2[28] = ~v2[28];
        v2[29] = ~v2[29];
      }
      for (i2 = 0; i2 < 32; i2++) {
        m3[i2] = B2B_GET32(ctx.b, 4 * i2);
      }
      for (i2 = 0; i2 < 12; i2++) {
        B2B_G(0, 8, 16, 24, SIGMA82[i2 * 16 + 0], SIGMA82[i2 * 16 + 1]);
        B2B_G(2, 10, 18, 26, SIGMA82[i2 * 16 + 2], SIGMA82[i2 * 16 + 3]);
        B2B_G(4, 12, 20, 28, SIGMA82[i2 * 16 + 4], SIGMA82[i2 * 16 + 5]);
        B2B_G(6, 14, 22, 30, SIGMA82[i2 * 16 + 6], SIGMA82[i2 * 16 + 7]);
        B2B_G(0, 10, 20, 30, SIGMA82[i2 * 16 + 8], SIGMA82[i2 * 16 + 9]);
        B2B_G(2, 12, 22, 24, SIGMA82[i2 * 16 + 10], SIGMA82[i2 * 16 + 11]);
        B2B_G(4, 14, 16, 26, SIGMA82[i2 * 16 + 12], SIGMA82[i2 * 16 + 13]);
        B2B_G(6, 8, 18, 28, SIGMA82[i2 * 16 + 14], SIGMA82[i2 * 16 + 15]);
      }
      for (i2 = 0; i2 < 16; i2++) {
        ctx.h[i2] = ctx.h[i2] ^ v2[i2] ^ v2[i2 + 16];
      }
    }
    var parameter_block = new Uint8Array([
      0,
      0,
      0,
      0,
      //  0: outlen, keylen, fanout, depth
      0,
      0,
      0,
      0,
      //  4: leaf length, sequential mode
      0,
      0,
      0,
      0,
      //  8: node offset
      0,
      0,
      0,
      0,
      // 12: node offset
      0,
      0,
      0,
      0,
      // 16: node depth, inner length, rfu
      0,
      0,
      0,
      0,
      // 20: rfu
      0,
      0,
      0,
      0,
      // 24: rfu
      0,
      0,
      0,
      0,
      // 28: rfu
      0,
      0,
      0,
      0,
      // 32: salt
      0,
      0,
      0,
      0,
      // 36: salt
      0,
      0,
      0,
      0,
      // 40: salt
      0,
      0,
      0,
      0,
      // 44: salt
      0,
      0,
      0,
      0,
      // 48: personal
      0,
      0,
      0,
      0,
      // 52: personal
      0,
      0,
      0,
      0,
      // 56: personal
      0,
      0,
      0,
      0
      // 60: personal
    ]);
    function Blake2b(outlen, key, salt, personal) {
      parameter_block.fill(0);
      this.b = new Uint8Array(128);
      this.h = new Uint32Array(16);
      this.t = 0;
      this.c = 0;
      this.outlen = outlen;
      parameter_block[0] = outlen;
      if (key)
        parameter_block[1] = key.length;
      parameter_block[2] = 1;
      parameter_block[3] = 1;
      if (salt)
        parameter_block.set(salt, 32);
      if (personal)
        parameter_block.set(personal, 48);
      for (var i2 = 0; i2 < 16; i2++) {
        this.h[i2] = BLAKE2B_IV32[i2] ^ B2B_GET32(parameter_block, i2 * 4);
      }
      if (key) {
        blake2bUpdate(this, key);
        this.c = 128;
      }
    }
    Blake2b.prototype.update = function(input) {
      assert(input != null, "input must be Uint8Array or Buffer");
      blake2bUpdate(this, input);
      return this;
    };
    Blake2b.prototype.digest = function(out) {
      var buf = !out || out === "binary" || out === "hex" ? new Uint8Array(this.outlen) : out;
      assert(buf.length >= this.outlen, "out must have at least outlen bytes of space");
      blake2bFinal(this, buf);
      if (out === "hex")
        return hexSlice(buf);
      return buf;
    };
    Blake2b.prototype.final = Blake2b.prototype.digest;
    Blake2b.ready = function(cb) {
      b2wasm.ready(function() {
        cb();
      });
    };
    function blake2bUpdate(ctx, input) {
      for (var i2 = 0; i2 < input.length; i2++) {
        if (ctx.c === 128) {
          ctx.t += ctx.c;
          blake2bCompress(ctx, false);
          ctx.c = 0;
        }
        ctx.b[ctx.c++] = input[i2];
      }
    }
    function blake2bFinal(ctx, out) {
      ctx.t += ctx.c;
      while (ctx.c < 128) {
        ctx.b[ctx.c++] = 0;
      }
      blake2bCompress(ctx, true);
      for (var i2 = 0; i2 < ctx.outlen; i2++) {
        out[i2] = ctx.h[i2 >> 2] >> 8 * (i2 & 3);
      }
      return out;
    }
    function hexSlice(buf) {
      var str = "";
      for (var i2 = 0; i2 < buf.length; i2++)
        str += toHex(buf[i2]);
      return str;
    }
    function toHex(n3) {
      if (n3 < 16)
        return "0" + n3.toString(16);
      return n3.toString(16);
    }
    var Proto = Blake2b;
    module2.exports = function createHash(outlen, key, salt, personal, noAssert) {
      if (noAssert !== true) {
        assert(outlen >= BYTES_MIN, "outlen must be at least " + BYTES_MIN + ", was given " + outlen);
        assert(outlen <= BYTES_MAX, "outlen must be at most " + BYTES_MAX + ", was given " + outlen);
        if (key != null)
          assert(key.length >= KEYBYTES_MIN, "key must be at least " + KEYBYTES_MIN + ", was given " + key.length);
        if (key != null)
          assert(key.length <= KEYBYTES_MAX, "key must be at most " + KEYBYTES_MAX + ", was given " + key.length);
        if (salt != null)
          assert(salt.length === SALTBYTES, "salt must be exactly " + SALTBYTES + ", was given " + salt.length);
        if (personal != null)
          assert(personal.length === PERSONALBYTES, "personal must be exactly " + PERSONALBYTES + ", was given " + personal.length);
      }
      return new Proto(outlen, key, salt, personal);
    };
    module2.exports.ready = function(cb) {
      b2wasm.ready(function() {
        cb();
      });
    };
    module2.exports.WASM_SUPPORTED = b2wasm.SUPPORTED;
    module2.exports.WASM_LOADED = false;
    var BYTES_MIN = module2.exports.BYTES_MIN = 16;
    var BYTES_MAX = module2.exports.BYTES_MAX = 64;
    var BYTES = module2.exports.BYTES = 32;
    var KEYBYTES_MIN = module2.exports.KEYBYTES_MIN = 16;
    var KEYBYTES_MAX = module2.exports.KEYBYTES_MAX = 64;
    var KEYBYTES = module2.exports.KEYBYTES = 32;
    var SALTBYTES = module2.exports.SALTBYTES = 16;
    var PERSONALBYTES = module2.exports.PERSONALBYTES = 16;
    b2wasm.ready(function(err) {
      if (!err) {
        module2.exports.WASM_LOADED = true;
        Proto = b2wasm;
      }
    });
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/code.js
var require_code = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/code.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Code = void 0;
    var createHasher = require_blake2b2();
    var CODE_HASH_LENGTH = 32;
    var Code = class _Code {
      constructor(hex) {
        this.hex = hex;
      }
      /**
       * Creates a Code object from a buffer (sequence of bytes).
       */
      static fromBuffer(code2) {
        return new _Code(code2.toString("hex"));
      }
      /**
       * Creates a Code object from a hex-encoded string.
       */
      static fromHex(hex) {
        return new _Code(hex);
      }
      /**
       * Returns the bytecode as a hex-encoded string.
       */
      toString() {
        return this.hex;
      }
      valueOf() {
        return import_buffer.Buffer.from(this.hex, "hex");
      }
      computeHash() {
        const hash = createHasher(CODE_HASH_LENGTH).update(this.valueOf()).digest();
        return import_buffer.Buffer.from(hash);
      }
    };
    exports2.Code = Code;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/codeMetadata.js
var require_codeMetadata2 = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/codeMetadata.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CodeMetadata = void 0;
    var CodeMetadata = class _CodeMetadata {
      /**
       * Creates a metadata object. By default, set the `upgradeable` attribute, and uset all others.
       *
       * @param upgradeable Whether the contract is upgradeable
       * @param readable Whether other contracts can read this contract's data (without calling one of its pure functions)
       * @param payable Whether the contract is payable
       * @param payableBySc Whether the contract is payable by other smart contracts
       */
      constructor(upgradeable = true, readable = false, payable = false, payableBySc = false) {
        this.upgradeable = upgradeable;
        this.readable = readable;
        this.payable = payable;
        this.payableBySc = payableBySc;
      }
      static fromBytes(bytes) {
        return _CodeMetadata.fromBuffer(import_buffer.Buffer.from(bytes));
      }
      /**
       * Creates a metadata object from a buffer.
       */
      static fromBuffer(buffer) {
        if (buffer.length < this.codeMetadataLength) {
          throw new Error("Buffer is too short.");
        }
        const byteZero = buffer[0];
        const byteOne = buffer[1];
        const upgradeable = (byteZero & _CodeMetadata.ByteZero.Upgradeable) !== 0;
        const readable = (byteZero & _CodeMetadata.ByteZero.Readable) !== 0;
        const payable = (byteOne & _CodeMetadata.ByteOne.Payable) !== 0;
        const payableBySc = (byteOne & _CodeMetadata.ByteOne.PayableBySc) !== 0;
        return new _CodeMetadata(upgradeable, readable, payable, payableBySc);
      }
      /**
       * Adjust the metadata (the `upgradeable` attribute), when preparing the deployment transaction.
       */
      toggleUpgradeable(value) {
        this.upgradeable = value;
      }
      /**
       * Adjust the metadata (the `readable` attribute), when preparing the deployment transaction.
       */
      toggleReadable(value) {
        this.readable = value;
      }
      /**
       * Adjust the metadata (the `payable` attribute), when preparing the deployment transaction.
       */
      togglePayable(value) {
        this.payable = value;
      }
      /**
       * Adjust the metadata (the `payableBySc` attribute), when preparing the deployment transaction.
       */
      togglePayableBySc(value) {
        this.payableBySc = value;
      }
      /**
       * Converts the metadata to the protocol-friendly representation.
       */
      toBuffer() {
        let byteZero = 0;
        let byteOne = 0;
        if (this.upgradeable) {
          byteZero |= _CodeMetadata.ByteZero.Upgradeable;
        }
        if (this.readable) {
          byteZero |= _CodeMetadata.ByteZero.Readable;
        }
        if (this.payable) {
          byteOne |= _CodeMetadata.ByteOne.Payable;
        }
        if (this.payableBySc) {
          byteOne |= _CodeMetadata.ByteOne.PayableBySc;
        }
        return import_buffer.Buffer.from([byteZero, byteOne]);
      }
      /**
       * Converts the metadata to a hex-encoded string.
       */
      toString() {
        return this.toBuffer().toString("hex");
      }
      /**
       * Converts the metadata to a pretty, plain JavaScript object.
       */
      toJSON() {
        return {
          upgradeable: this.upgradeable,
          readable: this.readable,
          payable: this.payable,
          payableBySc: this.payableBySc
        };
      }
      equals(other) {
        return this.upgradeable == other.upgradeable && this.readable == other.readable && this.payable == other.payable && this.payableBySc == other.payableBySc;
      }
    };
    exports2.CodeMetadata = CodeMetadata;
    CodeMetadata.codeMetadataLength = 2;
    CodeMetadata.ByteZero = {
      Upgradeable: 1,
      Reserved2: 2,
      Readable: 4
    };
    CodeMetadata.ByteOne = {
      Reserved1: 1,
      Payable: 2,
      PayableBySc: 4
    };
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/function.js
var require_function = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/function.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k4 in mod2)
          if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k4))
            __createBinding2(result, mod2, k4);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ContractFunction = void 0;
    var errors = __importStar2(require_errors());
    var ContractFunction = class _ContractFunction {
      /**
       * Creates a ContractFunction object, given its name.
       *
       * @param name the name of the function
       */
      constructor(name2) {
        this.name = name2;
        if (name2 == null) {
          throw new errors.ErrInvalidFunctionName();
        }
      }
      /**
       * Null-object pattern: creates an empty ContractFunction object.
       */
      static none() {
        return new _ContractFunction("untitled");
      }
      /**
       * Returns the name of the function.
       */
      toString() {
        return this.name;
      }
      valueOf() {
        return this.name;
      }
    };
    exports2.ContractFunction = ContractFunction;
  }
});

// node_modules/@multiversx/sdk-core/out/compatibility.js
var require_compatibility = __commonJS({
  "node_modules/@multiversx/sdk-core/out/compatibility.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Compatibility = void 0;
    var address_1 = require_address();
    var Compatibility = class {
      /**
       * For internal use only.
       */
      static guardAddressIsSetAndNonZero(address, context, resolution) {
        if (!address || address.bech32() == "") {
          console.warn(`${context}: address should be set; ${resolution}. In the future, this will throw an exception instead of emitting a WARN.`);
        } else if (address.bech32() == address_1.Address.Zero().bech32()) {
          console.warn(`${context}: address should not be the 'zero' address (also known as the 'contracts deployment address'); ${resolution}. In the future, this will throw an exception instead of emitting a WARN.`);
        }
      }
    };
    exports2.Compatibility = Compatibility;
  }
});

// node_modules/@multiversx/sdk-core/out/transactionPayload.js
var require_transactionPayload = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionPayload.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransactionPayload = void 0;
    var TransactionPayload = class _TransactionPayload {
      /**
       * Creates a TransactionPayload from a utf-8 string or from a buffer.
       */
      constructor(data) {
        this.data = import_buffer.Buffer.from(data || []);
      }
      /**
       * Creates a TransactionPayload from a base-64 encoded string.
       */
      static fromEncoded(encoded) {
        if (!encoded) {
          return new _TransactionPayload("");
        }
        let decoded = import_buffer.Buffer.from(encoded, "base64").toString();
        return new _TransactionPayload(decoded);
      }
      /**
       * Returns whether the "data" is void.
       */
      isEmpty() {
        return this.data.length == 0;
      }
      /**
       * Returns the base-64 representation of the data.
       */
      encoded() {
        return this.data.toString("base64");
      }
      /**
       * Returns the data as a buffer.
       */
      valueOf() {
        return this.data;
      }
      toString() {
        return this.data.toString();
      }
      getEncodedArguments() {
        return this.toString().split("@");
      }
      getRawArguments() {
        return this.getEncodedArguments().map((argument) => import_buffer.Buffer.from(argument, "hex"));
      }
      /**
       * Returns the length of the data.
       */
      length() {
        return import_buffer.Buffer.from(this.data).length;
      }
    };
    exports2.TransactionPayload = TransactionPayload;
  }
});

// node_modules/@multiversx/sdk-core/out/transactionsFactories/transactionBuilder.js
var require_transactionBuilder = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionsFactories/transactionBuilder.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransactionBuilder = void 0;
    var constants_1 = require_constants();
    var transaction_1 = require_transaction();
    var transactionPayload_1 = require_transactionPayload();
    var TransactionBuilder = class {
      constructor(options) {
        this.config = options.config;
        this.sender = options.sender;
        this.receiver = options.receiver;
        this.dataParts = options.dataParts;
        this.providedGasLimit = options.gasLimit;
        this.addDataMovementGas = options.addDataMovementGas;
        this.amount = options.amount;
      }
      computeGasLimit(payload) {
        if (!this.addDataMovementGas) {
          return this.providedGasLimit;
        }
        const dataMovementGas = this.config.minGasLimit + this.config.gasLimitPerByte * BigInt(payload.length());
        const gasLimit = dataMovementGas + this.providedGasLimit;
        return gasLimit;
      }
      buildTransactionPayload() {
        const data = this.dataParts.join(constants_1.ARGUMENTS_SEPARATOR);
        return new transactionPayload_1.TransactionPayload(data);
      }
      build() {
        const data = this.buildTransactionPayload();
        const gasLimit = this.computeGasLimit(data);
        return new transaction_1.Transaction({
          sender: this.sender.bech32(),
          receiver: this.receiver.bech32(),
          gasLimit,
          value: this.amount || 0n,
          data: data.valueOf(),
          chainID: this.config.chainID
        });
      }
    };
    exports2.TransactionBuilder = TransactionBuilder;
  }
});

// node_modules/@multiversx/sdk-core/out/transactionsFactories/delegationTransactionsFactory.js
var require_delegationTransactionsFactory = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionsFactories/delegationTransactionsFactory.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DelegationTransactionsFactory = void 0;
    var address_1 = require_address();
    var constants_1 = require_constants();
    var errors_1 = require_errors();
    var smartcontracts_1 = require_smartcontracts();
    var transactionBuilder_1 = require_transactionBuilder();
    var DelegationTransactionsFactory = class {
      constructor(options) {
        this.config = options.config;
        this.argSerializer = new smartcontracts_1.ArgSerializer();
      }
      createTransactionForNewDelegationContract(options) {
        const dataParts = [
          "createNewDelegationContract",
          ...this.argSerializer.valuesToStrings([
            new smartcontracts_1.BigUIntValue(options.totalDelegationCap),
            new smartcontracts_1.BigUIntValue(options.serviceFee)
          ])
        ];
        const executionGasLimit = this.config.gasLimitCreateDelegationContract + this.config.additionalGasLimitForDelegationOperations;
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: address_1.Address.fromBech32(constants_1.DELEGATION_MANAGER_SC_ADDRESS),
          dataParts,
          gasLimit: executionGasLimit,
          addDataMovementGas: true,
          amount: options.amount
        }).build();
      }
      createTransactionForAddingNodes(options) {
        if (options.publicKeys.length !== options.signedMessages.length) {
          throw new errors_1.Err("The number of public keys should match the number of signed messages");
        }
        const signedMessagesAsTypedValues = options.signedMessages.map((message) => new smartcontracts_1.BytesValue(import_buffer.Buffer.from(message)));
        const messagesAsStrings = this.argSerializer.valuesToStrings(signedMessagesAsTypedValues);
        const numNodes = options.publicKeys.length;
        const dataParts = ["addNodes"];
        for (let i2 = 0; i2 < numNodes; i2++) {
          dataParts.push(...[options.publicKeys[i2].hex(), messagesAsStrings[i2]]);
        }
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.delegationContract,
          dataParts,
          gasLimit: this.computeExecutionGasLimitForNodesManagement(numNodes),
          addDataMovementGas: true
        }).build();
      }
      createTransactionForRemovingNodes(options) {
        const dataParts = ["removeNodes"];
        for (const key of options.publicKeys) {
          dataParts.push(key.hex());
        }
        const numNodes = options.publicKeys.length;
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.delegationContract,
          dataParts,
          gasLimit: this.computeExecutionGasLimitForNodesManagement(numNodes),
          addDataMovementGas: true
        }).build();
      }
      createTransactionForStakingNodes(options) {
        let dataParts = ["stakeNodes"];
        for (const key of options.publicKeys) {
          dataParts = dataParts.concat(key.hex());
        }
        const numNodes = options.publicKeys.length;
        const additionalGasForAllNodes = BigInt(numNodes) * this.config.additionalGasLimitPerValidatorNode;
        const executionGasLimit = additionalGasForAllNodes + this.config.gasLimitStake + this.config.gasLimitDelegationOperations;
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.delegationContract,
          dataParts,
          gasLimit: executionGasLimit,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForUnbondingNodes(options) {
        let dataParts = ["unBondNodes"];
        for (const key of options.publicKeys) {
          dataParts = dataParts.concat(key.hex());
        }
        const numNodes = options.publicKeys.length;
        const executionGasLimit = BigInt(numNodes) * this.config.additionalGasLimitPerValidatorNode + this.config.gasLimitUnbond + this.config.gasLimitDelegationOperations;
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.delegationContract,
          dataParts,
          gasLimit: executionGasLimit,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForUnstakingNodes(options) {
        let dataParts = ["unStakeNodes"];
        for (const key of options.publicKeys) {
          dataParts = dataParts.concat(key.hex());
        }
        const numNodes = options.publicKeys.length;
        const executionGasLimit = BigInt(numNodes) * this.config.additionalGasLimitPerValidatorNode + this.config.gasLimitUnstake + this.config.gasLimitDelegationOperations;
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.delegationContract,
          dataParts,
          gasLimit: executionGasLimit,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForUnjailingNodes(options) {
        const dataParts = ["unJailNodes"];
        for (const key of options.publicKeys) {
          dataParts.push(key.hex());
        }
        const numNodes = options.publicKeys.length;
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.delegationContract,
          dataParts,
          gasLimit: this.computeExecutionGasLimitForNodesManagement(numNodes),
          addDataMovementGas: true
        }).build();
      }
      createTransactionForChangingServiceFee(options) {
        const dataParts = [
          "changeServiceFee",
          this.argSerializer.valuesToStrings([new smartcontracts_1.BigUIntValue(options.serviceFee)])[0]
        ];
        const gasLimit = this.config.gasLimitDelegationOperations + this.config.additionalGasLimitForDelegationOperations;
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.delegationContract,
          dataParts,
          gasLimit,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForModifyingDelegationCap(options) {
        const dataParts = [
          "modifyTotalDelegationCap",
          this.argSerializer.valuesToStrings([new smartcontracts_1.BigUIntValue(options.delegationCap)])[0]
        ];
        const gasLimit = this.config.gasLimitDelegationOperations + this.config.additionalGasLimitForDelegationOperations;
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.delegationContract,
          dataParts,
          gasLimit,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForSettingAutomaticActivation(options) {
        const dataParts = ["setAutomaticActivation", this.argSerializer.valuesToStrings([new smartcontracts_1.StringValue("true")])[0]];
        const gasLimit = this.config.gasLimitDelegationOperations + this.config.additionalGasLimitForDelegationOperations;
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.delegationContract,
          dataParts,
          gasLimit,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForUnsettingAutomaticActivation(options) {
        const dataParts = ["setAutomaticActivation", this.argSerializer.valuesToStrings([new smartcontracts_1.StringValue("false")])[0]];
        const gasLimit = this.config.gasLimitDelegationOperations + this.config.additionalGasLimitForDelegationOperations;
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.delegationContract,
          dataParts,
          gasLimit,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForSettingCapCheckOnRedelegateRewards(options) {
        const dataParts = [
          "setCheckCapOnReDelegateRewards",
          this.argSerializer.valuesToStrings([new smartcontracts_1.StringValue("true")])[0]
        ];
        const gasLimit = this.config.gasLimitDelegationOperations + this.config.additionalGasLimitForDelegationOperations;
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.delegationContract,
          dataParts,
          gasLimit,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForUnsettingCapCheckOnRedelegateRewards(options) {
        const dataParts = [
          "setCheckCapOnReDelegateRewards",
          this.argSerializer.valuesToStrings([new smartcontracts_1.StringValue("false")])[0]
        ];
        const gasLimit = this.config.gasLimitDelegationOperations + this.config.additionalGasLimitForDelegationOperations;
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.delegationContract,
          dataParts,
          gasLimit,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForSettingMetadata(options) {
        const dataParts = [
          "setMetaData",
          ...this.argSerializer.valuesToStrings([
            new smartcontracts_1.StringValue(options.name),
            new smartcontracts_1.StringValue(options.website),
            new smartcontracts_1.StringValue(options.identifier)
          ])
        ];
        const gasLimit = this.config.gasLimitDelegationOperations + this.config.additionalGasLimitForDelegationOperations;
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.delegationContract,
          dataParts,
          gasLimit,
          addDataMovementGas: true
        }).build();
      }
      computeExecutionGasLimitForNodesManagement(numNodes) {
        const additionalGasForAllNodes = this.config.additionalGasLimitPerValidatorNode * BigInt(numNodes);
        return this.config.gasLimitDelegationOperations + additionalGasForAllNodes;
      }
    };
    exports2.DelegationTransactionsFactory = DelegationTransactionsFactory;
  }
});

// node_modules/json-bigint/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/json-bigint/lib/stringify.js"(exports2, module2) {
    init_shim();
    var BigNumber2 = require_bignumber();
    var JSON2 = module2.exports;
    (function() {
      "use strict";
      function f4(n3) {
        return n3 < 10 ? "0" + n3 : n3;
      }
      var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
        // table of character substitutions
        "\b": "\\b",
        "	": "\\t",
        "\n": "\\n",
        "\f": "\\f",
        "\r": "\\r",
        '"': '\\"',
        "\\": "\\\\"
      }, rep;
      function quote(string2) {
        escapable.lastIndex = 0;
        return escapable.test(string2) ? '"' + string2.replace(escapable, function(a3) {
          var c4 = meta[a3];
          return typeof c4 === "string" ? c4 : "\\u" + ("0000" + a3.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string2 + '"';
      }
      function str(key, holder) {
        var i2, k4, v2, length2, mind = gap, partial, value = holder[key], isBigNumber = value != null && (value instanceof BigNumber2 || BigNumber2.isBigNumber(value));
        if (value && typeof value === "object" && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        if (typeof rep === "function") {
          value = rep.call(holder, key, value);
        }
        switch (typeof value) {
          case "string":
            if (isBigNumber) {
              return value;
            } else {
              return quote(value);
            }
          case "number":
            return isFinite(value) ? String(value) : "null";
          case "boolean":
          case "null":
          case "bigint":
            return String(value);
          case "object":
            if (!value) {
              return "null";
            }
            gap += indent;
            partial = [];
            if (Object.prototype.toString.apply(value) === "[object Array]") {
              length2 = value.length;
              for (i2 = 0; i2 < length2; i2 += 1) {
                partial[i2] = str(i2, value) || "null";
              }
              v2 = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
              gap = mind;
              return v2;
            }
            if (rep && typeof rep === "object") {
              length2 = rep.length;
              for (i2 = 0; i2 < length2; i2 += 1) {
                if (typeof rep[i2] === "string") {
                  k4 = rep[i2];
                  v2 = str(k4, value);
                  if (v2) {
                    partial.push(quote(k4) + (gap ? ": " : ":") + v2);
                  }
                }
              }
            } else {
              Object.keys(value).forEach(function(k5) {
                var v3 = str(k5, value);
                if (v3) {
                  partial.push(quote(k5) + (gap ? ": " : ":") + v3);
                }
              });
            }
            v2 = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
            gap = mind;
            return v2;
        }
      }
      if (typeof JSON2.stringify !== "function") {
        JSON2.stringify = function(value, replacer, space) {
          var i2;
          gap = "";
          indent = "";
          if (typeof space === "number") {
            for (i2 = 0; i2 < space; i2 += 1) {
              indent += " ";
            }
          } else if (typeof space === "string") {
            indent = space;
          }
          rep = replacer;
          if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
            throw new Error("JSON.stringify");
          }
          return str("", { "": value });
        };
      }
    })();
  }
});

// node_modules/json-bigint/lib/parse.js
var require_parse = __commonJS({
  "node_modules/json-bigint/lib/parse.js"(exports2, module2) {
    init_shim();
    var BigNumber2 = null;
    var suspectProtoRx2 = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/;
    var suspectConstructorRx2 = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
    var json_parse = function(options) {
      "use strict";
      var _options = {
        strict: false,
        // not being strict means do not generate syntax errors for "duplicate key"
        storeAsString: false,
        // toggles whether the values should be stored as BigNumber (default) or a string
        alwaysParseAsBig: false,
        // toggles whether all numbers should be Big
        useNativeBigInt: false,
        // toggles whether to use native BigInt instead of bignumber.js
        protoAction: "error",
        constructorAction: "error"
      };
      if (options !== void 0 && options !== null) {
        if (options.strict === true) {
          _options.strict = true;
        }
        if (options.storeAsString === true) {
          _options.storeAsString = true;
        }
        _options.alwaysParseAsBig = options.alwaysParseAsBig === true ? options.alwaysParseAsBig : false;
        _options.useNativeBigInt = options.useNativeBigInt === true ? options.useNativeBigInt : false;
        if (typeof options.constructorAction !== "undefined") {
          if (options.constructorAction === "error" || options.constructorAction === "ignore" || options.constructorAction === "preserve") {
            _options.constructorAction = options.constructorAction;
          } else {
            throw new Error(
              `Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${options.constructorAction}`
            );
          }
        }
        if (typeof options.protoAction !== "undefined") {
          if (options.protoAction === "error" || options.protoAction === "ignore" || options.protoAction === "preserve") {
            _options.protoAction = options.protoAction;
          } else {
            throw new Error(
              `Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${options.protoAction}`
            );
          }
        }
      }
      var at, ch, escapee = {
        '"': '"',
        "\\": "\\",
        "/": "/",
        b: "\b",
        f: "\f",
        n: "\n",
        r: "\r",
        t: "	"
      }, text, error = function(m3) {
        throw {
          name: "SyntaxError",
          message: m3,
          at,
          text
        };
      }, next = function(c4) {
        if (c4 && c4 !== ch) {
          error("Expected '" + c4 + "' instead of '" + ch + "'");
        }
        ch = text.charAt(at);
        at += 1;
        return ch;
      }, number = function() {
        var number2, string3 = "";
        if (ch === "-") {
          string3 = "-";
          next("-");
        }
        while (ch >= "0" && ch <= "9") {
          string3 += ch;
          next();
        }
        if (ch === ".") {
          string3 += ".";
          while (next() && ch >= "0" && ch <= "9") {
            string3 += ch;
          }
        }
        if (ch === "e" || ch === "E") {
          string3 += ch;
          next();
          if (ch === "-" || ch === "+") {
            string3 += ch;
            next();
          }
          while (ch >= "0" && ch <= "9") {
            string3 += ch;
            next();
          }
        }
        number2 = +string3;
        if (!isFinite(number2)) {
          error("Bad number");
        } else {
          if (BigNumber2 == null)
            BigNumber2 = require_bignumber();
          if (string3.length > 15)
            return _options.storeAsString ? string3 : _options.useNativeBigInt ? BigInt(string3) : new BigNumber2(string3);
          else
            return !_options.alwaysParseAsBig ? number2 : _options.useNativeBigInt ? BigInt(number2) : new BigNumber2(number2);
        }
      }, string2 = function() {
        var hex, i2, string3 = "", uffff;
        if (ch === '"') {
          var startAt = at;
          while (next()) {
            if (ch === '"') {
              if (at - 1 > startAt)
                string3 += text.substring(startAt, at - 1);
              next();
              return string3;
            }
            if (ch === "\\") {
              if (at - 1 > startAt)
                string3 += text.substring(startAt, at - 1);
              next();
              if (ch === "u") {
                uffff = 0;
                for (i2 = 0; i2 < 4; i2 += 1) {
                  hex = parseInt(next(), 16);
                  if (!isFinite(hex)) {
                    break;
                  }
                  uffff = uffff * 16 + hex;
                }
                string3 += String.fromCharCode(uffff);
              } else if (typeof escapee[ch] === "string") {
                string3 += escapee[ch];
              } else {
                break;
              }
              startAt = at;
            }
          }
        }
        error("Bad string");
      }, white = function() {
        while (ch && ch <= " ") {
          next();
        }
      }, word = function() {
        switch (ch) {
          case "t":
            next("t");
            next("r");
            next("u");
            next("e");
            return true;
          case "f":
            next("f");
            next("a");
            next("l");
            next("s");
            next("e");
            return false;
          case "n":
            next("n");
            next("u");
            next("l");
            next("l");
            return null;
        }
        error("Unexpected '" + ch + "'");
      }, value, array = function() {
        var array2 = [];
        if (ch === "[") {
          next("[");
          white();
          if (ch === "]") {
            next("]");
            return array2;
          }
          while (ch) {
            array2.push(value());
            white();
            if (ch === "]") {
              next("]");
              return array2;
            }
            next(",");
            white();
          }
        }
        error("Bad array");
      }, object = function() {
        var key, object2 = /* @__PURE__ */ Object.create(null);
        if (ch === "{") {
          next("{");
          white();
          if (ch === "}") {
            next("}");
            return object2;
          }
          while (ch) {
            key = string2();
            white();
            next(":");
            if (_options.strict === true && Object.hasOwnProperty.call(object2, key)) {
              error('Duplicate key "' + key + '"');
            }
            if (suspectProtoRx2.test(key) === true) {
              if (_options.protoAction === "error") {
                error("Object contains forbidden prototype property");
              } else if (_options.protoAction === "ignore") {
                value();
              } else {
                object2[key] = value();
              }
            } else if (suspectConstructorRx2.test(key) === true) {
              if (_options.constructorAction === "error") {
                error("Object contains forbidden constructor property");
              } else if (_options.constructorAction === "ignore") {
                value();
              } else {
                object2[key] = value();
              }
            } else {
              object2[key] = value();
            }
            white();
            if (ch === "}") {
              next("}");
              return object2;
            }
            next(",");
            white();
          }
        }
        error("Bad object");
      };
      value = function() {
        white();
        switch (ch) {
          case "{":
            return object();
          case "[":
            return array();
          case '"':
            return string2();
          case "-":
            return number();
          default:
            return ch >= "0" && ch <= "9" ? number() : word();
        }
      };
      return function(source, reviver) {
        var result;
        text = source + "";
        at = 0;
        ch = " ";
        result = value();
        white();
        if (ch) {
          error("Syntax error");
        }
        return typeof reviver === "function" ? function walk(holder, key) {
          var k4, v2, value2 = holder[key];
          if (value2 && typeof value2 === "object") {
            Object.keys(value2).forEach(function(k5) {
              v2 = walk(value2, k5);
              if (v2 !== void 0) {
                value2[k5] = v2;
              } else {
                delete value2[k5];
              }
            });
          }
          return reviver.call(holder, key, value2);
        }({ "": result }, "") : result;
      };
    };
    module2.exports = json_parse;
  }
});

// node_modules/json-bigint/index.js
var require_json_bigint = __commonJS({
  "node_modules/json-bigint/index.js"(exports2, module2) {
    init_shim();
    var json_stringify = require_stringify().stringify;
    var json_parse = require_parse();
    module2.exports = function(options) {
      return {
        parse: json_parse(options),
        stringify: json_stringify
      };
    };
    module2.exports.parse = json_parse();
    module2.exports.stringify = json_stringify;
  }
});

// node_modules/@multiversx/sdk-core/out/transactionsFactories/relayedTransactionsFactory.js
var require_relayedTransactionsFactory = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionsFactories/relayedTransactionsFactory.js"(exports2) {
    "use strict";
    init_shim();
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RelayedTransactionsFactory = void 0;
    var bignumber_js_1 = __importDefault2(require_bignumber());
    var address_1 = require_address();
    var errors_1 = require_errors();
    var smartcontracts_1 = require_smartcontracts();
    var transaction_1 = require_transaction();
    var JSONbig = require_json_bigint();
    var RelayedTransactionsFactory = class {
      constructor(options) {
        this.config = options.config;
      }
      createRelayedV1Transaction(options) {
        if (!options.innerTransaction.gasLimit) {
          throw new errors_1.ErrInvalidInnerTransaction("The gas limit is not set for the inner transaction");
        }
        if (!options.innerTransaction.signature.length) {
          throw new errors_1.ErrInvalidInnerTransaction("The inner transaction is not signed");
        }
        const serializedTransaction = this.prepareInnerTransactionForRelayedV1(options.innerTransaction);
        const data = `relayedTx@${import_buffer.Buffer.from(serializedTransaction).toString("hex")}`;
        const additionalGasForDataLength = this.config.gasLimitPerByte * BigInt(data.length);
        const gasLimit = this.config.minGasLimit + additionalGasForDataLength + options.innerTransaction.gasLimit;
        return new transaction_1.Transaction({
          chainID: this.config.chainID,
          sender: options.relayerAddress.bech32(),
          receiver: options.innerTransaction.sender,
          gasLimit,
          data: import_buffer.Buffer.from(data)
        });
      }
      createRelayedV2Transaction(options) {
        if (options.innerTransaction.gasLimit) {
          throw new errors_1.ErrInvalidInnerTransaction("The gas limit should not be set for the inner transaction");
        }
        if (!options.innerTransaction.signature.length) {
          throw new errors_1.ErrInvalidInnerTransaction("The inner transaction is not signed");
        }
        const { argumentsString } = new smartcontracts_1.ArgSerializer().valuesToString([
          new smartcontracts_1.AddressValue(address_1.Address.fromBech32(options.innerTransaction.receiver)),
          new smartcontracts_1.U64Value(new bignumber_js_1.default(options.innerTransaction.nonce.toString())),
          new smartcontracts_1.BytesValue(import_buffer.Buffer.from(options.innerTransaction.data)),
          new smartcontracts_1.BytesValue(import_buffer.Buffer.from(options.innerTransaction.signature))
        ]);
        const data = `relayedTxV2@${argumentsString}`;
        const additionalGasForDataLength = this.config.gasLimitPerByte * BigInt(data.length);
        const gasLimit = options.innerTransactionGasLimit + this.config.minGasLimit + additionalGasForDataLength;
        return new transaction_1.Transaction({
          sender: options.relayerAddress.bech32(),
          receiver: options.innerTransaction.sender,
          value: 0n,
          gasLimit,
          chainID: this.config.chainID,
          data: import_buffer.Buffer.from(data),
          version: options.innerTransaction.version,
          options: options.innerTransaction.options
        });
      }
      prepareInnerTransactionForRelayedV1(innerTransaction) {
        const txObject = {
          nonce: innerTransaction.nonce,
          sender: address_1.Address.fromBech32(innerTransaction.sender).pubkey().toString("base64"),
          receiver: address_1.Address.fromBech32(innerTransaction.receiver).pubkey().toString("base64"),
          value: innerTransaction.value,
          gasPrice: innerTransaction.gasPrice,
          gasLimit: innerTransaction.gasLimit,
          data: import_buffer.Buffer.from(innerTransaction.data).toString("base64"),
          signature: import_buffer.Buffer.from(innerTransaction.signature).toString("base64"),
          chainID: import_buffer.Buffer.from(innerTransaction.chainID).toString("base64"),
          version: innerTransaction.version,
          options: innerTransaction.options.valueOf() == 0 ? void 0 : innerTransaction.options,
          guardian: innerTransaction.guardian ? address_1.Address.fromBech32(innerTransaction.guardian).pubkey().toString("base64") : void 0,
          guardianSignature: innerTransaction.guardianSignature.length ? import_buffer.Buffer.from(innerTransaction.guardianSignature).toString("base64") : void 0,
          sndUserName: innerTransaction.senderUsername ? import_buffer.Buffer.from(innerTransaction.senderUsername).toString("base64") : void 0,
          rcvUserName: innerTransaction.receiverUsername ? import_buffer.Buffer.from(innerTransaction.receiverUsername).toString("base64") : void 0
        };
        return JSONbig.stringify(txObject);
      }
    };
    exports2.RelayedTransactionsFactory = RelayedTransactionsFactory;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/argumentErrorContext.js
var require_argumentErrorContext = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/argumentErrorContext.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ArgumentErrorContext = void 0;
    var errors_1 = require_errors();
    var ArgumentErrorContext = class {
      constructor(endpointName, argumentIndex, parameterDefinition) {
        this.endpointName = endpointName;
        this.argumentIndex = argumentIndex;
        this.parameterDefinition = parameterDefinition;
      }
      throwError(specificError) {
        throw new errors_1.ErrInvalidArgument(`Error when converting arguments for endpoint (endpoint name: ${this.endpointName}, argument index: ${this.argumentIndex}, name: ${this.parameterDefinition.name}, type: ${this.parameterDefinition.type})
Nested error: ${specificError}`);
      }
      convertError(native, typeName) {
        this.throwError(`Can't convert argument (argument: ${native}, type ${typeof native}), wanted type: ${typeName})`);
      }
      unhandledType(functionName, type) {
        this.throwError(`Unhandled type (function: ${functionName}, type: ${type})`);
      }
      guardSameLength(native, valueTypes) {
        native = native || [];
        if (native.length != valueTypes.length) {
          this.throwError(`Incorrect composite type length: have ${native.length}, expected ${valueTypes.length} (argument: ${native})`);
        }
      }
      guardHasField(native, fieldName) {
        native = native || {};
        if (!(fieldName in native)) {
          this.throwError(`Struct argument does not contain a field named "${fieldName}" (argument: ${JSON.stringify(native)})`);
        }
      }
    };
    exports2.ArgumentErrorContext = ArgumentErrorContext;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/nativeSerializer.js
var require_nativeSerializer = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/nativeSerializer.js"(exports2) {
    "use strict";
    init_shim();
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NativeSerializer = void 0;
    var bignumber_js_1 = __importDefault2(require_bignumber());
    var address_1 = require_address();
    var errors_1 = require_errors();
    var utils_codec_1 = require_utils_codec();
    var argumentErrorContext_1 = require_argumentErrorContext();
    var typesystem_1 = require_typesystem();
    var NativeSerializer;
    (function(NativeSerializer2) {
      function nativeToTypedValues(args, endpoint) {
        args = args || [];
        checkArgumentsCardinality(args, endpoint);
        if (hasNonCountedVariadicParameter(endpoint)) {
          args = repackNonCountedVariadicParameters(args, endpoint);
        } else {
        }
        let parameters = endpoint.input;
        let values = [];
        for (let i2 = 0; i2 < parameters.length; i2++) {
          let parameter = parameters[i2];
          let errorContext = new argumentErrorContext_1.ArgumentErrorContext(endpoint.name, i2, parameter);
          let value = convertToTypedValue(args[i2], parameter.type, errorContext);
          values.push(value);
        }
        return values;
      }
      NativeSerializer2.nativeToTypedValues = nativeToTypedValues;
      function checkArgumentsCardinality(args, endpoint) {
        const { min, max } = getArgumentsCardinality(endpoint.input);
        if (!(min <= args.length && args.length <= max)) {
          throw new errors_1.ErrInvalidArgument(`Wrong number of arguments for endpoint ${endpoint.name}: expected between ${min} and ${max} arguments, have ${args.length}`);
        }
      }
      function hasNonCountedVariadicParameter(endpoint) {
        const lastParameter = endpoint.input[endpoint.input.length - 1];
        return lastParameter?.type instanceof typesystem_1.VariadicType && !lastParameter.type.isCounted;
      }
      function repackNonCountedVariadicParameters(args, endpoint) {
        const lastEndpointParamIndex = endpoint.input.length - 1;
        const argAtIndex = args[lastEndpointParamIndex];
        if (argAtIndex?.belongsToTypesystem) {
          const isVariadicValue = argAtIndex.hasClassOrSuperclass(typesystem_1.VariadicValue.ClassName);
          if (!isVariadicValue) {
            throw new errors_1.ErrInvalidArgument(`Wrong argument type for endpoint ${endpoint.name}: typed value provided; expected variadic type, have ${argAtIndex.getClassName()}`);
          }
        } else {
          args[lastEndpointParamIndex] = args.slice(lastEndpointParamIndex);
        }
        return args;
      }
      function getArgumentsCardinality(parameters) {
        let reversed = [...parameters].reverse();
        let min = parameters.length;
        let max = parameters.length;
        let variadic = false;
        if (reversed.length > 0 && reversed[0].type.getCardinality().isComposite()) {
          max = Infinity;
          variadic = true;
        }
        for (let parameter of reversed) {
          if (parameter.type.getCardinality().isSingular()) {
            break;
          }
          min -= 1;
        }
        return { min, max, variadic };
      }
      NativeSerializer2.getArgumentsCardinality = getArgumentsCardinality;
      function convertToTypedValue(value, type, errorContext) {
        if (value && value.belongsToTypesystem) {
          return value;
        }
        if (type instanceof typesystem_1.OptionType) {
          return toOptionValue(value, type, errorContext);
        }
        if (type instanceof typesystem_1.OptionalType) {
          return toOptionalValue(value, type, errorContext);
        }
        if (type instanceof typesystem_1.VariadicType) {
          return toVariadicValue(value, type, errorContext);
        }
        if (type instanceof typesystem_1.CompositeType) {
          return toCompositeValue(value, type, errorContext);
        }
        if (type instanceof typesystem_1.TupleType) {
          return toTupleValue(value, type, errorContext);
        }
        if (type instanceof typesystem_1.StructType) {
          return toStructValue(value, type, errorContext);
        }
        if (type instanceof typesystem_1.ListType) {
          return toListValue(value, type, errorContext);
        }
        if (type instanceof typesystem_1.PrimitiveType) {
          return toPrimitive(value, type, errorContext);
        }
        if (type instanceof typesystem_1.EnumType) {
          return toEnumValue(value, type, errorContext);
        }
        errorContext.throwError(`convertToTypedValue: unhandled type ${type}`);
      }
      function toOptionValue(native, type, errorContext) {
        if (native == null) {
          return typesystem_1.OptionValue.newMissing();
        }
        let converted = convertToTypedValue(native, type.getFirstTypeParameter(), errorContext);
        return typesystem_1.OptionValue.newProvided(converted);
      }
      function toOptionalValue(native, type, errorContext) {
        if (native == null) {
          return new typesystem_1.OptionalValue(type);
        }
        let converted = convertToTypedValue(native, type.getFirstTypeParameter(), errorContext);
        return new typesystem_1.OptionalValue(type, converted);
      }
      function toVariadicValue(native, type, errorContext) {
        if (type.isCounted) {
          throw new errors_1.ErrInvalidArgument(`Counted variadic arguments must be explicitly typed. E.g. use "VariadicValue.fromItemsCounted()" or "new VariadicValue()"`);
        }
        if (native == null) {
          native = [];
        }
        if (native.map === void 0) {
          errorContext.convertError(native, "Variadic");
        }
        let converted = native.map(function(item) {
          return convertToTypedValue(item, type.getFirstTypeParameter(), errorContext);
        });
        return new typesystem_1.VariadicValue(type, converted);
      }
      function toListValue(native, type, errorContext) {
        if (native.map === void 0) {
          errorContext.convertError(native, "List");
        }
        let converted = native.map(function(item) {
          return convertToTypedValue(item, type.getFirstTypeParameter(), errorContext);
        });
        return new typesystem_1.List(type, converted);
      }
      function toCompositeValue(native, type, errorContext) {
        let typedValues = [];
        let typeParameters = type.getTypeParameters();
        errorContext.guardSameLength(native, typeParameters);
        for (let i2 = 0; i2 < typeParameters.length; i2++) {
          typedValues.push(convertToTypedValue(native[i2], typeParameters[i2], errorContext));
        }
        return new typesystem_1.CompositeValue(type, typedValues);
      }
      function toTupleValue(native, type, errorContext) {
        let typedValues = [];
        const fields = type.getFieldsDefinitions();
        errorContext.guardSameLength(native, fields);
        for (let i2 = 0; i2 < fields.length; i2++) {
          typedValues.push(convertToTypedValue(native[i2], fields[i2].type, errorContext));
        }
        return typesystem_1.Tuple.fromItems(typedValues);
      }
      function toStructValue(native, type, errorContext) {
        let structFieldValues = [];
        const fields = type.getFieldsDefinitions();
        for (let i2 = 0; i2 < fields.length; i2++) {
          const fieldName = fields[i2].name;
          errorContext.guardHasField(native, fieldName);
          const fieldNativeValue = native[fieldName];
          const fieldTypedValue = convertToTypedValue(fieldNativeValue, fields[i2].type, errorContext);
          structFieldValues.push(new typesystem_1.Field(fieldTypedValue, fieldName));
        }
        return new typesystem_1.Struct(type, structFieldValues);
      }
      function toPrimitive(native, type, errorContext) {
        if (type instanceof typesystem_1.NumericalType) {
          let number = new bignumber_js_1.default(native);
          return convertNumericalType(number, type, errorContext);
        }
        if (type instanceof typesystem_1.BytesType) {
          return convertNativeToBytesValue(native, errorContext);
        }
        if (type instanceof typesystem_1.AddressType) {
          return new typesystem_1.AddressValue(convertNativeToAddress(native, errorContext));
        }
        if (type instanceof typesystem_1.BooleanType) {
          return new typesystem_1.BooleanValue(native);
        }
        if (type instanceof typesystem_1.TokenIdentifierType) {
          return new typesystem_1.TokenIdentifierValue(convertNativeToString(native, errorContext));
        }
        errorContext.throwError(`(function: toPrimitive) unsupported type ${type}`);
      }
      function toEnumValue(native, type, errorContext) {
        if (typeof native === "number") {
          return typesystem_1.EnumValue.fromDiscriminant(type, native);
        }
        if (typeof native === "string") {
          return typesystem_1.EnumValue.fromName(type, native);
        }
        if (typeof native === "object") {
          errorContext.guardHasField(native, "name");
          const variant = type.getVariantByName(native.name);
          errorContext.guardHasField(native, "fields");
          const nativeFields = native.fields;
          const fieldValues = [];
          const fields = variant.getFieldsDefinitions();
          for (let i2 = 0; i2 < fields.length; i2++) {
            const fieldName = fields[i2].name;
            errorContext.guardHasField(nativeFields, fieldName);
            const fieldNativeValue = nativeFields[fieldName];
            const fieldTypedValue = convertToTypedValue(fieldNativeValue, fields[i2].type, errorContext);
            fieldValues.push(new typesystem_1.Field(fieldTypedValue, fieldName));
          }
          return new typesystem_1.EnumValue(type, variant, fieldValues);
        }
        errorContext.throwError(`(function: toEnumValue) unsupported native type ${typeof native}`);
      }
      function convertNativeToBytesValue(native, errorContext) {
        const innerValue = native.valueOf();
        if (native === void 0) {
          errorContext.convertError(native, "BytesValue");
        }
        if (native instanceof import_buffer.Buffer) {
          return new typesystem_1.BytesValue(native);
        }
        if (typeof native === "string") {
          return typesystem_1.BytesValue.fromUTF8(native);
        }
        if (innerValue instanceof import_buffer.Buffer) {
          return new typesystem_1.BytesValue(innerValue);
        }
        if (typeof innerValue === "number") {
          return typesystem_1.BytesValue.fromHex(utils_codec_1.numberToPaddedHex(innerValue));
        }
        errorContext.convertError(native, "BytesValue");
      }
      function convertNativeToString(native, errorContext) {
        if (native === void 0) {
          errorContext.convertError(native, "Buffer");
        }
        if (native instanceof import_buffer.Buffer) {
          return native.toString();
        }
        if (typeof native === "string") {
          return native;
        }
        errorContext.convertError(native, "Buffer");
      }
      function convertNativeToAddress(native, errorContext) {
        if (native.bech32) {
          return native;
        }
        if (native.getAddress) {
          return native.getAddress();
        }
        switch (native.constructor) {
          case import_buffer.Buffer:
          case String:
            return new address_1.Address(native);
          default:
            errorContext.convertError(native, "Address");
        }
      }
      NativeSerializer2.convertNativeToAddress = convertNativeToAddress;
      function convertNumericalType(number, type, errorContext) {
        switch (type.constructor) {
          case typesystem_1.U8Type:
            return new typesystem_1.U8Value(number);
          case typesystem_1.I8Type:
            return new typesystem_1.I8Value(number);
          case typesystem_1.U16Type:
            return new typesystem_1.U16Value(number);
          case typesystem_1.I16Type:
            return new typesystem_1.I16Value(number);
          case typesystem_1.U32Type:
            return new typesystem_1.U32Value(number);
          case typesystem_1.I32Type:
            return new typesystem_1.I32Value(number);
          case typesystem_1.U64Type:
            return new typesystem_1.U64Value(number);
          case typesystem_1.I64Type:
            return new typesystem_1.I64Value(number);
          case typesystem_1.BigUIntType:
            return new typesystem_1.BigUIntValue(number);
          case typesystem_1.BigIntType:
            return new typesystem_1.BigIntValue(number);
          default:
            errorContext.unhandledType("convertNumericalType", type);
        }
      }
    })(NativeSerializer = exports2.NativeSerializer || (exports2.NativeSerializer = {}));
  }
});

// node_modules/@multiversx/sdk-core/out/transactionsFactories/tokenTransfersDataBuilder.js
var require_tokenTransfersDataBuilder = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionsFactories/tokenTransfersDataBuilder.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TokenTransfersDataBuilder = void 0;
    var argSerializer_1 = require_argSerializer();
    var typesystem_1 = require_typesystem();
    var tokens_1 = require_tokens();
    var TokenTransfersDataBuilder = class {
      constructor() {
        this.tokenComputer = new tokens_1.TokenComputer();
        this.argsSerializer = new argSerializer_1.ArgSerializer();
      }
      buildDataPartsForESDTTransfer(transfer) {
        const args = this.argsSerializer.valuesToStrings([
          new typesystem_1.TokenIdentifierValue(transfer.token.identifier),
          new typesystem_1.BigUIntValue(transfer.amount)
        ]);
        return ["ESDTTransfer", ...args];
      }
      buildDataPartsForSingleESDTNFTTransfer(transfer, receiver) {
        const token = transfer.token;
        const identifier = this.tokenComputer.extractIdentifierFromExtendedIdentifier(token.identifier);
        const args = this.argsSerializer.valuesToStrings([
          new typesystem_1.TokenIdentifierValue(identifier),
          new typesystem_1.BigUIntValue(token.nonce),
          new typesystem_1.BigUIntValue(transfer.amount),
          new typesystem_1.AddressValue(receiver)
        ]);
        return ["ESDTNFTTransfer", ...args];
      }
      buildDataPartsForMultiESDTNFTTransfer(receiver, transfers) {
        const argsTyped = [new typesystem_1.AddressValue(receiver), new typesystem_1.U32Value(transfers.length)];
        for (const transfer of transfers) {
          const identifier = this.tokenComputer.extractIdentifierFromExtendedIdentifier(transfer.token.identifier);
          argsTyped.push(...[
            new typesystem_1.TokenIdentifierValue(identifier),
            new typesystem_1.BigUIntValue(transfer.token.nonce),
            new typesystem_1.BigUIntValue(transfer.amount)
          ]);
        }
        const args = this.argsSerializer.valuesToStrings(argsTyped);
        return ["MultiESDTNFTTransfer", ...args];
      }
    };
    exports2.TokenTransfersDataBuilder = TokenTransfersDataBuilder;
  }
});

// node_modules/@multiversx/sdk-core/out/transactionsFactories/smartContractTransactionsFactory.js
var require_smartContractTransactionsFactory = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionsFactories/smartContractTransactionsFactory.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SmartContractTransactionsFactory = void 0;
    var address_1 = require_address();
    var constants_1 = require_constants();
    var errors_1 = require_errors();
    var logger_1 = require_logger();
    var smartcontracts_1 = require_smartcontracts();
    var nativeSerializer_1 = require_nativeSerializer();
    var tokens_1 = require_tokens();
    var utils_codec_1 = require_utils_codec();
    var tokenTransfersDataBuilder_1 = require_tokenTransfersDataBuilder();
    var transactionBuilder_1 = require_transactionBuilder();
    var SmartContractTransactionsFactory2 = class {
      constructor(options) {
        this.config = options.config;
        this.abi = options.abi;
        this.tokenComputer = new tokens_1.TokenComputer();
        this.dataArgsBuilder = new tokenTransfersDataBuilder_1.TokenTransfersDataBuilder();
      }
      createTransactionForDeploy(options) {
        const nativeTransferAmount = options.nativeTransferAmount ?? 0n;
        const isUpgradeable = options.isUpgradeable ?? true;
        const isReadable = options.isReadable ?? true;
        const isPayable = options.isPayable ?? false;
        const isPayableBySmartContract = options.isPayableBySmartContract ?? true;
        const args = options.arguments || [];
        const metadata = new smartcontracts_1.CodeMetadata(isUpgradeable, isReadable, isPayable, isPayableBySmartContract);
        const dataParts = [utils_codec_1.byteArrayToHex(options.bytecode), utils_codec_1.byteArrayToHex(constants_1.VM_TYPE_WASM_VM), metadata.toString()];
        const endpoint = this.abi?.constructorDefinition;
        const preparedArgs = this.argsToDataParts(args, endpoint);
        dataParts.push(...preparedArgs);
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: address_1.Address.fromBech32(constants_1.CONTRACT_DEPLOY_ADDRESS),
          dataParts,
          gasLimit: options.gasLimit,
          addDataMovementGas: false,
          amount: nativeTransferAmount
        }).build();
      }
      createTransactionForExecute(options) {
        const args = options.arguments || [];
        const tokenTransfer = options.tokenTransfers || [];
        const nativeTransferAmount = options.nativeTransferAmount ?? 0n;
        const numberOfTokens = tokenTransfer.length;
        if (nativeTransferAmount && numberOfTokens) {
          throw new errors_1.ErrBadUsage("Can't send both native tokens and custom tokens(ESDT/NFT)");
        }
        let receiver = options.contract;
        let dataParts = [];
        if (numberOfTokens === 1) {
          const transfer = tokenTransfer[0];
          if (this.tokenComputer.isFungible(transfer.token)) {
            dataParts = this.dataArgsBuilder.buildDataPartsForESDTTransfer(transfer);
          } else {
            dataParts = this.dataArgsBuilder.buildDataPartsForSingleESDTNFTTransfer(transfer, receiver);
            receiver = options.sender;
          }
        } else if (numberOfTokens > 1) {
          dataParts = this.dataArgsBuilder.buildDataPartsForMultiESDTNFTTransfer(receiver, tokenTransfer);
          receiver = options.sender;
        }
        dataParts.push(dataParts.length ? utils_codec_1.utf8ToHex(options.function) : options.function);
        const endpoint = this.abi?.getEndpoint(options.function);
        const preparedArgs = this.argsToDataParts(args, endpoint);
        dataParts.push(...preparedArgs);
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver,
          dataParts,
          gasLimit: options.gasLimit,
          addDataMovementGas: false,
          amount: nativeTransferAmount
        }).build();
      }
      createTransactionForUpgrade(options) {
        const nativeTransferAmount = options.nativeTransferAmount ?? 0n;
        const isUpgradeable = options.isUpgradeable ?? true;
        const isReadable = options.isReadable ?? true;
        const isPayable = options.isPayable ?? false;
        const isPayableBySmartContract = options.isPayableBySmartContract ?? true;
        const args = options.arguments || [];
        const metadata = new smartcontracts_1.CodeMetadata(isUpgradeable, isReadable, isPayable, isPayableBySmartContract);
        const dataParts = ["upgradeContract", utils_codec_1.byteArrayToHex(options.bytecode), metadata.toString()];
        const endpoint = this.getEndpointForUpgrade();
        const preparedArgs = this.argsToDataParts(args, endpoint);
        dataParts.push(...preparedArgs);
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.contract,
          dataParts,
          gasLimit: options.gasLimit,
          addDataMovementGas: false,
          amount: nativeTransferAmount
        }).build();
      }
      getEndpointForUpgrade() {
        if (!this.abi) {
          return void 0;
        }
        try {
          return this.abi.getEndpoint("upgrade");
        } catch (error) {
          logger_1.Logger.warn("In the ABI, cannot find the 'upgrade' endpoint definition. Will use the constructor definition (fallback).");
          return this.abi.constructorDefinition;
        }
      }
      createTransactionForClaimingDeveloperRewards(options) {
        const dataParts = ["ClaimDeveloperRewards"];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.contract,
          dataParts,
          gasLimit: this.config.gasLimitClaimDeveloperRewards,
          addDataMovementGas: false
        }).build();
      }
      createTransactionForChangingOwnerAddress(options) {
        const dataParts = ["ChangeOwnerAddress", address_1.Address.fromBech32(options.newOwner.bech32()).toHex()];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.contract,
          dataParts,
          gasLimit: this.config.gasLimitChangeOwnerAddress,
          addDataMovementGas: false
        }).build();
      }
      argsToDataParts(args, endpoint) {
        if (endpoint) {
          const typedArgs = nativeSerializer_1.NativeSerializer.nativeToTypedValues(args, endpoint);
          return new smartcontracts_1.ArgSerializer().valuesToStrings(typedArgs);
        }
        if (this.areArgsOfTypedValue(args)) {
          return new smartcontracts_1.ArgSerializer().valuesToStrings(args);
        }
        throw new errors_1.Err("Can't convert args to TypedValues");
      }
      areArgsOfTypedValue(args) {
        for (const arg of args) {
          if (!arg.belongsToTypesystem) {
            return false;
          }
        }
        return true;
      }
    };
    exports2.SmartContractTransactionsFactory = SmartContractTransactionsFactory2;
  }
});

// node_modules/@multiversx/sdk-core/out/transactionsFactories/tokenManagementTransactionsFactory.js
var require_tokenManagementTransactionsFactory = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionsFactories/tokenManagementTransactionsFactory.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TokenManagementTransactionsFactory = void 0;
    var address_1 = require_address();
    var constants_1 = require_constants();
    var logger_1 = require_logger();
    var smartcontracts_1 = require_smartcontracts();
    var transactionBuilder_1 = require_transactionBuilder();
    var TokenManagementTransactionsFactory2 = class {
      constructor(options) {
        this.config = options.config;
        this.argSerializer = new smartcontracts_1.ArgSerializer();
        this.trueAsString = "true";
        this.falseAsString = "false";
      }
      createTransactionForIssuingFungible(options) {
        this.notifyAboutUnsettingBurnRoleGlobally();
        const args = [
          new smartcontracts_1.StringValue(options.tokenName),
          new smartcontracts_1.StringValue(options.tokenTicker),
          new smartcontracts_1.BigUIntValue(options.initialSupply),
          new smartcontracts_1.BigUIntValue(options.numDecimals),
          new smartcontracts_1.StringValue("canFreeze"),
          new smartcontracts_1.StringValue(this.boolToString(options.canFreeze)),
          new smartcontracts_1.StringValue("canWipe"),
          new smartcontracts_1.StringValue(this.boolToString(options.canWipe)),
          new smartcontracts_1.StringValue("canPause"),
          new smartcontracts_1.StringValue(this.boolToString(options.canPause)),
          new smartcontracts_1.StringValue("canChangeOwner"),
          new smartcontracts_1.StringValue(this.boolToString(options.canChangeOwner)),
          new smartcontracts_1.StringValue("canUpgrade"),
          new smartcontracts_1.StringValue(this.boolToString(options.canUpgrade)),
          new smartcontracts_1.StringValue("canAddSpecialRoles"),
          new smartcontracts_1.StringValue(this.boolToString(options.canAddSpecialRoles))
        ];
        const dataParts = ["issue", ...this.argSerializer.valuesToStrings(args)];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: address_1.Address.fromBech32(constants_1.ESDT_CONTRACT_ADDRESS),
          dataParts,
          gasLimit: this.config.gasLimitIssue,
          addDataMovementGas: true,
          amount: this.config.issueCost
        }).build();
      }
      createTransactionForIssuingSemiFungible(options) {
        this.notifyAboutUnsettingBurnRoleGlobally();
        const args = [
          new smartcontracts_1.StringValue(options.tokenName),
          new smartcontracts_1.StringValue(options.tokenTicker),
          new smartcontracts_1.StringValue("canFreeze"),
          new smartcontracts_1.StringValue(this.boolToString(options.canFreeze)),
          new smartcontracts_1.StringValue("canWipe"),
          new smartcontracts_1.StringValue(this.boolToString(options.canWipe)),
          new smartcontracts_1.StringValue("canPause"),
          new smartcontracts_1.StringValue(this.boolToString(options.canPause)),
          new smartcontracts_1.StringValue("canTransferNFTCreateRole"),
          new smartcontracts_1.StringValue(this.boolToString(options.canTransferNFTCreateRole)),
          new smartcontracts_1.StringValue("canChangeOwner"),
          new smartcontracts_1.StringValue(this.boolToString(options.canChangeOwner)),
          new smartcontracts_1.StringValue("canUpgrade"),
          new smartcontracts_1.StringValue(this.boolToString(options.canUpgrade)),
          new smartcontracts_1.StringValue("canAddSpecialRoles"),
          new smartcontracts_1.StringValue(this.boolToString(options.canAddSpecialRoles))
        ];
        const dataParts = ["issueSemiFungible", ...this.argSerializer.valuesToStrings(args)];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: address_1.Address.fromBech32(constants_1.ESDT_CONTRACT_ADDRESS),
          dataParts,
          gasLimit: this.config.gasLimitIssue,
          addDataMovementGas: true,
          amount: this.config.issueCost
        }).build();
      }
      createTransactionForIssuingNonFungible(options) {
        this.notifyAboutUnsettingBurnRoleGlobally();
        const args = [
          new smartcontracts_1.StringValue(options.tokenName),
          new smartcontracts_1.StringValue(options.tokenTicker),
          new smartcontracts_1.StringValue("canFreeze"),
          new smartcontracts_1.StringValue(this.boolToString(options.canFreeze)),
          new smartcontracts_1.StringValue("canWipe"),
          new smartcontracts_1.StringValue(this.boolToString(options.canWipe)),
          new smartcontracts_1.StringValue("canPause"),
          new smartcontracts_1.StringValue(this.boolToString(options.canPause)),
          new smartcontracts_1.StringValue("canTransferNFTCreateRole"),
          new smartcontracts_1.StringValue(this.boolToString(options.canTransferNFTCreateRole)),
          new smartcontracts_1.StringValue("canChangeOwner"),
          new smartcontracts_1.StringValue(this.boolToString(options.canChangeOwner)),
          new smartcontracts_1.StringValue("canUpgrade"),
          new smartcontracts_1.StringValue(this.boolToString(options.canUpgrade)),
          new smartcontracts_1.StringValue("canAddSpecialRoles"),
          new smartcontracts_1.StringValue(this.boolToString(options.canAddSpecialRoles))
        ];
        const dataParts = ["issueNonFungible", ...this.argSerializer.valuesToStrings(args)];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: address_1.Address.fromBech32(constants_1.ESDT_CONTRACT_ADDRESS),
          dataParts,
          gasLimit: this.config.gasLimitIssue,
          addDataMovementGas: true,
          amount: this.config.issueCost
        }).build();
      }
      createTransactionForRegisteringMetaESDT(options) {
        this.notifyAboutUnsettingBurnRoleGlobally();
        const args = [
          new smartcontracts_1.StringValue(options.tokenName),
          new smartcontracts_1.StringValue(options.tokenTicker),
          new smartcontracts_1.BigUIntValue(options.numDecimals),
          new smartcontracts_1.StringValue("canFreeze"),
          new smartcontracts_1.StringValue(this.boolToString(options.canFreeze)),
          new smartcontracts_1.StringValue("canWipe"),
          new smartcontracts_1.StringValue(this.boolToString(options.canWipe)),
          new smartcontracts_1.StringValue("canPause"),
          new smartcontracts_1.StringValue(this.boolToString(options.canPause)),
          new smartcontracts_1.StringValue("canTransferNFTCreateRole"),
          new smartcontracts_1.StringValue(this.boolToString(options.canTransferNFTCreateRole)),
          new smartcontracts_1.StringValue("canChangeOwner"),
          new smartcontracts_1.StringValue(this.boolToString(options.canChangeOwner)),
          new smartcontracts_1.StringValue("canUpgrade"),
          new smartcontracts_1.StringValue(this.boolToString(options.canUpgrade)),
          new smartcontracts_1.StringValue("canAddSpecialRoles"),
          new smartcontracts_1.StringValue(this.boolToString(options.canAddSpecialRoles))
        ];
        const dataParts = ["registerMetaESDT", ...this.argSerializer.valuesToStrings(args)];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: address_1.Address.fromBech32(constants_1.ESDT_CONTRACT_ADDRESS),
          dataParts,
          gasLimit: this.config.gasLimitIssue,
          addDataMovementGas: true,
          amount: this.config.issueCost
        }).build();
      }
      createTransactionForRegisteringAndSettingRoles(options) {
        this.notifyAboutUnsettingBurnRoleGlobally();
        const dataParts = [
          "registerAndSetAllRoles",
          ...this.argSerializer.valuesToStrings([
            new smartcontracts_1.StringValue(options.tokenName),
            new smartcontracts_1.StringValue(options.tokenTicker),
            new smartcontracts_1.StringValue(options.tokenType),
            new smartcontracts_1.BigUIntValue(options.numDecimals)
          ])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: address_1.Address.fromBech32(constants_1.ESDT_CONTRACT_ADDRESS),
          dataParts,
          gasLimit: this.config.gasLimitIssue,
          addDataMovementGas: true,
          amount: this.config.issueCost
        }).build();
      }
      createTransactionForSettingBurnRoleGlobally(options) {
        const dataParts = [
          "setBurnRoleGlobally",
          ...this.argSerializer.valuesToStrings([new smartcontracts_1.StringValue(options.tokenIdentifier)])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: address_1.Address.fromBech32(constants_1.ESDT_CONTRACT_ADDRESS),
          dataParts,
          gasLimit: this.config.gasLimitToggleBurnRoleGlobally,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForUnsettingBurnRoleGlobally(options) {
        const dataParts = [
          "unsetBurnRoleGlobally",
          ...this.argSerializer.valuesToStrings([new smartcontracts_1.StringValue(options.tokenIdentifier)])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: address_1.Address.fromBech32(constants_1.ESDT_CONTRACT_ADDRESS),
          dataParts,
          gasLimit: this.config.gasLimitToggleBurnRoleGlobally,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForSettingSpecialRoleOnFungibleToken(options) {
        const args = [new smartcontracts_1.StringValue(options.tokenIdentifier), new smartcontracts_1.AddressValue(options.user)];
        options.addRoleLocalMint ? args.push(new smartcontracts_1.StringValue("ESDTRoleLocalMint")) : 0;
        options.addRoleLocalBurn ? args.push(new smartcontracts_1.StringValue("ESDTRoleLocalBurn")) : 0;
        options.addRoleESDTTransferRole ? args.push(new smartcontracts_1.StringValue("ESDTTransferRole")) : 0;
        const dataParts = ["setSpecialRole", ...this.argSerializer.valuesToStrings(args)];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: address_1.Address.fromBech32(constants_1.ESDT_CONTRACT_ADDRESS),
          dataParts,
          gasLimit: this.config.gasLimitSetSpecialRole,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForSettingSpecialRoleOnSemiFungibleToken(options) {
        const args = [new smartcontracts_1.StringValue(options.tokenIdentifier), new smartcontracts_1.AddressValue(options.user)];
        options.addRoleNFTCreate ? args.push(new smartcontracts_1.StringValue("ESDTRoleNFTCreate")) : 0;
        options.addRoleNFTBurn ? args.push(new smartcontracts_1.StringValue("ESDTRoleNFTBurn")) : 0;
        options.addRoleNFTAddQuantity ? args.push(new smartcontracts_1.StringValue("ESDTRoleNFTAddQuantity")) : 0;
        options.addRoleESDTTransferRole ? args.push(new smartcontracts_1.StringValue("ESDTTransferRole")) : 0;
        const dataParts = ["setSpecialRole", ...this.argSerializer.valuesToStrings(args)];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: address_1.Address.fromBech32(constants_1.ESDT_CONTRACT_ADDRESS),
          dataParts,
          gasLimit: this.config.gasLimitSetSpecialRole,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForSettingSpecialRoleOnMetaESDT(options) {
        return this.createTransactionForSettingSpecialRoleOnSemiFungibleToken(options);
      }
      createTransactionForSettingSpecialRoleOnNonFungibleToken(options) {
        const args = [new smartcontracts_1.StringValue(options.tokenIdentifier), new smartcontracts_1.AddressValue(options.user)];
        options.addRoleNFTCreate ? args.push(new smartcontracts_1.StringValue("ESDTRoleNFTCreate")) : 0;
        options.addRoleNFTBurn ? args.push(new smartcontracts_1.StringValue("ESDTRoleNFTBurn")) : 0;
        options.addRoleNFTUpdateAttributes ? args.push(new smartcontracts_1.StringValue("ESDTRoleNFTUpdateAttributes")) : 0;
        options.addRoleNFTAddURI ? args.push(new smartcontracts_1.StringValue("ESDTRoleNFTAddURI")) : 0;
        options.addRoleESDTTransferRole ? args.push(new smartcontracts_1.StringValue("ESDTTransferRole")) : 0;
        const dataParts = ["setSpecialRole", ...this.argSerializer.valuesToStrings(args)];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: address_1.Address.fromBech32(constants_1.ESDT_CONTRACT_ADDRESS),
          dataParts,
          gasLimit: this.config.gasLimitSetSpecialRole,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForCreatingNFT(options) {
        const dataParts = [
          "ESDTNFTCreate",
          ...this.argSerializer.valuesToStrings([
            new smartcontracts_1.StringValue(options.tokenIdentifier),
            new smartcontracts_1.BigUIntValue(options.initialQuantity),
            new smartcontracts_1.StringValue(options.name),
            new smartcontracts_1.BigUIntValue(options.royalties),
            new smartcontracts_1.StringValue(options.hash),
            new smartcontracts_1.BytesValue(import_buffer.Buffer.from(options.attributes)),
            ...options.uris.map((uri) => new smartcontracts_1.StringValue(uri))
          ])
        ];
        const nftData = options.name + options.hash + options.attributes + options.uris.join("");
        const storageGasLimit = this.config.gasLimitStorePerByte + BigInt(nftData.length);
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitEsdtNftCreate + storageGasLimit,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForPausing(options) {
        const dataParts = ["pause", ...this.argSerializer.valuesToStrings([new smartcontracts_1.StringValue(options.tokenIdentifier)])];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitPausing,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForUnpausing(options) {
        const dataParts = [
          "unPause",
          ...this.argSerializer.valuesToStrings([new smartcontracts_1.StringValue(options.tokenIdentifier)])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitPausing,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForFreezing(options) {
        const dataParts = [
          "freeze",
          ...this.argSerializer.valuesToStrings([
            new smartcontracts_1.StringValue(options.tokenIdentifier),
            new smartcontracts_1.AddressValue(options.user)
          ])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitFreezing,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForUnfreezing(options) {
        const dataParts = [
          "UnFreeze",
          ...this.argSerializer.valuesToStrings([
            new smartcontracts_1.StringValue(options.tokenIdentifier),
            new smartcontracts_1.AddressValue(options.user)
          ])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitFreezing,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForWiping(options) {
        const dataParts = [
          "wipe",
          ...this.argSerializer.valuesToStrings([
            new smartcontracts_1.StringValue(options.tokenIdentifier),
            new smartcontracts_1.AddressValue(options.user)
          ])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitWiping,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForLocalMint(options) {
        const dataParts = [
          "ESDTLocalMint",
          ...this.argSerializer.valuesToStrings([
            new smartcontracts_1.StringValue(options.tokenIdentifier),
            new smartcontracts_1.BigUIntValue(options.supplyToMint)
          ])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitEsdtLocalMint,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForLocalBurning(options) {
        const dataParts = [
          "ESDTLocalBurn",
          ...this.argSerializer.valuesToStrings([
            new smartcontracts_1.StringValue(options.tokenIdentifier),
            new smartcontracts_1.BigUIntValue(options.supplyToBurn)
          ])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitEsdtLocalBurn,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForUpdatingAttributes(options) {
        const dataParts = [
          "ESDTNFTUpdateAttributes",
          ...this.argSerializer.valuesToStrings([
            new smartcontracts_1.StringValue(options.tokenIdentifier),
            new smartcontracts_1.BigUIntValue(options.tokenNonce),
            new smartcontracts_1.BytesValue(import_buffer.Buffer.from(options.attributes))
          ])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitEsdtNftUpdateAttributes,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForAddingQuantity(options) {
        const dataParts = [
          "ESDTNFTAddQuantity",
          ...this.argSerializer.valuesToStrings([
            new smartcontracts_1.StringValue(options.tokenIdentifier),
            new smartcontracts_1.BigUIntValue(options.tokenNonce),
            new smartcontracts_1.BigUIntValue(options.quantityToAdd)
          ])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitEsdtNftAddQuantity,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForBurningQuantity(options) {
        const dataParts = [
          "ESDTNFTBurn",
          ...this.argSerializer.valuesToStrings([
            new smartcontracts_1.StringValue(options.tokenIdentifier),
            new smartcontracts_1.BigUIntValue(options.tokenNonce),
            new smartcontracts_1.BigUIntValue(options.quantityToBurn)
          ])
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitEsdtNftBurn,
          addDataMovementGas: true
        }).build();
      }
      notifyAboutUnsettingBurnRoleGlobally() {
        logger_1.Logger.info(`
==========
IMPORTANT!
==========
You are about to issue (register) a new token. This will set the role "ESDTRoleBurnForAll" (globally).
Once the token is registered, you can unset this role by calling "unsetBurnRoleGlobally" (in a separate transaction).`);
      }
      boolToString(value) {
        if (value) {
          return this.trueAsString;
        }
        return this.falseAsString;
      }
    };
    exports2.TokenManagementTransactionsFactory = TokenManagementTransactionsFactory2;
  }
});

// node_modules/@multiversx/sdk-core/out/transactionsFactories/transactionsFactoryConfig.js
var require_transactionsFactoryConfig = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionsFactories/transactionsFactoryConfig.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransactionsFactoryConfig = void 0;
    var constants_1 = require_constants();
    var TransactionsFactoryConfig2 = class {
      constructor(options) {
        this.chainID = options.chainID;
        this.addressHrp = constants_1.DEFAULT_HRP;
        this.minGasLimit = 50000n;
        this.gasLimitPerByte = 1500n;
        this.gasLimitIssue = 60000000n;
        this.gasLimitToggleBurnRoleGlobally = 60000000n;
        this.gasLimitEsdtLocalMint = 300000n;
        this.gasLimitEsdtLocalBurn = 300000n;
        this.gasLimitSetSpecialRole = 60000000n;
        this.gasLimitPausing = 60000000n;
        this.gasLimitFreezing = 60000000n;
        this.gasLimitWiping = 60000000n;
        this.gasLimitEsdtNftCreate = 3000000n;
        this.gasLimitEsdtNftUpdateAttributes = 1000000n;
        this.gasLimitEsdtNftAddQuantity = 1000000n;
        this.gasLimitEsdtNftBurn = 1000000n;
        this.gasLimitStorePerByte = 10000n;
        this.issueCost = 50000000000000000n;
        this.gasLimitStake = 5000000n;
        this.gasLimitUnstake = 5000000n;
        this.gasLimitUnbond = 5000000n;
        this.gasLimitCreateDelegationContract = 50000000n;
        this.gasLimitDelegationOperations = 1000000n;
        this.additionalGasLimitPerValidatorNode = 6000000n;
        this.additionalGasLimitForDelegationOperations = 10000000n;
        this.gasLimitSaveKeyValue = 100000n;
        this.gasLimitPersistPerByte = 1000n;
        this.gasLimitSetGuardian = 250000n;
        this.gasLimitGuardAccount = 250000n;
        this.gasLimitUnguardAccount = 250000n;
        this.gasLimitESDTTransfer = 200000n;
        this.gasLimitESDTNFTTransfer = 200000n;
        this.gasLimitMultiESDTNFTTransfer = 200000n;
        this.gasLimitClaimDeveloperRewards = 6000000n;
        this.gasLimitChangeOwnerAddress = 6000000n;
      }
    };
    exports2.TransactionsFactoryConfig = TransactionsFactoryConfig2;
  }
});

// node_modules/@multiversx/sdk-core/out/transactionsFactories/transferTransactionsFactory.js
var require_transferTransactionsFactory = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionsFactories/transferTransactionsFactory.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransferTransactionsFactory = void 0;
    var errors_1 = require_errors();
    var smartcontracts_1 = require_smartcontracts();
    var tokens_1 = require_tokens();
    var transaction_1 = require_transaction();
    var transactionPayload_1 = require_transactionPayload();
    var tokenTransfersDataBuilder_1 = require_tokenTransfersDataBuilder();
    var transactionBuilder_1 = require_transactionBuilder();
    var ADDITIONAL_GAS_FOR_ESDT_TRANSFER = 1e5;
    var ADDITIONAL_GAS_FOR_ESDT_NFT_TRANSFER = 8e5;
    var TransferTransactionsFactory2 = class {
      /**
       * Should be instantiated using `Config` and `TokenComputer`.
       * Instantiating this class using GasEstimator represents the legacy version of this class.
       * The legacy version contains methods like `createEGLDTransfer`, `createESDTTransfer`, `createESDTNFTTransfer` and `createMultiESDTNFTTransfer`.
       * This was done in order to minimize breaking changes in client code.
       */
      constructor(options) {
        if (this.isGasEstimator(options)) {
          this.gasEstimator = options;
        } else {
          this.config = options.config;
          this.tokenComputer = new tokens_1.TokenComputer();
          this.tokenTransfersDataBuilder = new tokenTransfersDataBuilder_1.TokenTransfersDataBuilder();
        }
      }
      isGasEstimator(options) {
        return typeof options === "object" && typeof options.forEGLDTransfer === "function" && typeof options.forESDTTransfer === "function" && typeof options.forESDTNFTTransfer === "function" && typeof options.forMultiESDTNFTTransfer === "function";
      }
      isGasEstimatorDefined() {
        return this.gasEstimator !== void 0;
      }
      ensureMembersAreDefined() {
        if (this.config === void 0) {
          throw new errors_1.Err("'config' is not defined");
        }
        if (this.tokenTransfersDataBuilder === void 0) {
          throw new errors_1.Err("`dataArgsBuilder is not defined`");
        }
        if (this.tokenComputer === void 0) {
          throw new errors_1.Err("`tokenComputer is not defined`");
        }
      }
      createTransactionForNativeTokenTransfer(options) {
        this.ensureMembersAreDefined();
        const data = options.data || new Uint8Array();
        return new transaction_1.Transaction({
          sender: options.sender.bech32(),
          receiver: options.receiver.bech32(),
          chainID: this.config.chainID,
          gasLimit: this.computeGasForMoveBalance(this.config, data),
          data,
          value: options.nativeAmount
        });
      }
      createTransactionForESDTTokenTransfer(options) {
        this.ensureMembersAreDefined();
        const numberOfTransfers = options.tokenTransfers.length;
        if (numberOfTransfers === 0) {
          throw new errors_1.ErrBadUsage("No token transfer has been provided");
        }
        if (numberOfTransfers === 1) {
          return this.createSingleESDTTransferTransaction(options);
        }
        const dataParts = this.tokenTransfersDataBuilder.buildDataPartsForMultiESDTNFTTransfer(options.receiver, options.tokenTransfers);
        const extraGasForTransfer = this.config.gasLimitMultiESDTNFTTransfer * BigInt(numberOfTransfers) + BigInt(ADDITIONAL_GAS_FOR_ESDT_NFT_TRANSFER);
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: extraGasForTransfer,
          addDataMovementGas: true
        }).build();
      }
      /**
       * This is a legacy method. Can only be used if the class was instantiated using `GasEstimator`.
       * Use {@link createTransactionForNativeTokenTransfer} instead.
       */
      createEGLDTransfer(args) {
        if (!this.isGasEstimatorDefined()) {
          throw new errors_1.Err("You are calling a legacy function to create an EGLD transfer transaction. If this is your intent, then instantiate the class using a `GasEstimator`. Or, instead, use the new, recommended `createTransactionForNativeTokenTransfer` method.");
        }
        const dataLength = args.data?.length() || 0;
        const estimatedGasLimit = this.gasEstimator.forEGLDTransfer(dataLength);
        return new transaction_1.Transaction({
          nonce: args.nonce,
          value: args.value,
          receiver: args.receiver,
          sender: args.sender,
          gasPrice: args.gasPrice,
          gasLimit: args.gasLimit || estimatedGasLimit,
          data: args.data,
          chainID: args.chainID
        });
      }
      /**
       * This is a legacy method. Can only be used if the class was instantiated using `GasEstimator`.
       * Use {@link createTransactionForESDTTokenTransfer} instead.
       */
      createESDTTransfer(args) {
        if (!this.isGasEstimatorDefined()) {
          throw new errors_1.Err("You are calling a legacy function to create an ESDT transfer transaction. If this is your intent, then instantiate the class using a `GasEstimator`. Or, instead, use the new, recommended `createTransactionForESDTTokenTransfer` method.");
        }
        const { argumentsString } = new smartcontracts_1.ArgSerializer().valuesToString([
          // The token identifier
          smartcontracts_1.BytesValue.fromUTF8(args.tokenTransfer.tokenIdentifier),
          // The transfered amount
          new smartcontracts_1.BigUIntValue(args.tokenTransfer.valueOf())
        ]);
        const data = `ESDTTransfer@${argumentsString}`;
        const transactionPayload = new transactionPayload_1.TransactionPayload(data);
        const dataLength = transactionPayload.length() || 0;
        const estimatedGasLimit = this.gasEstimator.forESDTTransfer(dataLength);
        return new transaction_1.Transaction({
          nonce: args.nonce,
          receiver: args.receiver,
          sender: args.sender,
          gasPrice: args.gasPrice,
          gasLimit: args.gasLimit || estimatedGasLimit,
          data: transactionPayload,
          chainID: args.chainID
        });
      }
      /**
       * This is a legacy method. Can only be used if the class was instantiated using `GasEstimator`.
       * Use {@link createTransactionForESDTTokenTransfer} instead.
       */
      createESDTNFTTransfer(args) {
        if (!this.isGasEstimatorDefined()) {
          throw new errors_1.Err("You are calling a legacy function to create an ESDTNFT transfer transaction. If this is your intent, then instantiate the class using a `GasEstimator`. Or, instead, use the new, recommended `createTransactionForESDTTokenTransfer` method.");
        }
        const { argumentsString } = new smartcontracts_1.ArgSerializer().valuesToString([
          // The token identifier
          smartcontracts_1.BytesValue.fromUTF8(args.tokenTransfer.tokenIdentifier),
          // The nonce of the token
          new smartcontracts_1.U64Value(args.tokenTransfer.nonce),
          // The transferred quantity
          new smartcontracts_1.BigUIntValue(args.tokenTransfer.valueOf()),
          // The destination address
          new smartcontracts_1.AddressValue(args.destination)
        ]);
        const data = `ESDTNFTTransfer@${argumentsString}`;
        const transactionPayload = new transactionPayload_1.TransactionPayload(data);
        const dataLength = transactionPayload.length() || 0;
        const estimatedGasLimit = this.gasEstimator.forESDTNFTTransfer(dataLength);
        return new transaction_1.Transaction({
          nonce: args.nonce,
          receiver: args.sender,
          sender: args.sender,
          gasPrice: args.gasPrice,
          gasLimit: args.gasLimit || estimatedGasLimit,
          data: transactionPayload,
          chainID: args.chainID
        });
      }
      /**
       * This is a legacy method. Can only be used if the class was instantiated using `GasEstimator`.
       * Use {@link createTransactionForESDTTokenTransfer} instead.
       */
      createMultiESDTNFTTransfer(args) {
        if (!this.isGasEstimatorDefined()) {
          throw new errors_1.Err("You are calling a legacy function to create a MultiESDTNFT transfer transaction. If this is your intent, then instantiate the class using a `GasEstimator`. Or, instead, use the new, recommended `createTransactionForESDTTokenTransfer` method.");
        }
        const parts = [
          // The destination address
          new smartcontracts_1.AddressValue(args.destination),
          // Number of tokens
          new smartcontracts_1.U16Value(args.tokenTransfers.length)
        ];
        for (const payment of args.tokenTransfers) {
          parts.push(...[
            // The token identifier
            smartcontracts_1.BytesValue.fromUTF8(payment.tokenIdentifier),
            // The nonce of the token
            new smartcontracts_1.U64Value(payment.nonce),
            // The transfered quantity
            new smartcontracts_1.BigUIntValue(payment.valueOf())
          ]);
        }
        const { argumentsString } = new smartcontracts_1.ArgSerializer().valuesToString(parts);
        const data = `MultiESDTNFTTransfer@${argumentsString}`;
        const transactionPayload = new transactionPayload_1.TransactionPayload(data);
        const dataLength = transactionPayload.length() || 0;
        const estimatedGasLimit = this.gasEstimator.forMultiESDTNFTTransfer(dataLength, args.tokenTransfers.length);
        return new transaction_1.Transaction({
          nonce: args.nonce,
          receiver: args.sender,
          sender: args.sender,
          gasPrice: args.gasPrice,
          gasLimit: args.gasLimit || estimatedGasLimit,
          data: transactionPayload,
          chainID: args.chainID
        });
      }
      createSingleESDTTransferTransaction(options) {
        this.ensureMembersAreDefined();
        let dataParts = [];
        const transfer = options.tokenTransfers[0];
        let extraGasForTransfer = 0n;
        let receiver = options.receiver;
        if (this.tokenComputer.isFungible(transfer.token)) {
          dataParts = this.tokenTransfersDataBuilder.buildDataPartsForESDTTransfer(transfer);
          extraGasForTransfer = this.config.gasLimitESDTTransfer + BigInt(ADDITIONAL_GAS_FOR_ESDT_TRANSFER);
        } else {
          dataParts = this.tokenTransfersDataBuilder.buildDataPartsForSingleESDTNFTTransfer(transfer, receiver);
          extraGasForTransfer = this.config.gasLimitESDTNFTTransfer + BigInt(ADDITIONAL_GAS_FOR_ESDT_NFT_TRANSFER);
          receiver = options.sender;
        }
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver,
          dataParts,
          gasLimit: extraGasForTransfer,
          addDataMovementGas: true
        }).build();
      }
      computeGasForMoveBalance(config, data) {
        return config.minGasLimit + config.gasLimitPerByte * BigInt(data.length);
      }
    };
    exports2.TransferTransactionsFactory = TransferTransactionsFactory2;
  }
});

// node_modules/@multiversx/sdk-core/out/transactionsFactories/accountTransactionsFactory.js
var require_accountTransactionsFactory = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionsFactories/accountTransactionsFactory.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AccountTransactionsFactory = void 0;
    var address_1 = require_address();
    var transactionBuilder_1 = require_transactionBuilder();
    var AccountTransactionsFactory = class {
      constructor(options) {
        this.config = options.config;
      }
      createTransactionForSavingKeyValue(options) {
        const functionName = "SaveKeyValue";
        const keyValueParts = this.computeDataPartsForSavingKeyValue(options.keyValuePairs);
        const dataParts = [functionName, ...keyValueParts];
        const extraGas = this.computeExtraGasForSavingKeyValue(options.keyValuePairs);
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: extraGas,
          addDataMovementGas: true
        }).build();
      }
      computeExtraGasForSavingKeyValue(keyValuePairs) {
        let extraGas = 0n;
        keyValuePairs.forEach((value, key) => {
          extraGas += this.config.gasLimitPersistPerByte * BigInt(key.length + value.length) + this.config.gasLimitStorePerByte * BigInt(value.length);
        });
        return extraGas + this.config.gasLimitSaveKeyValue;
      }
      computeDataPartsForSavingKeyValue(keyValuePairs) {
        const dataParts = [];
        keyValuePairs.forEach((value, key) => {
          dataParts.push(...[import_buffer.Buffer.from(key).toString("hex"), import_buffer.Buffer.from(value).toString("hex")]);
        });
        return dataParts;
      }
      createTransactionForSettingGuardian(options) {
        const dataParts = [
          "SetGuardian",
          address_1.Address.fromBech32(options.guardianAddress.bech32()).toHex(),
          import_buffer.Buffer.from(options.serviceID).toString("hex")
        ];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitSetGuardian,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForGuardingAccount(options) {
        const dataParts = ["GuardAccount"];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitGuardAccount,
          addDataMovementGas: true
        }).build();
      }
      createTransactionForUnguardingAccount(options) {
        const dataParts = ["UnGuardAccount"];
        return new transactionBuilder_1.TransactionBuilder({
          config: this.config,
          sender: options.sender,
          receiver: options.sender,
          dataParts,
          gasLimit: this.config.gasLimitUnguardAccount,
          addDataMovementGas: true
        }).build();
      }
    };
    exports2.AccountTransactionsFactory = AccountTransactionsFactory;
  }
});

// node_modules/@multiversx/sdk-core/out/transactionsFactories/index.js
var require_transactionsFactories = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionsFactories/index.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m3, exports3) {
      for (var p3 in m3)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3))
          __createBinding2(exports3, m3, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_delegationTransactionsFactory(), exports2);
    __exportStar2(require_relayedTransactionsFactory(), exports2);
    __exportStar2(require_smartContractTransactionsFactory(), exports2);
    __exportStar2(require_tokenManagementTransactionsFactory(), exports2);
    __exportStar2(require_transactionsFactoryConfig(), exports2);
    __exportStar2(require_transferTransactionsFactory(), exports2);
    __exportStar2(require_accountTransactionsFactory(), exports2);
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/interactionChecker.js
var require_interactionChecker = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/interactionChecker.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k4 in mod2)
          if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k4))
            __createBinding2(result, mod2, k4);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InteractionChecker = void 0;
    var errors = __importStar2(require_errors());
    var bignumber_js_1 = __importDefault2(require_bignumber());
    var InteractionChecker = class {
      checkInteraction(interaction, definition) {
        this.checkPayable(interaction, definition);
        this.checkArguments(interaction, definition);
      }
      checkPayable(interaction, definition) {
        let hasValue = !new bignumber_js_1.default(interaction.getValue().toString()).isZero();
        let isPayableInEGLD = definition.modifiers.isPayableInEGLD();
        if (hasValue && !isPayableInEGLD) {
          throw new errors.ErrContractInteraction("cannot send EGLD value to non-payable");
        }
      }
      checkArguments(interaction, definition) {
        let formalArguments = definition.input;
        let actualArguments = interaction.getArguments();
        let numFormalArguments = formalArguments.length;
        let numActualArguments = actualArguments.length;
        if (numFormalArguments != numActualArguments) {
          throw new errors.ErrContractInteraction(`bad arguments, expected: ${numFormalArguments}, got: ${numActualArguments}`);
        }
        for (let i2 = 0; i2 < numFormalArguments; i2++) {
          let expectedType = formalArguments[i2].type;
          let argument = actualArguments[i2];
          let actualType = argument.getType();
          let ok = expectedType.isAssignableFrom(actualType);
          if (!ok) {
            throw new errors.ErrContractInteraction(`type mismatch at index ${i2}, expected: ${expectedType}, got: ${actualType}`);
          }
        }
      }
    };
    exports2.InteractionChecker = InteractionChecker;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/query.js
var require_query = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/query.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Query = void 0;
    var address_1 = require_address();
    var argSerializer_1 = require_argSerializer();
    var Query2 = class {
      constructor(obj) {
        this.caller = obj.caller || address_1.Address.empty();
        this.address = obj.address;
        this.func = obj.func;
        this.args = obj.args || [];
        this.value = obj.value || 0;
      }
      getEncodedArguments() {
        return new argSerializer_1.ArgSerializer().valuesToStrings(this.args);
      }
    };
    exports2.Query = Query2;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/interaction.js
var require_interaction = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/interaction.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Interaction = void 0;
    var address_1 = require_address();
    var compatibility_1 = require_compatibility();
    var constants_1 = require_constants();
    var tokens_1 = require_tokens();
    var transactionsFactories_1 = require_transactionsFactories();
    var interactionChecker_1 = require_interactionChecker();
    var query_1 = require_query();
    var Interaction = class {
      constructor(contract, func, args) {
        this.nonce = 0;
        this.value = "0";
        this.gasLimit = 0;
        this.gasPrice = void 0;
        this.chainID = "";
        this.querent = address_1.Address.empty();
        this.sender = address_1.Address.empty();
        this.version = constants_1.TRANSACTION_VERSION_DEFAULT;
        this.contract = contract;
        this.function = func;
        this.args = args;
        this.tokenTransfers = [];
      }
      getContractAddress() {
        return this.contract.getAddress();
      }
      getFunction() {
        return this.function;
      }
      getEndpoint() {
        return this.contract.getEndpoint(this.function);
      }
      getArguments() {
        return this.args;
      }
      getValue() {
        return this.value;
      }
      getTokenTransfers() {
        return this.tokenTransfers;
      }
      getGasLimit() {
        return this.gasLimit;
      }
      getExplicitReceiver() {
        return this.explicitReceiver;
      }
      buildTransaction() {
        compatibility_1.Compatibility.guardAddressIsSetAndNonZero(this.sender, "'sender' of interaction", "use interaction.withSender()");
        const factoryConfig = new transactionsFactories_1.TransactionsFactoryConfig({ chainID: this.chainID.valueOf() });
        const factory = new transactionsFactories_1.SmartContractTransactionsFactory({
          config: factoryConfig
        });
        const transaction = factory.createTransactionForExecute({
          sender: this.sender,
          contract: this.contract.getAddress(),
          function: this.function.valueOf(),
          gasLimit: BigInt(this.gasLimit.valueOf()),
          arguments: this.args,
          nativeTransferAmount: BigInt(this.value.toString()),
          tokenTransfers: this.tokenTransfers
        });
        transaction.chainID = this.chainID.valueOf();
        transaction.nonce = BigInt(this.nonce.valueOf());
        transaction.version = this.version;
        if (this.gasPrice) {
          transaction.gasPrice = BigInt(this.gasPrice.valueOf());
        }
        return transaction;
      }
      buildQuery() {
        return new query_1.Query({
          address: this.contract.getAddress(),
          func: this.function,
          args: this.args,
          // Value will be set using "withValue()".
          value: this.value,
          caller: this.querent
        });
      }
      withValue(value) {
        this.value = value;
        return this;
      }
      withSingleESDTTransfer(transfer) {
        this.tokenTransfers = [transfer].map((transfer2) => new tokens_1.TokenTransfer(transfer2));
        return this;
      }
      withSingleESDTNFTTransfer(transfer) {
        this.tokenTransfers = [transfer].map((transfer2) => new tokens_1.TokenTransfer(transfer2));
        return this;
      }
      withMultiESDTNFTTransfer(transfers) {
        this.tokenTransfers = transfers.map((transfer) => new tokens_1.TokenTransfer(transfer));
        return this;
      }
      withGasLimit(gasLimit) {
        this.gasLimit = gasLimit;
        return this;
      }
      withGasPrice(gasPrice) {
        this.gasPrice = gasPrice;
        return this;
      }
      withNonce(nonce) {
        this.nonce = nonce;
        return this;
      }
      useThenIncrementNonceOf(account) {
        return this.withNonce(account.getNonceThenIncrement());
      }
      withChainID(chainID) {
        this.chainID = chainID;
        return this;
      }
      withSender(sender) {
        this.sender = sender;
        return this;
      }
      withVersion(version2) {
        this.version = version2;
        return this;
      }
      /**
       * Sets the "caller" field on contract queries.
       */
      withQuerent(querent) {
        this.querent = querent;
        return this;
      }
      withExplicitReceiver(receiver) {
        this.explicitReceiver = receiver;
        return this;
      }
      /**
       * To perform custom checking, extend {@link Interaction} and override this method.
       */
      check() {
        new interactionChecker_1.InteractionChecker().checkInteraction(this, this.getEndpoint());
        return this;
      }
    };
    exports2.Interaction = Interaction;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/interface.js
var require_interface = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/interface.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@multiversx/sdk-transaction-decoder/node_modules/bech32/dist/index.js
var require_dist = __commonJS({
  "node_modules/@multiversx/sdk-transaction-decoder/node_modules/bech32/dist/index.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bech32m = exports2.bech32 = void 0;
    var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
    var ALPHABET_MAP = {};
    for (let z3 = 0; z3 < ALPHABET.length; z3++) {
      const x3 = ALPHABET.charAt(z3);
      ALPHABET_MAP[x3] = z3;
    }
    function polymodStep(pre) {
      const b4 = pre >> 25;
      return (pre & 33554431) << 5 ^ -(b4 >> 0 & 1) & 996825010 ^ -(b4 >> 1 & 1) & 642813549 ^ -(b4 >> 2 & 1) & 513874426 ^ -(b4 >> 3 & 1) & 1027748829 ^ -(b4 >> 4 & 1) & 705979059;
    }
    function prefixChk(prefix) {
      let chk = 1;
      for (let i2 = 0; i2 < prefix.length; ++i2) {
        const c4 = prefix.charCodeAt(i2);
        if (c4 < 33 || c4 > 126)
          return "Invalid prefix (" + prefix + ")";
        chk = polymodStep(chk) ^ c4 >> 5;
      }
      chk = polymodStep(chk);
      for (let i2 = 0; i2 < prefix.length; ++i2) {
        const v2 = prefix.charCodeAt(i2);
        chk = polymodStep(chk) ^ v2 & 31;
      }
      return chk;
    }
    function convert(data, inBits, outBits, pad) {
      let value = 0;
      let bits = 0;
      const maxV = (1 << outBits) - 1;
      const result = [];
      for (let i2 = 0; i2 < data.length; ++i2) {
        value = value << inBits | data[i2];
        bits += inBits;
        while (bits >= outBits) {
          bits -= outBits;
          result.push(value >> bits & maxV);
        }
      }
      if (pad) {
        if (bits > 0) {
          result.push(value << outBits - bits & maxV);
        }
      } else {
        if (bits >= inBits)
          return "Excess padding";
        if (value << outBits - bits & maxV)
          return "Non-zero padding";
      }
      return result;
    }
    function toWords(bytes) {
      return convert(bytes, 8, 5, true);
    }
    function fromWordsUnsafe(words) {
      const res = convert(words, 5, 8, false);
      if (Array.isArray(res))
        return res;
    }
    function fromWords(words) {
      const res = convert(words, 5, 8, false);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    function getLibraryFromEncoding(encoding) {
      let ENCODING_CONST;
      if (encoding === "bech32") {
        ENCODING_CONST = 1;
      } else {
        ENCODING_CONST = 734539939;
      }
      function encode5(prefix, words, LIMIT) {
        LIMIT = LIMIT || 90;
        if (prefix.length + 7 + words.length > LIMIT)
          throw new TypeError("Exceeds length limit");
        prefix = prefix.toLowerCase();
        let chk = prefixChk(prefix);
        if (typeof chk === "string")
          throw new Error(chk);
        let result = prefix + "1";
        for (let i2 = 0; i2 < words.length; ++i2) {
          const x3 = words[i2];
          if (x3 >> 5 !== 0)
            throw new Error("Non 5-bit word");
          chk = polymodStep(chk) ^ x3;
          result += ALPHABET.charAt(x3);
        }
        for (let i2 = 0; i2 < 6; ++i2) {
          chk = polymodStep(chk);
        }
        chk ^= ENCODING_CONST;
        for (let i2 = 0; i2 < 6; ++i2) {
          const v2 = chk >> (5 - i2) * 5 & 31;
          result += ALPHABET.charAt(v2);
        }
        return result;
      }
      function __decode(str, LIMIT) {
        LIMIT = LIMIT || 90;
        if (str.length < 8)
          return str + " too short";
        if (str.length > LIMIT)
          return "Exceeds length limit";
        const lowered = str.toLowerCase();
        const uppered = str.toUpperCase();
        if (str !== lowered && str !== uppered)
          return "Mixed-case string " + str;
        str = lowered;
        const split = str.lastIndexOf("1");
        if (split === -1)
          return "No separator character for " + str;
        if (split === 0)
          return "Missing prefix for " + str;
        const prefix = str.slice(0, split);
        const wordChars = str.slice(split + 1);
        if (wordChars.length < 6)
          return "Data too short";
        let chk = prefixChk(prefix);
        if (typeof chk === "string")
          return chk;
        const words = [];
        for (let i2 = 0; i2 < wordChars.length; ++i2) {
          const c4 = wordChars.charAt(i2);
          const v2 = ALPHABET_MAP[c4];
          if (v2 === void 0)
            return "Unknown character " + c4;
          chk = polymodStep(chk) ^ v2;
          if (i2 + 6 >= wordChars.length)
            continue;
          words.push(v2);
        }
        if (chk !== ENCODING_CONST)
          return "Invalid checksum for " + str;
        return { prefix, words };
      }
      function decodeUnsafe(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === "object")
          return res;
      }
      function decode6(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === "object")
          return res;
        throw new Error(res);
      }
      return {
        decodeUnsafe,
        decode: decode6,
        encode: encode5,
        toWords,
        fromWordsUnsafe,
        fromWords
      };
    }
    exports2.bech32 = getLibraryFromEncoding("bech32");
    exports2.bech32m = getLibraryFromEncoding("bech32m");
  }
});

// node_modules/@multiversx/sdk-transaction-decoder/lib/src/transaction.decoder.js
var require_transaction_decoder = __commonJS({
  "node_modules/@multiversx/sdk-transaction-decoder/lib/src/transaction.decoder.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TokenTransferProperties = exports2.TransactionMetadataTransfer = exports2.TransactionMetadata = exports2.TransactionToDecode = exports2.TransactionDecoder = void 0;
    var bech32_1 = require_dist();
    var TransactionDecoder = class {
      getTransactionMetadata(transaction) {
        const metadata = this.getNormalTransactionMetadata(transaction);
        const esdtMetadata = this.getEsdtTransactionMetadata(metadata);
        if (esdtMetadata) {
          return esdtMetadata;
        }
        const nftMetadata = this.getNftTransferMetadata(metadata);
        if (nftMetadata) {
          return nftMetadata;
        }
        const multiMetadata = this.getMultiTransferMetadata(metadata);
        if (multiMetadata) {
          return multiMetadata;
        }
        return metadata;
      }
      getNormalTransactionMetadata(transaction) {
        const metadata = new TransactionMetadata();
        metadata.sender = transaction.sender;
        metadata.receiver = transaction.receiver;
        metadata.value = BigInt(transaction.value);
        if (transaction.data) {
          const decodedData = this.base64Decode(transaction.data);
          const dataComponents = decodedData.split("@");
          const args = dataComponents.slice(1);
          if (args.every((x3) => this.isSmartContractArgument(x3))) {
            metadata.functionName = dataComponents[0];
            metadata.functionArgs = args;
          }
          if (metadata.functionName === "relayedTx" && metadata.functionArgs && metadata.functionArgs.length === 1) {
            try {
              const relayedTransaction = JSON.parse(this.hexToString(metadata.functionArgs[0]));
              relayedTransaction.value = relayedTransaction.value.toString();
              relayedTransaction.sender = this.bech32Encode(this.base64ToHex(relayedTransaction.sender));
              relayedTransaction.receiver = this.bech32Encode(this.base64ToHex(relayedTransaction.receiver));
              return this.getNormalTransactionMetadata(relayedTransaction);
            } catch (error) {
            }
          }
          if (metadata.functionName === "relayedTxV2" && metadata.functionArgs && metadata.functionArgs.length === 4) {
            try {
              const relayedTransaction = new TransactionToDecode();
              relayedTransaction.sender = transaction.receiver;
              relayedTransaction.receiver = this.bech32Encode(metadata.functionArgs[0]);
              relayedTransaction.data = this.base64Encode(this.hexToString(metadata.functionArgs[2]));
              relayedTransaction.value = "0";
              return this.getNormalTransactionMetadata(relayedTransaction);
            } catch (error) {
            }
          }
        }
        return metadata;
      }
      getMultiTransferMetadata(metadata) {
        if (metadata.sender !== metadata.receiver) {
          return void 0;
        }
        if (metadata.functionName !== "MultiESDTNFTTransfer") {
          return void 0;
        }
        const args = metadata.functionArgs;
        if (!args) {
          return void 0;
        }
        if (args.length < 3) {
          return void 0;
        }
        if (!this.isAddressValid(args[0])) {
          return void 0;
        }
        const receiver = this.bech32Encode(args[0]);
        const transferCount = this.hexToNumber(args[1]);
        const result = new TransactionMetadata();
        if (!result.transfers) {
          result.transfers = [];
        }
        let index = 2;
        for (let i2 = 0; i2 < transferCount; i2++) {
          const identifier = this.hexToString(args[index++]);
          const nonce = args[index++];
          const value = this.hexToBigInt(args[index++]);
          if (nonce) {
            result.transfers.push({
              value,
              properties: {
                collection: identifier,
                identifier: `${identifier}-${nonce}`
              }
            });
          } else {
            result.transfers.push({
              value,
              properties: {
                token: identifier
              }
            });
          }
        }
        result.sender = metadata.sender;
        result.receiver = receiver;
        if (args.length > index) {
          result.functionName = this.hexToString(args[index++]);
          result.functionArgs = args.slice(index++);
        }
        return result;
      }
      getNftTransferMetadata(metadata) {
        if (metadata.sender !== metadata.receiver) {
          return void 0;
        }
        if (metadata.functionName !== "ESDTNFTTransfer") {
          return void 0;
        }
        const args = metadata.functionArgs;
        if (!args) {
          return void 0;
        }
        if (args.length < 4) {
          return void 0;
        }
        if (!this.isAddressValid(args[3])) {
          return void 0;
        }
        const collectionIdentifier = this.hexToString(args[0]);
        const nonce = args[1];
        const value = this.hexToBigInt(args[2]);
        const receiver = this.bech32Encode(args[3]);
        const result = new TransactionMetadata();
        result.sender = metadata.sender;
        result.receiver = receiver;
        result.value = value;
        if (args.length > 4) {
          result.functionName = this.hexToString(args[4]);
          result.functionArgs = args.slice(5);
        }
        result.transfers = [{
          value,
          properties: {
            collection: collectionIdentifier,
            identifier: `${collectionIdentifier}-${nonce}`
          }
        }];
        return result;
      }
      base64Encode(str) {
        return import_buffer.Buffer.from(str).toString("base64");
      }
      base64Decode(str) {
        return import_buffer.Buffer.from(str, "base64").toString("binary");
      }
      hexToNumber(hex) {
        return parseInt(hex, 16);
      }
      getEsdtTransactionMetadata(metadata) {
        if (metadata.functionName !== "ESDTTransfer") {
          return void 0;
        }
        const args = metadata.functionArgs;
        if (!args) {
          return void 0;
        }
        if (args.length < 2) {
          return void 0;
        }
        const tokenIdentifier = this.hexToString(args[0]);
        const value = this.hexToBigInt(args[1]);
        const result = new TransactionMetadata();
        result.sender = metadata.sender;
        result.receiver = metadata.receiver;
        if (args.length > 2) {
          result.functionName = this.hexToString(args[2]);
          result.functionArgs = args.slice(3);
        }
        result.transfers = [{
          value,
          properties: {
            identifier: tokenIdentifier
          }
        }];
        result.value = value;
        return result;
      }
      bech32Encode(address) {
        const pubKey = import_buffer.Buffer.from(address, "hex");
        const words = bech32_1.bech32.toWords(pubKey);
        return bech32_1.bech32.encode("erd", words);
      }
      isAddressValid(address) {
        return import_buffer.Buffer.from(address, "hex").length == 32;
      }
      isSmartContractArgument(arg) {
        if (!this.isHex(arg)) {
          return false;
        }
        if (arg.length % 2 !== 0) {
          return false;
        }
        return true;
      }
      isHex(value) {
        return new RegExp(/[^a-f0-9]/gi).test(value) === false;
      }
      base64ToHex(str) {
        return import_buffer.Buffer.from(str, "base64").toString("hex");
      }
      hexToString(hex) {
        return import_buffer.Buffer.from(hex, "hex").toString("ascii");
      }
      hexToBigInt(hex) {
        if (!hex) {
          return BigInt(0);
        }
        return BigInt("0x" + hex);
      }
    };
    exports2.TransactionDecoder = TransactionDecoder;
    var TransactionToDecode = class {
      constructor() {
        this.sender = "";
        this.receiver = "";
        this.data = "";
        this.value = "0";
      }
    };
    exports2.TransactionToDecode = TransactionToDecode;
    var TransactionMetadata = class {
      constructor() {
        this.sender = "";
        this.receiver = "";
        this.value = BigInt(0);
      }
    };
    exports2.TransactionMetadata = TransactionMetadata;
    var TransactionMetadataTransfer = class {
      constructor() {
        this.value = BigInt(0);
      }
    };
    exports2.TransactionMetadataTransfer = TransactionMetadataTransfer;
    var TokenTransferProperties = class {
    };
    exports2.TokenTransferProperties = TokenTransferProperties;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/returnCode.js
var require_returnCode = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/returnCode.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReturnCode = void 0;
    var ReturnCode = class _ReturnCode {
      constructor(text) {
        this.text = text;
      }
      static fromBuffer(buffer) {
        let text = buffer.toString();
        return new _ReturnCode(text);
      }
      toString() {
        return this.text;
      }
      valueOf() {
        return this.text;
      }
      equals(other) {
        if (!other) {
          return false;
        }
        return this.text == other.text;
      }
      isSuccess() {
        return this.equals(_ReturnCode.Ok) || this.equals(_ReturnCode.None);
      }
    };
    exports2.ReturnCode = ReturnCode;
    ReturnCode.None = new ReturnCode("");
    ReturnCode.Ok = new ReturnCode("ok");
    ReturnCode.FunctionNotFound = new ReturnCode("function not found");
    ReturnCode.FunctionWrongSignature = new ReturnCode("wrong signature for function");
    ReturnCode.ContractNotFound = new ReturnCode("contract not found");
    ReturnCode.UserError = new ReturnCode("user error");
    ReturnCode.OutOfGas = new ReturnCode("out of gas");
    ReturnCode.AccountCollision = new ReturnCode("account collision");
    ReturnCode.OutOfFunds = new ReturnCode("out of funds");
    ReturnCode.CallStackOverFlow = new ReturnCode("call stack overflow");
    ReturnCode.ContractInvalid = new ReturnCode("contract invalid");
    ReturnCode.ExecutionFailed = new ReturnCode("execution failed");
    ReturnCode.Unknown = new ReturnCode("unknown");
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/resultsParser.js
var require_resultsParser = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/resultsParser.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ResultsParser = void 0;
    var transaction_decoder_1 = require_transaction_decoder();
    var address_1 = require_address();
    var errors_1 = require_errors();
    var logger_1 = require_logger();
    var argSerializer_1 = require_argSerializer();
    var returnCode_1 = require_returnCode();
    var WellKnownEvents;
    (function(WellKnownEvents2) {
      WellKnownEvents2["OnTransactionCompleted"] = "completedTxEvent";
      WellKnownEvents2["OnSignalError"] = "signalError";
      WellKnownEvents2["OnWriteLog"] = "writeLog";
    })(WellKnownEvents || (WellKnownEvents = {}));
    var WellKnownTopics;
    (function(WellKnownTopics2) {
      WellKnownTopics2["TooMuchGas"] = "@too much gas provided for processing";
    })(WellKnownTopics || (WellKnownTopics = {}));
    var defaultResultsParserOptions = {
      argsSerializer: new argSerializer_1.ArgSerializer()
    };
    var ResultsParser = class {
      constructor(options) {
        options = { ...defaultResultsParserOptions, ...options };
        this.argsSerializer = options.argsSerializer;
      }
      /**
       * Legacy method, use "SmartContractQueriesController.parseQueryResponse()" instead.
       */
      parseQueryResponse(queryResponse, endpoint) {
        let parts = queryResponse.getReturnDataParts();
        let values = this.argsSerializer.buffersToValues(parts, endpoint.output);
        let returnCode = new returnCode_1.ReturnCode(queryResponse.returnCode.toString());
        return {
          returnCode,
          returnMessage: queryResponse.returnMessage,
          values,
          firstValue: values[0],
          secondValue: values[1],
          thirdValue: values[2],
          lastValue: values[values.length - 1]
        };
      }
      /**
       * Legacy method, use "SmartContractQueriesController.parseQueryResponse()" instead.
       */
      parseUntypedQueryResponse(queryResponse) {
        let returnCode = new returnCode_1.ReturnCode(queryResponse.returnCode.toString());
        return {
          returnCode,
          returnMessage: queryResponse.returnMessage,
          values: queryResponse.getReturnDataParts()
        };
      }
      /**
       * Legacy method, use "SmartContractTransactionsOutcomeParser.parseExecute()" instead.
       */
      parseOutcome(transaction, endpoint) {
        const untypedBundle = this.parseUntypedOutcome(transaction);
        const typedBundle = this.parseOutcomeFromUntypedBundle(untypedBundle, endpoint);
        return typedBundle;
      }
      /**
       * @internal
       * For internal use only.
       */
      parseOutcomeFromUntypedBundle(bundle, endpoint) {
        const values = this.argsSerializer.buffersToValues(bundle.values, endpoint.output);
        return {
          returnCode: bundle.returnCode,
          returnMessage: bundle.returnMessage,
          values,
          firstValue: values[0],
          secondValue: values[1],
          thirdValue: values[2],
          lastValue: values[values.length - 1]
        };
      }
      /**
       * Legacy method, use "SmartContractTransactionsOutcomeParser.parseExecute()" instead.
       */
      parseUntypedOutcome(transaction) {
        let bundle;
        let transactionMetadata = this.parseTransactionMetadata(transaction);
        bundle = this.createBundleOnSimpleMoveBalance(transaction);
        if (bundle) {
          logger_1.Logger.trace("parseUntypedOutcome(): on simple move balance");
          return bundle;
        }
        bundle = this.createBundleOnInvalidTransaction(transaction);
        if (bundle) {
          logger_1.Logger.trace("parseUntypedOutcome(): on invalid transaction");
          return bundle;
        }
        bundle = this.createBundleOnEasilyFoundResultWithReturnData(transaction.contractResults);
        if (bundle) {
          logger_1.Logger.trace("parseUntypedOutcome(): on easily found result with return data");
          return bundle;
        }
        bundle = this.createBundleOnSignalError(transaction.logs);
        if (bundle) {
          logger_1.Logger.trace("parseUntypedOutcome(): on signal error");
          return bundle;
        }
        bundle = this.createBundleOnTooMuchGasWarning(transaction.logs);
        if (bundle) {
          logger_1.Logger.trace("parseUntypedOutcome(): on 'too much gas' warning");
          return bundle;
        }
        bundle = this.createBundleOnWriteLogWhereFirstTopicEqualsAddress(transaction.logs, transaction.sender);
        if (bundle) {
          logger_1.Logger.trace("parseUntypedOutcome(): on writelog with topics[0] == tx.sender");
          return bundle;
        }
        bundle = this.createBundleWithCustomHeuristics(transaction, transactionMetadata);
        if (bundle) {
          logger_1.Logger.trace("parseUntypedOutcome(): with custom heuristics");
          return bundle;
        }
        bundle = this.createBundleWithFallbackHeuristics(transaction, transactionMetadata);
        if (bundle) {
          logger_1.Logger.trace("parseUntypedOutcome(): with fallback heuristics");
          return bundle;
        }
        throw new errors_1.ErrCannotParseContractResults(`transaction ${transaction.hash.toString()}`);
      }
      parseTransactionMetadata(transaction) {
        return new transaction_decoder_1.TransactionDecoder().getTransactionMetadata({
          sender: transaction.sender.bech32(),
          receiver: transaction.receiver.bech32(),
          data: transaction.data.toString("base64"),
          value: transaction.value.toString()
        });
      }
      createBundleOnSimpleMoveBalance(transaction) {
        let noResults = transaction.contractResults.items.length == 0;
        let noLogs = transaction.logs.events.length == 0;
        if (noResults && noLogs) {
          return {
            returnCode: returnCode_1.ReturnCode.None,
            returnMessage: returnCode_1.ReturnCode.None.toString(),
            values: []
          };
        }
        return null;
      }
      createBundleOnInvalidTransaction(transaction) {
        if (transaction.status.isInvalid()) {
          if (transaction.receipt.data) {
            return {
              returnCode: returnCode_1.ReturnCode.OutOfFunds,
              returnMessage: transaction.receipt.data,
              values: []
            };
          }
        }
        return null;
      }
      createBundleOnEasilyFoundResultWithReturnData(results) {
        let resultItemWithReturnData = results.items.find((item) => item.nonce.valueOf() != 0 && item.data.startsWith("@"));
        if (!resultItemWithReturnData) {
          return null;
        }
        let { returnCode, returnDataParts } = this.sliceDataFieldInParts(resultItemWithReturnData.data);
        let returnMessage = resultItemWithReturnData.returnMessage || returnCode.toString();
        return {
          returnCode,
          returnMessage,
          values: returnDataParts
        };
      }
      createBundleOnSignalError(logs) {
        let eventSignalError = logs.findSingleOrNoneEvent(WellKnownEvents.OnSignalError);
        if (!eventSignalError) {
          return null;
        }
        let { returnCode, returnDataParts } = this.sliceDataFieldInParts(eventSignalError.data);
        let lastTopic = eventSignalError.getLastTopic();
        let returnMessage = lastTopic?.toString() || returnCode.toString();
        return {
          returnCode,
          returnMessage,
          values: returnDataParts
        };
      }
      createBundleOnTooMuchGasWarning(logs) {
        let eventTooMuchGas = logs.findSingleOrNoneEvent(WellKnownEvents.OnWriteLog, (event) => event.findFirstOrNoneTopic((topic) => topic.toString().startsWith(WellKnownTopics.TooMuchGas)) != void 0);
        if (!eventTooMuchGas) {
          return null;
        }
        let { returnCode, returnDataParts } = this.sliceDataFieldInParts(eventTooMuchGas.data);
        let lastTopic = eventTooMuchGas.getLastTopic();
        let returnMessage = lastTopic?.toString() || returnCode.toString();
        return {
          returnCode,
          returnMessage,
          values: returnDataParts
        };
      }
      createBundleOnWriteLogWhereFirstTopicEqualsAddress(logs, address) {
        let hexAddress = new address_1.Address(address.bech32()).hex();
        let eventWriteLogWhereTopicIsSender = logs.findSingleOrNoneEvent(WellKnownEvents.OnWriteLog, (event) => event.findFirstOrNoneTopic((topic) => topic.hex() == hexAddress) != void 0);
        if (!eventWriteLogWhereTopicIsSender) {
          return null;
        }
        let { returnCode, returnDataParts } = this.sliceDataFieldInParts(eventWriteLogWhereTopicIsSender.data);
        let returnMessage = returnCode.toString();
        return {
          returnCode,
          returnMessage,
          values: returnDataParts
        };
      }
      /**
       * Override this method (in a subclass of {@link ResultsParser}) if the basic heuristics of the parser are not sufficient.
       */
      createBundleWithCustomHeuristics(_transaction, _transactionMetadata) {
        return null;
      }
      createBundleWithFallbackHeuristics(transaction, transactionMetadata) {
        let contractAddress = new address_1.Address(transactionMetadata.receiver);
        for (const resultItem of transaction.contractResults.items) {
          let writeLogWithReturnData = resultItem.logs.findSingleOrNoneEvent(WellKnownEvents.OnWriteLog, (event) => {
            let addressIsSender = event.address.bech32() == transaction.sender.bech32();
            let firstTopicIsContract = event.topics[0]?.hex() == contractAddress.hex();
            return addressIsSender && firstTopicIsContract;
          });
          if (writeLogWithReturnData) {
            let { returnCode, returnDataParts } = this.sliceDataFieldInParts(writeLogWithReturnData.data);
            let returnMessage = returnCode.toString();
            return {
              returnCode,
              returnMessage,
              values: returnDataParts
            };
          }
        }
        return null;
      }
      sliceDataFieldInParts(data) {
        let startingIndex = 1;
        if (data.startsWith("ESDTTransfer")) {
          startingIndex = 3;
        } else {
        }
        let parts = this.argsSerializer.stringToBuffers(data);
        let returnCodePart = parts[startingIndex] || import_buffer.Buffer.from([]);
        let returnDataParts = parts.slice(startingIndex + 1);
        if (returnCodePart.length == 0) {
          throw new errors_1.ErrCannotParseContractResults("no return code");
        }
        let returnCode = returnCode_1.ReturnCode.fromBuffer(returnCodePart);
        return { returnCode, returnDataParts };
      }
      /**
       * Legacy method, use "TransactionEventsParser.parseEvent()" instead.
       */
      parseEvent(transactionEvent, eventDefinition) {
        const topics = transactionEvent.topics.map((topic) => import_buffer.Buffer.from(topic.valueOf())).slice(1);
        const legacyData = transactionEvent.dataPayload?.valueOf() || import_buffer.Buffer.from([]);
        const dataItems = transactionEvent.additionalData?.map((data) => import_buffer.Buffer.from(data.valueOf())) || [];
        if (dataItems.length === 0) {
          if (legacyData.length) {
            dataItems.push(import_buffer.Buffer.from(legacyData));
          }
        }
        return this.doParseEvent({ topics, dataItems, eventDefinition });
      }
      /**
       * @internal
       * For internal use only.
       *
       * Once the legacy "ResultParser" is deprecated & removed, this logic will be absorbed into "TransactionEventsParser".
       */
      doParseEvent(options) {
        const result = {};
        const indexedInputs = options.eventDefinition.inputs.filter((input) => input.indexed);
        const decodedTopics = this.argsSerializer.buffersToValues(options.topics, indexedInputs);
        for (let i2 = 0; i2 < indexedInputs.length; i2++) {
          result[indexedInputs[i2].name] = decodedTopics[i2].valueOf();
        }
        const nonIndexedInputs = options.eventDefinition.inputs.filter((input) => !input.indexed);
        const decodedDataParts = this.argsSerializer.buffersToValues(options.dataItems, nonIndexedInputs);
        for (let i2 = 0; i2 < nonIndexedInputs.length; i2++) {
          result[nonIndexedInputs[i2].name] = decodedDataParts[i2].valueOf();
        }
        return result;
      }
    };
    exports2.ResultsParser = ResultsParser;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/smartContract.js
var require_smartContract = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/smartContract.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SmartContract = void 0;
    var address_1 = require_address();
    var compatibility_1 = require_compatibility();
    var constants_1 = require_constants();
    var errors_1 = require_errors();
    var smartContractTransactionsFactory_1 = require_smartContractTransactionsFactory();
    var transactionsFactoryConfig_1 = require_transactionsFactoryConfig();
    var utils_1 = require_utils2();
    var codeMetadata_1 = require_codeMetadata2();
    var function_1 = require_function();
    var interaction_1 = require_interaction();
    var nativeSerializer_1 = require_nativeSerializer();
    var query_1 = require_query();
    var SmartContract = class {
      /**
       * Create a SmartContract object by providing its address on the Network.
       */
      constructor(options = {}) {
        this.address = address_1.Address.empty();
        this.methodsExplicit = {};
        this.methods = {};
        this.address = options.address || address_1.Address.empty();
        this.abi = options.abi;
        if (this.abi) {
          this.setupMethods();
        }
      }
      setupMethods() {
        let contract = this;
        let abi = this.getAbi();
        for (const definition of abi.getEndpoints()) {
          let functionName = definition.name;
          this.methodsExplicit[functionName] = function(args) {
            let func = new function_1.ContractFunction(functionName);
            let interaction = new interaction_1.Interaction(contract, func, args || []);
            return interaction;
          };
          this.methods[functionName] = function(args) {
            let func = new function_1.ContractFunction(functionName);
            let typedArgs = nativeSerializer_1.NativeSerializer.nativeToTypedValues(args || [], definition);
            let interaction = new interaction_1.Interaction(contract, func, typedArgs || []);
            return interaction;
          };
        }
      }
      /**
       * Sets the address, as on Network.
       */
      setAddress(address) {
        this.address = address;
      }
      /**
       * Gets the address, as on Network.
       */
      getAddress() {
        return this.address;
      }
      getAbi() {
        utils_1.guardValueIsSet("abi", this.abi);
        return this.abi;
      }
      getEndpoint(name2) {
        return this.getAbi().getEndpoint(name2);
      }
      /**
       * Creates a {@link Transaction} for deploying the Smart Contract to the Network.
       */
      deploy({ deployer, code: code2, codeMetadata, initArguments, value, gasLimit, gasPrice, chainID }) {
        compatibility_1.Compatibility.guardAddressIsSetAndNonZero(deployer, "'deployer' of SmartContract.deploy()", "pass the actual address to deploy()");
        const config = new transactionsFactoryConfig_1.TransactionsFactoryConfig({ chainID: chainID.valueOf() });
        const factory = new smartContractTransactionsFactory_1.SmartContractTransactionsFactory({
          config,
          abi: this.abi
        });
        const bytecode = import_buffer.Buffer.from(code2.toString(), "hex");
        const metadataAsJson = this.getMetadataPropertiesAsObject(codeMetadata);
        const transaction = factory.createTransactionForDeploy({
          sender: deployer,
          bytecode,
          gasLimit: BigInt(gasLimit.valueOf()),
          arguments: initArguments,
          isUpgradeable: metadataAsJson.upgradeable,
          isReadable: metadataAsJson.readable,
          isPayable: metadataAsJson.payable,
          isPayableBySmartContract: metadataAsJson.payableBySc
        });
        transaction.setChainID(chainID);
        transaction.setValue(value ?? 0);
        transaction.setGasPrice(gasPrice ?? constants_1.TRANSACTION_MIN_GAS_PRICE);
        return transaction;
      }
      getMetadataPropertiesAsObject(codeMetadata) {
        let metadata;
        if (codeMetadata) {
          metadata = codeMetadata_1.CodeMetadata.fromBytes(import_buffer.Buffer.from(codeMetadata.toString(), "hex"));
        } else {
          metadata = new codeMetadata_1.CodeMetadata();
        }
        const metadataAsJson = metadata.toJSON();
        return metadataAsJson;
      }
      /**
       * Creates a {@link Transaction} for upgrading the Smart Contract on the Network.
       */
      upgrade({ caller, code: code2, codeMetadata, initArguments, value, gasLimit, gasPrice, chainID }) {
        compatibility_1.Compatibility.guardAddressIsSetAndNonZero(caller, "'caller' of SmartContract.upgrade()", "pass the actual address to upgrade()");
        this.ensureHasAddress();
        const config = new transactionsFactoryConfig_1.TransactionsFactoryConfig({ chainID: chainID.valueOf() });
        const factory = new smartContractTransactionsFactory_1.SmartContractTransactionsFactory({
          config,
          abi: this.abi
        });
        const bytecode = Uint8Array.from(import_buffer.Buffer.from(code2.toString(), "hex"));
        const metadataAsJson = this.getMetadataPropertiesAsObject(codeMetadata);
        const transaction = factory.createTransactionForUpgrade({
          sender: caller,
          contract: this.getAddress(),
          bytecode,
          gasLimit: BigInt(gasLimit.valueOf()),
          arguments: initArguments,
          isUpgradeable: metadataAsJson.upgradeable,
          isReadable: metadataAsJson.readable,
          isPayable: metadataAsJson.payable,
          isPayableBySmartContract: metadataAsJson.payableBySc
        });
        transaction.setChainID(chainID);
        transaction.setValue(value ?? 0);
        transaction.setGasPrice(gasPrice ?? constants_1.TRANSACTION_MIN_GAS_PRICE);
        return transaction;
      }
      /**
       * Creates a {@link Transaction} for calling (a function of) the Smart Contract.
       */
      call({ func, args, value, gasLimit, receiver, gasPrice, chainID, caller }) {
        compatibility_1.Compatibility.guardAddressIsSetAndNonZero(caller, "'caller' of SmartContract.call()", "pass the actual address to call()");
        this.ensureHasAddress();
        const config = new transactionsFactoryConfig_1.TransactionsFactoryConfig({ chainID: chainID.valueOf() });
        const factory = new smartContractTransactionsFactory_1.SmartContractTransactionsFactory({
          config,
          abi: this.abi
        });
        args = args || [];
        value = value || 0;
        const transaction = factory.createTransactionForExecute({
          sender: caller,
          contract: receiver ? receiver : this.getAddress(),
          function: func.toString(),
          gasLimit: BigInt(gasLimit.valueOf()),
          arguments: args
        });
        transaction.setChainID(chainID);
        transaction.setValue(value);
        transaction.setGasPrice(gasPrice ?? constants_1.TRANSACTION_MIN_GAS_PRICE);
        return transaction;
      }
      createQuery({ func, args, value, caller }) {
        this.ensureHasAddress();
        return new query_1.Query({
          address: this.getAddress(),
          func,
          args,
          value,
          caller
        });
      }
      ensureHasAddress() {
        if (!this.getAddress().bech32()) {
          throw new errors_1.ErrContractHasNoAddress();
        }
      }
      /**
       * Computes the address of a Smart Contract.
       * The address is computed deterministically, from the address of the owner and the nonce of the deployment transaction.
       *
       * @param owner The owner of the Smart Contract
       * @param nonce The owner nonce used for the deployment transaction
       */
      static computeAddress(owner, nonce) {
        const deployer = address_1.Address.fromBech32(owner.bech32());
        const addressComputer = new address_1.AddressComputer();
        return addressComputer.computeContractAddress(deployer, BigInt(nonce.valueOf()));
      }
    };
    exports2.SmartContract = SmartContract;
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/transactionPayloadBuilders.js
var require_transactionPayloadBuilders = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/transactionPayloadBuilders.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ContractCallPayloadBuilder = exports2.ContractUpgradePayloadBuilder = exports2.ContractDeployPayloadBuilder = void 0;
    var constants_1 = require_constants();
    var transactionPayload_1 = require_transactionPayload();
    var utils_1 = require_utils2();
    var argSerializer_1 = require_argSerializer();
    var ContractDeployPayloadBuilder = class {
      constructor() {
        this.code = null;
        this.codeMetadata = "";
        this.arguments = [];
      }
      /**
       * Sets the code of the Smart Contract.
       */
      setCode(code2) {
        this.code = code2;
        return this;
      }
      /**
       * Sets the code metadata of the Smart Contract.
       */
      setCodeMetadata(codeMetadata) {
        this.codeMetadata = codeMetadata;
        return this;
      }
      /**
       * Adds constructor (`init`) arguments.
       */
      addInitArg(arg) {
        this.arguments.push(arg);
        return this;
      }
      /**
       * Sets constructor (`init`) arguments.
       */
      setInitArgs(args) {
        this.arguments = args;
        return this;
      }
      /**
       * Builds the {@link TransactionPayload}.
       */
      build() {
        utils_1.guardValueIsSet("code", this.code);
        let code2 = this.code.toString();
        let codeMetadata = this.codeMetadata.toString();
        let data = `${code2}@${constants_1.WasmVirtualMachine}@${codeMetadata}`;
        data = appendArgumentsToString(data, this.arguments);
        return new transactionPayload_1.TransactionPayload(data);
      }
    };
    exports2.ContractDeployPayloadBuilder = ContractDeployPayloadBuilder;
    var ContractUpgradePayloadBuilder = class {
      constructor() {
        this.code = null;
        this.codeMetadata = "";
        this.arguments = [];
      }
      /**
       * Sets the code of the Smart Contract.
       */
      setCode(code2) {
        this.code = code2;
        return this;
      }
      /**
       * Sets the code metadata of the Smart Contract.
       */
      setCodeMetadata(codeMetadata) {
        this.codeMetadata = codeMetadata;
        return this;
      }
      /**
       * Adds upgrade (`init`) arguments.
       */
      addInitArg(arg) {
        this.arguments.push(arg);
        return this;
      }
      /**
       * Sets upgrade (`init`) arguments.
       */
      setInitArgs(args) {
        this.arguments = args;
        return this;
      }
      /**
       * Builds the {@link TransactionPayload}.
       */
      build() {
        utils_1.guardValueIsSet("code", this.code);
        let code2 = this.code.toString();
        let codeMetadata = this.codeMetadata.toString();
        let data = `upgradeContract@${code2}@${codeMetadata}`;
        data = appendArgumentsToString(data, this.arguments);
        return new transactionPayload_1.TransactionPayload(data);
      }
    };
    exports2.ContractUpgradePayloadBuilder = ContractUpgradePayloadBuilder;
    var ContractCallPayloadBuilder = class {
      constructor() {
        this.contractFunction = null;
        this.arguments = [];
      }
      /**
       * Sets the function to be called (executed).
       */
      setFunction(contractFunction) {
        this.contractFunction = contractFunction;
        return this;
      }
      /**
       * Adds a function argument.
       */
      addArg(arg) {
        this.arguments.push(arg);
        return this;
      }
      /**
       * Sets the function arguments.
       */
      setArgs(args) {
        this.arguments = args;
        return this;
      }
      /**
       * Builds the {@link TransactionPayload}.
       */
      build() {
        utils_1.guardValueIsSet("calledFunction", this.contractFunction);
        let data = this.contractFunction.toString();
        data = appendArgumentsToString(data, this.arguments);
        return new transactionPayload_1.TransactionPayload(data);
      }
    };
    exports2.ContractCallPayloadBuilder = ContractCallPayloadBuilder;
    function appendArgumentsToString(to, values) {
      let { argumentsString, count } = new argSerializer_1.ArgSerializer().valuesToString(values);
      if (count == 0) {
        return to;
      }
      return `${to}@${argumentsString}`;
    }
  }
});

// node_modules/@multiversx/sdk-core/out/smartcontracts/index.js
var require_smartcontracts = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartcontracts/index.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m3, exports3) {
      for (var p3 in m3)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3))
          __createBinding2(exports3, m3, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_argSerializer(), exports2);
    __exportStar2(require_code(), exports2);
    __exportStar2(require_codec2(), exports2);
    __exportStar2(require_codeMetadata2(), exports2);
    __exportStar2(require_function(), exports2);
    __exportStar2(require_interaction(), exports2);
    __exportStar2(require_interactionChecker(), exports2);
    __exportStar2(require_interface(), exports2);
    __exportStar2(require_nativeSerializer(), exports2);
    __exportStar2(require_query(), exports2);
    __exportStar2(require_resultsParser(), exports2);
    __exportStar2(require_returnCode(), exports2);
    __exportStar2(require_smartContract(), exports2);
    __exportStar2(require_transactionPayloadBuilders(), exports2);
    __exportStar2(require_typesystem(), exports2);
  }
});

// node_modules/@multiversx/sdk-core/out/transactionsOutcomeParsers/resources.js
var require_resources = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionsOutcomeParsers/resources.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.gatherAllEvents = exports2.findEventsByFirstTopic = exports2.findEventsByIdentifier = exports2.findEventsByPredicate = exports2.SmartContractCallOutcome = exports2.TransactionOutcome = exports2.SmartContractResult = exports2.TransactionLogs = exports2.TransactionEvent = void 0;
    var TransactionEvent = class {
      constructor(init) {
        this.address = "";
        this.identifier = "";
        this.topics = [];
        this.dataItems = [];
        Object.assign(this, init);
      }
    };
    exports2.TransactionEvent = TransactionEvent;
    var TransactionLogs2 = class {
      constructor(init) {
        this.address = "";
        this.events = [];
        Object.assign(this, init);
      }
    };
    exports2.TransactionLogs = TransactionLogs2;
    var SmartContractResult = class {
      constructor(init) {
        this.sender = "";
        this.receiver = "";
        this.data = new Uint8Array();
        this.logs = new TransactionLogs2({});
        Object.assign(this, init);
      }
    };
    exports2.SmartContractResult = SmartContractResult;
    var TransactionOutcome = class {
      constructor(init) {
        this.directSmartContractCallOutcome = new SmartContractCallOutcome({});
        this.smartContractResults = [];
        this.logs = new TransactionLogs2({});
        Object.assign(this, init);
      }
    };
    exports2.TransactionOutcome = TransactionOutcome;
    var SmartContractCallOutcome = class {
      constructor(init) {
        this.function = "";
        this.returnDataParts = [];
        this.returnMessage = "";
        this.returnCode = "";
        Object.assign(this, init);
      }
    };
    exports2.SmartContractCallOutcome = SmartContractCallOutcome;
    function findEventsByPredicate(transactionOutcome, predicate) {
      return gatherAllEvents(transactionOutcome).filter(predicate);
    }
    exports2.findEventsByPredicate = findEventsByPredicate;
    function findEventsByIdentifier(transactionOutcome, identifier) {
      return findEventsByPredicate(transactionOutcome, (event) => event.identifier == identifier);
    }
    exports2.findEventsByIdentifier = findEventsByIdentifier;
    function findEventsByFirstTopic(transactionOutcome, topic) {
      return findEventsByPredicate(transactionOutcome, (event) => event.topics[0]?.toString() == topic);
    }
    exports2.findEventsByFirstTopic = findEventsByFirstTopic;
    function gatherAllEvents(transactionOutcome) {
      const allEvents = [];
      allEvents.push(...transactionOutcome.logs.events);
      for (const item of transactionOutcome.smartContractResults) {
        allEvents.push(...item.logs.events);
      }
      return allEvents;
    }
    exports2.gatherAllEvents = gatherAllEvents;
  }
});

// node_modules/@multiversx/sdk-core/out/converters/transactionsConverter.js
var require_transactionsConverter = __commonJS({
  "node_modules/@multiversx/sdk-core/out/converters/transactionsConverter.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransactionsConverter = void 0;
    var smartcontracts_1 = require_smartcontracts();
    var transaction_1 = require_transaction();
    var resources_1 = require_resources();
    var TransactionsConverter = class {
      transactionToPlainObject(transaction) {
        const plainObject = {
          nonce: Number(transaction.nonce),
          value: transaction.value.toString(),
          receiver: transaction.receiver,
          sender: transaction.sender,
          senderUsername: this.toBase64OrUndefined(transaction.senderUsername),
          receiverUsername: this.toBase64OrUndefined(transaction.receiverUsername),
          gasPrice: Number(transaction.gasPrice),
          gasLimit: Number(transaction.gasLimit),
          data: this.toBase64OrUndefined(transaction.data),
          chainID: transaction.chainID.valueOf(),
          version: transaction.version,
          options: transaction.options == 0 ? void 0 : transaction.options,
          guardian: transaction.guardian ? transaction.guardian : void 0,
          signature: this.toHexOrUndefined(transaction.signature),
          guardianSignature: this.toHexOrUndefined(transaction.guardianSignature)
        };
        return plainObject;
      }
      toBase64OrUndefined(value) {
        return value && value.length ? import_buffer.Buffer.from(value).toString("base64") : void 0;
      }
      toHexOrUndefined(value) {
        return value && value.length ? import_buffer.Buffer.from(value).toString("hex") : void 0;
      }
      plainObjectToTransaction(object) {
        const transaction = new transaction_1.Transaction({
          nonce: BigInt(object.nonce),
          value: BigInt(object.value || ""),
          receiver: object.receiver,
          receiverUsername: this.bufferFromBase64(object.receiverUsername).toString(),
          sender: object.sender,
          senderUsername: this.bufferFromBase64(object.senderUsername).toString(),
          guardian: object.guardian,
          gasPrice: BigInt(object.gasPrice),
          gasLimit: BigInt(object.gasLimit),
          data: this.bufferFromBase64(object.data),
          chainID: String(object.chainID),
          version: Number(object.version),
          options: Number(object.options),
          signature: this.bufferFromHex(object.signature),
          guardianSignature: this.bufferFromHex(object.guardianSignature)
        });
        return transaction;
      }
      bufferFromBase64(value) {
        return import_buffer.Buffer.from(value || "", "base64");
      }
      bufferFromHex(value) {
        return import_buffer.Buffer.from(value || "", "hex");
      }
      transactionOnNetworkToOutcome(transactionOnNetwork) {
        const legacyResultsParser = new smartcontracts_1.ResultsParser();
        const callOutcomeBundle = legacyResultsParser.parseUntypedOutcome(transactionOnNetwork);
        const callOutcome = new resources_1.SmartContractCallOutcome({
          function: transactionOnNetwork.function,
          returnCode: callOutcomeBundle.returnCode.toString(),
          returnMessage: callOutcomeBundle.returnMessage,
          returnDataParts: callOutcomeBundle.values
        });
        const contractResults = transactionOnNetwork.contractResults.items.map((result) => this.smartContractResultOnNetworkToSmartContractResult(result));
        const logs = new resources_1.TransactionLogs({
          address: transactionOnNetwork.logs.address.bech32(),
          events: transactionOnNetwork.logs.events.map((event) => this.eventOnNetworkToEvent(event))
        });
        return new resources_1.TransactionOutcome({
          logs,
          smartContractResults: contractResults,
          directSmartContractCallOutcome: callOutcome
        });
      }
      smartContractResultOnNetworkToSmartContractResult(resultOnNetwork) {
        return new resources_1.SmartContractResult({
          sender: resultOnNetwork.sender.bech32(),
          receiver: resultOnNetwork.receiver.bech32(),
          data: import_buffer.Buffer.from(resultOnNetwork.data),
          logs: new resources_1.TransactionLogs({
            address: resultOnNetwork.logs.address.bech32(),
            events: resultOnNetwork.logs.events.map((event) => this.eventOnNetworkToEvent(event))
          })
        });
      }
      eventOnNetworkToEvent(eventOnNetwork) {
        const legacyData = eventOnNetwork.dataPayload?.valueOf() || import_buffer.Buffer.from(eventOnNetwork.data || "");
        const dataItems = eventOnNetwork.additionalData?.map((data) => import_buffer.Buffer.from(data.valueOf())) || [];
        if (dataItems.length === 0) {
          if (legacyData.length) {
            dataItems.push(import_buffer.Buffer.from(legacyData));
          }
        }
        return new resources_1.TransactionEvent({
          address: eventOnNetwork.address.bech32(),
          identifier: eventOnNetwork.identifier,
          topics: eventOnNetwork.topics.map((topic) => import_buffer.Buffer.from(topic.hex(), "hex")),
          dataItems
        });
      }
    };
    exports2.TransactionsConverter = TransactionsConverter;
  }
});

// node_modules/@multiversx/sdk-core/out/hash.js
var require_hash = __commonJS({
  "node_modules/@multiversx/sdk-core/out/hash.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k4 in mod2)
          if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k4))
            __createBinding2(result, mod2, k4);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Hash = void 0;
    var errors = __importStar2(require_errors());
    var Hash = class _Hash {
      /**
       * Creates a new Hash object.
       *
       * @param hash The hash, as a Buffer or a hex-encoded string.
       */
      constructor(hash) {
        if (!hash) {
          this.hash = import_buffer.Buffer.from([]);
        } else if (hash instanceof import_buffer.Buffer) {
          this.hash = hash;
        } else if (typeof hash === "string") {
          this.hash = import_buffer.Buffer.from(hash, "hex");
        } else {
          throw new errors.ErrBadType("hash", "buffer | string", hash);
        }
      }
      static empty() {
        return new _Hash(import_buffer.Buffer.from([]));
      }
      /**
       * Returns whether the hash is empty (not computed).
       */
      isEmpty() {
        return this.hash.length == 0;
      }
      toString() {
        return this.hex();
      }
      hex() {
        return this.hash.toString("hex");
      }
      valueOf() {
        return this.hash;
      }
    };
    exports2.Hash = Hash;
  }
});

// node_modules/@multiversx/sdk-core/out/signature.js
var require_signature = __commonJS({
  "node_modules/@multiversx/sdk-core/out/signature.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k4 in mod2)
          if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k4))
            __createBinding2(result, mod2, k4);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.interpretSignatureAsBuffer = exports2.Signature = void 0;
    var errors = __importStar2(require_errors());
    var SIGNATURE_LENGTH = 64;
    var Signature = class _Signature {
      constructor(value) {
        this.valueHex = "";
        if (!value) {
          return;
        }
        if (typeof value === "string") {
          return _Signature.fromHex(value);
        }
        if (value instanceof import_buffer.Buffer) {
          return _Signature.fromBuffer(value);
        }
      }
      static empty() {
        return new _Signature();
      }
      static fromHex(value) {
        if (value.startsWith("0x")) {
          value = value.slice(2);
        }
        if (!_Signature.isValidHex(value)) {
          throw new errors.ErrSignatureCannotCreate(value);
        }
        return _Signature.fromValidHex(value);
      }
      static isValidHex(value) {
        return import_buffer.Buffer.from(value, "hex").length == SIGNATURE_LENGTH;
      }
      static fromValidHex(value) {
        let result = new _Signature();
        result.valueHex = value;
        return result;
      }
      static fromBuffer(buffer) {
        if (buffer.length != SIGNATURE_LENGTH) {
          throw new errors.ErrSignatureCannotCreate(buffer);
        }
        return _Signature.fromValidHex(buffer.toString("hex"));
      }
      hex() {
        return this.valueHex;
      }
    };
    exports2.Signature = Signature;
    function interpretSignatureAsBuffer(signature) {
      if (ArrayBuffer.isView(signature)) {
        return import_buffer.Buffer.from(signature);
      } else if (signature.hex != null) {
        return import_buffer.Buffer.from(signature.hex(), "hex");
      }
      throw new Error(`Object cannot be interpreted as a signature: ${signature}`);
    }
    exports2.interpretSignatureAsBuffer = interpretSignatureAsBuffer;
  }
});

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    init_shim();
    var base642 = exports2;
    base642.length = function length2(string2) {
      var p3 = string2.length;
      if (!p3)
        return 0;
      var n3 = 0;
      while (--p3 % 4 > 1 && string2.charAt(p3) === "=")
        ++n3;
      return Math.ceil(string2.length * 3) / 4 - n3;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i2 = 0; i2 < 64; )
      s64[b64[i2] = i2 < 26 ? i2 + 65 : i2 < 52 ? i2 + 71 : i2 < 62 ? i2 - 4 : i2 - 59 | 43] = i2++;
    var i2;
    base642.encode = function encode5(buffer, start, end) {
      var parts = null, chunk = [];
      var i3 = 0, j2 = 0, t;
      while (start < end) {
        var b4 = buffer[start++];
        switch (j2) {
          case 0:
            chunk[i3++] = b64[b4 >> 2];
            t = (b4 & 3) << 4;
            j2 = 1;
            break;
          case 1:
            chunk[i3++] = b64[t | b4 >> 4];
            t = (b4 & 15) << 2;
            j2 = 2;
            break;
          case 2:
            chunk[i3++] = b64[t | b4 >> 6];
            chunk[i3++] = b64[b4 & 63];
            j2 = 0;
            break;
        }
        if (i3 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i3 = 0;
        }
      }
      if (j2) {
        chunk[i3++] = b64[t];
        chunk[i3++] = 61;
        if (j2 === 1)
          chunk[i3++] = 61;
      }
      if (parts) {
        if (i3)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i3)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i3));
    };
    var invalidEncoding = "invalid encoding";
    base642.decode = function decode6(string2, buffer, offset) {
      var start = offset;
      var j2 = 0, t;
      for (var i3 = 0; i3 < string2.length; ) {
        var c4 = string2.charCodeAt(i3++);
        if (c4 === 61 && j2 > 1)
          break;
        if ((c4 = s64[c4]) === void 0)
          throw Error(invalidEncoding);
        switch (j2) {
          case 0:
            t = c4;
            j2 = 1;
            break;
          case 1:
            buffer[offset++] = t << 2 | (c4 & 48) >> 4;
            t = c4;
            j2 = 2;
            break;
          case 2:
            buffer[offset++] = (t & 15) << 4 | (c4 & 60) >> 2;
            t = c4;
            j2 = 3;
            break;
          case 3:
            buffer[offset++] = (t & 3) << 6 | c4;
            j2 = 0;
            break;
        }
      }
      if (j2 === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base642.test = function test(string2) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string2);
    };
  }
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    module2.exports = EventEmitter2;
    function EventEmitter2() {
      this._listeners = {};
    }
    EventEmitter2.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter2.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i2 = 0; i2 < listeners.length; )
            if (listeners[i2].fn === fn)
              listeners.splice(i2, 1);
            else
              ++i2;
        }
      }
      return this;
    };
    EventEmitter2.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i2 = 1;
        for (; i2 < arguments.length; )
          args.push(arguments[i2++]);
        for (i2 = 0; i2 < listeners.length; )
          listeners[i2].fn.apply(listeners[i2++].ctx, args);
      }
      return this;
    };
  }
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign2 = val < 0 ? 1 : 0;
            if (sign2)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign2 << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign2 << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign2 << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign2 = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign2 * Infinity : exponent === 0 ? sign2 * 1401298464324817e-60 * mantissa : sign2 * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign2 = val < 0 ? 1 : 0;
            if (sign2)
              val = -val;
            if (val === 0) {
              writeUint(0, buf, pos + off0);
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf, pos + off0);
              writeUint(2146959360, buf, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf, pos + off0);
              writeUint((sign2 << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf, pos + off0);
                writeUint((sign2 << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                writeUint((sign2 << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign2 = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign2 * Infinity : exponent === 0 ? sign2 * 5e-324 * mantissa : sign2 * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e2) {
      }
      return null;
    }
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    init_shim();
    var utf8 = exports2;
    utf8.length = function utf8_length(string2) {
      var len = 0, c4 = 0;
      for (var i2 = 0; i2 < string2.length; ++i2) {
        c4 = string2.charCodeAt(i2);
        if (c4 < 128)
          len += 1;
        else if (c4 < 2048)
          len += 2;
        else if ((c4 & 64512) === 55296 && (string2.charCodeAt(i2 + 1) & 64512) === 56320) {
          ++i2;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i2 = 0, t;
      while (start < end) {
        t = buffer[start++];
        if (t < 128)
          chunk[i2++] = t;
        else if (t > 191 && t < 224)
          chunk[i2++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i2++] = 55296 + (t >> 10);
          chunk[i2++] = 56320 + (t & 1023);
        } else
          chunk[i2++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    utf8.write = function utf8_write(string2, buffer, offset) {
      var start = offset, c1, c22;
      for (var i2 = 0; i2 < string2.length; ++i2) {
        c1 = string2.charCodeAt(i2);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c22 = string2.charCodeAt(i2 + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c22 & 1023);
          ++i2;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192;
      var MAX2 = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX2)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    init_shim();
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign2 = value < 0;
      if (sign2)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign2) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from3(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length2() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    init_shim();
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString2(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e2) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src2, ifNotSet) {
      for (var keys2 = Object.keys(src2), i2 = 0; i2 < keys2.length; ++i2)
        if (dst[keys2[i2]] === void 0 || !ifNotSet)
          dst[keys2[i2]] = src2[keys2[i2]];
      return dst;
    }
    util.merge = merge;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name2) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get: function get2() {
            return name2;
          },
          set: void 0,
          enumerable: false,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: true
        },
        toString: {
          value: function value() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i2 = 0; i2 < fieldNames.length; ++i2)
        fieldMap[fieldNames[i2]] = 1;
      return function() {
        for (var keys2 = Object.keys(this), i3 = keys2.length - 1; i3 > -1; --i3)
          if (fieldMap[keys2[i3]] === 1 && this[keys2[i3]] !== void 0 && this[keys2[i3]] !== null)
            return keys2[i3];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name2) {
        for (var i2 = 0; i2 < fieldNames.length; ++i2)
          if (fieldNames[i2] !== name2)
            delete this[fieldNames[i2]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    init_shim();
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base642 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create2 = function create3() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create2();
    Writer.alloc = function alloc(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i2 = 0; i2 < val.length; ++i2)
        buf[pos + i2] = val[i2];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base642.length(value));
        base642.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create2();
      BufferWriter._configure();
    };
  }
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    init_shim();
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else
          for (var i2 = 0; i2 < val.length; )
            buf[pos++] = val[i2++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    init_shim();
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    };
    var create2 = function create3() {
      return util.Buffer ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer2) {
          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
        })(buffer);
      } : create_array;
    };
    Reader.create = create2();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = /* @__PURE__ */ function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i2 = 0;
      if (this.len - this.pos > 4) {
        for (; i2 < 4; ++i2) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i2 = 0;
      } else {
        for (; i2 < 3; ++i2) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i2 * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i2 < 5; ++i2) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i2 < 5; ++i2) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length2 = this.uint32(), start = this.pos, end = this.pos + length2;
      if (end > this.len)
        throw indexOutOfRange(this, length2);
      this.pos += length2;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      if (start === end) {
        var nativeBuffer = util.Buffer;
        return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
      }
      return this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length2) {
      if (typeof length2 === "number") {
        if (this.pos + length2 > this.len)
          throw indexOutOfRange(this, length2);
        this.pos += length2;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create2();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    init_shim();
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    init_shim();
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    init_shim();
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    init_shim();
    module2.exports = {};
  }
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    init_shim();
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    init_shim();
    module2.exports = require_index_minimal();
  }
});

// node_modules/@multiversx/sdk-core/out/proto/compiled.js
var require_compiled = __commonJS({
  "node_modules/@multiversx/sdk-core/out/proto/compiled.js"(exports2, module2) {
    "use strict";
    init_shim();
    (function(global2, factory) {
      if (typeof define === "function" && define.amd)
        define(["protobufjs/minimal"], factory);
      else if (typeof __require === "function" && typeof module2 === "object" && module2 && module2.exports)
        module2.exports = factory(require_minimal2());
    })(exports2, function($protobuf) {
      "use strict";
      var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
      var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
      $root.proto = function() {
        var proto = {};
        proto.Transaction = function() {
          function Transaction4(properties) {
            if (properties) {
              for (var keys2 = Object.keys(properties), i2 = 0; i2 < keys2.length; ++i2)
                if (properties[keys2[i2]] != null)
                  this[keys2[i2]] = properties[keys2[i2]];
            }
          }
          Transaction4.prototype.Nonce = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
          Transaction4.prototype.Value = $util.newBuffer([]);
          Transaction4.prototype.RcvAddr = $util.newBuffer([]);
          Transaction4.prototype.RcvUserName = $util.newBuffer([]);
          Transaction4.prototype.SndAddr = $util.newBuffer([]);
          Transaction4.prototype.SndUserName = $util.newBuffer([]);
          Transaction4.prototype.GasPrice = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
          Transaction4.prototype.GasLimit = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
          Transaction4.prototype.Data = $util.newBuffer([]);
          Transaction4.prototype.ChainID = $util.newBuffer([]);
          Transaction4.prototype.Version = 0;
          Transaction4.prototype.Signature = $util.newBuffer([]);
          Transaction4.prototype.Options = 0;
          Transaction4.prototype.GuardianAddr = $util.newBuffer([]);
          Transaction4.prototype.GuardianSignature = $util.newBuffer([]);
          Transaction4.create = function create2(properties) {
            return new Transaction4(properties);
          };
          Transaction4.encode = function encode5(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.Nonce != null && Object.hasOwnProperty.call(message, "Nonce"))
              writer.uint32(
                /* id 1, wireType 0 =*/
                8
              ).uint64(message.Nonce);
            if (message.Value != null && Object.hasOwnProperty.call(message, "Value"))
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).bytes(message.Value);
            if (message.RcvAddr != null && Object.hasOwnProperty.call(message, "RcvAddr"))
              writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).bytes(message.RcvAddr);
            if (message.RcvUserName != null && Object.hasOwnProperty.call(message, "RcvUserName"))
              writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).bytes(message.RcvUserName);
            if (message.SndAddr != null && Object.hasOwnProperty.call(message, "SndAddr"))
              writer.uint32(
                /* id 5, wireType 2 =*/
                42
              ).bytes(message.SndAddr);
            if (message.SndUserName != null && Object.hasOwnProperty.call(message, "SndUserName"))
              writer.uint32(
                /* id 6, wireType 2 =*/
                50
              ).bytes(message.SndUserName);
            if (message.GasPrice != null && Object.hasOwnProperty.call(message, "GasPrice"))
              writer.uint32(
                /* id 7, wireType 0 =*/
                56
              ).uint64(message.GasPrice);
            if (message.GasLimit != null && Object.hasOwnProperty.call(message, "GasLimit"))
              writer.uint32(
                /* id 8, wireType 0 =*/
                64
              ).uint64(message.GasLimit);
            if (message.Data != null && Object.hasOwnProperty.call(message, "Data"))
              writer.uint32(
                /* id 9, wireType 2 =*/
                74
              ).bytes(message.Data);
            if (message.ChainID != null && Object.hasOwnProperty.call(message, "ChainID"))
              writer.uint32(
                /* id 10, wireType 2 =*/
                82
              ).bytes(message.ChainID);
            if (message.Version != null && Object.hasOwnProperty.call(message, "Version"))
              writer.uint32(
                /* id 11, wireType 0 =*/
                88
              ).uint32(message.Version);
            if (message.Signature != null && Object.hasOwnProperty.call(message, "Signature"))
              writer.uint32(
                /* id 12, wireType 2 =*/
                98
              ).bytes(message.Signature);
            if (message.Options != null && Object.hasOwnProperty.call(message, "Options"))
              writer.uint32(
                /* id 13, wireType 0 =*/
                104
              ).uint32(message.Options);
            if (message.GuardianAddr != null && Object.hasOwnProperty.call(message, "GuardianAddr"))
              writer.uint32(
                /* id 14, wireType 2 =*/
                114
              ).bytes(message.GuardianAddr);
            if (message.GuardianSignature != null && Object.hasOwnProperty.call(message, "GuardianSignature"))
              writer.uint32(
                /* id 15, wireType 2 =*/
                122
              ).bytes(message.GuardianSignature);
            return writer;
          };
          Transaction4.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          Transaction4.decode = function decode6(reader, length2) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length2 === void 0 ? reader.len : reader.pos + length2, message = new $root.proto.Transaction();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.Nonce = reader.uint64();
                  break;
                }
                case 2: {
                  message.Value = reader.bytes();
                  break;
                }
                case 3: {
                  message.RcvAddr = reader.bytes();
                  break;
                }
                case 4: {
                  message.RcvUserName = reader.bytes();
                  break;
                }
                case 5: {
                  message.SndAddr = reader.bytes();
                  break;
                }
                case 6: {
                  message.SndUserName = reader.bytes();
                  break;
                }
                case 7: {
                  message.GasPrice = reader.uint64();
                  break;
                }
                case 8: {
                  message.GasLimit = reader.uint64();
                  break;
                }
                case 9: {
                  message.Data = reader.bytes();
                  break;
                }
                case 10: {
                  message.ChainID = reader.bytes();
                  break;
                }
                case 11: {
                  message.Version = reader.uint32();
                  break;
                }
                case 12: {
                  message.Signature = reader.bytes();
                  break;
                }
                case 13: {
                  message.Options = reader.uint32();
                  break;
                }
                case 14: {
                  message.GuardianAddr = reader.bytes();
                  break;
                }
                case 15: {
                  message.GuardianSignature = reader.bytes();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          Transaction4.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          Transaction4.verify = function verify2(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.Nonce != null && message.hasOwnProperty("Nonce")) {
              if (!$util.isInteger(message.Nonce) && !(message.Nonce && $util.isInteger(message.Nonce.low) && $util.isInteger(message.Nonce.high)))
                return "Nonce: integer|Long expected";
            }
            if (message.Value != null && message.hasOwnProperty("Value")) {
              if (!(message.Value && typeof message.Value.length === "number" || $util.isString(message.Value)))
                return "Value: buffer expected";
            }
            if (message.RcvAddr != null && message.hasOwnProperty("RcvAddr")) {
              if (!(message.RcvAddr && typeof message.RcvAddr.length === "number" || $util.isString(message.RcvAddr)))
                return "RcvAddr: buffer expected";
            }
            if (message.RcvUserName != null && message.hasOwnProperty("RcvUserName")) {
              if (!(message.RcvUserName && typeof message.RcvUserName.length === "number" || $util.isString(message.RcvUserName)))
                return "RcvUserName: buffer expected";
            }
            if (message.SndAddr != null && message.hasOwnProperty("SndAddr")) {
              if (!(message.SndAddr && typeof message.SndAddr.length === "number" || $util.isString(message.SndAddr)))
                return "SndAddr: buffer expected";
            }
            if (message.SndUserName != null && message.hasOwnProperty("SndUserName")) {
              if (!(message.SndUserName && typeof message.SndUserName.length === "number" || $util.isString(message.SndUserName)))
                return "SndUserName: buffer expected";
            }
            if (message.GasPrice != null && message.hasOwnProperty("GasPrice")) {
              if (!$util.isInteger(message.GasPrice) && !(message.GasPrice && $util.isInteger(message.GasPrice.low) && $util.isInteger(message.GasPrice.high)))
                return "GasPrice: integer|Long expected";
            }
            if (message.GasLimit != null && message.hasOwnProperty("GasLimit")) {
              if (!$util.isInteger(message.GasLimit) && !(message.GasLimit && $util.isInteger(message.GasLimit.low) && $util.isInteger(message.GasLimit.high)))
                return "GasLimit: integer|Long expected";
            }
            if (message.Data != null && message.hasOwnProperty("Data")) {
              if (!(message.Data && typeof message.Data.length === "number" || $util.isString(message.Data)))
                return "Data: buffer expected";
            }
            if (message.ChainID != null && message.hasOwnProperty("ChainID")) {
              if (!(message.ChainID && typeof message.ChainID.length === "number" || $util.isString(message.ChainID)))
                return "ChainID: buffer expected";
            }
            if (message.Version != null && message.hasOwnProperty("Version")) {
              if (!$util.isInteger(message.Version))
                return "Version: integer expected";
            }
            if (message.Signature != null && message.hasOwnProperty("Signature")) {
              if (!(message.Signature && typeof message.Signature.length === "number" || $util.isString(message.Signature)))
                return "Signature: buffer expected";
            }
            if (message.Options != null && message.hasOwnProperty("Options")) {
              if (!$util.isInteger(message.Options))
                return "Options: integer expected";
            }
            if (message.GuardianAddr != null && message.hasOwnProperty("GuardianAddr")) {
              if (!(message.GuardianAddr && typeof message.GuardianAddr.length === "number" || $util.isString(message.GuardianAddr)))
                return "GuardianAddr: buffer expected";
            }
            if (message.GuardianSignature != null && message.hasOwnProperty("GuardianSignature")) {
              if (!(message.GuardianSignature && typeof message.GuardianSignature.length === "number" || $util.isString(message.GuardianSignature)))
                return "GuardianSignature: buffer expected";
            }
            return null;
          };
          Transaction4.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.Transaction)
              return object;
            var message = new $root.proto.Transaction();
            if (object.Nonce != null) {
              if ($util.Long)
                (message.Nonce = $util.Long.fromValue(object.Nonce)).unsigned = true;
              else if (typeof object.Nonce === "string")
                message.Nonce = parseInt(object.Nonce, 10);
              else if (typeof object.Nonce === "number")
                message.Nonce = object.Nonce;
              else if (typeof object.Nonce === "object")
                message.Nonce = new $util.LongBits(object.Nonce.low >>> 0, object.Nonce.high >>> 0).toNumber(true);
            }
            if (object.Value != null) {
              if (typeof object.Value === "string")
                $util.base64.decode(object.Value, message.Value = $util.newBuffer($util.base64.length(object.Value)), 0);
              else if (object.Value.length >= 0)
                message.Value = object.Value;
            }
            if (object.RcvAddr != null) {
              if (typeof object.RcvAddr === "string")
                $util.base64.decode(object.RcvAddr, message.RcvAddr = $util.newBuffer($util.base64.length(object.RcvAddr)), 0);
              else if (object.RcvAddr.length >= 0)
                message.RcvAddr = object.RcvAddr;
            }
            if (object.RcvUserName != null) {
              if (typeof object.RcvUserName === "string")
                $util.base64.decode(object.RcvUserName, message.RcvUserName = $util.newBuffer($util.base64.length(object.RcvUserName)), 0);
              else if (object.RcvUserName.length >= 0)
                message.RcvUserName = object.RcvUserName;
            }
            if (object.SndAddr != null) {
              if (typeof object.SndAddr === "string")
                $util.base64.decode(object.SndAddr, message.SndAddr = $util.newBuffer($util.base64.length(object.SndAddr)), 0);
              else if (object.SndAddr.length >= 0)
                message.SndAddr = object.SndAddr;
            }
            if (object.SndUserName != null) {
              if (typeof object.SndUserName === "string")
                $util.base64.decode(object.SndUserName, message.SndUserName = $util.newBuffer($util.base64.length(object.SndUserName)), 0);
              else if (object.SndUserName.length >= 0)
                message.SndUserName = object.SndUserName;
            }
            if (object.GasPrice != null) {
              if ($util.Long)
                (message.GasPrice = $util.Long.fromValue(object.GasPrice)).unsigned = true;
              else if (typeof object.GasPrice === "string")
                message.GasPrice = parseInt(object.GasPrice, 10);
              else if (typeof object.GasPrice === "number")
                message.GasPrice = object.GasPrice;
              else if (typeof object.GasPrice === "object")
                message.GasPrice = new $util.LongBits(object.GasPrice.low >>> 0, object.GasPrice.high >>> 0).toNumber(true);
            }
            if (object.GasLimit != null) {
              if ($util.Long)
                (message.GasLimit = $util.Long.fromValue(object.GasLimit)).unsigned = true;
              else if (typeof object.GasLimit === "string")
                message.GasLimit = parseInt(object.GasLimit, 10);
              else if (typeof object.GasLimit === "number")
                message.GasLimit = object.GasLimit;
              else if (typeof object.GasLimit === "object")
                message.GasLimit = new $util.LongBits(object.GasLimit.low >>> 0, object.GasLimit.high >>> 0).toNumber(true);
            }
            if (object.Data != null) {
              if (typeof object.Data === "string")
                $util.base64.decode(object.Data, message.Data = $util.newBuffer($util.base64.length(object.Data)), 0);
              else if (object.Data.length >= 0)
                message.Data = object.Data;
            }
            if (object.ChainID != null) {
              if (typeof object.ChainID === "string")
                $util.base64.decode(object.ChainID, message.ChainID = $util.newBuffer($util.base64.length(object.ChainID)), 0);
              else if (object.ChainID.length >= 0)
                message.ChainID = object.ChainID;
            }
            if (object.Version != null)
              message.Version = object.Version >>> 0;
            if (object.Signature != null) {
              if (typeof object.Signature === "string")
                $util.base64.decode(object.Signature, message.Signature = $util.newBuffer($util.base64.length(object.Signature)), 0);
              else if (object.Signature.length >= 0)
                message.Signature = object.Signature;
            }
            if (object.Options != null)
              message.Options = object.Options >>> 0;
            if (object.GuardianAddr != null) {
              if (typeof object.GuardianAddr === "string")
                $util.base64.decode(object.GuardianAddr, message.GuardianAddr = $util.newBuffer($util.base64.length(object.GuardianAddr)), 0);
              else if (object.GuardianAddr.length >= 0)
                message.GuardianAddr = object.GuardianAddr;
            }
            if (object.GuardianSignature != null) {
              if (typeof object.GuardianSignature === "string")
                $util.base64.decode(object.GuardianSignature, message.GuardianSignature = $util.newBuffer($util.base64.length(object.GuardianSignature)), 0);
              else if (object.GuardianSignature.length >= 0)
                message.GuardianSignature = object.GuardianSignature;
            }
            return message;
          };
          Transaction4.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.Nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.Nonce = options.longs === String ? "0" : 0;
              if (options.bytes === String)
                object.Value = "";
              else {
                object.Value = [];
                if (options.bytes !== Array)
                  object.Value = $util.newBuffer(object.Value);
              }
              if (options.bytes === String)
                object.RcvAddr = "";
              else {
                object.RcvAddr = [];
                if (options.bytes !== Array)
                  object.RcvAddr = $util.newBuffer(object.RcvAddr);
              }
              if (options.bytes === String)
                object.RcvUserName = "";
              else {
                object.RcvUserName = [];
                if (options.bytes !== Array)
                  object.RcvUserName = $util.newBuffer(object.RcvUserName);
              }
              if (options.bytes === String)
                object.SndAddr = "";
              else {
                object.SndAddr = [];
                if (options.bytes !== Array)
                  object.SndAddr = $util.newBuffer(object.SndAddr);
              }
              if (options.bytes === String)
                object.SndUserName = "";
              else {
                object.SndUserName = [];
                if (options.bytes !== Array)
                  object.SndUserName = $util.newBuffer(object.SndUserName);
              }
              if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.GasPrice = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.GasPrice = options.longs === String ? "0" : 0;
              if ($util.Long) {
                var long = new $util.Long(0, 0, true);
                object.GasLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.GasLimit = options.longs === String ? "0" : 0;
              if (options.bytes === String)
                object.Data = "";
              else {
                object.Data = [];
                if (options.bytes !== Array)
                  object.Data = $util.newBuffer(object.Data);
              }
              if (options.bytes === String)
                object.ChainID = "";
              else {
                object.ChainID = [];
                if (options.bytes !== Array)
                  object.ChainID = $util.newBuffer(object.ChainID);
              }
              object.Version = 0;
              if (options.bytes === String)
                object.Signature = "";
              else {
                object.Signature = [];
                if (options.bytes !== Array)
                  object.Signature = $util.newBuffer(object.Signature);
              }
              object.Options = 0;
              if (options.bytes === String)
                object.GuardianAddr = "";
              else {
                object.GuardianAddr = [];
                if (options.bytes !== Array)
                  object.GuardianAddr = $util.newBuffer(object.GuardianAddr);
              }
              if (options.bytes === String)
                object.GuardianSignature = "";
              else {
                object.GuardianSignature = [];
                if (options.bytes !== Array)
                  object.GuardianSignature = $util.newBuffer(object.GuardianSignature);
              }
            }
            if (message.Nonce != null && message.hasOwnProperty("Nonce"))
              if (typeof message.Nonce === "number")
                object.Nonce = options.longs === String ? String(message.Nonce) : message.Nonce;
              else
                object.Nonce = options.longs === String ? $util.Long.prototype.toString.call(message.Nonce) : options.longs === Number ? new $util.LongBits(message.Nonce.low >>> 0, message.Nonce.high >>> 0).toNumber(true) : message.Nonce;
            if (message.Value != null && message.hasOwnProperty("Value"))
              object.Value = options.bytes === String ? $util.base64.encode(message.Value, 0, message.Value.length) : options.bytes === Array ? Array.prototype.slice.call(message.Value) : message.Value;
            if (message.RcvAddr != null && message.hasOwnProperty("RcvAddr"))
              object.RcvAddr = options.bytes === String ? $util.base64.encode(message.RcvAddr, 0, message.RcvAddr.length) : options.bytes === Array ? Array.prototype.slice.call(message.RcvAddr) : message.RcvAddr;
            if (message.RcvUserName != null && message.hasOwnProperty("RcvUserName"))
              object.RcvUserName = options.bytes === String ? $util.base64.encode(message.RcvUserName, 0, message.RcvUserName.length) : options.bytes === Array ? Array.prototype.slice.call(message.RcvUserName) : message.RcvUserName;
            if (message.SndAddr != null && message.hasOwnProperty("SndAddr"))
              object.SndAddr = options.bytes === String ? $util.base64.encode(message.SndAddr, 0, message.SndAddr.length) : options.bytes === Array ? Array.prototype.slice.call(message.SndAddr) : message.SndAddr;
            if (message.SndUserName != null && message.hasOwnProperty("SndUserName"))
              object.SndUserName = options.bytes === String ? $util.base64.encode(message.SndUserName, 0, message.SndUserName.length) : options.bytes === Array ? Array.prototype.slice.call(message.SndUserName) : message.SndUserName;
            if (message.GasPrice != null && message.hasOwnProperty("GasPrice"))
              if (typeof message.GasPrice === "number")
                object.GasPrice = options.longs === String ? String(message.GasPrice) : message.GasPrice;
              else
                object.GasPrice = options.longs === String ? $util.Long.prototype.toString.call(message.GasPrice) : options.longs === Number ? new $util.LongBits(message.GasPrice.low >>> 0, message.GasPrice.high >>> 0).toNumber(true) : message.GasPrice;
            if (message.GasLimit != null && message.hasOwnProperty("GasLimit"))
              if (typeof message.GasLimit === "number")
                object.GasLimit = options.longs === String ? String(message.GasLimit) : message.GasLimit;
              else
                object.GasLimit = options.longs === String ? $util.Long.prototype.toString.call(message.GasLimit) : options.longs === Number ? new $util.LongBits(message.GasLimit.low >>> 0, message.GasLimit.high >>> 0).toNumber(true) : message.GasLimit;
            if (message.Data != null && message.hasOwnProperty("Data"))
              object.Data = options.bytes === String ? $util.base64.encode(message.Data, 0, message.Data.length) : options.bytes === Array ? Array.prototype.slice.call(message.Data) : message.Data;
            if (message.ChainID != null && message.hasOwnProperty("ChainID"))
              object.ChainID = options.bytes === String ? $util.base64.encode(message.ChainID, 0, message.ChainID.length) : options.bytes === Array ? Array.prototype.slice.call(message.ChainID) : message.ChainID;
            if (message.Version != null && message.hasOwnProperty("Version"))
              object.Version = message.Version;
            if (message.Signature != null && message.hasOwnProperty("Signature"))
              object.Signature = options.bytes === String ? $util.base64.encode(message.Signature, 0, message.Signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.Signature) : message.Signature;
            if (message.Options != null && message.hasOwnProperty("Options"))
              object.Options = message.Options;
            if (message.GuardianAddr != null && message.hasOwnProperty("GuardianAddr"))
              object.GuardianAddr = options.bytes === String ? $util.base64.encode(message.GuardianAddr, 0, message.GuardianAddr.length) : options.bytes === Array ? Array.prototype.slice.call(message.GuardianAddr) : message.GuardianAddr;
            if (message.GuardianSignature != null && message.hasOwnProperty("GuardianSignature"))
              object.GuardianSignature = options.bytes === String ? $util.base64.encode(message.GuardianSignature, 0, message.GuardianSignature.length) : options.bytes === Array ? Array.prototype.slice.call(message.GuardianSignature) : message.GuardianSignature;
            return object;
          };
          Transaction4.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          Transaction4.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Transaction";
          };
          return Transaction4;
        }();
        return proto;
      }();
      return $root;
    });
  }
});

// node_modules/@multiversx/sdk-core/out/proto/serializer.js
var require_serializer = __commonJS({
  "node_modules/@multiversx/sdk-core/out/proto/serializer.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k4 in mod2)
          if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k4))
            __createBinding2(result, mod2, k4);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProtoSerializer = void 0;
    var bignumber_js_1 = __importDefault2(require_bignumber());
    var address_1 = require_address();
    var constants_1 = require_constants();
    var errors = __importStar2(require_errors());
    var utils_1 = require_utils();
    var ProtoSerializer = class {
      /**
       * Serializes a Transaction object to a Buffer. Handles low-level conversion logic and field-mappings as well.
       */
      serializeTransaction(transaction) {
        const proto = require_compiled().proto;
        const receiverPubkey = new address_1.Address(transaction.getReceiver().bech32()).pubkey();
        const senderPubkey = new address_1.Address(transaction.getSender().bech32()).pubkey();
        let protoTransaction = new proto.Transaction({
          // mx-chain-go's serializer handles nonce == 0 differently, thus we treat 0 as "undefined".
          Nonce: transaction.getNonce().valueOf() ? transaction.getNonce().valueOf() : void 0,
          Value: this.serializeTransactionValue(transaction.getValue()),
          RcvAddr: receiverPubkey,
          RcvUserName: transaction.getReceiverUsername() ? import_buffer.Buffer.from(transaction.getReceiverUsername()).toString("base64") : void 0,
          SndAddr: senderPubkey,
          SndUserName: transaction.getSenderUsername() ? import_buffer.Buffer.from(transaction.getSenderUsername()).toString("base64") : void 0,
          GasPrice: transaction.getGasPrice().valueOf(),
          GasLimit: transaction.getGasLimit().valueOf(),
          Data: transaction.getData().length() == 0 ? null : transaction.getData().valueOf(),
          ChainID: import_buffer.Buffer.from(transaction.getChainID().valueOf()),
          Version: transaction.getVersion().valueOf(),
          Signature: transaction.getSignature()
        });
        if (transaction.getOptions().valueOf() !== constants_1.TRANSACTION_OPTIONS_DEFAULT) {
          protoTransaction.Options = transaction.getOptions().valueOf();
        }
        if (transaction.isGuardedTransaction()) {
          const guardianAddress = transaction.getGuardian();
          protoTransaction.GuardianAddr = new address_1.Address(guardianAddress.bech32()).pubkey();
          protoTransaction.GuardianSignature = transaction.getGuardianSignature();
        }
        const encoded = proto.Transaction.encode(protoTransaction).finish();
        const buffer = import_buffer.Buffer.from(encoded);
        return buffer;
      }
      /**
       * Custom serialization, compatible with mx-chain-go.
       */
      serializeTransactionValue(transactionValue) {
        let value = new bignumber_js_1.default(transactionValue.toString());
        if (value.isZero()) {
          return import_buffer.Buffer.from([0, 0]);
        }
        let buffer = utils_1.bigIntToBuffer(value);
        buffer = import_buffer.Buffer.concat([import_buffer.Buffer.from([0]), buffer]);
        return buffer;
      }
      deserializeTransaction(_buffer) {
        throw new errors.ErrUnsupportedOperation("deserializeTransaction");
      }
    };
    exports2.ProtoSerializer = ProtoSerializer;
  }
});

// node_modules/@multiversx/sdk-core/out/proto/index.js
var require_proto = __commonJS({
  "node_modules/@multiversx/sdk-core/out/proto/index.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m3, exports3) {
      for (var p3 in m3)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3))
          __createBinding2(exports3, m3, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_serializer(), exports2);
  }
});

// node_modules/@multiversx/sdk-core/out/transactionComputer.js
var require_transactionComputer = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionComputer.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k4 in mod2)
          if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k4))
            __createBinding2(result, mod2, k4);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransactionComputer = void 0;
    var errors = __importStar2(require_errors());
    var bignumber_js_1 = __importDefault2(require_bignumber());
    var proto_1 = require_proto();
    var transaction_1 = require_transaction();
    var constants_1 = require_constants();
    var createTransactionHasher = require_blake2b2();
    var createKeccakHash = require_js();
    var TRANSACTION_HASH_LENGTH = 32;
    var TransactionComputer2 = class {
      constructor() {
      }
      computeTransactionFee(transaction, networkConfig2) {
        const moveBalanceGas = BigInt(networkConfig2.MinGasLimit + transaction.data.length * networkConfig2.GasPerDataByte);
        if (moveBalanceGas > transaction.gasLimit) {
          throw new errors.ErrNotEnoughGas(parseInt(transaction.gasLimit.toString(), 10));
        }
        const gasPrice = transaction.gasPrice;
        const feeForMove = moveBalanceGas * gasPrice;
        if (moveBalanceGas === transaction.gasLimit) {
          return feeForMove;
        }
        const diff = transaction.gasLimit - moveBalanceGas;
        const modifiedGasPrice = BigInt(new bignumber_js_1.default(gasPrice.toString()).multipliedBy(new bignumber_js_1.default(networkConfig2.GasPriceModifier)).toFixed(0));
        const processingFee = diff * modifiedGasPrice;
        return feeForMove + processingFee;
      }
      computeBytesForSigning(transaction) {
        this.ensureValidTransactionFields(transaction);
        const plainTransaction = this.toPlainObjectForSigning(transaction);
        const serialized = JSON.stringify(plainTransaction);
        return new Uint8Array(import_buffer.Buffer.from(serialized));
      }
      computeBytesForVerifying(transaction) {
        const isTxSignedByHash = this.hasOptionsSetForHashSigning(transaction);
        if (isTxSignedByHash) {
          return this.computeHashForSigning(transaction);
        }
        return this.computeBytesForSigning(transaction);
      }
      computeHashForSigning(transaction) {
        const plainTransaction = this.toPlainObjectForSigning(transaction);
        const signable = import_buffer.Buffer.from(JSON.stringify(plainTransaction));
        return createKeccakHash("keccak256").update(signable).digest();
      }
      computeTransactionHash(transaction) {
        const serializer = new proto_1.ProtoSerializer();
        const buffer = serializer.serializeTransaction(new transaction_1.Transaction(transaction));
        const hash = createTransactionHasher(TRANSACTION_HASH_LENGTH).update(buffer).digest("hex");
        return import_buffer.Buffer.from(hash, "hex");
      }
      hasOptionsSetForGuardedTransaction(transaction) {
        return (transaction.options & constants_1.TRANSACTION_OPTIONS_TX_GUARDED) == constants_1.TRANSACTION_OPTIONS_TX_GUARDED;
      }
      hasOptionsSetForHashSigning(transaction) {
        return (transaction.options & constants_1.TRANSACTION_OPTIONS_TX_HASH_SIGN) == constants_1.TRANSACTION_OPTIONS_TX_HASH_SIGN;
      }
      applyGuardian(transaction, guardian) {
        if (transaction.version < constants_1.MIN_TRANSACTION_VERSION_THAT_SUPPORTS_OPTIONS) {
          transaction.version = constants_1.MIN_TRANSACTION_VERSION_THAT_SUPPORTS_OPTIONS;
        }
        transaction.options = transaction.options | constants_1.TRANSACTION_OPTIONS_TX_GUARDED;
        transaction.guardian = guardian;
      }
      applyOptionsForHashSigning(transaction) {
        if (transaction.version < constants_1.MIN_TRANSACTION_VERSION_THAT_SUPPORTS_OPTIONS) {
          transaction.version = constants_1.MIN_TRANSACTION_VERSION_THAT_SUPPORTS_OPTIONS;
        }
        transaction.options = transaction.options | constants_1.TRANSACTION_OPTIONS_TX_HASH_SIGN;
      }
      toPlainObjectForSigning(transaction) {
        return {
          nonce: Number(transaction.nonce),
          value: transaction.value.toString(),
          receiver: transaction.receiver,
          sender: transaction.sender,
          senderUsername: this.toBase64OrUndefined(transaction.senderUsername),
          receiverUsername: this.toBase64OrUndefined(transaction.receiverUsername),
          gasPrice: Number(transaction.gasPrice),
          gasLimit: Number(transaction.gasLimit),
          data: this.toBase64OrUndefined(transaction.data),
          chainID: transaction.chainID,
          version: transaction.version,
          options: transaction.options ? transaction.options : void 0,
          guardian: transaction.guardian ? transaction.guardian : void 0
        };
      }
      toBase64OrUndefined(value) {
        return value && value.length ? import_buffer.Buffer.from(value).toString("base64") : void 0;
      }
      ensureValidTransactionFields(transaction) {
        if (transaction.sender.length !== constants_1.BECH32_ADDRESS_LENGTH) {
          throw new errors.ErrBadUsage("Invalid `sender` field. Should be the bech32 address of the sender.");
        }
        if (transaction.receiver.length !== constants_1.BECH32_ADDRESS_LENGTH) {
          throw new errors.ErrBadUsage("Invalid `receiver` field. Should be the bech32 address of the receiver.");
        }
        if (!transaction.chainID.length) {
          throw new errors.ErrBadUsage("The `chainID` field is not set");
        }
        if (transaction.version < constants_1.MIN_TRANSACTION_VERSION_THAT_SUPPORTS_OPTIONS) {
          if (this.hasOptionsSetForGuardedTransaction(transaction) || this.hasOptionsSetForHashSigning(transaction)) {
            throw new errors.ErrBadUsage(`Non-empty transaction options requires transaction version >= ${constants_1.MIN_TRANSACTION_VERSION_THAT_SUPPORTS_OPTIONS}`);
          }
        }
      }
    };
    exports2.TransactionComputer = TransactionComputer2;
  }
});

// node_modules/@multiversx/sdk-core/out/transaction.js
var require_transaction = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transaction.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransactionHash = exports2.Transaction = void 0;
    var bignumber_js_1 = require_bignumber();
    var address_1 = require_address();
    var constants_1 = require_constants();
    var transactionsConverter_1 = require_transactionsConverter();
    var hash_1 = require_hash();
    var networkParams_1 = require_networkParams();
    var signature_1 = require_signature();
    var transactionPayload_1 = require_transactionPayload();
    var transactionComputer_1 = require_transactionComputer();
    var Transaction4 = class {
      /**
       * Creates a new Transaction object.
       */
      constructor(options) {
        this.nonce = BigInt(options.nonce?.valueOf() || 0n);
        this.value = options.value ? BigInt(new bignumber_js_1.BigNumber(options.value.toString()).toFixed(0)) : 0n;
        this.sender = this.addressAsBech32(options.sender);
        this.receiver = this.addressAsBech32(options.receiver);
        this.senderUsername = options.senderUsername || "";
        this.receiverUsername = options.receiverUsername || "";
        this.gasPrice = BigInt(options.gasPrice?.valueOf() || constants_1.TRANSACTION_MIN_GAS_PRICE);
        this.gasLimit = BigInt(options.gasLimit.valueOf());
        this.data = options.data?.valueOf() || new Uint8Array();
        this.chainID = options.chainID.valueOf();
        this.version = Number(options.version?.valueOf() || constants_1.TRANSACTION_VERSION_DEFAULT);
        this.options = Number(options.options?.valueOf() || constants_1.TRANSACTION_OPTIONS_DEFAULT);
        this.guardian = options.guardian ? this.addressAsBech32(options.guardian) : "";
        this.signature = options.signature || import_buffer.Buffer.from([]);
        this.guardianSignature = options.guardianSignature || import_buffer.Buffer.from([]);
      }
      addressAsBech32(address) {
        return typeof address === "string" ? address : address.bech32();
      }
      /**
       * Legacy method, use the "nonce" property instead.
       */
      getNonce() {
        return Number(this.nonce);
      }
      /**
       * Legacy method, use the "nonce" property instead.
       * Sets the account sequence number of the sender. Must be done prior signing.
       */
      setNonce(nonce) {
        this.nonce = BigInt(nonce.valueOf());
      }
      /**
       * Legacy method, use the "value" property instead.
       */
      getValue() {
        return this.value;
      }
      /**
       * Legacy method, use the "value" property instead.
       */
      setValue(value) {
        this.value = BigInt(value.toString());
      }
      /**
       * Legacy method, use the "sender" property instead.
       */
      getSender() {
        return address_1.Address.fromBech32(this.sender);
      }
      /**
       * Legacy method, use the "sender" property instead.
       */
      setSender(sender) {
        this.sender = typeof sender === "string" ? sender : sender.bech32();
      }
      /**
       * Legacy method, use the "receiver" property instead.
       */
      getReceiver() {
        return address_1.Address.fromBech32(this.receiver);
      }
      /**
       * Legacy method, use the "senderUsername" property instead.
       */
      getSenderUsername() {
        return this.senderUsername;
      }
      /**
       * Legacy method, use the "senderUsername" property instead.
       */
      setSenderUsername(senderUsername) {
        this.senderUsername = senderUsername;
      }
      /**
       * Legacy method, use the "receiverUsername" property instead.
       */
      getReceiverUsername() {
        return this.receiverUsername;
      }
      /**
       * Legacy method, use the "receiverUsername" property instead.
       */
      setReceiverUsername(receiverUsername) {
        this.receiverUsername = receiverUsername;
      }
      /**
       * Legacy method, use the "guardian" property instead.
       */
      getGuardian() {
        return new address_1.Address(this.guardian);
      }
      /**
       * Legacy method, use the "gasPrice" property instead.
       */
      getGasPrice() {
        return Number(this.gasPrice);
      }
      /**
       * Legacy method, use the "gasPrice" property instead.
       */
      setGasPrice(gasPrice) {
        this.gasPrice = BigInt(gasPrice.valueOf());
      }
      /**
       * Legacy method, use the "gasLimit" property instead.
       */
      getGasLimit() {
        return Number(this.gasLimit);
      }
      /**
       * Legacy method, use the "gasLimit" property instead.
       */
      setGasLimit(gasLimit) {
        this.gasLimit = BigInt(gasLimit.valueOf());
      }
      /**
       * Legacy method, use the "data" property instead.
       */
      getData() {
        return new transactionPayload_1.TransactionPayload(import_buffer.Buffer.from(this.data));
      }
      /**
       * Legacy method, use the "chainID" property instead.
       */
      getChainID() {
        return this.chainID;
      }
      /**
       * Legacy method, use the "chainID" property instead.
       */
      setChainID(chainID) {
        this.chainID = chainID.valueOf();
      }
      /**
       * Legacy method, use the "version" property instead.
       */
      getVersion() {
        return new networkParams_1.TransactionVersion(this.version);
      }
      /**
       * Legacy method, use the "version" property instead.
       */
      setVersion(version2) {
        this.version = version2.valueOf();
      }
      /**
       * Legacy method, use the "options" property instead.
       */
      getOptions() {
        return new networkParams_1.TransactionOptions(this.options.valueOf());
      }
      /**
       * Legacy method, use the "options" property instead.
       *
       * Question for review: check how the options are set by sdk-dapp, wallet, ledger, extension.
       */
      setOptions(options) {
        this.options = options.valueOf();
      }
      /**
       * Legacy method, use the "signature" property instead.
       */
      getSignature() {
        return import_buffer.Buffer.from(this.signature);
      }
      /**
       * Legacy method, use the "guardianSignature" property instead.
       */
      getGuardianSignature() {
        return import_buffer.Buffer.from(this.guardianSignature);
      }
      /**
       * Legacy method, use the "guardian" property instead.
       */
      setGuardian(guardian) {
        this.guardian = typeof guardian === "string" ? guardian : guardian.bech32();
      }
      /**
       * Legacy method, use "TransactionComputer.computeTransactionHash()" instead.
       */
      getHash() {
        return TransactionHash.compute(this);
      }
      /**
       * Legacy method, use "TransactionComputer.computeBytesForSigning()" instead.
       * Serializes a transaction to a sequence of bytes, ready to be signed.
       * This function is called internally by signers.
       */
      serializeForSigning() {
        const computer = new transactionComputer_1.TransactionComputer();
        const bytes = computer.computeBytesForSigning(this);
        return import_buffer.Buffer.from(bytes);
      }
      /**
       * Checks the integrity of the guarded transaction
       */
      isGuardedTransaction() {
        const hasGuardian = this.guardian.length > 0;
        const hasGuardianSignature = this.guardianSignature.length > 0;
        return this.getOptions().isWithGuardian() && hasGuardian && hasGuardianSignature;
      }
      /**
       * Legacy method, use "TransactionsConverter.transactionToPlainObject()" instead.
       *
       * Converts the transaction object into a ready-to-serialize, plain JavaScript object.
       * This function is called internally within the signing procedure.
       */
      toPlainObject() {
        const converter = new transactionsConverter_1.TransactionsConverter();
        return converter.transactionToPlainObject(this);
      }
      /**
       * Legacy method, use "TransactionsConverter.plainObjectToTransaction()" instead.
       * Converts a plain object transaction into a Transaction Object.
       *
       * @param plainObjectTransaction Raw data of a transaction, usually obtained by calling toPlainObject()
       */
      static fromPlainObject(plainObjectTransaction) {
        const converter = new transactionsConverter_1.TransactionsConverter();
        return converter.plainObjectToTransaction(plainObjectTransaction);
      }
      /**
       * Legacy method, use the "signature" property instead.
       * Applies the signature on the transaction.
       *
       * @param signature The signature, as computed by a signer.
       */
      applySignature(signature) {
        this.signature = signature_1.interpretSignatureAsBuffer(signature);
      }
      /**
       * Legacy method, use the "guardianSignature" property instead.
       * Applies the guardian signature on the transaction.
       *
       * @param guardianSignature The signature, as computed by a signer.
       */
      applyGuardianSignature(guardianSignature) {
        this.guardianSignature = signature_1.interpretSignatureAsBuffer(guardianSignature);
      }
      /**
       * Converts a transaction to a ready-to-broadcast object.
       * Called internally by the network provider.
       */
      toSendable() {
        return this.toPlainObject();
      }
      /**
       * Legacy method, use "TransactionComputer.computeTransactionFee()" instead.
       *
       * Computes the current transaction fee based on the {@link NetworkConfig} and transaction properties
       * @param networkConfig {@link NetworkConfig}
       */
      computeFee(networkConfig2) {
        const computer = new transactionComputer_1.TransactionComputer();
        const fee = computer.computeTransactionFee(this, networkConfig2);
        return new bignumber_js_1.BigNumber(fee.toString());
      }
    };
    exports2.Transaction = Transaction4;
    var TransactionHash = class _TransactionHash extends hash_1.Hash {
      constructor(hash) {
        super(hash);
      }
      /**
       * Legacy method, use "TransactionComputer.computeTransactionHash()" instead.
       * Computes the hash of a transaction.
       */
      static compute(transaction) {
        const computer = new transactionComputer_1.TransactionComputer();
        const hash = computer.computeTransactionHash(transaction);
        return new _TransactionHash(import_buffer.Buffer.from(hash).toString("hex"));
      }
    };
    exports2.TransactionHash = TransactionHash;
  }
});

// node_modules/@multiversx/sdk-core/out/tokenOperations/tokenOperationsFactory.js
var require_tokenOperationsFactory = __commonJS({
  "node_modules/@multiversx/sdk-core/out/tokenOperations/tokenOperationsFactory.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TokenOperationsFactory = void 0;
    var constants_1 = require_constants();
    var logger_1 = require_logger();
    var networkParams_1 = require_networkParams();
    var transaction_1 = require_transaction();
    var transactionPayload_1 = require_transactionPayload();
    var codec_1 = require_codec();
    var TokenOperationsFactory2 = class {
      constructor(config) {
        this.config = config;
        this.trueAsHex = codec_1.utf8ToHex("true");
        this.falseAsHex = codec_1.utf8ToHex("false");
      }
      issueFungible(args) {
        this.notifyAboutUnsettingBurnRoleGlobally();
        const parts = [
          "issue",
          codec_1.utf8ToHex(args.tokenName),
          codec_1.utf8ToHex(args.tokenTicker),
          codec_1.bigIntToHex(args.initialSupply),
          codec_1.bigIntToHex(args.numDecimals),
          codec_1.utf8ToHex("canFreeze"),
          args.canFreeze ? this.trueAsHex : this.falseAsHex,
          codec_1.utf8ToHex("canWipe"),
          args.canWipe ? this.trueAsHex : this.falseAsHex,
          codec_1.utf8ToHex("canPause"),
          args.canPause ? this.trueAsHex : this.falseAsHex,
          codec_1.utf8ToHex("canChangeOwner"),
          args.canChangeOwner ? this.trueAsHex : this.falseAsHex,
          codec_1.utf8ToHex("canUpgrade"),
          args.canUpgrade ? this.trueAsHex : this.falseAsHex,
          codec_1.utf8ToHex("canAddSpecialRoles"),
          args.canAddSpecialRoles ? this.trueAsHex : this.falseAsHex
        ];
        return this.createTransaction({
          sender: args.issuer,
          receiver: this.config.esdtContractAddress,
          nonce: args.transactionNonce,
          value: this.config.issueCost,
          gasPrice: args.gasPrice,
          gasLimitHint: args.gasLimit,
          executionGasLimit: this.config.gasLimitIssue,
          dataParts: parts
        });
      }
      notifyAboutUnsettingBurnRoleGlobally() {
        logger_1.Logger.info(`
==========
IMPORTANT!
==========
You are about to issue (register) a new token. This will set the role "ESDTRoleBurnForAll" (globally).
Once the token is registered, you can unset this role by calling "unsetBurnRoleGlobally" (in a separate transaction).`);
      }
      issueSemiFungible(args) {
        this.notifyAboutUnsettingBurnRoleGlobally();
        const parts = [
          "issueSemiFungible",
          codec_1.utf8ToHex(args.tokenName),
          codec_1.utf8ToHex(args.tokenTicker),
          codec_1.utf8ToHex("canFreeze"),
          args.canFreeze ? this.trueAsHex : this.falseAsHex,
          codec_1.utf8ToHex("canWipe"),
          args.canWipe ? this.trueAsHex : this.falseAsHex,
          codec_1.utf8ToHex("canPause"),
          args.canPause ? this.trueAsHex : this.falseAsHex,
          codec_1.utf8ToHex("canTransferNFTCreateRole"),
          args.canTransferNFTCreateRole ? this.trueAsHex : this.falseAsHex,
          codec_1.utf8ToHex("canChangeOwner"),
          args.canChangeOwner ? this.trueAsHex : this.falseAsHex,
          codec_1.utf8ToHex("canUpgrade"),
          args.canUpgrade ? this.trueAsHex : this.falseAsHex,
          codec_1.utf8ToHex("canAddSpecialRoles"),
          args.canAddSpecialRoles ? this.trueAsHex : this.falseAsHex
        ];
        return this.createTransaction({
          sender: args.issuer,
          receiver: this.config.esdtContractAddress,
          nonce: args.transactionNonce,
          value: this.config.issueCost,
          gasPrice: args.gasPrice,
          gasLimitHint: args.gasLimit,
          executionGasLimit: this.config.gasLimitIssue,
          dataParts: parts
        });
      }
      issueNonFungible(args) {
        this.notifyAboutUnsettingBurnRoleGlobally();
        const parts = [
          "issueNonFungible",
          codec_1.utf8ToHex(args.tokenName),
          codec_1.utf8ToHex(args.tokenTicker),
          codec_1.utf8ToHex("canFreeze"),
          args.canFreeze ? this.trueAsHex : this.falseAsHex,
          codec_1.utf8ToHex("canWipe"),
          args.canWipe ? this.trueAsHex : this.falseAsHex,
          codec_1.utf8ToHex("canPause"),
          args.canPause ? this.trueAsHex : this.falseAsHex,
          codec_1.utf8ToHex("canTransferNFTCreateRole"),
          args.canTransferNFTCreateRole ? this.trueAsHex : this.falseAsHex,
          codec_1.utf8ToHex("canChangeOwner"),
          args.canChangeOwner ? this.trueAsHex : this.falseAsHex,
          codec_1.utf8ToHex("canUpgrade"),
          args.canUpgrade ? this.trueAsHex : this.falseAsHex,
          codec_1.utf8ToHex("canAddSpecialRoles"),
          args.canAddSpecialRoles ? this.trueAsHex : this.falseAsHex
        ];
        return this.createTransaction({
          sender: args.issuer,
          receiver: this.config.esdtContractAddress,
          nonce: args.transactionNonce,
          value: this.config.issueCost,
          gasPrice: args.gasPrice,
          gasLimitHint: args.gasLimit,
          executionGasLimit: this.config.gasLimitIssue,
          dataParts: parts
        });
      }
      registerMetaESDT(args) {
        this.notifyAboutUnsettingBurnRoleGlobally();
        const parts = [
          "registerMetaESDT",
          codec_1.utf8ToHex(args.tokenName),
          codec_1.utf8ToHex(args.tokenTicker),
          codec_1.bigIntToHex(args.numDecimals),
          codec_1.utf8ToHex("canFreeze"),
          args.canFreeze ? this.trueAsHex : this.falseAsHex,
          codec_1.utf8ToHex("canWipe"),
          args.canWipe ? this.trueAsHex : this.falseAsHex,
          codec_1.utf8ToHex("canPause"),
          args.canPause ? this.trueAsHex : this.falseAsHex,
          codec_1.utf8ToHex("canTransferNFTCreateRole"),
          args.canTransferNFTCreateRole ? this.trueAsHex : this.falseAsHex,
          codec_1.utf8ToHex("canChangeOwner"),
          args.canChangeOwner ? this.trueAsHex : this.falseAsHex,
          codec_1.utf8ToHex("canUpgrade"),
          args.canUpgrade ? this.trueAsHex : this.falseAsHex,
          codec_1.utf8ToHex("canAddSpecialRoles"),
          args.canAddSpecialRoles ? this.trueAsHex : this.falseAsHex
        ];
        return this.createTransaction({
          sender: args.issuer,
          receiver: this.config.esdtContractAddress,
          nonce: args.transactionNonce,
          value: this.config.issueCost,
          gasPrice: args.gasPrice,
          gasLimitHint: args.gasLimit,
          executionGasLimit: this.config.gasLimitIssue,
          dataParts: parts
        });
      }
      registerAndSetAllRoles(args) {
        this.notifyAboutUnsettingBurnRoleGlobally();
        const parts = [
          "registerAndSetAllRoles",
          codec_1.utf8ToHex(args.tokenName),
          codec_1.utf8ToHex(args.tokenTicker),
          codec_1.utf8ToHex(args.tokenType),
          codec_1.bigIntToHex(args.numDecimals)
        ];
        return this.createTransaction({
          sender: args.issuer,
          receiver: this.config.esdtContractAddress,
          nonce: args.transactionNonce,
          value: this.config.issueCost,
          gasPrice: args.gasPrice,
          gasLimitHint: args.gasLimit,
          executionGasLimit: this.config.gasLimitIssue,
          dataParts: parts
        });
      }
      setBurnRoleGlobally(args) {
        const parts = ["setBurnRoleGlobally", codec_1.utf8ToHex(args.tokenIdentifier)];
        return this.createTransaction({
          sender: args.manager,
          receiver: this.config.esdtContractAddress,
          nonce: args.transactionNonce,
          gasPrice: args.gasPrice,
          gasLimitHint: args.gasLimit,
          executionGasLimit: this.config.gasLimitToggleBurnRoleGlobally,
          dataParts: parts
        });
      }
      unsetBurnRoleGlobally(args) {
        const parts = ["unsetBurnRoleGlobally", codec_1.utf8ToHex(args.tokenIdentifier)];
        return this.createTransaction({
          sender: args.manager,
          receiver: this.config.esdtContractAddress,
          nonce: args.transactionNonce,
          gasPrice: args.gasPrice,
          gasLimitHint: args.gasLimit,
          executionGasLimit: this.config.gasLimitToggleBurnRoleGlobally,
          dataParts: parts
        });
      }
      setSpecialRoleOnFungible(args) {
        const parts = [
          "setSpecialRole",
          codec_1.utf8ToHex(args.tokenIdentifier),
          codec_1.addressToHex(args.user),
          ...args.addRoleLocalMint ? [codec_1.utf8ToHex("ESDTRoleLocalMint")] : [],
          ...args.addRoleLocalBurn ? [codec_1.utf8ToHex("ESDTRoleLocalBurn")] : []
        ];
        return this.createTransaction({
          sender: args.manager,
          receiver: this.config.esdtContractAddress,
          nonce: args.transactionNonce,
          gasPrice: args.gasPrice,
          gasLimitHint: args.gasLimit,
          executionGasLimit: this.config.gasLimitSetSpecialRole,
          dataParts: parts
        });
      }
      setSpecialRoleOnSemiFungible(args) {
        const parts = [
          "setSpecialRole",
          codec_1.utf8ToHex(args.tokenIdentifier),
          codec_1.addressToHex(args.user),
          ...args.addRoleNFTCreate ? [codec_1.utf8ToHex("ESDTRoleNFTCreate")] : [],
          ...args.addRoleNFTBurn ? [codec_1.utf8ToHex("ESDTRoleNFTBurn")] : [],
          ...args.addRoleNFTAddQuantity ? [codec_1.utf8ToHex("ESDTRoleNFTAddQuantity")] : [],
          ...args.addRoleESDTTransferRole ? [codec_1.utf8ToHex("ESDTTransferRole")] : []
        ];
        return this.createTransaction({
          sender: args.manager,
          receiver: this.config.esdtContractAddress,
          nonce: args.transactionNonce,
          gasPrice: args.gasPrice,
          gasLimitHint: args.gasLimit,
          executionGasLimit: this.config.gasLimitSetSpecialRole,
          dataParts: parts
        });
      }
      setSpecialRoleOnMetaESDT(args) {
        return this.setSpecialRoleOnSemiFungible(args);
      }
      setSpecialRoleOnNonFungible(args) {
        const parts = [
          "setSpecialRole",
          codec_1.utf8ToHex(args.tokenIdentifier),
          codec_1.addressToHex(args.user),
          ...args.addRoleNFTCreate ? [codec_1.utf8ToHex("ESDTRoleNFTCreate")] : [],
          ...args.addRoleNFTBurn ? [codec_1.utf8ToHex("ESDTRoleNFTBurn")] : [],
          ...args.addRoleNFTUpdateAttributes ? [codec_1.utf8ToHex("ESDTRoleNFTUpdateAttributes")] : [],
          ...args.addRoleNFTAddURI ? [codec_1.utf8ToHex("ESDTRoleNFTAddURI")] : [],
          ...args.addRoleESDTTransferRole ? [codec_1.utf8ToHex("ESDTTransferRole")] : []
        ];
        return this.createTransaction({
          sender: args.manager,
          receiver: this.config.esdtContractAddress,
          nonce: args.transactionNonce,
          gasPrice: args.gasPrice,
          gasLimitHint: args.gasLimit,
          executionGasLimit: this.config.gasLimitSetSpecialRole,
          dataParts: parts
        });
      }
      nftCreate(args) {
        const parts = [
          "ESDTNFTCreate",
          codec_1.utf8ToHex(args.tokenIdentifier),
          codec_1.bigIntToHex(args.initialQuantity),
          codec_1.utf8ToHex(args.name),
          codec_1.bigIntToHex(args.royalties),
          codec_1.utf8ToHex(args.hash),
          codec_1.bufferToHex(args.attributes),
          ...args.uris.map(codec_1.utf8ToHex)
        ];
        const nftData = args.name + args.hash + args.attributes + args.uris.join("");
        const storageGasLimit = nftData.length * this.config.gasLimitStorePerByte.valueOf();
        return this.createTransaction({
          sender: args.creator,
          receiver: args.creator,
          nonce: args.transactionNonce,
          gasPrice: args.gasPrice,
          gasLimitHint: args.gasLimit,
          executionGasLimit: this.config.gasLimitESDTNFTCreate.valueOf() + storageGasLimit.valueOf(),
          dataParts: parts
        });
      }
      pause(args) {
        const parts = ["pause", codec_1.utf8ToHex(args.tokenIdentifier)];
        return this.createTransaction({
          sender: args.manager,
          receiver: this.config.esdtContractAddress,
          nonce: args.transactionNonce,
          gasPrice: args.gasPrice,
          gasLimitHint: args.gasLimit,
          executionGasLimit: this.config.gasLimitPausing,
          dataParts: parts
        });
      }
      unpause(args) {
        const parts = ["unPause", codec_1.utf8ToHex(args.tokenIdentifier)];
        return this.createTransaction({
          sender: args.manager,
          receiver: this.config.esdtContractAddress,
          nonce: args.transactionNonce,
          gasPrice: args.gasPrice,
          gasLimitHint: args.gasLimit,
          executionGasLimit: this.config.gasLimitPausing,
          dataParts: parts
        });
      }
      freeze(args) {
        const parts = ["freeze", codec_1.utf8ToHex(args.tokenIdentifier), codec_1.addressToHex(args.user)];
        return this.createTransaction({
          sender: args.manager,
          receiver: this.config.esdtContractAddress,
          nonce: args.transactionNonce,
          gasPrice: args.gasPrice,
          gasLimitHint: args.gasLimit,
          executionGasLimit: this.config.gasLimitFreezing,
          dataParts: parts
        });
      }
      unfreeze(args) {
        const parts = ["unFreeze", codec_1.utf8ToHex(args.tokenIdentifier), codec_1.addressToHex(args.user)];
        return this.createTransaction({
          sender: args.manager,
          receiver: this.config.esdtContractAddress,
          nonce: args.transactionNonce,
          gasPrice: args.gasPrice,
          gasLimitHint: args.gasLimit,
          executionGasLimit: this.config.gasLimitFreezing,
          dataParts: parts
        });
      }
      wipe(args) {
        const parts = ["wipe", codec_1.utf8ToHex(args.tokenIdentifier), codec_1.addressToHex(args.user)];
        return this.createTransaction({
          sender: args.manager,
          receiver: this.config.esdtContractAddress,
          nonce: args.transactionNonce,
          gasPrice: args.gasPrice,
          gasLimitHint: args.gasLimit,
          executionGasLimit: this.config.gasLimitWiping,
          dataParts: parts
        });
      }
      localMint(args) {
        const parts = ["ESDTLocalMint", codec_1.utf8ToHex(args.tokenIdentifier), codec_1.bigIntToHex(args.supplyToMint)];
        return this.createTransaction({
          sender: args.manager,
          receiver: args.manager,
          nonce: args.transactionNonce,
          gasPrice: args.gasPrice,
          gasLimitHint: args.gasLimit,
          executionGasLimit: this.config.gasLimitESDTLocalMint,
          dataParts: parts
        });
      }
      localBurn(args) {
        const parts = ["ESDTLocalBurn", codec_1.utf8ToHex(args.tokenIdentifier), codec_1.bigIntToHex(args.supplyToBurn)];
        return this.createTransaction({
          sender: args.manager,
          receiver: args.manager,
          nonce: args.transactionNonce,
          gasPrice: args.gasPrice,
          gasLimitHint: args.gasLimit,
          executionGasLimit: this.config.gasLimitESDTLocalBurn,
          dataParts: parts
        });
      }
      updateAttributes(args) {
        const parts = [
          "ESDTNFTUpdateAttributes",
          codec_1.utf8ToHex(args.tokenIdentifier),
          codec_1.bigIntToHex(args.tokenNonce),
          codec_1.bufferToHex(args.attributes)
        ];
        return this.createTransaction({
          sender: args.manager,
          receiver: args.manager,
          nonce: args.transactionNonce,
          gasPrice: args.gasPrice,
          gasLimitHint: args.gasLimit,
          executionGasLimit: this.config.gasLimitESDTNFTUpdateAttributes,
          dataParts: parts
        });
      }
      addQuantity(args) {
        const parts = [
          "ESDTNFTAddQuantity",
          codec_1.utf8ToHex(args.tokenIdentifier),
          codec_1.bigIntToHex(args.tokenNonce),
          codec_1.bigIntToHex(args.quantityToAdd)
        ];
        return this.createTransaction({
          sender: args.manager,
          receiver: args.manager,
          nonce: args.transactionNonce,
          gasPrice: args.gasPrice,
          gasLimitHint: args.gasLimit,
          executionGasLimit: this.config.gasLimitESDTNFTAddQuantity,
          dataParts: parts
        });
      }
      burnQuantity(args) {
        const parts = [
          "ESDTNFTBurn",
          codec_1.utf8ToHex(args.tokenIdentifier),
          codec_1.bigIntToHex(args.tokenNonce),
          codec_1.bigIntToHex(args.quantityToBurn)
        ];
        return this.createTransaction({
          sender: args.manager,
          receiver: args.manager,
          nonce: args.transactionNonce,
          gasPrice: args.gasPrice,
          gasLimitHint: args.gasLimit,
          executionGasLimit: this.config.gasLimitESDTNFTBurn,
          dataParts: parts
        });
      }
      createTransaction({ sender, receiver, nonce, value, gasPrice, gasLimitHint, executionGasLimit, dataParts }) {
        const payload = this.buildTransactionPayload(dataParts);
        const gasLimit = gasLimitHint || this.computeGasLimit(payload, executionGasLimit);
        const version2 = new networkParams_1.TransactionVersion(constants_1.TRANSACTION_VERSION_DEFAULT);
        const options = new networkParams_1.TransactionOptions(constants_1.TRANSACTION_OPTIONS_DEFAULT);
        return new transaction_1.Transaction({
          chainID: this.config.chainID,
          sender,
          receiver,
          gasLimit,
          gasPrice,
          nonce: nonce || 0,
          value: value || 0,
          data: payload,
          version: version2,
          options
        });
      }
      buildTransactionPayload(parts) {
        const data = parts.join(constants_1.ARGUMENTS_SEPARATOR);
        return new transactionPayload_1.TransactionPayload(data);
      }
      computeGasLimit(payload, executionGas) {
        const dataMovementGas = this.config.minGasLimit.valueOf() + this.config.gasLimitPerByte.valueOf() * payload.length();
        return dataMovementGas + executionGas.valueOf();
      }
    };
    exports2.TokenOperationsFactory = TokenOperationsFactory2;
  }
});

// node_modules/@multiversx/sdk-core/out/tokenOperations/tokenOperationsFactoryConfig.js
var require_tokenOperationsFactoryConfig = __commonJS({
  "node_modules/@multiversx/sdk-core/out/tokenOperations/tokenOperationsFactoryConfig.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TokenOperationsFactoryConfig = void 0;
    var address_1 = require_address();
    var TokenOperationsFactoryConfig2 = class {
      constructor(chainID) {
        this.minGasPrice = 1e9;
        this.minGasLimit = 5e4;
        this.gasLimitPerByte = 1500;
        this.gasLimitIssue = 6e7;
        this.gasLimitToggleBurnRoleGlobally = 6e7;
        this.gasLimitESDTLocalMint = 3e5;
        this.gasLimitESDTLocalBurn = 3e5;
        this.gasLimitSetSpecialRole = 6e7;
        this.gasLimitPausing = 6e7;
        this.gasLimitFreezing = 6e7;
        this.gasLimitWiping = 6e7;
        this.gasLimitESDTNFTCreate = 3e6;
        this.gasLimitESDTNFTUpdateAttributes = 1e6;
        this.gasLimitESDTNFTAddQuantity = 1e6;
        this.gasLimitESDTNFTBurn = 1e6;
        this.gasLimitStorePerByte = 5e4;
        this.issueCost = "50000000000000000";
        this.esdtContractAddress = address_1.Address.fromBech32("erd1qqqqqqqqqqqqqqqpqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqzllls8a5w6u");
        this.chainID = chainID;
      }
    };
    exports2.TokenOperationsFactoryConfig = TokenOperationsFactoryConfig2;
  }
});

// node_modules/@multiversx/sdk-core/out/tokenOperations/tokenOperationsOutcomeParser.js
var require_tokenOperationsOutcomeParser = __commonJS({
  "node_modules/@multiversx/sdk-core/out/tokenOperations/tokenOperationsOutcomeParser.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TokenOperationsOutcomeParser = void 0;
    var address_1 = require_address();
    var errors_1 = require_errors();
    var codec_1 = require_codec();
    var TokenOperationsOutcomeParser2 = class {
      parseIssueFungible(transaction) {
        this.ensureNoError(transaction);
        const event = this.findSingleEventByIdentifier(transaction, "issue");
        const tokenIdentifier = this.extractTokenIdentifier(event);
        return { tokenIdentifier };
      }
      parseIssueNonFungible(transaction) {
        this.ensureNoError(transaction);
        const event = this.findSingleEventByIdentifier(transaction, "issueNonFungible");
        const tokenIdentifier = this.extractTokenIdentifier(event);
        return { tokenIdentifier };
      }
      parseIssueSemiFungible(transaction) {
        this.ensureNoError(transaction);
        const event = this.findSingleEventByIdentifier(transaction, "issueSemiFungible");
        const tokenIdentifier = this.extractTokenIdentifier(event);
        return { tokenIdentifier };
      }
      parseRegisterMetaESDT(transaction) {
        this.ensureNoError(transaction);
        const event = this.findSingleEventByIdentifier(transaction, "registerMetaESDT");
        const tokenIdentifier = this.extractTokenIdentifier(event);
        return { tokenIdentifier };
      }
      parseRegisterAndSetAllRoles(transaction) {
        this.ensureNoError(transaction);
        const eventRegister = this.findSingleEventByIdentifier(transaction, "registerAndSetAllRoles");
        const tokenIdentifier = this.extractTokenIdentifier(eventRegister);
        const eventSetRole = this.findSingleEventByIdentifier(transaction, "ESDTSetRole");
        const roles = eventSetRole.topics.slice(3).map((topic) => topic.valueOf().toString());
        return { tokenIdentifier, roles };
      }
      parseSetBurnRoleGlobally(transaction) {
        this.ensureNoError(transaction);
        return {};
      }
      parseUnsetBurnRoleGlobally(transaction) {
        this.ensureNoError(transaction);
        return {};
      }
      parseSetSpecialRole(transaction) {
        this.ensureNoError(transaction);
        const event = this.findSingleEventByIdentifier(transaction, "ESDTSetRole");
        const userAddress = event.address.toString();
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const roles = event.topics.slice(3).map((topic) => topic.valueOf().toString());
        return { userAddress, tokenIdentifier, roles };
      }
      parseNFTCreate(transaction) {
        this.ensureNoError(transaction);
        const event = this.findSingleEventByIdentifier(transaction, "ESDTNFTCreate");
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const initialQuantity = this.extractAmount(event);
        return { tokenIdentifier, nonce, initialQuantity };
      }
      parseLocalMint(transaction) {
        this.ensureNoError(transaction);
        const event = this.findSingleEventByIdentifier(transaction, "ESDTLocalMint");
        const userAddress = event.address.toString();
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const mintedSupply = this.extractAmount(event);
        return { userAddress, tokenIdentifier, nonce, mintedSupply };
      }
      parseLocalBurn(transaction) {
        this.ensureNoError(transaction);
        const event = this.findSingleEventByIdentifier(transaction, "ESDTLocalBurn");
        const userAddress = event.address.toString();
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const burntSupply = this.extractAmount(event);
        return { userAddress, tokenIdentifier, nonce, burntSupply };
      }
      parsePause(transaction) {
        this.ensureNoError(transaction);
        const _4 = this.findSingleEventByIdentifier(transaction, "ESDTPause");
        return {};
      }
      parseUnpause(transaction) {
        this.ensureNoError(transaction);
        const _4 = this.findSingleEventByIdentifier(transaction, "ESDTUnPause");
        return {};
      }
      parseFreeze(transaction) {
        this.ensureNoError(transaction);
        const event = this.findSingleEventByIdentifier(transaction, "ESDTFreeze");
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const balance = this.extractAmount(event);
        const userAddress = this.extractAddress(event);
        return { userAddress, tokenIdentifier, nonce, balance };
      }
      parseUnfreeze(transaction) {
        this.ensureNoError(transaction);
        const event = this.findSingleEventByIdentifier(transaction, "ESDTUnFreeze");
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const balance = this.extractAmount(event);
        const userAddress = this.extractAddress(event);
        return { userAddress, tokenIdentifier, nonce, balance };
      }
      parseWipe(transaction) {
        this.ensureNoError(transaction);
        const event = this.findSingleEventByIdentifier(transaction, "ESDTWipe");
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const balance = this.extractAmount(event);
        const userAddress = this.extractAddress(event);
        return { userAddress, tokenIdentifier, nonce, balance };
      }
      parseUpdateAttributes(transaction) {
        this.ensureNoError(transaction);
        const event = this.findSingleEventByIdentifier(transaction, "ESDTNFTUpdateAttributes");
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const attributes = event.topics[3]?.valueOf();
        return { tokenIdentifier, nonce, attributes };
      }
      parseAddQuantity(transaction) {
        this.ensureNoError(transaction);
        const event = this.findSingleEventByIdentifier(transaction, "ESDTNFTAddQuantity");
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const addedQuantity = this.extractAmount(event);
        return { tokenIdentifier, nonce, addedQuantity };
      }
      parseBurnQuantity(transaction) {
        this.ensureNoError(transaction);
        const event = this.findSingleEventByIdentifier(transaction, "ESDTNFTBurn");
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const burntQuantity = this.extractAmount(event);
        return { tokenIdentifier, nonce, burntQuantity };
      }
      ensureNoError(transaction) {
        for (const event of transaction.logs.events) {
          if (event.identifier == "signalError") {
            const data = import_buffer.Buffer.from(event.data.substring(1), "hex").toString();
            const message = event.topics[1]?.valueOf().toString();
            throw new errors_1.ErrCannotParseTransactionOutcome(transaction.hash, `encountered signalError: ${message} (${data})`);
          }
        }
      }
      findSingleEventByIdentifier(transaction, identifier) {
        const events = this.gatherAllEvents(transaction).filter((event) => event.identifier == identifier);
        if (events.length == 0) {
          throw new errors_1.ErrCannotParseTransactionOutcome(transaction.hash, `cannot find event of type ${identifier}`);
        }
        if (events.length > 1) {
          throw new errors_1.ErrCannotParseTransactionOutcome(transaction.hash, `more than one event of type ${identifier}`);
        }
        return events[0];
      }
      gatherAllEvents(transaction) {
        const allEvents = [];
        allEvents.push(...transaction.logs.events);
        for (const item of transaction.contractResults.items) {
          allEvents.push(...item.logs.events);
        }
        return allEvents;
      }
      extractTokenIdentifier(event) {
        return event.topics[0]?.valueOf().toString();
      }
      extractNonce(event) {
        return codec_1.bufferToBigInt(event.topics[1]?.valueOf()).toFixed(0);
      }
      extractAmount(event) {
        return codec_1.bufferToBigInt(event.topics[2]?.valueOf()).toFixed(0);
      }
      extractAddress(event) {
        return address_1.Address.fromBuffer(event.topics[3]?.valueOf()).toString();
      }
    };
    exports2.TokenOperationsOutcomeParser = TokenOperationsOutcomeParser2;
  }
});

// node_modules/@multiversx/sdk-core/out/tokenOperations/index.js
var require_tokenOperations = __commonJS({
  "node_modules/@multiversx/sdk-core/out/tokenOperations/index.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m3, exports3) {
      for (var p3 in m3)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3))
          __createBinding2(exports3, m3, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_tokenOperationsFactory(), exports2);
    __exportStar2(require_tokenOperationsFactoryConfig(), exports2);
    __exportStar2(require_tokenOperationsOutcomeParser(), exports2);
  }
});

// node_modules/@multiversx/sdk-core/out/transactionsOutcomeParsers/delegationTransactionsOutcomeParser.js
var require_delegationTransactionsOutcomeParser = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionsOutcomeParsers/delegationTransactionsOutcomeParser.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DelegationTransactionsOutcomeParser = void 0;
    var address_1 = require_address();
    var errors_1 = require_errors();
    var resources_1 = require_resources();
    var DelegationTransactionsOutcomeParser = class {
      constructor() {
      }
      parseCreateNewDelegationContract(transactionOutcome) {
        this.ensureNoError(transactionOutcome.logs.events);
        const events = resources_1.findEventsByIdentifier(transactionOutcome, "SCDeploy");
        return events.map((event) => ({ contractAddress: this.extractContractAddress(event) }));
      }
      ensureNoError(transactionEvents) {
        for (const event of transactionEvents) {
          if (event.identifier == "signalError") {
            const data = import_buffer.Buffer.from(event.dataItems[0]?.toString().slice(1)).toString() || "";
            const message = this.decodeTopicAsString(event.topics[1]);
            throw new errors_1.ErrParseTransactionOutcome(`encountered signalError: ${message} (${import_buffer.Buffer.from(data, "hex").toString()})`);
          }
        }
      }
      extractContractAddress(event) {
        if (!event.topics[0]?.length) {
          return "";
        }
        const address = import_buffer.Buffer.from(event.topics[0]);
        return address_1.Address.fromBuffer(address).bech32();
      }
      decodeTopicAsString(topic) {
        return import_buffer.Buffer.from(topic).toString();
      }
    };
    exports2.DelegationTransactionsOutcomeParser = DelegationTransactionsOutcomeParser;
  }
});

// node_modules/@multiversx/sdk-core/out/transactionsOutcomeParsers/smartContractTransactionsOutcomeParser.js
var require_smartContractTransactionsOutcomeParser = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionsOutcomeParsers/smartContractTransactionsOutcomeParser.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SmartContractTransactionsOutcomeParser = void 0;
    var address_1 = require_address();
    var errors_1 = require_errors();
    var smartcontracts_1 = require_smartcontracts();
    var resources_1 = require_resources();
    var SmartContractTransactionsOutcomeParser2 = class {
      constructor(options) {
        this.abi = options?.abi;
        this.legacyResultsParser = options?.legacyResultsParser || new smartcontracts_1.ResultsParser();
      }
      parseDeploy(options) {
        const directCallOutcome = options.transactionOutcome.directSmartContractCallOutcome;
        const events = resources_1.findEventsByIdentifier(options.transactionOutcome, "SCDeploy");
        const contracts = events.map((event) => this.parseScDeployEvent(event));
        return {
          returnCode: directCallOutcome.returnCode,
          returnMessage: directCallOutcome.returnMessage,
          contracts
        };
      }
      parseScDeployEvent(event) {
        const topicForAddress = event.topics[0];
        const topicForOwnerAddress = event.topics[1];
        const topicForCodeHash = event.topics[2];
        const address = topicForAddress?.length ? new address_1.Address(topicForAddress).toBech32() : "";
        const ownerAddress = topicForOwnerAddress?.length ? new address_1.Address(topicForOwnerAddress).toBech32() : "";
        const codeHash = topicForCodeHash;
        return {
          address,
          ownerAddress,
          codeHash
        };
      }
      parseExecute(options) {
        const directCallOutcome = options.transactionOutcome.directSmartContractCallOutcome;
        if (!this.abi) {
          return {
            values: directCallOutcome.returnDataParts,
            returnCode: directCallOutcome.returnCode,
            returnMessage: directCallOutcome.returnMessage
          };
        }
        const functionName = options.function || directCallOutcome.function;
        if (!functionName) {
          throw new errors_1.Err(`Function name is not available in the transaction outcome, thus endpoint definition (ABI) cannot be picked (for parsing). Maybe provide the "function" parameter explicitly?`);
        }
        const endpoint = this.abi.getEndpoint(functionName);
        const legacyUntypedBundle = {
          returnCode: new smartcontracts_1.ReturnCode(directCallOutcome.returnCode),
          returnMessage: directCallOutcome.returnMessage,
          values: directCallOutcome.returnDataParts.map((part) => import_buffer.Buffer.from(part))
        };
        const legacyTypedBundle = this.legacyResultsParser.parseOutcomeFromUntypedBundle(legacyUntypedBundle, endpoint);
        return {
          values: legacyTypedBundle.values.map((value) => value.valueOf()),
          returnCode: legacyTypedBundle.returnCode.toString(),
          returnMessage: legacyTypedBundle.returnMessage
        };
      }
    };
    exports2.SmartContractTransactionsOutcomeParser = SmartContractTransactionsOutcomeParser2;
  }
});

// node_modules/@multiversx/sdk-core/out/transactionsOutcomeParsers/tokenManagementTransactionsOutcomeParser.js
var require_tokenManagementTransactionsOutcomeParser = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionsOutcomeParsers/tokenManagementTransactionsOutcomeParser.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TokenManagementTransactionsOutcomeParser = void 0;
    var address_1 = require_address();
    var errors_1 = require_errors();
    var utils_1 = require_utils();
    var resources_1 = require_resources();
    var TokenManagementTransactionsOutcomeParser2 = class {
      constructor() {
      }
      parseIssueFungible(transactionOutcome) {
        this.ensureNoError(transactionOutcome.logs.events);
        const events = resources_1.findEventsByIdentifier(transactionOutcome, "issue");
        return events.map((event) => ({ tokenIdentifier: this.extractTokenIdentifier(event) }));
      }
      parseIssueNonFungible(transactionOutcome) {
        this.ensureNoError(transactionOutcome.logs.events);
        const events = resources_1.findEventsByIdentifier(transactionOutcome, "issueNonFungible");
        return events.map((event) => ({ tokenIdentifier: this.extractTokenIdentifier(event) }));
      }
      parseIssueSemiFungible(transactionOutcome) {
        this.ensureNoError(transactionOutcome.logs.events);
        const events = resources_1.findEventsByIdentifier(transactionOutcome, "issueSemiFungible");
        return events.map((event) => ({ tokenIdentifier: this.extractTokenIdentifier(event) }));
      }
      parseRegisterMetaEsdt(transactionOutcome) {
        this.ensureNoError(transactionOutcome.logs.events);
        const events = resources_1.findEventsByIdentifier(transactionOutcome, "registerMetaESDT");
        return events.map((event) => ({ tokenIdentifier: this.extractTokenIdentifier(event) }));
      }
      parseRegisterAndSetAllRoles(transactionOutcome) {
        this.ensureNoError(transactionOutcome.logs.events);
        const registerEvents = resources_1.findEventsByIdentifier(transactionOutcome, "registerAndSetAllRoles");
        const setRoleEvents = resources_1.findEventsByIdentifier(transactionOutcome, "ESDTSetRole");
        if (registerEvents.length !== setRoleEvents.length) {
          throw new errors_1.ErrParseTransactionOutcome("Register Events and Set Role events mismatch. Should have the same number of events.");
        }
        return registerEvents.map((registerEvent, index) => {
          const tokenIdentifier = this.extractTokenIdentifier(registerEvent);
          const encodedRoles = setRoleEvents[index].topics.slice(3);
          const roles = encodedRoles.map((role) => this.decodeTopicAsString(role));
          return { tokenIdentifier, roles };
        });
      }
      parseSetBurnRoleGlobally(transactionOutcome) {
        this.ensureNoError(transactionOutcome.logs.events);
      }
      parseUnsetBurnRoleGlobally(transactionOutcome) {
        this.ensureNoError(transactionOutcome.logs.events);
      }
      parseSetSpecialRole(transactionOutcome) {
        this.ensureNoError(transactionOutcome.logs.events);
        const events = resources_1.findEventsByIdentifier(transactionOutcome, "ESDTSetRole");
        return events.map((event) => this.getOutputForSetSpecialRoleEvent(event));
      }
      getOutputForSetSpecialRoleEvent(event) {
        const userAddress = event.address;
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const encodedRoles = event.topics.slice(3);
        const roles = encodedRoles.map((role) => this.decodeTopicAsString(role));
        return { userAddress, tokenIdentifier, roles };
      }
      parseNftCreate(transactionOutcome) {
        this.ensureNoError(transactionOutcome.logs.events);
        const events = resources_1.findEventsByIdentifier(transactionOutcome, "ESDTNFTCreate");
        return events.map((event) => this.getOutputForNftCreateEvent(event));
      }
      getOutputForNftCreateEvent(event) {
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const amount = this.extractAmount(event);
        return { tokenIdentifier, nonce, initialQuantity: amount };
      }
      parseLocalMint(transactionOutcome) {
        this.ensureNoError(transactionOutcome.logs.events);
        const events = resources_1.findEventsByIdentifier(transactionOutcome, "ESDTLocalMint");
        return events.map((event) => this.getOutputForLocalMintEvent(event));
      }
      getOutputForLocalMintEvent(event) {
        const userAddress = event.address;
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const mintedSupply = this.extractAmount(event);
        return {
          userAddress,
          tokenIdentifier,
          nonce,
          mintedSupply
        };
      }
      parseLocalBurn(transactionOutcome) {
        this.ensureNoError(transactionOutcome.logs.events);
        const events = resources_1.findEventsByIdentifier(transactionOutcome, "ESDTLocalBurn");
        return events.map((event) => this.getOutputForLocalBurnEvent(event));
      }
      getOutputForLocalBurnEvent(event) {
        const userAddress = event.address;
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const burntSupply = this.extractAmount(event);
        return {
          userAddress,
          tokenIdentifier,
          nonce,
          burntSupply
        };
      }
      parsePause(transactionOutcome) {
        this.ensureNoError(transactionOutcome.logs.events);
        const events = resources_1.findEventsByIdentifier(transactionOutcome, "ESDTPause");
        return events.map((event) => ({ tokenIdentifier: this.extractTokenIdentifier(event) }));
      }
      parseUnpause(transactionOutcome) {
        this.ensureNoError(transactionOutcome.logs.events);
        const events = resources_1.findEventsByIdentifier(transactionOutcome, "ESDTUnPause");
        return events.map((event) => ({ tokenIdentifier: this.extractTokenIdentifier(event) }));
      }
      parseFreeze(transactionOutcome) {
        this.ensureNoError(transactionOutcome.logs.events);
        const events = resources_1.findEventsByIdentifier(transactionOutcome, "ESDTFreeze");
        return events.map((event) => this.getOutputForFreezeEvent(event));
      }
      getOutputForFreezeEvent(event) {
        const userAddress = this.extractAddress(event);
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const balance = this.extractAmount(event);
        return {
          userAddress,
          tokenIdentifier,
          nonce,
          balance
        };
      }
      parseUnfreeze(transactionOutcome) {
        this.ensureNoError(transactionOutcome.logs.events);
        const events = resources_1.findEventsByIdentifier(transactionOutcome, "ESDTUnFreeze");
        return events.map((event) => this.getOutputForUnfreezeEvent(event));
      }
      getOutputForUnfreezeEvent(event) {
        const userAddress = this.extractAddress(event);
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const balance = this.extractAmount(event);
        return {
          userAddress,
          tokenIdentifier,
          nonce,
          balance
        };
      }
      parseWipe(transactionOutcome) {
        this.ensureNoError(transactionOutcome.logs.events);
        const events = resources_1.findEventsByIdentifier(transactionOutcome, "ESDTWipe");
        return events.map((event) => this.getOutputForWipeEvent(event));
      }
      getOutputForWipeEvent(event) {
        const userAddress = this.extractAddress(event);
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const balance = this.extractAmount(event);
        return {
          userAddress,
          tokenIdentifier,
          nonce,
          balance
        };
      }
      parseUpdateAttributes(transactionOutcome) {
        this.ensureNoError(transactionOutcome.logs.events);
        const events = resources_1.findEventsByIdentifier(transactionOutcome, "ESDTNFTUpdateAttributes");
        return events.map((event) => this.getOutputForUpdateAttributesEvent(event));
      }
      getOutputForUpdateAttributesEvent(event) {
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const attributes = event.topics[3] ? event.topics[3] : new Uint8Array();
        return {
          tokenIdentifier,
          nonce,
          attributes
        };
      }
      parseAddQuantity(transactionOutcome) {
        this.ensureNoError(transactionOutcome.logs.events);
        const events = resources_1.findEventsByIdentifier(transactionOutcome, "ESDTNFTAddQuantity");
        return events.map((event) => this.getOutputForAddQuantityEvent(event));
      }
      getOutputForAddQuantityEvent(event) {
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const addedQuantity = this.extractAmount(event);
        return {
          tokenIdentifier,
          nonce,
          addedQuantity
        };
      }
      parseBurnQuantity(transactionOutcome) {
        this.ensureNoError(transactionOutcome.logs.events);
        const events = resources_1.findEventsByIdentifier(transactionOutcome, "ESDTNFTBurn");
        return events.map((event) => this.getOutputForBurnQuantityEvent(event));
      }
      getOutputForBurnQuantityEvent(event) {
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const burntQuantity = this.extractAmount(event);
        return {
          tokenIdentifier,
          nonce,
          burntQuantity
        };
      }
      ensureNoError(transactionEvents) {
        for (const event of transactionEvents) {
          if (event.identifier == "signalError") {
            const data = import_buffer.Buffer.from(event.dataItems[0]?.toString().slice(1)).toString() || "";
            const message = this.decodeTopicAsString(event.topics[1]);
            throw new errors_1.ErrParseTransactionOutcome(`encountered signalError: ${message} (${import_buffer.Buffer.from(data, "hex").toString()})`);
          }
        }
      }
      extractTokenIdentifier(event) {
        if (!event.topics[0]?.length) {
          return "";
        }
        return this.decodeTopicAsString(event.topics[0]);
      }
      extractNonce(event) {
        if (!event.topics[1]?.length) {
          return BigInt(0);
        }
        const nonce = import_buffer.Buffer.from(event.topics[1]);
        return BigInt(utils_1.bufferToBigInt(nonce).toFixed(0));
      }
      extractAmount(event) {
        if (!event.topics[2]?.length) {
          return BigInt(0);
        }
        const amount = import_buffer.Buffer.from(event.topics[2]);
        return BigInt(utils_1.bufferToBigInt(amount).toFixed(0));
      }
      extractAddress(event) {
        if (!event.topics[3]?.length) {
          return "";
        }
        const address = import_buffer.Buffer.from(event.topics[3]);
        return address_1.Address.fromBuffer(address).bech32();
      }
      decodeTopicAsString(topic) {
        return import_buffer.Buffer.from(topic).toString();
      }
    };
    exports2.TokenManagementTransactionsOutcomeParser = TokenManagementTransactionsOutcomeParser2;
  }
});

// node_modules/@multiversx/sdk-core/out/transactionsOutcomeParsers/transactionEventsParser.js
var require_transactionEventsParser = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionsOutcomeParsers/transactionEventsParser.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransactionEventsParser = void 0;
    var smartcontracts_1 = require_smartcontracts();
    var TransactionEventsParser2 = class {
      constructor(options) {
        this.legacyResultsParser = new smartcontracts_1.ResultsParser();
        this.abi = options.abi;
        this.firstTopicIsIdentifier = options.firstTopicIsIdentifier ?? true;
      }
      parseEvents(options) {
        const results = [];
        for (const event of options.events) {
          const parsedEvent = this.parseEvent({ event });
          results.push(parsedEvent);
        }
        return results;
      }
      parseEvent(options) {
        const topics = options.event.topics.map((topic) => import_buffer.Buffer.from(topic));
        const abiIdentifier = this.firstTopicIsIdentifier ? topics[0]?.toString() : options.event.identifier;
        if (this.firstTopicIsIdentifier) {
          topics.shift();
        }
        const dataItems = options.event.dataItems.map((dataItem) => import_buffer.Buffer.from(dataItem));
        const eventDefinition = this.abi.getEvent(abiIdentifier);
        const parsedEvent = this.legacyResultsParser.doParseEvent({
          topics,
          dataItems,
          eventDefinition
        });
        return parsedEvent;
      }
    };
    exports2.TransactionEventsParser = TransactionEventsParser2;
  }
});

// node_modules/@multiversx/sdk-core/out/transactionsOutcomeParsers/index.js
var require_transactionsOutcomeParsers = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionsOutcomeParsers/index.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m3, exports3) {
      for (var p3 in m3)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3))
          __createBinding2(exports3, m3, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_delegationTransactionsOutcomeParser(), exports2);
    __exportStar2(require_resources(), exports2);
    __exportStar2(require_smartContractTransactionsOutcomeParser(), exports2);
    __exportStar2(require_tokenManagementTransactionsOutcomeParser(), exports2);
    __exportStar2(require_transactionEventsParser(), exports2);
  }
});

// node_modules/@multiversx/sdk-core/out/account.js
var require_account = __commonJS({
  "node_modules/@multiversx/sdk-core/out/account.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Account = void 0;
    var address_1 = require_address();
    var Account5 = class {
      /**
       * Creates an account object from an address
       */
      constructor(address) {
        this.address = address_1.Address.empty();
        this.nonce = 0;
        this.balance = "0";
        this.address = address;
      }
      /**
       * Updates account properties (such as nonce, balance).
       */
      update(obj) {
        this.nonce = obj.nonce;
        this.balance = obj.balance;
      }
      /**
       * Increments (locally) the nonce (the account sequence number).
       */
      incrementNonce() {
        this.nonce = this.nonce.valueOf() + 1;
      }
      /**
       * Gets then increments (locally) the nonce (the account sequence number).
       */
      getNonceThenIncrement() {
        let nonce = this.nonce;
        this.nonce = this.nonce.valueOf() + 1;
        return nonce;
      }
      /**
       * Converts the account to a pretty, plain JavaScript object.
       */
      toJSON() {
        return {
          address: this.address.bech32(),
          nonce: this.nonce.valueOf(),
          balance: this.balance.toString()
        };
      }
    };
    exports2.Account = Account5;
  }
});

// node_modules/@multiversx/sdk-core/out/message.js
var require_message = __commonJS({
  "node_modules/@multiversx/sdk-core/out/message.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MessageComputer = exports2.Message = void 0;
    var constants_1 = require_constants();
    var address_1 = require_address();
    var createKeccakHash = require_js();
    var Message2 = class {
      constructor(options) {
        this.data = options.data;
        this.signature = options.signature;
        this.address = options.address;
        this.version = options.version || constants_1.DEFAULT_MESSAGE_VERSION;
        this.signer = options.signer || constants_1.SDK_JS_SIGNER;
      }
    };
    exports2.Message = Message2;
    var MessageComputer2 = class {
      constructor() {
      }
      computeBytesForSigning(message) {
        const messageSize = import_buffer.Buffer.from(message.data.length.toString());
        const signableMessage = import_buffer.Buffer.concat([messageSize, message.data]);
        let bytesToHash = import_buffer.Buffer.concat([import_buffer.Buffer.from(constants_1.MESSAGE_PREFIX), signableMessage]);
        return createKeccakHash("keccak256").update(bytesToHash).digest();
      }
      computeBytesForVerifying(message) {
        return this.computeBytesForSigning(message);
      }
      packMessage(message) {
        return {
          message: import_buffer.Buffer.from(message.data).toString("hex"),
          signature: message.signature ? import_buffer.Buffer.from(message.signature).toString("hex") : "",
          address: message.address ? message.address.bech32() : "",
          version: message.version,
          signer: message.signer
        };
      }
      unpackMessage(packedMessage) {
        const dataHex = this.trimHexPrefix(packedMessage.message);
        const data = import_buffer.Buffer.from(dataHex, "hex");
        const signatureHex = this.trimHexPrefix(packedMessage.signature || "");
        const signature = import_buffer.Buffer.from(signatureHex, "hex");
        let address = void 0;
        if (packedMessage.address) {
          address = address_1.Address.fromBech32(packedMessage.address);
        }
        const version2 = packedMessage.version || constants_1.DEFAULT_MESSAGE_VERSION;
        const signer = packedMessage.signer || constants_1.UNKNOWN_SIGNER;
        return new Message2({
          data,
          signature,
          address,
          version: version2,
          signer
        });
      }
      trimHexPrefix(data) {
        if (data.startsWith("0x") || data.startsWith("0X")) {
          return data.slice(2);
        }
        return data;
      }
    };
    exports2.MessageComputer = MessageComputer2;
  }
});

// node_modules/@multiversx/sdk-core/out/asyncTimer.js
var require_asyncTimer = __commonJS({
  "node_modules/@multiversx/sdk-core/out/asyncTimer.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k4 in mod2)
          if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k4))
            __createBinding2(result, mod2, k4);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsyncTimer = void 0;
    var errors = __importStar2(require_errors());
    var errors_1 = require_errors();
    var logger_1 = require_logger();
    var AsyncTimer = class {
      /**
       * Creates an AsyncTimer.
       */
      constructor(name2) {
        this.timeoutHandle = null;
        this.rejectionFunc = null;
        this.name = name2;
        this.correlationTag = 0;
      }
      /**
       * Starts the timer.
       * @param timeout The time (in milliseconds) to wait until resolving the promise.
       */
      start(timeout) {
        if (this.timeoutHandle) {
          throw new errors.ErrAsyncTimerAlreadyRunning();
        }
        this.correlationTag++;
        logger_1.Logger.trace(`AsyncTimer[${this.name}'${this.correlationTag}].start()`);
        return new Promise((resolve, reject) => {
          this.rejectionFunc = reject;
          let timeoutCallback = () => {
            this.rejectionFunc = null;
            this.stop();
            resolve();
          };
          this.timeoutHandle = setTimeout(timeoutCallback, timeout);
        });
      }
      /**
       * Aborts the timer: rejects the promise (if any) and stops the timer.
       */
      abort() {
        logger_1.Logger.trace(`AsyncTimer[${this.name}'${this.correlationTag}].abort()`);
        if (this.rejectionFunc) {
          this.rejectionFunc(new errors_1.ErrAsyncTimerAborted());
          this.rejectionFunc = null;
        }
        this.stop();
      }
      /**
       * Stops the timer.
       */
      stop() {
        if (this.isStopped()) {
          return;
        }
        logger_1.Logger.trace(`AsyncTimer[${this.name}'${this.correlationTag}].stop()`);
        if (this.timeoutHandle) {
          clearTimeout(this.timeoutHandle);
          this.timeoutHandle = null;
        }
      }
      /**
       * Returns whether the timer is stopped.
       */
      isStopped() {
        return this.timeoutHandle ? false : true;
      }
    };
    exports2.AsyncTimer = AsyncTimer;
  }
});

// node_modules/@multiversx/sdk-core/out/transactionWatcher.js
var require_transactionWatcher = __commonJS({
  "node_modules/@multiversx/sdk-core/out/transactionWatcher.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransactionWatcher = void 0;
    var asyncTimer_1 = require_asyncTimer();
    var constants_1 = require_constants();
    var errors_1 = require_errors();
    var logger_1 = require_logger();
    var TransactionWatcher3 = class _TransactionWatcher {
      /**
       * A transaction watcher (awaiter).
       *
       * @param fetcher The transaction fetcher
       * @param options The options
       * @param options.pollingIntervalMilliseconds The polling interval, in milliseconds
       * @param options.timeoutMilliseconds The timeout, in milliseconds
       * @param options.patienceMilliseconds The patience: an extra time (in milliseconds) to wait, after the transaction has reached its desired status. Currently there's a delay between the moment a transaction is marked as "completed" and the moment its outcome (contract results, events and logs) is available.
       */
      constructor(fetcher, options = {}) {
        this.fetcher = new TransactionFetcherWithTracing(fetcher);
        this.pollingIntervalMilliseconds = options.pollingIntervalMilliseconds || _TransactionWatcher.DefaultPollingInterval;
        this.timeoutMilliseconds = options.timeoutMilliseconds || _TransactionWatcher.DefaultTimeout;
        this.patienceMilliseconds = options.patienceMilliseconds || _TransactionWatcher.DefaultPatience;
      }
      /**
       * Waits until the transaction reaches the "pending" status.
       * @param txHash The hex-encoded transaction hash
       */
      async awaitPending(transactionOrTxHash) {
        const isPending = (transaction) => transaction.status.isPending();
        const doFetch = async () => {
          const hash = this.transactionOrTxHashToTxHash(transactionOrTxHash);
          return await this.fetcher.getTransaction(hash);
        };
        const errorProvider = () => new errors_1.ErrExpectedTransactionStatusNotReached();
        return this.awaitConditionally(isPending, doFetch, errorProvider);
      }
      /**
       * Waits until the transaction is completely processed.
       * @param txHash The hex-encoded transaction hash
       */
      async awaitCompleted(transactionOrTxHash) {
        const isCompleted = (transactionOnNetwork) => {
          if (transactionOnNetwork.isCompleted === void 0) {
            throw new errors_1.ErrIsCompletedFieldIsMissingOnTransaction();
          }
          return transactionOnNetwork.isCompleted;
        };
        const doFetch = async () => {
          const hash = this.transactionOrTxHashToTxHash(transactionOrTxHash);
          return await this.fetcher.getTransaction(hash);
        };
        const errorProvider = () => new errors_1.ErrExpectedTransactionStatusNotReached();
        return this.awaitConditionally(isCompleted, doFetch, errorProvider);
      }
      async awaitAllEvents(transactionOrTxHash, events) {
        const foundAllEvents = (transactionOnNetwork) => {
          const allEventIdentifiers = this.getAllTransactionEvents(transactionOnNetwork).map((event) => event.identifier);
          const allAreFound = events.every((event) => allEventIdentifiers.includes(event));
          return allAreFound;
        };
        const doFetch = async () => {
          const hash = this.transactionOrTxHashToTxHash(transactionOrTxHash);
          return await this.fetcher.getTransaction(hash);
        };
        const errorProvider = () => new errors_1.ErrExpectedTransactionEventsNotFound();
        return this.awaitConditionally(foundAllEvents, doFetch, errorProvider);
      }
      async awaitAnyEvent(transactionOrTxHash, events) {
        const foundAnyEvent = (transactionOnNetwork) => {
          const allEventIdentifiers = this.getAllTransactionEvents(transactionOnNetwork).map((event) => event.identifier);
          const anyIsFound = events.find((event) => allEventIdentifiers.includes(event)) != void 0;
          return anyIsFound;
        };
        const doFetch = async () => {
          const hash = this.transactionOrTxHashToTxHash(transactionOrTxHash);
          return await this.fetcher.getTransaction(hash);
        };
        const errorProvider = () => new errors_1.ErrExpectedTransactionEventsNotFound();
        return this.awaitConditionally(foundAnyEvent, doFetch, errorProvider);
      }
      async awaitOnCondition(transactionOrTxHash, condition) {
        const doFetch = async () => {
          const hash = this.transactionOrTxHashToTxHash(transactionOrTxHash);
          return await this.fetcher.getTransaction(hash);
        };
        const errorProvider = () => new errors_1.ErrExpectedTransactionStatusNotReached();
        return this.awaitConditionally(condition, doFetch, errorProvider);
      }
      transactionOrTxHashToTxHash(transactionOrTxHash) {
        const hash = typeof transactionOrTxHash === "string" ? transactionOrTxHash : transactionOrTxHash.getHash().hex();
        if (hash.length !== constants_1.HEX_TRANSACTION_HASH_LENGTH) {
          throw new errors_1.Err(`Invalid transaction hash length. The length of a hex encoded hash should be ${constants_1.HEX_TRANSACTION_HASH_LENGTH}.`);
        }
        return hash;
      }
      async awaitConditionally(isSatisfied, doFetch, createError) {
        const periodicTimer = new asyncTimer_1.AsyncTimer("watcher:periodic");
        const patienceTimer = new asyncTimer_1.AsyncTimer("watcher:patience");
        const timeoutTimer = new asyncTimer_1.AsyncTimer("watcher:timeout");
        let stop = false;
        let fetchedData = void 0;
        let satisfied = false;
        timeoutTimer.start(this.timeoutMilliseconds).finally(() => {
          timeoutTimer.stop();
          stop = true;
        });
        while (!stop) {
          await periodicTimer.start(this.pollingIntervalMilliseconds);
          try {
            fetchedData = await doFetch();
            satisfied = isSatisfied(fetchedData);
            if (satisfied || stop) {
              break;
            }
          } catch (error) {
            logger_1.Logger.debug("TransactionWatcher.awaitConditionally(): cannot (yet) fetch data.");
            if (error instanceof errors_1.ErrIsCompletedFieldIsMissingOnTransaction) {
              throw error;
            }
            if (!(error instanceof errors_1.Err)) {
              throw error;
            }
          }
        }
        if (satisfied) {
          await patienceTimer.start(this.patienceMilliseconds);
        }
        if (!timeoutTimer.isStopped()) {
          timeoutTimer.stop();
        }
        if (!fetchedData || !satisfied) {
          throw createError();
        }
        return fetchedData;
      }
      getAllTransactionEvents(transaction) {
        const result = [...transaction.logs.events];
        for (const resultItem of transaction.contractResults.items) {
          result.push(...resultItem.logs.events);
        }
        return result;
      }
    };
    exports2.TransactionWatcher = TransactionWatcher3;
    TransactionWatcher3.DefaultPollingInterval = 6e3;
    TransactionWatcher3.DefaultTimeout = TransactionWatcher3.DefaultPollingInterval * 15;
    TransactionWatcher3.DefaultPatience = 0;
    TransactionWatcher3.NoopOnStatusReceived = (_4) => {
    };
    var TransactionFetcherWithTracing = class {
      constructor(fetcher) {
        this.fetcher = fetcher;
      }
      async getTransaction(txHash) {
        logger_1.Logger.debug(`transactionWatcher, getTransaction(${txHash})`);
        return await this.fetcher.getTransaction(txHash);
      }
    };
  }
});

// node_modules/@multiversx/sdk-core/out/signableMessage.js
var require_signableMessage = __commonJS({
  "node_modules/@multiversx/sdk-core/out/signableMessage.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SignableMessage = void 0;
    var address_1 = require_address();
    var signature_1 = require_signature();
    var constants_1 = require_constants();
    var createKeccakHash = require_js();
    var SignableMessage3 = class {
      constructor(init) {
        this.message = import_buffer.Buffer.from([]);
        this.signature = import_buffer.Buffer.from([]);
        this.version = 1;
        this.signer = "ErdJS";
        this.address = address_1.Address.empty();
        Object.assign(this, init);
      }
      serializeForSigning() {
        const messageSize = import_buffer.Buffer.from(this.message.length.toString());
        const signableMessage = import_buffer.Buffer.concat([messageSize, this.message]);
        let bytesToHash = import_buffer.Buffer.concat([import_buffer.Buffer.from(constants_1.MESSAGE_PREFIX), signableMessage]);
        return createKeccakHash("keccak256").update(bytesToHash).digest();
      }
      serializeForSigningRaw() {
        return import_buffer.Buffer.concat([this.getMessageSize(), this.message]);
      }
      getSignature() {
        return this.signature;
      }
      applySignature(signature) {
        this.signature = signature_1.interpretSignatureAsBuffer(signature);
      }
      getMessageSize() {
        const messageSize = import_buffer.Buffer.alloc(4);
        messageSize.writeUInt32BE(this.message.length, 0);
        return messageSize;
      }
      toJSON() {
        return {
          address: this.address.bech32(),
          message: "0x" + this.message.toString("hex"),
          signature: "0x" + this.signature.toString("hex"),
          version: this.version,
          signer: this.signer
        };
      }
    };
    exports2.SignableMessage = SignableMessage3;
  }
});

// node_modules/@multiversx/sdk-network-providers/node_modules/bignumber.js/bignumber.js
var require_bignumber2 = __commonJS({
  "node_modules/@multiversx/sdk-network-providers/node_modules/bignumber.js/bignumber.js"(exports2, module2) {
    init_shim();
    (function(globalObject) {
      "use strict";
      var BigNumber2, isNumeric2 = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil2 = Math.ceil, mathfloor2 = Math.floor, bignumberError2 = "[BigNumber Error] ", tooManyDigits2 = bignumberError2 + "Number primitive has more than 15 significant digits: ", BASE2 = 1e14, LOG_BASE2 = 14, MAX_SAFE_INTEGER2 = 9007199254740991, POWS_TEN2 = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE2 = 1e7, MAX2 = 1e9;
      function clone2(configObject) {
        var div, convertBase, parseNumeric, P2 = BigNumber3.prototype = { constructor: BigNumber3, toString: null, valueOf: null }, ONE = new BigNumber3(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: "\xA0",
          // non-breaking space
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
        function BigNumber3(v2, b4) {
          var alphabet2, c4, caseChanged, e2, i2, isNum, len, str, x3 = this;
          if (!(x3 instanceof BigNumber3))
            return new BigNumber3(v2, b4);
          if (b4 == null) {
            if (v2 && v2._isBigNumber === true) {
              x3.s = v2.s;
              if (!v2.c || v2.e > MAX_EXP) {
                x3.c = x3.e = null;
              } else if (v2.e < MIN_EXP) {
                x3.c = [x3.e = 0];
              } else {
                x3.e = v2.e;
                x3.c = v2.c.slice();
              }
              return;
            }
            if ((isNum = typeof v2 == "number") && v2 * 0 == 0) {
              x3.s = 1 / v2 < 0 ? (v2 = -v2, -1) : 1;
              if (v2 === ~~v2) {
                for (e2 = 0, i2 = v2; i2 >= 10; i2 /= 10, e2++)
                  ;
                if (e2 > MAX_EXP) {
                  x3.c = x3.e = null;
                } else {
                  x3.e = e2;
                  x3.c = [v2];
                }
                return;
              }
              str = String(v2);
            } else {
              if (!isNumeric2.test(str = String(v2)))
                return parseNumeric(x3, str, isNum);
              x3.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e2 = str.indexOf(".")) > -1)
              str = str.replace(".", "");
            if ((i2 = str.search(/e/i)) > 0) {
              if (e2 < 0)
                e2 = i2;
              e2 += +str.slice(i2 + 1);
              str = str.substring(0, i2);
            } else if (e2 < 0) {
              e2 = str.length;
            }
          } else {
            intCheck2(b4, 2, ALPHABET.length, "Base");
            if (b4 == 10) {
              x3 = new BigNumber3(v2);
              return round(x3, DECIMAL_PLACES + x3.e + 1, ROUNDING_MODE);
            }
            str = String(v2);
            if (isNum = typeof v2 == "number") {
              if (v2 * 0 != 0)
                return parseNumeric(x3, str, isNum, b4);
              x3.s = 1 / v2 < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber3.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits2 + v2);
              }
            } else {
              x3.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet2 = ALPHABET.slice(0, b4);
            e2 = i2 = 0;
            for (len = str.length; i2 < len; i2++) {
              if (alphabet2.indexOf(c4 = str.charAt(i2)) < 0) {
                if (c4 == ".") {
                  if (i2 > e2) {
                    e2 = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i2 = -1;
                    e2 = 0;
                    continue;
                  }
                }
                return parseNumeric(x3, String(v2), isNum, b4);
              }
            }
            isNum = false;
            str = convertBase(str, b4, 10, x3.s);
            if ((e2 = str.indexOf(".")) > -1)
              str = str.replace(".", "");
            else
              e2 = str.length;
          }
          for (i2 = 0; str.charCodeAt(i2) === 48; i2++)
            ;
          for (len = str.length; str.charCodeAt(--len) === 48; )
            ;
          if (str = str.slice(i2, ++len)) {
            len -= i2;
            if (isNum && BigNumber3.DEBUG && len > 15 && (v2 > MAX_SAFE_INTEGER2 || v2 !== mathfloor2(v2))) {
              throw Error(tooManyDigits2 + x3.s * v2);
            }
            if ((e2 = e2 - i2 - 1) > MAX_EXP) {
              x3.c = x3.e = null;
            } else if (e2 < MIN_EXP) {
              x3.c = [x3.e = 0];
            } else {
              x3.e = e2;
              x3.c = [];
              i2 = (e2 + 1) % LOG_BASE2;
              if (e2 < 0)
                i2 += LOG_BASE2;
              if (i2 < len) {
                if (i2)
                  x3.c.push(+str.slice(0, i2));
                for (len -= LOG_BASE2; i2 < len; ) {
                  x3.c.push(+str.slice(i2, i2 += LOG_BASE2));
                }
                i2 = LOG_BASE2 - (str = str.slice(i2)).length;
              } else {
                i2 -= len;
              }
              for (; i2--; str += "0")
                ;
              x3.c.push(+str);
            }
          } else {
            x3.c = [x3.e = 0];
          }
        }
        BigNumber3.clone = clone2;
        BigNumber3.ROUND_UP = 0;
        BigNumber3.ROUND_DOWN = 1;
        BigNumber3.ROUND_CEIL = 2;
        BigNumber3.ROUND_FLOOR = 3;
        BigNumber3.ROUND_HALF_UP = 4;
        BigNumber3.ROUND_HALF_DOWN = 5;
        BigNumber3.ROUND_HALF_EVEN = 6;
        BigNumber3.ROUND_HALF_CEIL = 7;
        BigNumber3.ROUND_HALF_FLOOR = 8;
        BigNumber3.EUCLID = 9;
        BigNumber3.config = BigNumber3.set = function(obj) {
          var p3, v2;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p3 = "DECIMAL_PLACES")) {
                v2 = obj[p3];
                intCheck2(v2, 0, MAX2, p3);
                DECIMAL_PLACES = v2;
              }
              if (obj.hasOwnProperty(p3 = "ROUNDING_MODE")) {
                v2 = obj[p3];
                intCheck2(v2, 0, 8, p3);
                ROUNDING_MODE = v2;
              }
              if (obj.hasOwnProperty(p3 = "EXPONENTIAL_AT")) {
                v2 = obj[p3];
                if (v2 && v2.pop) {
                  intCheck2(v2[0], -MAX2, 0, p3);
                  intCheck2(v2[1], 0, MAX2, p3);
                  TO_EXP_NEG = v2[0];
                  TO_EXP_POS = v2[1];
                } else {
                  intCheck2(v2, -MAX2, MAX2, p3);
                  TO_EXP_NEG = -(TO_EXP_POS = v2 < 0 ? -v2 : v2);
                }
              }
              if (obj.hasOwnProperty(p3 = "RANGE")) {
                v2 = obj[p3];
                if (v2 && v2.pop) {
                  intCheck2(v2[0], -MAX2, -1, p3);
                  intCheck2(v2[1], 1, MAX2, p3);
                  MIN_EXP = v2[0];
                  MAX_EXP = v2[1];
                } else {
                  intCheck2(v2, -MAX2, MAX2, p3);
                  if (v2) {
                    MIN_EXP = -(MAX_EXP = v2 < 0 ? -v2 : v2);
                  } else {
                    throw Error(bignumberError2 + p3 + " cannot be zero: " + v2);
                  }
                }
              }
              if (obj.hasOwnProperty(p3 = "CRYPTO")) {
                v2 = obj[p3];
                if (v2 === !!v2) {
                  if (v2) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v2;
                    } else {
                      CRYPTO = !v2;
                      throw Error(bignumberError2 + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v2;
                  }
                } else {
                  throw Error(bignumberError2 + p3 + " not true or false: " + v2);
                }
              }
              if (obj.hasOwnProperty(p3 = "MODULO_MODE")) {
                v2 = obj[p3];
                intCheck2(v2, 0, 9, p3);
                MODULO_MODE = v2;
              }
              if (obj.hasOwnProperty(p3 = "POW_PRECISION")) {
                v2 = obj[p3];
                intCheck2(v2, 0, MAX2, p3);
                POW_PRECISION = v2;
              }
              if (obj.hasOwnProperty(p3 = "FORMAT")) {
                v2 = obj[p3];
                if (typeof v2 == "object")
                  FORMAT = v2;
                else
                  throw Error(bignumberError2 + p3 + " not an object: " + v2);
              }
              if (obj.hasOwnProperty(p3 = "ALPHABET")) {
                v2 = obj[p3];
                if (typeof v2 == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v2)) {
                  ALPHABET = v2;
                } else {
                  throw Error(bignumberError2 + p3 + " invalid: " + v2);
                }
              }
            } else {
              throw Error(bignumberError2 + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber3.isBigNumber = function(v2) {
          if (!v2 || v2._isBigNumber !== true)
            return false;
          if (!BigNumber3.DEBUG)
            return true;
          var i2, n3, c4 = v2.c, e2 = v2.e, s2 = v2.s;
          out:
            if ({}.toString.call(c4) == "[object Array]") {
              if ((s2 === 1 || s2 === -1) && e2 >= -MAX2 && e2 <= MAX2 && e2 === mathfloor2(e2)) {
                if (c4[0] === 0) {
                  if (e2 === 0 && c4.length === 1)
                    return true;
                  break out;
                }
                i2 = (e2 + 1) % LOG_BASE2;
                if (i2 < 1)
                  i2 += LOG_BASE2;
                if (String(c4[0]).length == i2) {
                  for (i2 = 0; i2 < c4.length; i2++) {
                    n3 = c4[i2];
                    if (n3 < 0 || n3 >= BASE2 || n3 !== mathfloor2(n3))
                      break out;
                  }
                  if (n3 !== 0)
                    return true;
                }
              }
            } else if (c4 === null && e2 === null && (s2 === null || s2 === 1 || s2 === -1)) {
              return true;
            }
          throw Error(bignumberError2 + "Invalid BigNumber: " + v2);
        };
        BigNumber3.maximum = BigNumber3.max = function() {
          return maxOrMin(arguments, P2.lt);
        };
        BigNumber3.minimum = BigNumber3.min = function() {
          return maxOrMin(arguments, P2.gt);
        };
        BigNumber3.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor2(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a3, b4, e2, k4, v2, i2 = 0, c4 = [], rand = new BigNumber3(ONE);
            if (dp == null)
              dp = DECIMAL_PLACES;
            else
              intCheck2(dp, 0, MAX2);
            k4 = mathceil2(dp / LOG_BASE2);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a3 = crypto.getRandomValues(new Uint32Array(k4 *= 2));
                for (; i2 < k4; ) {
                  v2 = a3[i2] * 131072 + (a3[i2 + 1] >>> 11);
                  if (v2 >= 9e15) {
                    b4 = crypto.getRandomValues(new Uint32Array(2));
                    a3[i2] = b4[0];
                    a3[i2 + 1] = b4[1];
                  } else {
                    c4.push(v2 % 1e14);
                    i2 += 2;
                  }
                }
                i2 = k4 / 2;
              } else if (crypto.randomBytes) {
                a3 = crypto.randomBytes(k4 *= 7);
                for (; i2 < k4; ) {
                  v2 = (a3[i2] & 31) * 281474976710656 + a3[i2 + 1] * 1099511627776 + a3[i2 + 2] * 4294967296 + a3[i2 + 3] * 16777216 + (a3[i2 + 4] << 16) + (a3[i2 + 5] << 8) + a3[i2 + 6];
                  if (v2 >= 9e15) {
                    crypto.randomBytes(7).copy(a3, i2);
                  } else {
                    c4.push(v2 % 1e14);
                    i2 += 7;
                  }
                }
                i2 = k4 / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError2 + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i2 < k4; ) {
                v2 = random53bitInt();
                if (v2 < 9e15)
                  c4[i2++] = v2 % 1e14;
              }
            }
            k4 = c4[--i2];
            dp %= LOG_BASE2;
            if (k4 && dp) {
              v2 = POWS_TEN2[LOG_BASE2 - dp];
              c4[i2] = mathfloor2(k4 / v2) * v2;
            }
            for (; c4[i2] === 0; c4.pop(), i2--)
              ;
            if (i2 < 0) {
              c4 = [e2 = 0];
            } else {
              for (e2 = -1; c4[0] === 0; c4.splice(0, 1), e2 -= LOG_BASE2)
                ;
              for (i2 = 1, v2 = c4[0]; v2 >= 10; v2 /= 10, i2++)
                ;
              if (i2 < LOG_BASE2)
                e2 -= LOG_BASE2 - i2;
            }
            rand.e = e2;
            rand.c = c4;
            return rand;
          };
        }();
        BigNumber3.sum = function() {
          var i2 = 1, args = arguments, sum = new BigNumber3(args[0]);
          for (; i2 < args.length; )
            sum = sum.plus(args[i2++]);
          return sum;
        };
        convertBase = /* @__PURE__ */ function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet2) {
            var j2, arr = [0], arrL, i2 = 0, len = str.length;
            for (; i2 < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
                ;
              arr[0] += alphabet2.indexOf(str.charAt(i2++));
              for (j2 = 0; j2 < arr.length; j2++) {
                if (arr[j2] > baseOut - 1) {
                  if (arr[j2 + 1] == null)
                    arr[j2 + 1] = 0;
                  arr[j2 + 1] += arr[j2] / baseOut | 0;
                  arr[j2] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign2, callerIsToString) {
            var alphabet2, d3, e2, k4, r, x3, xc, y4, i2 = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i2 >= 0) {
              k4 = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y4 = new BigNumber3(baseIn);
              x3 = y4.pow(str.length - i2);
              POW_PRECISION = k4;
              y4.c = toBaseOut(
                toFixedPoint2(coeffToString2(x3.c), x3.e, "0"),
                10,
                baseOut,
                decimal
              );
              y4.e = y4.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet2 = ALPHABET, decimal) : (alphabet2 = decimal, ALPHABET));
            e2 = k4 = xc.length;
            for (; xc[--k4] == 0; xc.pop())
              ;
            if (!xc[0])
              return alphabet2.charAt(0);
            if (i2 < 0) {
              --e2;
            } else {
              x3.c = xc;
              x3.e = e2;
              x3.s = sign2;
              x3 = div(x3, y4, dp, rm, baseOut);
              xc = x3.c;
              r = x3.r;
              e2 = x3.e;
            }
            d3 = e2 + dp + 1;
            i2 = xc[d3];
            k4 = baseOut / 2;
            r = r || d3 < 0 || xc[d3 + 1] != null;
            r = rm < 4 ? (i2 != null || r) && (rm == 0 || rm == (x3.s < 0 ? 3 : 2)) : i2 > k4 || i2 == k4 && (rm == 4 || r || rm == 6 && xc[d3 - 1] & 1 || rm == (x3.s < 0 ? 8 : 7));
            if (d3 < 1 || !xc[0]) {
              str = r ? toFixedPoint2(alphabet2.charAt(1), -dp, alphabet2.charAt(0)) : alphabet2.charAt(0);
            } else {
              xc.length = d3;
              if (r) {
                for (--baseOut; ++xc[--d3] > baseOut; ) {
                  xc[d3] = 0;
                  if (!d3) {
                    ++e2;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k4 = xc.length; !xc[--k4]; )
                ;
              for (i2 = 0, str = ""; i2 <= k4; str += alphabet2.charAt(xc[i2++]))
                ;
              str = toFixedPoint2(str, e2, alphabet2.charAt(0));
            }
            return str;
          };
        }();
        div = /* @__PURE__ */ function() {
          function multiply(x3, k4, base3) {
            var m3, temp, xlo, xhi, carry = 0, i2 = x3.length, klo = k4 % SQRT_BASE2, khi = k4 / SQRT_BASE2 | 0;
            for (x3 = x3.slice(); i2--; ) {
              xlo = x3[i2] % SQRT_BASE2;
              xhi = x3[i2] / SQRT_BASE2 | 0;
              m3 = khi * xlo + xhi * klo;
              temp = klo * xlo + m3 % SQRT_BASE2 * SQRT_BASE2 + carry;
              carry = (temp / base3 | 0) + (m3 / SQRT_BASE2 | 0) + khi * xhi;
              x3[i2] = temp % base3;
            }
            if (carry)
              x3 = [carry].concat(x3);
            return x3;
          }
          function compare4(a3, b4, aL, bL) {
            var i2, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i2 = cmp = 0; i2 < aL; i2++) {
                if (a3[i2] != b4[i2]) {
                  cmp = a3[i2] > b4[i2] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a3, b4, aL, base3) {
            var i2 = 0;
            for (; aL--; ) {
              a3[aL] -= i2;
              i2 = a3[aL] < b4[aL] ? 1 : 0;
              a3[aL] = i2 * base3 + a3[aL] - b4[aL];
            }
            for (; !a3[0] && a3.length > 1; a3.splice(0, 1))
              ;
          }
          return function(x3, y4, dp, rm, base3) {
            var cmp, e2, i2, more, n3, prod, prodL, q2, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s2 = x3.s == y4.s ? 1 : -1, xc = x3.c, yc = y4.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber3(
                // Return NaN if either NaN, or both Infinity or 0.
                !x3.s || !y4.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                  // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                  xc && xc[0] == 0 || !yc ? s2 * 0 : s2 / 0
                )
              );
            }
            q2 = new BigNumber3(s2);
            qc = q2.c = [];
            e2 = x3.e - y4.e;
            s2 = dp + e2 + 1;
            if (!base3) {
              base3 = BASE2;
              e2 = bitFloor2(x3.e / LOG_BASE2) - bitFloor2(y4.e / LOG_BASE2);
              s2 = s2 / LOG_BASE2 | 0;
            }
            for (i2 = 0; yc[i2] == (xc[i2] || 0); i2++)
              ;
            if (yc[i2] > (xc[i2] || 0))
              e2--;
            if (s2 < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i2 = 0;
              s2 += 2;
              n3 = mathfloor2(base3 / (yc[0] + 1));
              if (n3 > 1) {
                yc = multiply(yc, n3, base3);
                xc = multiply(xc, n3, base3);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0)
                ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base3 / 2)
                yc0++;
              do {
                n3 = 0;
                cmp = compare4(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL)
                    rem0 = rem0 * base3 + (rem[1] || 0);
                  n3 = mathfloor2(rem0 / yc0);
                  if (n3 > 1) {
                    if (n3 >= base3)
                      n3 = base3 - 1;
                    prod = multiply(yc, n3, base3);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare4(prod, rem, prodL, remL) == 1) {
                      n3--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base3);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n3 == 0) {
                      cmp = n3 = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL)
                    prod = [0].concat(prod);
                  subtract(rem, prod, remL, base3);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare4(yc, rem, yL, remL) < 1) {
                      n3++;
                      subtract(rem, yL < remL ? yz : yc, remL, base3);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n3++;
                  rem = [0];
                }
                qc[i2++] = n3;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s2--);
              more = rem[0] != null;
              if (!qc[0])
                qc.splice(0, 1);
            }
            if (base3 == BASE2) {
              for (i2 = 1, s2 = qc[0]; s2 >= 10; s2 /= 10, i2++)
                ;
              round(q2, dp + (q2.e = i2 + e2 * LOG_BASE2 - 1) + 1, rm, more);
            } else {
              q2.e = e2;
              q2.r = +more;
            }
            return q2;
          };
        }();
        function format(n3, i2, rm, id) {
          var c0, e2, ne, len, str;
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck2(rm, 0, 8);
          if (!n3.c)
            return n3.toString();
          c0 = n3.c[0];
          ne = n3.e;
          if (i2 == null) {
            str = coeffToString2(n3.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential2(str, ne) : toFixedPoint2(str, ne, "0");
          } else {
            n3 = round(new BigNumber3(n3), i2, rm);
            e2 = n3.e;
            str = coeffToString2(n3.c);
            len = str.length;
            if (id == 1 || id == 2 && (i2 <= e2 || e2 <= TO_EXP_NEG)) {
              for (; len < i2; str += "0", len++)
                ;
              str = toExponential2(str, e2);
            } else {
              i2 -= ne;
              str = toFixedPoint2(str, e2, "0");
              if (e2 + 1 > len) {
                if (--i2 > 0)
                  for (str += "."; i2--; str += "0")
                    ;
              } else {
                i2 += e2 - len;
                if (i2 > 0) {
                  if (e2 + 1 == len)
                    str += ".";
                  for (; i2--; str += "0")
                    ;
                }
              }
            }
          }
          return n3.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, method) {
          var n3, i2 = 1, m3 = new BigNumber3(args[0]);
          for (; i2 < args.length; i2++) {
            n3 = new BigNumber3(args[i2]);
            if (!n3.s) {
              m3 = n3;
              break;
            } else if (method.call(m3, n3)) {
              m3 = n3;
            }
          }
          return m3;
        }
        function normalise(n3, c4, e2) {
          var i2 = 1, j2 = c4.length;
          for (; !c4[--j2]; c4.pop())
            ;
          for (j2 = c4[0]; j2 >= 10; j2 /= 10, i2++)
            ;
          if ((e2 = i2 + e2 * LOG_BASE2 - 1) > MAX_EXP) {
            n3.c = n3.e = null;
          } else if (e2 < MIN_EXP) {
            n3.c = [n3.e = 0];
          } else {
            n3.e = e2;
            n3.c = c4;
          }
          return n3;
        }
        parseNumeric = /* @__PURE__ */ function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x3, str, isNum, b4) {
            var base3, s2 = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s2)) {
              x3.s = isNaN(s2) ? null : s2 < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s2 = s2.replace(basePrefix, function(m3, p1, p22) {
                  base3 = (p22 = p22.toLowerCase()) == "x" ? 16 : p22 == "b" ? 2 : 8;
                  return !b4 || b4 == base3 ? p1 : m3;
                });
                if (b4) {
                  base3 = b4;
                  s2 = s2.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s2)
                  return new BigNumber3(s2, base3);
              }
              if (BigNumber3.DEBUG) {
                throw Error(bignumberError2 + "Not a" + (b4 ? " base " + b4 : "") + " number: " + str);
              }
              x3.s = null;
            }
            x3.c = x3.e = null;
          };
        }();
        function round(x3, sd, rm, r) {
          var d3, i2, j2, k4, n3, ni, rd, xc = x3.c, pows10 = POWS_TEN2;
          if (xc) {
            out: {
              for (d3 = 1, k4 = xc[0]; k4 >= 10; k4 /= 10, d3++)
                ;
              i2 = sd - d3;
              if (i2 < 0) {
                i2 += LOG_BASE2;
                j2 = sd;
                n3 = xc[ni = 0];
                rd = n3 / pows10[d3 - j2 - 1] % 10 | 0;
              } else {
                ni = mathceil2((i2 + 1) / LOG_BASE2);
                if (ni >= xc.length) {
                  if (r) {
                    for (; xc.length <= ni; xc.push(0))
                      ;
                    n3 = rd = 0;
                    d3 = 1;
                    i2 %= LOG_BASE2;
                    j2 = i2 - LOG_BASE2 + 1;
                  } else {
                    break out;
                  }
                } else {
                  n3 = k4 = xc[ni];
                  for (d3 = 1; k4 >= 10; k4 /= 10, d3++)
                    ;
                  i2 %= LOG_BASE2;
                  j2 = i2 - LOG_BASE2 + d3;
                  rd = j2 < 0 ? 0 : n3 / pows10[d3 - j2 - 1] % 10 | 0;
                }
              }
              r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              xc[ni + 1] != null || (j2 < 0 ? n3 : n3 % pows10[d3 - j2 - 1]);
              r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x3.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (i2 > 0 ? j2 > 0 ? n3 / pows10[d3 - j2] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x3.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r) {
                  sd -= x3.e + 1;
                  xc[0] = pows10[(LOG_BASE2 - sd % LOG_BASE2) % LOG_BASE2];
                  x3.e = -sd || 0;
                } else {
                  xc[0] = x3.e = 0;
                }
                return x3;
              }
              if (i2 == 0) {
                xc.length = ni;
                k4 = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k4 = pows10[LOG_BASE2 - i2];
                xc[ni] = j2 > 0 ? mathfloor2(n3 / pows10[d3 - j2] % pows10[j2]) * k4 : 0;
              }
              if (r) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i2 = 1, j2 = xc[0]; j2 >= 10; j2 /= 10, i2++)
                      ;
                    j2 = xc[0] += k4;
                    for (k4 = 1; j2 >= 10; j2 /= 10, k4++)
                      ;
                    if (i2 != k4) {
                      x3.e++;
                      if (xc[0] == BASE2)
                        xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k4;
                    if (xc[ni] != BASE2)
                      break;
                    xc[ni--] = 0;
                    k4 = 1;
                  }
                }
              }
              for (i2 = xc.length; xc[--i2] === 0; xc.pop())
                ;
            }
            if (x3.e > MAX_EXP) {
              x3.c = x3.e = null;
            } else if (x3.e < MIN_EXP) {
              x3.c = [x3.e = 0];
            }
          }
          return x3;
        }
        function valueOf(n3) {
          var str, e2 = n3.e;
          if (e2 === null)
            return n3.toString();
          str = coeffToString2(n3.c);
          str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential2(str, e2) : toFixedPoint2(str, e2, "0");
          return n3.s < 0 ? "-" + str : str;
        }
        P2.absoluteValue = P2.abs = function() {
          var x3 = new BigNumber3(this);
          if (x3.s < 0)
            x3.s = 1;
          return x3;
        };
        P2.comparedTo = function(y4, b4) {
          return compare3(this, new BigNumber3(y4, b4));
        };
        P2.decimalPlaces = P2.dp = function(dp, rm) {
          var c4, n3, v2, x3 = this;
          if (dp != null) {
            intCheck2(dp, 0, MAX2);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck2(rm, 0, 8);
            return round(new BigNumber3(x3), dp + x3.e + 1, rm);
          }
          if (!(c4 = x3.c))
            return null;
          n3 = ((v2 = c4.length - 1) - bitFloor2(this.e / LOG_BASE2)) * LOG_BASE2;
          if (v2 = c4[v2])
            for (; v2 % 10 == 0; v2 /= 10, n3--)
              ;
          if (n3 < 0)
            n3 = 0;
          return n3;
        };
        P2.dividedBy = P2.div = function(y4, b4) {
          return div(this, new BigNumber3(y4, b4), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P2.dividedToIntegerBy = P2.idiv = function(y4, b4) {
          return div(this, new BigNumber3(y4, b4), 0, 1);
        };
        P2.exponentiatedBy = P2.pow = function(n3, m3) {
          var half, isModExp, i2, k4, more, nIsBig, nIsNeg, nIsOdd, y4, x3 = this;
          n3 = new BigNumber3(n3);
          if (n3.c && !n3.isInteger()) {
            throw Error(bignumberError2 + "Exponent not an integer: " + valueOf(n3));
          }
          if (m3 != null)
            m3 = new BigNumber3(m3);
          nIsBig = n3.e > 14;
          if (!x3.c || !x3.c[0] || x3.c[0] == 1 && !x3.e && x3.c.length == 1 || !n3.c || !n3.c[0]) {
            y4 = new BigNumber3(Math.pow(+valueOf(x3), nIsBig ? 2 - isOdd2(n3) : +valueOf(n3)));
            return m3 ? y4.mod(m3) : y4;
          }
          nIsNeg = n3.s < 0;
          if (m3) {
            if (m3.c ? !m3.c[0] : !m3.s)
              return new BigNumber3(NaN);
            isModExp = !nIsNeg && x3.isInteger() && m3.isInteger();
            if (isModExp)
              x3 = x3.mod(m3);
          } else if (n3.e > 9 && (x3.e > 0 || x3.e < -1 || (x3.e == 0 ? x3.c[0] > 1 || nIsBig && x3.c[1] >= 24e7 : x3.c[0] < 8e13 || nIsBig && x3.c[0] <= 9999975e7))) {
            k4 = x3.s < 0 && isOdd2(n3) ? -0 : 0;
            if (x3.e > -1)
              k4 = 1 / k4;
            return new BigNumber3(nIsNeg ? 1 / k4 : k4);
          } else if (POW_PRECISION) {
            k4 = mathceil2(POW_PRECISION / LOG_BASE2 + 2);
          }
          if (nIsBig) {
            half = new BigNumber3(0.5);
            if (nIsNeg)
              n3.s = 1;
            nIsOdd = isOdd2(n3);
          } else {
            i2 = Math.abs(+valueOf(n3));
            nIsOdd = i2 % 2;
          }
          y4 = new BigNumber3(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y4 = y4.times(x3);
              if (!y4.c)
                break;
              if (k4) {
                if (y4.c.length > k4)
                  y4.c.length = k4;
              } else if (isModExp) {
                y4 = y4.mod(m3);
              }
            }
            if (i2) {
              i2 = mathfloor2(i2 / 2);
              if (i2 === 0)
                break;
              nIsOdd = i2 % 2;
            } else {
              n3 = n3.times(half);
              round(n3, n3.e + 1, 1);
              if (n3.e > 14) {
                nIsOdd = isOdd2(n3);
              } else {
                i2 = +valueOf(n3);
                if (i2 === 0)
                  break;
                nIsOdd = i2 % 2;
              }
            }
            x3 = x3.times(x3);
            if (k4) {
              if (x3.c && x3.c.length > k4)
                x3.c.length = k4;
            } else if (isModExp) {
              x3 = x3.mod(m3);
            }
          }
          if (isModExp)
            return y4;
          if (nIsNeg)
            y4 = ONE.div(y4);
          return m3 ? y4.mod(m3) : k4 ? round(y4, POW_PRECISION, ROUNDING_MODE, more) : y4;
        };
        P2.integerValue = function(rm) {
          var n3 = new BigNumber3(this);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck2(rm, 0, 8);
          return round(n3, n3.e + 1, rm);
        };
        P2.isEqualTo = P2.eq = function(y4, b4) {
          return compare3(this, new BigNumber3(y4, b4)) === 0;
        };
        P2.isFinite = function() {
          return !!this.c;
        };
        P2.isGreaterThan = P2.gt = function(y4, b4) {
          return compare3(this, new BigNumber3(y4, b4)) > 0;
        };
        P2.isGreaterThanOrEqualTo = P2.gte = function(y4, b4) {
          return (b4 = compare3(this, new BigNumber3(y4, b4))) === 1 || b4 === 0;
        };
        P2.isInteger = function() {
          return !!this.c && bitFloor2(this.e / LOG_BASE2) > this.c.length - 2;
        };
        P2.isLessThan = P2.lt = function(y4, b4) {
          return compare3(this, new BigNumber3(y4, b4)) < 0;
        };
        P2.isLessThanOrEqualTo = P2.lte = function(y4, b4) {
          return (b4 = compare3(this, new BigNumber3(y4, b4))) === -1 || b4 === 0;
        };
        P2.isNaN = function() {
          return !this.s;
        };
        P2.isNegative = function() {
          return this.s < 0;
        };
        P2.isPositive = function() {
          return this.s > 0;
        };
        P2.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P2.minus = function(y4, b4) {
          var i2, j2, t, xLTy, x3 = this, a3 = x3.s;
          y4 = new BigNumber3(y4, b4);
          b4 = y4.s;
          if (!a3 || !b4)
            return new BigNumber3(NaN);
          if (a3 != b4) {
            y4.s = -b4;
            return x3.plus(y4);
          }
          var xe = x3.e / LOG_BASE2, ye = y4.e / LOG_BASE2, xc = x3.c, yc = y4.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return xc ? (y4.s = -b4, y4) : new BigNumber3(yc ? x3 : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y4.s = -b4, y4) : new BigNumber3(xc[0] ? x3 : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0
              ));
            }
          }
          xe = bitFloor2(xe);
          ye = bitFloor2(ye);
          xc = xc.slice();
          if (a3 = xe - ye) {
            if (xLTy = a3 < 0) {
              a3 = -a3;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }
            t.reverse();
            for (b4 = a3; b4--; t.push(0))
              ;
            t.reverse();
          } else {
            j2 = (xLTy = (a3 = xc.length) < (b4 = yc.length)) ? a3 : b4;
            for (a3 = b4 = 0; b4 < j2; b4++) {
              if (xc[b4] != yc[b4]) {
                xLTy = xc[b4] < yc[b4];
                break;
              }
            }
          }
          if (xLTy)
            t = xc, xc = yc, yc = t, y4.s = -y4.s;
          b4 = (j2 = yc.length) - (i2 = xc.length);
          if (b4 > 0)
            for (; b4--; xc[i2++] = 0)
              ;
          b4 = BASE2 - 1;
          for (; j2 > a3; ) {
            if (xc[--j2] < yc[j2]) {
              for (i2 = j2; i2 && !xc[--i2]; xc[i2] = b4)
                ;
              --xc[i2];
              xc[j2] += BASE2;
            }
            xc[j2] -= yc[j2];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye)
            ;
          if (!xc[0]) {
            y4.s = ROUNDING_MODE == 3 ? -1 : 1;
            y4.c = [y4.e = 0];
            return y4;
          }
          return normalise(y4, xc, ye);
        };
        P2.modulo = P2.mod = function(y4, b4) {
          var q2, s2, x3 = this;
          y4 = new BigNumber3(y4, b4);
          if (!x3.c || !y4.s || y4.c && !y4.c[0]) {
            return new BigNumber3(NaN);
          } else if (!y4.c || x3.c && !x3.c[0]) {
            return new BigNumber3(x3);
          }
          if (MODULO_MODE == 9) {
            s2 = y4.s;
            y4.s = 1;
            q2 = div(x3, y4, 0, 3);
            y4.s = s2;
            q2.s *= s2;
          } else {
            q2 = div(x3, y4, 0, MODULO_MODE);
          }
          y4 = x3.minus(q2.times(y4));
          if (!y4.c[0] && MODULO_MODE == 1)
            y4.s = x3.s;
          return y4;
        };
        P2.multipliedBy = P2.times = function(y4, b4) {
          var c4, e2, i2, j2, k4, m3, xcL, xlo, xhi, ycL, ylo, yhi, zc, base3, sqrtBase, x3 = this, xc = x3.c, yc = (y4 = new BigNumber3(y4, b4)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x3.s || !y4.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y4.c = y4.e = y4.s = null;
            } else {
              y4.s *= x3.s;
              if (!xc || !yc) {
                y4.c = y4.e = null;
              } else {
                y4.c = [0];
                y4.e = 0;
              }
            }
            return y4;
          }
          e2 = bitFloor2(x3.e / LOG_BASE2) + bitFloor2(y4.e / LOG_BASE2);
          y4.s *= x3.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL)
            zc = xc, xc = yc, yc = zc, i2 = xcL, xcL = ycL, ycL = i2;
          for (i2 = xcL + ycL, zc = []; i2--; zc.push(0))
            ;
          base3 = BASE2;
          sqrtBase = SQRT_BASE2;
          for (i2 = ycL; --i2 >= 0; ) {
            c4 = 0;
            ylo = yc[i2] % sqrtBase;
            yhi = yc[i2] / sqrtBase | 0;
            for (k4 = xcL, j2 = i2 + k4; j2 > i2; ) {
              xlo = xc[--k4] % sqrtBase;
              xhi = xc[k4] / sqrtBase | 0;
              m3 = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m3 % sqrtBase * sqrtBase + zc[j2] + c4;
              c4 = (xlo / base3 | 0) + (m3 / sqrtBase | 0) + yhi * xhi;
              zc[j2--] = xlo % base3;
            }
            zc[j2] = c4;
          }
          if (c4) {
            ++e2;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y4, zc, e2);
        };
        P2.negated = function() {
          var x3 = new BigNumber3(this);
          x3.s = -x3.s || null;
          return x3;
        };
        P2.plus = function(y4, b4) {
          var t, x3 = this, a3 = x3.s;
          y4 = new BigNumber3(y4, b4);
          b4 = y4.s;
          if (!a3 || !b4)
            return new BigNumber3(NaN);
          if (a3 != b4) {
            y4.s = -b4;
            return x3.minus(y4);
          }
          var xe = x3.e / LOG_BASE2, ye = y4.e / LOG_BASE2, xc = x3.c, yc = y4.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return new BigNumber3(a3 / 0);
            if (!xc[0] || !yc[0])
              return yc[0] ? y4 : new BigNumber3(xc[0] ? x3 : a3 * 0);
          }
          xe = bitFloor2(xe);
          ye = bitFloor2(ye);
          xc = xc.slice();
          if (a3 = xe - ye) {
            if (a3 > 0) {
              ye = xe;
              t = yc;
            } else {
              a3 = -a3;
              t = xc;
            }
            t.reverse();
            for (; a3--; t.push(0))
              ;
            t.reverse();
          }
          a3 = xc.length;
          b4 = yc.length;
          if (a3 - b4 < 0)
            t = yc, yc = xc, xc = t, b4 = a3;
          for (a3 = 0; b4; ) {
            a3 = (xc[--b4] = xc[b4] + yc[b4] + a3) / BASE2 | 0;
            xc[b4] = BASE2 === xc[b4] ? 0 : xc[b4] % BASE2;
          }
          if (a3) {
            xc = [a3].concat(xc);
            ++ye;
          }
          return normalise(y4, xc, ye);
        };
        P2.precision = P2.sd = function(sd, rm) {
          var c4, n3, v2, x3 = this;
          if (sd != null && sd !== !!sd) {
            intCheck2(sd, 1, MAX2);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck2(rm, 0, 8);
            return round(new BigNumber3(x3), sd, rm);
          }
          if (!(c4 = x3.c))
            return null;
          v2 = c4.length - 1;
          n3 = v2 * LOG_BASE2 + 1;
          if (v2 = c4[v2]) {
            for (; v2 % 10 == 0; v2 /= 10, n3--)
              ;
            for (v2 = c4[0]; v2 >= 10; v2 /= 10, n3++)
              ;
          }
          if (sd && x3.e + 1 > n3)
            n3 = x3.e + 1;
          return n3;
        };
        P2.shiftedBy = function(k4) {
          intCheck2(k4, -MAX_SAFE_INTEGER2, MAX_SAFE_INTEGER2);
          return this.times("1e" + k4);
        };
        P2.squareRoot = P2.sqrt = function() {
          var m3, n3, r, rep, t, x3 = this, c4 = x3.c, s2 = x3.s, e2 = x3.e, dp = DECIMAL_PLACES + 4, half = new BigNumber3("0.5");
          if (s2 !== 1 || !c4 || !c4[0]) {
            return new BigNumber3(!s2 || s2 < 0 && (!c4 || c4[0]) ? NaN : c4 ? x3 : 1 / 0);
          }
          s2 = Math.sqrt(+valueOf(x3));
          if (s2 == 0 || s2 == 1 / 0) {
            n3 = coeffToString2(c4);
            if ((n3.length + e2) % 2 == 0)
              n3 += "0";
            s2 = Math.sqrt(+n3);
            e2 = bitFloor2((e2 + 1) / 2) - (e2 < 0 || e2 % 2);
            if (s2 == 1 / 0) {
              n3 = "5e" + e2;
            } else {
              n3 = s2.toExponential();
              n3 = n3.slice(0, n3.indexOf("e") + 1) + e2;
            }
            r = new BigNumber3(n3);
          } else {
            r = new BigNumber3(s2 + "");
          }
          if (r.c[0]) {
            e2 = r.e;
            s2 = e2 + dp;
            if (s2 < 3)
              s2 = 0;
            for (; ; ) {
              t = r;
              r = half.times(t.plus(div(x3, t, dp, 1)));
              if (coeffToString2(t.c).slice(0, s2) === (n3 = coeffToString2(r.c)).slice(0, s2)) {
                if (r.e < e2)
                  --s2;
                n3 = n3.slice(s2 - 3, s2 + 1);
                if (n3 == "9999" || !rep && n3 == "4999") {
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x3)) {
                      r = t;
                      break;
                    }
                  }
                  dp += 4;
                  s2 += 4;
                  rep = 1;
                } else {
                  if (!+n3 || !+n3.slice(1) && n3.charAt(0) == "5") {
                    round(r, r.e + DECIMAL_PLACES + 2, 1);
                    m3 = !r.times(r).eq(x3);
                  }
                  break;
                }
              }
            }
          }
          return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m3);
        };
        P2.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck2(dp, 0, MAX2);
            dp++;
          }
          return format(this, dp, rm, 1);
        };
        P2.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck2(dp, 0, MAX2);
            dp = dp + this.e + 1;
          }
          return format(this, dp, rm);
        };
        P2.toFormat = function(dp, rm, format2) {
          var str, x3 = this;
          if (format2 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format2 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format2 = dp;
              dp = rm = null;
            } else {
              format2 = FORMAT;
            }
          } else if (typeof format2 != "object") {
            throw Error(bignumberError2 + "Argument not an object: " + format2);
          }
          str = x3.toFixed(dp, rm);
          if (x3.c) {
            var i2, arr = str.split("."), g1 = +format2.groupSize, g22 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x3.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g22)
              i2 = g1, g1 = g22, g22 = i2, len -= i2;
            if (g1 > 0 && len > 0) {
              i2 = len % g1 || g1;
              intPart = intDigits.substr(0, i2);
              for (; i2 < len; i2 += g1)
                intPart += groupSeparator + intDigits.substr(i2, g1);
              if (g22 > 0)
                intPart += groupSeparator + intDigits.slice(i2);
              if (isNeg)
                intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g22 = +format2.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g22 + "}\\B", "g"),
              "$&" + (format2.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format2.prefix || "") + str + (format2.suffix || "");
        };
        P2.toFraction = function(md) {
          var d3, d0, d1, d22, e2, exp, n3, n0, n1, q2, r, s2, x3 = this, xc = x3.c;
          if (md != null) {
            n3 = new BigNumber3(md);
            if (!n3.isInteger() && (n3.c || n3.s !== 1) || n3.lt(ONE)) {
              throw Error(bignumberError2 + "Argument " + (n3.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n3));
            }
          }
          if (!xc)
            return new BigNumber3(x3);
          d3 = new BigNumber3(ONE);
          n1 = d0 = new BigNumber3(ONE);
          d1 = n0 = new BigNumber3(ONE);
          s2 = coeffToString2(xc);
          e2 = d3.e = s2.length - x3.e - 1;
          d3.c[0] = POWS_TEN2[(exp = e2 % LOG_BASE2) < 0 ? LOG_BASE2 + exp : exp];
          md = !md || n3.comparedTo(d3) > 0 ? e2 > 0 ? d3 : n1 : n3;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n3 = new BigNumber3(s2);
          n0.c[0] = 0;
          for (; ; ) {
            q2 = div(n3, d3, 0, 1);
            d22 = d0.plus(q2.times(d1));
            if (d22.comparedTo(md) == 1)
              break;
            d0 = d1;
            d1 = d22;
            n1 = n0.plus(q2.times(d22 = n1));
            n0 = d22;
            d3 = n3.minus(q2.times(d22 = d3));
            n3 = d22;
          }
          d22 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d22.times(n1));
          d0 = d0.plus(d22.times(d1));
          n0.s = n1.s = x3.s;
          e2 = e2 * 2;
          r = div(n1, d1, e2, ROUNDING_MODE).minus(x3).abs().comparedTo(
            div(n0, d0, e2, ROUNDING_MODE).minus(x3).abs()
          ) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp;
          return r;
        };
        P2.toNumber = function() {
          return +valueOf(this);
        };
        P2.toPrecision = function(sd, rm) {
          if (sd != null)
            intCheck2(sd, 1, MAX2);
          return format(this, sd, rm, 2);
        };
        P2.toString = function(b4) {
          var str, n3 = this, s2 = n3.s, e2 = n3.e;
          if (e2 === null) {
            if (s2) {
              str = "Infinity";
              if (s2 < 0)
                str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b4 == null) {
              str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential2(coeffToString2(n3.c), e2) : toFixedPoint2(coeffToString2(n3.c), e2, "0");
            } else if (b4 === 10) {
              n3 = round(new BigNumber3(n3), DECIMAL_PLACES + e2 + 1, ROUNDING_MODE);
              str = toFixedPoint2(coeffToString2(n3.c), n3.e, "0");
            } else {
              intCheck2(b4, 2, ALPHABET.length, "Base");
              str = convertBase(toFixedPoint2(coeffToString2(n3.c), e2, "0"), 10, b4, s2, true);
            }
            if (s2 < 0 && n3.c[0])
              str = "-" + str;
          }
          return str;
        };
        P2.valueOf = P2.toJSON = function() {
          return valueOf(this);
        };
        P2._isBigNumber = true;
        if (configObject != null)
          BigNumber3.set(configObject);
        return BigNumber3;
      }
      function bitFloor2(n3) {
        var i2 = n3 | 0;
        return n3 > 0 || n3 === i2 ? i2 : i2 - 1;
      }
      function coeffToString2(a3) {
        var s2, z3, i2 = 1, j2 = a3.length, r = a3[0] + "";
        for (; i2 < j2; ) {
          s2 = a3[i2++] + "";
          z3 = LOG_BASE2 - s2.length;
          for (; z3--; s2 = "0" + s2)
            ;
          r += s2;
        }
        for (j2 = r.length; r.charCodeAt(--j2) === 48; )
          ;
        return r.slice(0, j2 + 1 || 1);
      }
      function compare3(x3, y4) {
        var a3, b4, xc = x3.c, yc = y4.c, i2 = x3.s, j2 = y4.s, k4 = x3.e, l4 = y4.e;
        if (!i2 || !j2)
          return null;
        a3 = xc && !xc[0];
        b4 = yc && !yc[0];
        if (a3 || b4)
          return a3 ? b4 ? 0 : -j2 : i2;
        if (i2 != j2)
          return i2;
        a3 = i2 < 0;
        b4 = k4 == l4;
        if (!xc || !yc)
          return b4 ? 0 : !xc ^ a3 ? 1 : -1;
        if (!b4)
          return k4 > l4 ^ a3 ? 1 : -1;
        j2 = (k4 = xc.length) < (l4 = yc.length) ? k4 : l4;
        for (i2 = 0; i2 < j2; i2++)
          if (xc[i2] != yc[i2])
            return xc[i2] > yc[i2] ^ a3 ? 1 : -1;
        return k4 == l4 ? 0 : k4 > l4 ^ a3 ? 1 : -1;
      }
      function intCheck2(n3, min, max, name2) {
        if (n3 < min || n3 > max || n3 !== mathfloor2(n3)) {
          throw Error(bignumberError2 + (name2 || "Argument") + (typeof n3 == "number" ? n3 < min || n3 > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n3));
        }
      }
      function isOdd2(n3) {
        var k4 = n3.c.length - 1;
        return bitFloor2(n3.e / LOG_BASE2) == k4 && n3.c[k4] % 2 != 0;
      }
      function toExponential2(str, e2) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e2 < 0 ? "e" : "e+") + e2;
      }
      function toFixedPoint2(str, e2, z3) {
        var len, zs;
        if (e2 < 0) {
          for (zs = z3 + "."; ++e2; zs += z3)
            ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e2 > len) {
            for (zs = z3, e2 -= len; --e2; zs += z3)
              ;
            str += zs;
          } else if (e2 < len) {
            str = str.slice(0, e2) + "." + str.slice(e2);
          }
        }
        return str;
      }
      BigNumber2 = clone2();
      BigNumber2["default"] = BigNumber2.BigNumber = BigNumber2;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber2;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = BigNumber2;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber2;
      }
    })(exports2);
  }
});

// node_modules/@multiversx/sdk-network-providers/out/primitives.js
var require_primitives = __commonJS({
  "node_modules/@multiversx/sdk-network-providers/out/primitives.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k4 in mod2)
          if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k4))
            __createBinding2(result, mod2, k4);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.zeroPadStringIfOddLength = exports2.isPaddedHex = exports2.numberToPaddedHex = exports2.Nonce = exports2.Address = void 0;
    var bech32 = __importStar2(require_bech32());
    var HRP = "erd";
    var Address5 = class _Address {
      constructor(value) {
        this.value = value;
      }
      static fromPubkey(pubkey) {
        let words = bech32.toWords(pubkey);
        let address = bech32.encode(HRP, words);
        return new _Address(address);
      }
      bech32() {
        return this.value;
      }
      toString() {
        return this.bech32();
      }
    };
    exports2.Address = Address5;
    var Nonce = class {
      constructor(value) {
        this.value = value;
      }
      valueOf() {
        return this.value;
      }
      hex() {
        return numberToPaddedHex(this.value);
      }
    };
    exports2.Nonce = Nonce;
    function numberToPaddedHex(value) {
      let hex = value.toString(16);
      return zeroPadStringIfOddLength(hex);
    }
    exports2.numberToPaddedHex = numberToPaddedHex;
    function isPaddedHex(input) {
      input = input || "";
      let decodedThenEncoded = import_buffer.Buffer.from(input, "hex").toString("hex");
      return input.toUpperCase() == decodedThenEncoded.toUpperCase();
    }
    exports2.isPaddedHex = isPaddedHex;
    function zeroPadStringIfOddLength(input) {
      input = input || "";
      if (input.length % 2 == 1) {
        return "0" + input;
      }
      return input;
    }
    exports2.zeroPadStringIfOddLength = zeroPadStringIfOddLength;
  }
});

// node_modules/@multiversx/sdk-network-providers/out/constants.js
var require_constants3 = __commonJS({
  "node_modules/@multiversx/sdk-network-providers/out/constants.js"(exports2) {
    "use strict";
    init_shim();
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EsdtContractAddress = exports2.MaxUint64AsBigNumber = void 0;
    var bignumber_js_1 = __importDefault2(require_bignumber2());
    var primitives_1 = require_primitives();
    exports2.MaxUint64AsBigNumber = new bignumber_js_1.default("18446744073709551615");
    exports2.EsdtContractAddress = new primitives_1.Address("erd1qqqqqqqqqqqqqqqpqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqzllls8a5w6u");
  }
});

// node_modules/@multiversx/sdk-network-providers/out/contractQueryResponse.js
var require_contractQueryResponse = __commonJS({
  "node_modules/@multiversx/sdk-network-providers/out/contractQueryResponse.js"(exports2) {
    "use strict";
    init_shim();
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ContractQueryResponse = void 0;
    var bignumber_js_1 = __importDefault2(require_bignumber2());
    var constants_1 = require_constants3();
    var ContractQueryResponse3 = class _ContractQueryResponse {
      constructor(init) {
        this.returnData = (init === null || init === void 0 ? void 0 : init.returnData) || [];
        this.returnCode = (init === null || init === void 0 ? void 0 : init.returnCode) || "";
        this.returnMessage = (init === null || init === void 0 ? void 0 : init.returnMessage) || "";
        this.gasUsed = (init === null || init === void 0 ? void 0 : init.gasUsed) || 0;
      }
      /**
       * Constructs a QueryResponse object from a HTTP response (as returned by the provider).
       */
      static fromHttpResponse(payload) {
        let returnData = payload["returnData"] || payload["ReturnData"];
        let returnCode = payload["returnCode"] || payload["ReturnCode"];
        let returnMessage = payload["returnMessage"] || payload["ReturnMessage"];
        let gasRemaining = new bignumber_js_1.default(payload["gasRemaining"] || payload["GasRemaining"] || 0);
        let gasUsed = constants_1.MaxUint64AsBigNumber.minus(gasRemaining).toNumber();
        return new _ContractQueryResponse({
          returnData,
          returnCode,
          returnMessage,
          gasUsed
        });
      }
      getReturnDataParts() {
        return this.returnData.map((item) => import_buffer.Buffer.from(item || "", "base64"));
      }
      /**
       * Converts the object to a pretty, plain JavaScript object.
       */
      toJSON() {
        return {
          returnData: this.returnData,
          returnCode: this.returnCode,
          returnMessage: this.returnMessage,
          gasUsed: this.gasUsed.valueOf()
        };
      }
    };
    exports2.ContractQueryResponse = ContractQueryResponse3;
  }
});

// node_modules/@multiversx/sdk-extension-provider/out/errors.js
var require_errors2 = __commonJS({
  "node_modules/@multiversx/sdk-extension-provider/out/errors.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ErrAccountNotConnected = exports2.ErrCannotSignSingleTransaction = exports2.Err = void 0;
    var Err = class extends Error {
      constructor(message, inner) {
        super(message);
        this.inner = void 0;
        this.inner = inner;
      }
    };
    exports2.Err = Err;
    var ErrCannotSignSingleTransaction = class extends Err {
      constructor() {
        super("Cannot sign single transaction.");
      }
    };
    exports2.ErrCannotSignSingleTransaction = ErrCannotSignSingleTransaction;
    var ErrAccountNotConnected = class extends Err {
      constructor() {
        super("Account is not connected.");
      }
    };
    exports2.ErrAccountNotConnected = ErrAccountNotConnected;
  }
});

// node_modules/@multiversx/sdk-extension-provider/out/operation.js
var require_operation = __commonJS({
  "node_modules/@multiversx/sdk-extension-provider/out/operation.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Operation = void 0;
    var Operation;
    (function(Operation2) {
      Operation2["Connect"] = "connect";
      Operation2["Logout"] = "logout";
      Operation2["SignTransactions"] = "signTransactions";
      Operation2["SignMessage"] = "signMessage";
      Operation2["CancelAction"] = "cancelAction";
    })(Operation = exports2.Operation || (exports2.Operation = {}));
  }
});

// node_modules/@multiversx/sdk-extension-provider/out/extensionProvider.js
var require_extensionProvider = __commonJS({
  "node_modules/@multiversx/sdk-extension-provider/out/extensionProvider.js"(exports2) {
    "use strict";
    init_shim();
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExtensionProvider = void 0;
    var transaction_1 = require_transaction();
    var errors_1 = require_errors2();
    var operation_1 = require_operation();
    var ExtensionProvider3 = class _ExtensionProvider {
      constructor() {
        this.account = { address: "" };
        this.initialized = false;
        if (_ExtensionProvider._instance) {
          throw new Error("Error: Instantiation failed: Use ExtensionProvider.getInstance() instead of new.");
        }
        _ExtensionProvider._instance = this;
      }
      static getInstance() {
        return _ExtensionProvider._instance;
      }
      setAddress(address) {
        this.account.address = address;
        return _ExtensionProvider._instance;
      }
      init() {
        return __awaiter2(this, void 0, void 0, function* () {
          if (window && window.elrondWallet) {
            this.initialized = true;
          }
          return this.initialized;
        });
      }
      login(options = {}) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (!this.initialized) {
            throw new Error("Extension provider is not initialised, call init() first");
          }
          const { token } = options;
          const data = token ? token : "";
          yield this.startBgrMsgChannel(operation_1.Operation.Connect, data);
          return this.account.address;
        });
      }
      logout() {
        return __awaiter2(this, void 0, void 0, function* () {
          if (!this.initialized) {
            throw new Error("Extension provider is not initialised, call init() first");
          }
          try {
            yield this.startBgrMsgChannel(operation_1.Operation.Logout, this.account.address);
            this.disconnect();
          } catch (error) {
            console.warn("Extension origin url is already cleared!", error);
          }
          return true;
        });
      }
      disconnect() {
        this.account = { address: "" };
      }
      getAddress() {
        return __awaiter2(this, void 0, void 0, function* () {
          if (!this.initialized) {
            throw new Error("Extension provider is not initialised, call init() first");
          }
          return this.account ? this.account.address : "";
        });
      }
      isInitialized() {
        return this.initialized;
      }
      // TODO: In V3, this will not be an async function anymore.
      isConnected() {
        return __awaiter2(this, void 0, void 0, function* () {
          return Boolean(this.account.address);
        });
      }
      signTransaction(transaction) {
        return __awaiter2(this, void 0, void 0, function* () {
          this.ensureConnected();
          const signedTransactions = yield this.signTransactions([transaction]);
          if (signedTransactions.length != 1) {
            throw new errors_1.ErrCannotSignSingleTransaction();
          }
          return signedTransactions[0];
        });
      }
      ensureConnected() {
        if (!this.account.address) {
          throw new errors_1.ErrAccountNotConnected();
        }
      }
      signTransactions(transactions) {
        return __awaiter2(this, void 0, void 0, function* () {
          this.ensureConnected();
          const extensionResponse = yield this.startBgrMsgChannel(operation_1.Operation.SignTransactions, {
            from: this.account.address,
            transactions: transactions.map((transaction) => transaction.toPlainObject())
          });
          try {
            const transactionsResponse = extensionResponse.map((transaction) => transaction_1.Transaction.fromPlainObject(transaction));
            return transactionsResponse;
          } catch (error) {
            throw new Error(`Transaction canceled: ${error.message}.`);
          }
        });
      }
      signMessage(message) {
        return __awaiter2(this, void 0, void 0, function* () {
          this.ensureConnected();
          const data = {
            account: this.account.address,
            message: message.message.toString()
          };
          const extensionResponse = yield this.startBgrMsgChannel(operation_1.Operation.SignMessage, data);
          const signatureHex = extensionResponse.signature;
          const signature = import_buffer.Buffer.from(signatureHex, "hex");
          message.applySignature(signature);
          return message;
        });
      }
      cancelAction() {
        return this.startBgrMsgChannel(operation_1.Operation.CancelAction, {});
      }
      startBgrMsgChannel(operation, connectData) {
        return new Promise((resolve) => {
          window.postMessage({
            target: "erdw-inpage",
            type: operation,
            data: connectData
          }, window.origin);
          const eventHandler = (event) => {
            if (event.isTrusted && event.data.target === "erdw-contentScript") {
              if (event.data.type === "connectResponse") {
                if (event.data.data && Boolean(event.data.data.address)) {
                  this.account = event.data.data;
                }
                window.removeEventListener("message", eventHandler);
                resolve(event.data.data);
              } else {
                window.removeEventListener("message", eventHandler);
                resolve(event.data.data);
              }
            }
          };
          window.addEventListener("message", eventHandler, false);
        });
      }
    };
    exports2.ExtensionProvider = ExtensionProvider3;
    ExtensionProvider3._instance = new ExtensionProvider3();
  }
});

// node_modules/destr/dist/index.mjs
function jsonParseTransform(key, value) {
  if (key === "__proto__" || key === "constructor" && value && typeof value === "object" && "prototype" in value) {
    warnKeyDropped(key);
    return;
  }
  return value;
}
function warnKeyDropped(key) {
  console.warn(`[destr] Dropping "${key}" key to prevent prototype pollution.`);
}
function destr(value, options = {}) {
  if (typeof value !== "string") {
    return value;
  }
  const _value = value.trim();
  if (
    // eslint-disable-next-line unicorn/prefer-at
    value[0] === '"' && value.endsWith('"') && !value.includes("\\")
  ) {
    return _value.slice(1, -1);
  }
  if (_value.length <= 9) {
    const _lval = _value.toLowerCase();
    if (_lval === "true") {
      return true;
    }
    if (_lval === "false") {
      return false;
    }
    if (_lval === "undefined") {
      return void 0;
    }
    if (_lval === "null") {
      return null;
    }
    if (_lval === "nan") {
      return Number.NaN;
    }
    if (_lval === "infinity") {
      return Number.POSITIVE_INFINITY;
    }
    if (_lval === "-infinity") {
      return Number.NEGATIVE_INFINITY;
    }
  }
  if (!JsonSigRx.test(value)) {
    if (options.strict) {
      throw new SyntaxError("[destr] Invalid JSON");
    }
    return value;
  }
  try {
    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
      if (options.strict) {
        throw new Error("[destr] Possible prototype pollution");
      }
      return JSON.parse(value, jsonParseTransform);
    }
    return JSON.parse(value);
  } catch (error) {
    if (options.strict) {
      throw error;
    }
    return value;
  }
}
var suspectProtoRx, suspectConstructorRx, JsonSigRx;
var init_dist = __esm({
  "node_modules/destr/dist/index.mjs"() {
    init_shim();
    suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
    suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
    JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
  }
});

// node_modules/unstorage/dist/shared/unstorage.8581f561.mjs
function wrapToPromise(value) {
  if (!value || typeof value.then !== "function") {
    return Promise.resolve(value);
  }
  return value;
}
function asyncCall(function_, ...arguments_) {
  try {
    return wrapToPromise(function_(...arguments_));
  } catch (error) {
    return Promise.reject(error);
  }
}
function isPrimitive(value) {
  const type = typeof value;
  return value === null || type !== "object" && type !== "function";
}
function isPureObject(value) {
  const proto = Object.getPrototypeOf(value);
  return !proto || proto.isPrototypeOf(Object);
}
function stringify(value) {
  if (isPrimitive(value)) {
    return String(value);
  }
  if (isPureObject(value) || Array.isArray(value)) {
    return JSON.stringify(value);
  }
  if (typeof value.toJSON === "function") {
    return stringify(value.toJSON());
  }
  throw new Error("[unstorage] Cannot stringify value!");
}
function checkBufferSupport() {
  if (typeof import_buffer.Buffer === void 0) {
    throw new TypeError("[unstorage] Buffer is not supported!");
  }
}
function serializeRaw(value) {
  if (typeof value === "string") {
    return value;
  }
  checkBufferSupport();
  const base642 = import_buffer.Buffer.from(value).toString("base64");
  return BASE64_PREFIX + base642;
}
function deserializeRaw(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (!value.startsWith(BASE64_PREFIX)) {
    return value;
  }
  checkBufferSupport();
  return import_buffer.Buffer.from(value.slice(BASE64_PREFIX.length), "base64");
}
function normalizeKey(key) {
  if (!key) {
    return "";
  }
  return key.split("?")[0].replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "");
}
function joinKeys(...keys2) {
  return normalizeKey(keys2.join(":"));
}
function normalizeBaseKey(base3) {
  base3 = normalizeKey(base3);
  return base3 ? base3 + ":" : "";
}
var BASE64_PREFIX;
var init_unstorage_8581f561 = __esm({
  "node_modules/unstorage/dist/shared/unstorage.8581f561.mjs"() {
    init_shim();
    BASE64_PREFIX = "base64:";
  }
});

// node_modules/unstorage/dist/index.mjs
function defineDriver(factory) {
  return factory;
}
function createStorage(options = {}) {
  const context = {
    mounts: { "": options.driver || memory() },
    mountpoints: [""],
    watching: false,
    watchListeners: [],
    unwatch: {}
  };
  const getMount = (key) => {
    for (const base3 of context.mountpoints) {
      if (key.startsWith(base3)) {
        return {
          base: base3,
          relativeKey: key.slice(base3.length),
          driver: context.mounts[base3]
        };
      }
    }
    return {
      base: "",
      relativeKey: key,
      driver: context.mounts[""]
    };
  };
  const getMounts = (base3, includeParent) => {
    return context.mountpoints.filter(
      (mountpoint) => mountpoint.startsWith(base3) || includeParent && base3.startsWith(mountpoint)
    ).map((mountpoint) => ({
      relativeBase: base3.length > mountpoint.length ? base3.slice(mountpoint.length) : void 0,
      mountpoint,
      driver: context.mounts[mountpoint]
    }));
  };
  const onChange = (event, key) => {
    if (!context.watching) {
      return;
    }
    key = normalizeKey(key);
    for (const listener of context.watchListeners) {
      listener(event, key);
    }
  };
  const startWatch = async () => {
    if (context.watching) {
      return;
    }
    context.watching = true;
    for (const mountpoint in context.mounts) {
      context.unwatch[mountpoint] = await watch(
        context.mounts[mountpoint],
        onChange,
        mountpoint
      );
    }
  };
  const stopWatch = async () => {
    if (!context.watching) {
      return;
    }
    for (const mountpoint in context.unwatch) {
      await context.unwatch[mountpoint]();
    }
    context.unwatch = {};
    context.watching = false;
  };
  const runBatch = (items, commonOptions, cb) => {
    const batches = /* @__PURE__ */ new Map();
    const getBatch = (mount) => {
      let batch = batches.get(mount.base);
      if (!batch) {
        batch = {
          driver: mount.driver,
          base: mount.base,
          items: []
        };
        batches.set(mount.base, batch);
      }
      return batch;
    };
    for (const item of items) {
      const isStringItem = typeof item === "string";
      const key = normalizeKey(isStringItem ? item : item.key);
      const value = isStringItem ? void 0 : item.value;
      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };
      const mount = getMount(key);
      getBatch(mount).items.push({
        key,
        value,
        relativeKey: mount.relativeKey,
        options: options2
      });
    }
    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(
      (r) => r.flat()
    );
  };
  const storage = {
    // Item
    hasItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.hasItem, relativeKey, opts);
    },
    getItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => destr(value)
      );
    },
    getItems(items, commonOptions) {
      return runBatch(items, commonOptions, (batch) => {
        if (batch.driver.getItems) {
          return asyncCall(
            batch.driver.getItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              options: item.options
            })),
            commonOptions
          ).then(
            (r) => r.map((item) => ({
              key: joinKeys(batch.base, item.key),
              value: destr(item.value)
            }))
          );
        }
        return Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.getItem,
              item.relativeKey,
              item.options
            ).then((value) => ({
              key: item.key,
              value: destr(value)
            }));
          })
        );
      });
    },
    getItemRaw(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.getItemRaw) {
        return asyncCall(driver.getItemRaw, relativeKey, opts);
      }
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => deserializeRaw(value)
      );
    },
    async setItem(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.setItem) {
        return;
      }
      await asyncCall(driver.setItem, relativeKey, stringify(value), opts);
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async setItems(items, commonOptions) {
      await runBatch(items, commonOptions, async (batch) => {
        if (batch.driver.setItems) {
          return asyncCall(
            batch.driver.setItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              value: stringify(item.value),
              options: item.options
            })),
            commonOptions
          );
        }
        if (!batch.driver.setItem) {
          return;
        }
        await Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.setItem,
              item.relativeKey,
              stringify(item.value),
              item.options
            );
          })
        );
      });
    },
    async setItemRaw(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key, opts);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.setItemRaw) {
        await asyncCall(driver.setItemRaw, relativeKey, value, opts);
      } else if (driver.setItem) {
        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);
      } else {
        return;
      }
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async removeItem(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { removeMeta: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.removeItem) {
        return;
      }
      await asyncCall(driver.removeItem, relativeKey, opts);
      if (opts.removeMeta || opts.removeMata) {
        await asyncCall(driver.removeItem, relativeKey + "$", opts);
      }
      if (!driver.watch) {
        onChange("remove", key);
      }
    },
    // Meta
    async getMeta(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { nativeOnly: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      const meta = /* @__PURE__ */ Object.create(null);
      if (driver.getMeta) {
        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));
      }
      if (!opts.nativeOnly) {
        const value = await asyncCall(
          driver.getItem,
          relativeKey + "$",
          opts
        ).then((value_) => destr(value_));
        if (value && typeof value === "object") {
          if (typeof value.atime === "string") {
            value.atime = new Date(value.atime);
          }
          if (typeof value.mtime === "string") {
            value.mtime = new Date(value.mtime);
          }
          Object.assign(meta, value);
        }
      }
      return meta;
    },
    setMeta(key, value, opts = {}) {
      return this.setItem(key + "$", value, opts);
    },
    removeMeta(key, opts = {}) {
      return this.removeItem(key + "$", opts);
    },
    // Keys
    async getKeys(base3, opts = {}) {
      base3 = normalizeBaseKey(base3);
      const mounts = getMounts(base3, true);
      let maskedMounts = [];
      const allKeys = [];
      for (const mount of mounts) {
        const rawKeys = await asyncCall(
          mount.driver.getKeys,
          mount.relativeBase,
          opts
        );
        const keys2 = rawKeys.map((key) => mount.mountpoint + normalizeKey(key)).filter((key) => !maskedMounts.some((p3) => key.startsWith(p3)));
        allKeys.push(...keys2);
        maskedMounts = [
          mount.mountpoint,
          ...maskedMounts.filter((p3) => !p3.startsWith(mount.mountpoint))
        ];
      }
      return base3 ? allKeys.filter((key) => key.startsWith(base3) && !key.endsWith("$")) : allKeys.filter((key) => !key.endsWith("$"));
    },
    // Utils
    async clear(base3, opts = {}) {
      base3 = normalizeBaseKey(base3);
      await Promise.all(
        getMounts(base3, false).map(async (m3) => {
          if (m3.driver.clear) {
            return asyncCall(m3.driver.clear, m3.relativeBase, opts);
          }
          if (m3.driver.removeItem) {
            const keys2 = await m3.driver.getKeys(m3.relativeBase || "", opts);
            return Promise.all(
              keys2.map((key) => m3.driver.removeItem(key, opts))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(context.mounts).map((driver) => dispose(driver))
      );
    },
    async watch(callback) {
      await startWatch();
      context.watchListeners.push(callback);
      return async () => {
        context.watchListeners = context.watchListeners.filter(
          (listener) => listener !== callback
        );
        if (context.watchListeners.length === 0) {
          await stopWatch();
        }
      };
    },
    async unwatch() {
      context.watchListeners = [];
      await stopWatch();
    },
    // Mount
    mount(base3, driver) {
      base3 = normalizeBaseKey(base3);
      if (base3 && context.mounts[base3]) {
        throw new Error(`already mounted at ${base3}`);
      }
      if (base3) {
        context.mountpoints.push(base3);
        context.mountpoints.sort((a3, b4) => b4.length - a3.length);
      }
      context.mounts[base3] = driver;
      if (context.watching) {
        Promise.resolve(watch(driver, onChange, base3)).then((unwatcher) => {
          context.unwatch[base3] = unwatcher;
        }).catch(console.error);
      }
      return storage;
    },
    async unmount(base3, _dispose = true) {
      base3 = normalizeBaseKey(base3);
      if (!base3 || !context.mounts[base3]) {
        return;
      }
      if (context.watching && base3 in context.unwatch) {
        context.unwatch[base3]();
        delete context.unwatch[base3];
      }
      if (_dispose) {
        await dispose(context.mounts[base3]);
      }
      context.mountpoints = context.mountpoints.filter((key) => key !== base3);
      delete context.mounts[base3];
    },
    getMount(key = "") {
      key = normalizeKey(key) + ":";
      const m3 = getMount(key);
      return {
        driver: m3.driver,
        base: m3.base
      };
    },
    getMounts(base3 = "", opts = {}) {
      base3 = normalizeKey(base3);
      const mounts = getMounts(base3, opts.parents);
      return mounts.map((m3) => ({
        driver: m3.driver,
        base: m3.mountpoint
      }));
    }
  };
  return storage;
}
function watch(driver, onChange, base3) {
  return driver.watch ? driver.watch((event, key) => onChange(event, base3 + key)) : () => {
  };
}
async function dispose(driver) {
  if (typeof driver.dispose === "function") {
    await asyncCall(driver.dispose);
  }
}
var DRIVER_NAME, memory;
var init_dist2 = __esm({
  "node_modules/unstorage/dist/index.mjs"() {
    init_shim();
    init_dist();
    init_unstorage_8581f561();
    DRIVER_NAME = "memory";
    memory = defineDriver(() => {
      const data = /* @__PURE__ */ new Map();
      return {
        name: DRIVER_NAME,
        options: {},
        hasItem(key) {
          return data.has(key);
        },
        getItem(key) {
          return data.get(key) ?? null;
        },
        getItemRaw(key) {
          return data.get(key) ?? null;
        },
        setItem(key, value) {
          data.set(key, value);
        },
        setItemRaw(key, value) {
          data.set(key, value);
        },
        removeItem(key) {
          data.delete(key);
        },
        getKeys() {
          return Array.from(data.keys());
        },
        clear() {
          data.clear();
        },
        dispose() {
          data.clear();
        }
      };
    });
  }
});

// node_modules/idb-keyval/dist/index.js
function promisifyRequest(request) {
  return new Promise((resolve, reject) => {
    request.oncomplete = request.onsuccess = () => resolve(request.result);
    request.onabort = request.onerror = () => reject(request.error);
  });
}
function createStore(dbName, storeName) {
  const request = indexedDB.open(dbName);
  request.onupgradeneeded = () => request.result.createObjectStore(storeName);
  const dbp = promisifyRequest(request);
  return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
function defaultGetStore() {
  if (!defaultGetStoreFunc) {
    defaultGetStoreFunc = createStore("keyval-store", "keyval");
  }
  return defaultGetStoreFunc;
}
function get(key, customStore = defaultGetStore()) {
  return customStore("readonly", (store) => promisifyRequest(store.get(key)));
}
function set(key, value, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.put(value, key);
    return promisifyRequest(store.transaction);
  });
}
function del(key, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.delete(key);
    return promisifyRequest(store.transaction);
  });
}
function clear(customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.clear();
    return promisifyRequest(store.transaction);
  });
}
function eachCursor(store, callback) {
  store.openCursor().onsuccess = function() {
    if (!this.result)
      return;
    callback(this.result);
    this.result.continue();
  };
  return promisifyRequest(store.transaction);
}
function keys(customStore = defaultGetStore()) {
  return customStore("readonly", (store) => {
    if (store.getAllKeys) {
      return promisifyRequest(store.getAllKeys());
    }
    const items = [];
    return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);
  });
}
var defaultGetStoreFunc;
var init_dist3 = __esm({
  "node_modules/idb-keyval/dist/index.js"() {
    init_shim();
  }
});

// node_modules/@walletconnect/safe-json/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  safeJsonParse: () => safeJsonParse,
  safeJsonStringify: () => safeJsonStringify
});
function safeJsonParse(value) {
  if (typeof value !== "string") {
    throw new Error(`Cannot safe json parse value of type ${typeof value}`);
  }
  try {
    return JSONParse(value);
  } catch (_a) {
    return value;
  }
}
function safeJsonStringify(value) {
  return typeof value === "string" ? value : JSONStringify(value) || "";
}
var JSONStringify, JSONParse;
var init_esm = __esm({
  "node_modules/@walletconnect/safe-json/dist/esm/index.js"() {
    init_shim();
    JSONStringify = (data) => JSON.stringify(data, (_4, value) => typeof value === "bigint" ? value.toString() + "n" : value);
    JSONParse = (json) => {
      const numbersBiggerThanMaxInt = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g;
      const serializedData = json.replace(numbersBiggerThanMaxInt, '$1"$2n"$3');
      return JSON.parse(serializedData, (_4, value) => {
        const isCustomFormatBigInt = typeof value === "string" && value.match(/^\d+n$/);
        if (isCustomFormatBigInt)
          return BigInt(value.substring(0, value.length - 1));
        return value;
      });
    };
  }
});

// node_modules/@walletconnect/keyvaluestorage/dist/index.es.js
var index_es_exports = {};
__export(index_es_exports, {
  KeyValueStorage: () => h,
  default: () => h
});
function k(i2) {
  var t;
  return [i2[0], safeJsonParse((t = i2[1]) != null ? t : "")];
}
var x, z, D, E, _, l, c, K, N, y, O, j, h;
var init_index_es = __esm({
  "node_modules/@walletconnect/keyvaluestorage/dist/index.es.js"() {
    init_shim();
    init_dist2();
    init_dist3();
    init_esm();
    x = "idb-keyval";
    z = (i2 = {}) => {
      const t = i2.base && i2.base.length > 0 ? `${i2.base}:` : "", e2 = (s2) => t + s2;
      let n3;
      return i2.dbName && i2.storeName && (n3 = createStore(i2.dbName, i2.storeName)), { name: x, options: i2, async hasItem(s2) {
        return !(typeof await get(e2(s2), n3) > "u");
      }, async getItem(s2) {
        return await get(e2(s2), n3) ?? null;
      }, setItem(s2, a3) {
        return set(e2(s2), a3, n3);
      }, removeItem(s2) {
        return del(e2(s2), n3);
      }, getKeys() {
        return keys(n3);
      }, clear() {
        return clear(n3);
      } };
    };
    D = "WALLET_CONNECT_V2_INDEXED_DB";
    E = "keyvaluestorage";
    _ = class {
      constructor() {
        this.indexedDb = createStorage({ driver: z({ dbName: D, storeName: E }) });
      }
      async getKeys() {
        return this.indexedDb.getKeys();
      }
      async getEntries() {
        return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((t) => [t.key, t.value]);
      }
      async getItem(t) {
        const e2 = await this.indexedDb.getItem(t);
        if (e2 !== null)
          return e2;
      }
      async setItem(t, e2) {
        await this.indexedDb.setItem(t, safeJsonStringify(e2));
      }
      async removeItem(t) {
        await this.indexedDb.removeItem(t);
      }
    };
    l = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
    c = { exports: {} };
    (function() {
      let i2;
      function t() {
      }
      i2 = t, i2.prototype.getItem = function(e2) {
        return this.hasOwnProperty(e2) ? String(this[e2]) : null;
      }, i2.prototype.setItem = function(e2, n3) {
        this[e2] = String(n3);
      }, i2.prototype.removeItem = function(e2) {
        delete this[e2];
      }, i2.prototype.clear = function() {
        const e2 = this;
        Object.keys(e2).forEach(function(n3) {
          e2[n3] = void 0, delete e2[n3];
        });
      }, i2.prototype.key = function(e2) {
        return e2 = e2 || 0, Object.keys(this)[e2];
      }, i2.prototype.__defineGetter__("length", function() {
        return Object.keys(this).length;
      }), typeof l < "u" && l.localStorage ? c.exports = l.localStorage : typeof window < "u" && window.localStorage ? c.exports = window.localStorage : c.exports = new t();
    })();
    K = class {
      constructor() {
        this.localStorage = c.exports;
      }
      async getKeys() {
        return Object.keys(this.localStorage);
      }
      async getEntries() {
        return Object.entries(this.localStorage).map(k);
      }
      async getItem(t) {
        const e2 = this.localStorage.getItem(t);
        if (e2 !== null)
          return safeJsonParse(e2);
      }
      async setItem(t, e2) {
        this.localStorage.setItem(t, safeJsonStringify(e2));
      }
      async removeItem(t) {
        this.localStorage.removeItem(t);
      }
    };
    N = "wc_storage_version";
    y = 1;
    O = async (i2, t, e2) => {
      const n3 = N, s2 = await t.getItem(n3);
      if (s2 && s2 >= y) {
        e2(t);
        return;
      }
      const a3 = await i2.getKeys();
      if (!a3.length) {
        e2(t);
        return;
      }
      const m3 = [];
      for (; a3.length; ) {
        const r = a3.shift();
        if (!r)
          continue;
        const o2 = r.toLowerCase();
        if (o2.includes("wc@") || o2.includes("walletconnect") || o2.includes("wc_") || o2.includes("wallet_connect")) {
          const f4 = await i2.getItem(r);
          await t.setItem(r, f4), m3.push(r);
        }
      }
      await t.setItem(n3, y), e2(t), j(i2, m3);
    };
    j = async (i2, t) => {
      t.length && t.forEach(async (e2) => {
        await i2.removeItem(e2);
      });
    };
    h = class {
      constructor() {
        this.initialized = false, this.setInitialized = (e2) => {
          this.storage = e2, this.initialized = true;
        };
        const t = new K();
        this.storage = t;
        try {
          const e2 = new _();
          O(t, e2, this.setInitialized);
        } catch {
          this.initialized = true;
        }
      }
      async getKeys() {
        return await this.initialize(), this.storage.getKeys();
      }
      async getEntries() {
        return await this.initialize(), this.storage.getEntries();
      }
      async getItem(t) {
        return await this.initialize(), this.storage.getItem(t);
      }
      async setItem(t, e2) {
        return await this.initialize(), this.storage.setItem(t, e2);
      }
      async removeItem(t) {
        return await this.initialize(), this.storage.removeItem(t);
      }
      async initialize() {
        this.initialized || await new Promise((t) => {
          const e2 = setInterval(() => {
            this.initialized && (clearInterval(e2), t());
          }, 20);
        });
      }
    };
  }
});

// node_modules/tslib/tslib.es6.js
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __read: () => __read,
  __rest: () => __rest,
  __spread: () => __spread,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values
});
function __extends(d3, b4) {
  extendStatics(d3, b4);
  function __() {
    this.constructor = d3;
  }
  d3.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
}
function __rest(s2, e2) {
  var t = {};
  for (var p3 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p3) && e2.indexOf(p3) < 0)
      t[p3] = s2[p3];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s2); i2 < p3.length; i2++) {
      if (e2.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i2]))
        t[p3[i2]] = s2[p3[i2]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c4 = arguments.length, r = c4 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d3 = decorators[i2])
        r = (c4 < 3 ? d3(r) : c4 > 3 ? d3(target, key, r) : d3(target, key)) || r;
  return c4 > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _4 = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f4, y4, t, g3;
  return g3 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g3[Symbol.iterator] = function() {
    return this;
  }), g3;
  function verb(n3) {
    return function(v2) {
      return step([n3, v2]);
    };
  }
  function step(op) {
    if (f4)
      throw new TypeError("Generator is already executing.");
    while (_4)
      try {
        if (f4 = 1, y4 && (t = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t = y4["return"]) && t.call(y4), 0) : y4.next) && !(t = t.call(y4, op[1])).done)
          return t;
        if (y4 = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _4.label++;
            return { value: op[1], done: false };
          case 5:
            _4.label++;
            y4 = op[1];
            op = [0];
            continue;
          case 7:
            op = _4.ops.pop();
            _4.trys.pop();
            continue;
          default:
            if (!(t = _4.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _4 = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _4.label = op[1];
              break;
            }
            if (op[0] === 6 && _4.label < t[1]) {
              _4.label = t[1];
              t = op;
              break;
            }
            if (t && _4.label < t[2]) {
              _4.label = t[2];
              _4.ops.push(op);
              break;
            }
            if (t[2])
              _4.ops.pop();
            _4.trys.pop();
            continue;
        }
        op = body.call(thisArg, _4);
      } catch (e2) {
        op = [6, e2];
        y4 = 0;
      } finally {
        f4 = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __createBinding(o2, m3, k4, k22) {
  if (k22 === void 0)
    k22 = k4;
  o2[k22] = m3[k4];
}
function __exportStar(m3, exports2) {
  for (var p3 in m3)
    if (p3 !== "default" && !exports2.hasOwnProperty(p3))
      exports2[p3] = m3[p3];
}
function __values(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m3 = s2 && o2[s2], i2 = 0;
  if (m3)
    return m3.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i2 >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o2, n3) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3)
    return o2;
  var i2 = m3.call(o2), r, ar = [], e2;
  try {
    while ((n3 === void 0 || n3-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r && !r.done && (m3 = i2["return"]))
        m3.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
    ar = ar.concat(__read(arguments[i2]));
  return ar;
}
function __spreadArrays() {
  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
    s2 += arguments[i2].length;
  for (var r = Array(s2), k4 = 0, i2 = 0; i2 < il; i2++)
    for (var a3 = arguments[i2], j2 = 0, jl = a3.length; j2 < jl; j2++, k4++)
      r[k4] = a3[j2];
  return r;
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g3 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
  return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function verb(n3) {
    if (g3[n3])
      i2[n3] = function(v2) {
        return new Promise(function(a3, b4) {
          q2.push([n3, v2, a3, b4]) > 1 || resume(n3, v2);
        });
      };
  }
  function resume(n3, v2) {
    try {
      step(g3[n3](v2));
    } catch (e2) {
      settle(q2[0][3], e2);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q2[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f4, v2) {
    if (f4(v2), q2.shift(), q2.length)
      resume(q2[0][0], q2[0][1]);
  }
}
function __asyncDelegator(o2) {
  var i2, p3;
  return i2 = {}, verb("next"), verb("throw", function(e2) {
    throw e2;
  }), verb("return"), i2[Symbol.iterator] = function() {
    return this;
  }, i2;
  function verb(n3, f4) {
    i2[n3] = o2[n3] ? function(v2) {
      return (p3 = !p3) ? { value: __await(o2[n3](v2)), done: n3 === "return" } : f4 ? f4(v2) : v2;
    } : f4;
  }
}
function __asyncValues(o2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m3 = o2[Symbol.asyncIterator], i2;
  return m3 ? m3.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n3) {
    i2[n3] = o2[n3] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o2[n3](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d3, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d3 });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod2) {
  if (mod2 && mod2.__esModule)
    return mod2;
  var result = {};
  if (mod2 != null) {
    for (var k4 in mod2)
      if (Object.hasOwnProperty.call(mod2, k4))
        result[k4] = mod2[k4];
  }
  result.default = mod2;
  return result;
}
function __importDefault(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
var extendStatics, __assign;
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.js"() {
    init_shim();
    extendStatics = function(d3, b4) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b5) {
        d4.__proto__ = b5;
      } || function(d4, b5) {
        for (var p3 in b5)
          if (b5.hasOwnProperty(p3))
            d4[p3] = b5[p3];
      };
      return extendStatics(d3, b4);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s2, i2 = 1, n3 = arguments.length; i2 < n3; i2++) {
          s2 = arguments[i2];
          for (var p3 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p3))
              t[p3] = s2[p3];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
  }
});

// node_modules/@walletconnect/time/dist/cjs/utils/delay.js
var require_delay = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/utils/delay.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.delay = void 0;
    function delay(timeout) {
      return new Promise((resolve) => {
        setTimeout(() => {
          resolve(true);
        }, timeout);
      });
    }
    exports2.delay = delay;
  }
});

// node_modules/@walletconnect/time/dist/cjs/constants/misc.js
var require_misc = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/constants/misc.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ONE_THOUSAND = exports2.ONE_HUNDRED = void 0;
    exports2.ONE_HUNDRED = 100;
    exports2.ONE_THOUSAND = 1e3;
  }
});

// node_modules/@walletconnect/time/dist/cjs/constants/time.js
var require_time = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/constants/time.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ONE_YEAR = exports2.FOUR_WEEKS = exports2.THREE_WEEKS = exports2.TWO_WEEKS = exports2.ONE_WEEK = exports2.THIRTY_DAYS = exports2.SEVEN_DAYS = exports2.FIVE_DAYS = exports2.THREE_DAYS = exports2.ONE_DAY = exports2.TWENTY_FOUR_HOURS = exports2.TWELVE_HOURS = exports2.SIX_HOURS = exports2.THREE_HOURS = exports2.ONE_HOUR = exports2.SIXTY_MINUTES = exports2.THIRTY_MINUTES = exports2.TEN_MINUTES = exports2.FIVE_MINUTES = exports2.ONE_MINUTE = exports2.SIXTY_SECONDS = exports2.THIRTY_SECONDS = exports2.TEN_SECONDS = exports2.FIVE_SECONDS = exports2.ONE_SECOND = void 0;
    exports2.ONE_SECOND = 1;
    exports2.FIVE_SECONDS = 5;
    exports2.TEN_SECONDS = 10;
    exports2.THIRTY_SECONDS = 30;
    exports2.SIXTY_SECONDS = 60;
    exports2.ONE_MINUTE = exports2.SIXTY_SECONDS;
    exports2.FIVE_MINUTES = exports2.ONE_MINUTE * 5;
    exports2.TEN_MINUTES = exports2.ONE_MINUTE * 10;
    exports2.THIRTY_MINUTES = exports2.ONE_MINUTE * 30;
    exports2.SIXTY_MINUTES = exports2.ONE_MINUTE * 60;
    exports2.ONE_HOUR = exports2.SIXTY_MINUTES;
    exports2.THREE_HOURS = exports2.ONE_HOUR * 3;
    exports2.SIX_HOURS = exports2.ONE_HOUR * 6;
    exports2.TWELVE_HOURS = exports2.ONE_HOUR * 12;
    exports2.TWENTY_FOUR_HOURS = exports2.ONE_HOUR * 24;
    exports2.ONE_DAY = exports2.TWENTY_FOUR_HOURS;
    exports2.THREE_DAYS = exports2.ONE_DAY * 3;
    exports2.FIVE_DAYS = exports2.ONE_DAY * 5;
    exports2.SEVEN_DAYS = exports2.ONE_DAY * 7;
    exports2.THIRTY_DAYS = exports2.ONE_DAY * 30;
    exports2.ONE_WEEK = exports2.SEVEN_DAYS;
    exports2.TWO_WEEKS = exports2.ONE_WEEK * 2;
    exports2.THREE_WEEKS = exports2.ONE_WEEK * 3;
    exports2.FOUR_WEEKS = exports2.ONE_WEEK * 4;
    exports2.ONE_YEAR = exports2.ONE_DAY * 365;
  }
});

// node_modules/@walletconnect/time/dist/cjs/constants/index.js
var require_constants4 = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/constants/index.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_misc(), exports2);
    tslib_1.__exportStar(require_time(), exports2);
  }
});

// node_modules/@walletconnect/time/dist/cjs/utils/convert.js
var require_convert = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/utils/convert.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromMiliseconds = exports2.toMiliseconds = void 0;
    var constants_1 = require_constants4();
    function toMiliseconds(seconds) {
      return seconds * constants_1.ONE_THOUSAND;
    }
    exports2.toMiliseconds = toMiliseconds;
    function fromMiliseconds2(miliseconds) {
      return Math.floor(miliseconds / constants_1.ONE_THOUSAND);
    }
    exports2.fromMiliseconds = fromMiliseconds2;
  }
});

// node_modules/@walletconnect/time/dist/cjs/utils/index.js
var require_utils3 = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/utils/index.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_delay(), exports2);
    tslib_1.__exportStar(require_convert(), exports2);
  }
});

// node_modules/@walletconnect/time/dist/cjs/watch.js
var require_watch = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/watch.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Watch = void 0;
    var Watch = class {
      constructor() {
        this.timestamps = /* @__PURE__ */ new Map();
      }
      start(label) {
        if (this.timestamps.has(label)) {
          throw new Error(`Watch already started for label: ${label}`);
        }
        this.timestamps.set(label, { started: Date.now() });
      }
      stop(label) {
        const timestamp = this.get(label);
        if (typeof timestamp.elapsed !== "undefined") {
          throw new Error(`Watch already stopped for label: ${label}`);
        }
        const elapsed = Date.now() - timestamp.started;
        this.timestamps.set(label, { started: timestamp.started, elapsed });
      }
      get(label) {
        const timestamp = this.timestamps.get(label);
        if (typeof timestamp === "undefined") {
          throw new Error(`No timestamp found for label: ${label}`);
        }
        return timestamp;
      }
      elapsed(label) {
        const timestamp = this.get(label);
        const elapsed = timestamp.elapsed || Date.now() - timestamp.started;
        return elapsed;
      }
    };
    exports2.Watch = Watch;
    exports2.default = Watch;
  }
});

// node_modules/@walletconnect/time/dist/cjs/types/watch.js
var require_watch2 = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/types/watch.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IWatch = void 0;
    var IWatch = class {
    };
    exports2.IWatch = IWatch;
  }
});

// node_modules/@walletconnect/time/dist/cjs/types/index.js
var require_types2 = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/types/index.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_watch2(), exports2);
  }
});

// node_modules/@walletconnect/time/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/index.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_utils3(), exports2);
    tslib_1.__exportStar(require_watch(), exports2);
    tslib_1.__exportStar(require_types2(), exports2);
    tslib_1.__exportStar(require_constants4(), exports2);
  }
});

// node_modules/@walletconnect/events/dist/esm/events.js
var IEvents;
var init_events = __esm({
  "node_modules/@walletconnect/events/dist/esm/events.js"() {
    init_shim();
    IEvents = class {
    };
  }
});

// node_modules/@walletconnect/events/dist/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  IEvents: () => IEvents
});
var init_esm2 = __esm({
  "node_modules/@walletconnect/events/dist/esm/index.js"() {
    init_shim();
    init_events();
  }
});

// node_modules/@walletconnect/heartbeat/dist/cjs/types/heartbeat.js
var require_heartbeat = __commonJS({
  "node_modules/@walletconnect/heartbeat/dist/cjs/types/heartbeat.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IHeartBeat = void 0;
    var events_1 = (init_esm2(), __toCommonJS(esm_exports2));
    var IHeartBeat = class extends events_1.IEvents {
      constructor(opts) {
        super();
      }
    };
    exports2.IHeartBeat = IHeartBeat;
  }
});

// node_modules/@walletconnect/heartbeat/dist/cjs/types/index.js
var require_types3 = __commonJS({
  "node_modules/@walletconnect/heartbeat/dist/cjs/types/index.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_heartbeat(), exports2);
  }
});

// node_modules/@walletconnect/heartbeat/dist/cjs/constants/heartbeat.js
var require_heartbeat2 = __commonJS({
  "node_modules/@walletconnect/heartbeat/dist/cjs/constants/heartbeat.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HEARTBEAT_EVENTS = exports2.HEARTBEAT_INTERVAL = void 0;
    var time_1 = require_cjs();
    exports2.HEARTBEAT_INTERVAL = time_1.FIVE_SECONDS;
    exports2.HEARTBEAT_EVENTS = {
      pulse: "heartbeat_pulse"
    };
  }
});

// node_modules/@walletconnect/heartbeat/dist/cjs/constants/index.js
var require_constants5 = __commonJS({
  "node_modules/@walletconnect/heartbeat/dist/cjs/constants/index.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_heartbeat2(), exports2);
  }
});

// node_modules/@walletconnect/heartbeat/dist/cjs/heartbeat.js
var require_heartbeat3 = __commonJS({
  "node_modules/@walletconnect/heartbeat/dist/cjs/heartbeat.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HeartBeat = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var events_1 = require_events();
    var time_1 = require_cjs();
    var types_1 = require_types3();
    var constants_1 = require_constants5();
    var HeartBeat = class _HeartBeat extends types_1.IHeartBeat {
      constructor(opts) {
        super(opts);
        this.events = new events_1.EventEmitter();
        this.interval = constants_1.HEARTBEAT_INTERVAL;
        this.interval = (opts === null || opts === void 0 ? void 0 : opts.interval) || constants_1.HEARTBEAT_INTERVAL;
      }
      static init(opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const heartbeat = new _HeartBeat(opts);
          yield heartbeat.init();
          return heartbeat;
        });
      }
      init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          yield this.initialize();
        });
      }
      stop() {
        clearInterval(this.intervalRef);
      }
      on(event, listener) {
        this.events.on(event, listener);
      }
      once(event, listener) {
        this.events.once(event, listener);
      }
      off(event, listener) {
        this.events.off(event, listener);
      }
      removeListener(event, listener) {
        this.events.removeListener(event, listener);
      }
      initialize() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          this.intervalRef = setInterval(() => this.pulse(), time_1.toMiliseconds(this.interval));
        });
      }
      pulse() {
        this.events.emit(constants_1.HEARTBEAT_EVENTS.pulse);
      }
    };
    exports2.HeartBeat = HeartBeat;
  }
});

// node_modules/@walletconnect/heartbeat/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@walletconnect/heartbeat/dist/cjs/index.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_heartbeat3(), exports2);
    tslib_1.__exportStar(require_types3(), exports2);
    tslib_1.__exportStar(require_constants5(), exports2);
  }
});

// node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS({
  "node_modules/quick-format-unescaped/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    function tryStringify(o2) {
      try {
        return JSON.stringify(o2);
      } catch (e2) {
        return '"[Circular]"';
      }
    }
    module2.exports = format;
    function format(f4, args, opts) {
      var ss = opts && opts.stringify || tryStringify;
      var offset = 1;
      if (typeof f4 === "object" && f4 !== null) {
        var len = args.length + offset;
        if (len === 1)
          return f4;
        var objects = new Array(len);
        objects[0] = ss(f4);
        for (var index = 1; index < len; index++) {
          objects[index] = ss(args[index]);
        }
        return objects.join(" ");
      }
      if (typeof f4 !== "string") {
        return f4;
      }
      var argLen = args.length;
      if (argLen === 0)
        return f4;
      var str = "";
      var a3 = 1 - offset;
      var lastPos = -1;
      var flen = f4 && f4.length || 0;
      for (var i2 = 0; i2 < flen; ) {
        if (f4.charCodeAt(i2) === 37 && i2 + 1 < flen) {
          lastPos = lastPos > -1 ? lastPos : 0;
          switch (f4.charCodeAt(i2 + 1)) {
            case 100:
            case 102:
              if (a3 >= argLen)
                break;
              if (args[a3] == null)
                break;
              if (lastPos < i2)
                str += f4.slice(lastPos, i2);
              str += Number(args[a3]);
              lastPos = i2 + 2;
              i2++;
              break;
            case 105:
              if (a3 >= argLen)
                break;
              if (args[a3] == null)
                break;
              if (lastPos < i2)
                str += f4.slice(lastPos, i2);
              str += Math.floor(Number(args[a3]));
              lastPos = i2 + 2;
              i2++;
              break;
            case 79:
            case 111:
            case 106:
              if (a3 >= argLen)
                break;
              if (args[a3] === void 0)
                break;
              if (lastPos < i2)
                str += f4.slice(lastPos, i2);
              var type = typeof args[a3];
              if (type === "string") {
                str += "'" + args[a3] + "'";
                lastPos = i2 + 2;
                i2++;
                break;
              }
              if (type === "function") {
                str += args[a3].name || "<anonymous>";
                lastPos = i2 + 2;
                i2++;
                break;
              }
              str += ss(args[a3]);
              lastPos = i2 + 2;
              i2++;
              break;
            case 115:
              if (a3 >= argLen)
                break;
              if (lastPos < i2)
                str += f4.slice(lastPos, i2);
              str += String(args[a3]);
              lastPos = i2 + 2;
              i2++;
              break;
            case 37:
              if (lastPos < i2)
                str += f4.slice(lastPos, i2);
              str += "%";
              lastPos = i2 + 2;
              i2++;
              a3--;
              break;
          }
          ++a3;
        }
        ++i2;
      }
      if (lastPos === -1)
        return f4;
      else if (lastPos < flen) {
        str += f4.slice(lastPos);
      }
      return str;
    }
  }
});

// node_modules/pino/browser.js
var require_browser3 = __commonJS({
  "node_modules/pino/browser.js"(exports2, module2) {
    "use strict";
    init_shim();
    var format = require_quick_format_unescaped();
    module2.exports = pino;
    var _console = pfGlobalThisOrFallback().console || {};
    var stdSerializers = {
      mapHttpRequest: mock,
      mapHttpResponse: mock,
      wrapRequestSerializer: passthrough,
      wrapResponseSerializer: passthrough,
      wrapErrorSerializer: passthrough,
      req: mock,
      res: mock,
      err: asErrValue
    };
    function shouldSerialize(serialize, serializers) {
      if (Array.isArray(serialize)) {
        const hasToFilter = serialize.filter(function(k4) {
          return k4 !== "!stdSerializers.err";
        });
        return hasToFilter;
      } else if (serialize === true) {
        return Object.keys(serializers);
      }
      return false;
    }
    function pino(opts) {
      opts = opts || {};
      opts.browser = opts.browser || {};
      const transmit2 = opts.browser.transmit;
      if (transmit2 && typeof transmit2.send !== "function") {
        throw Error("pino: transmit option must have a send function");
      }
      const proto = opts.browser.write || _console;
      if (opts.browser.write)
        opts.browser.asObject = true;
      const serializers = opts.serializers || {};
      const serialize = shouldSerialize(opts.browser.serialize, serializers);
      let stdErrSerialize = opts.browser.serialize;
      if (Array.isArray(opts.browser.serialize) && opts.browser.serialize.indexOf("!stdSerializers.err") > -1)
        stdErrSerialize = false;
      const levels = ["error", "fatal", "warn", "info", "debug", "trace"];
      if (typeof proto === "function") {
        proto.error = proto.fatal = proto.warn = proto.info = proto.debug = proto.trace = proto;
      }
      if (opts.enabled === false)
        opts.level = "silent";
      const level = opts.level || "info";
      const logger = Object.create(proto);
      if (!logger.log)
        logger.log = noop;
      Object.defineProperty(logger, "levelVal", {
        get: getLevelVal
      });
      Object.defineProperty(logger, "level", {
        get: getLevel,
        set: setLevel
      });
      const setOpts = {
        transmit: transmit2,
        serialize,
        asObject: opts.browser.asObject,
        levels,
        timestamp: getTimeFunction(opts)
      };
      logger.levels = pino.levels;
      logger.level = level;
      logger.setMaxListeners = logger.getMaxListeners = logger.emit = logger.addListener = logger.on = logger.prependListener = logger.once = logger.prependOnceListener = logger.removeListener = logger.removeAllListeners = logger.listeners = logger.listenerCount = logger.eventNames = logger.write = logger.flush = noop;
      logger.serializers = serializers;
      logger._serialize = serialize;
      logger._stdErrSerialize = stdErrSerialize;
      logger.child = child;
      if (transmit2)
        logger._logEvent = createLogEventShape();
      function getLevelVal() {
        return this.level === "silent" ? Infinity : this.levels.values[this.level];
      }
      function getLevel() {
        return this._level;
      }
      function setLevel(level2) {
        if (level2 !== "silent" && !this.levels.values[level2]) {
          throw Error("unknown level " + level2);
        }
        this._level = level2;
        set2(setOpts, logger, "error", "log");
        set2(setOpts, logger, "fatal", "error");
        set2(setOpts, logger, "warn", "error");
        set2(setOpts, logger, "info", "log");
        set2(setOpts, logger, "debug", "log");
        set2(setOpts, logger, "trace", "log");
      }
      function child(bindings, childOptions) {
        if (!bindings) {
          throw new Error("missing bindings for child Pino");
        }
        childOptions = childOptions || {};
        if (serialize && bindings.serializers) {
          childOptions.serializers = bindings.serializers;
        }
        const childOptionsSerializers = childOptions.serializers;
        if (serialize && childOptionsSerializers) {
          var childSerializers = Object.assign({}, serializers, childOptionsSerializers);
          var childSerialize = opts.browser.serialize === true ? Object.keys(childSerializers) : serialize;
          delete bindings.serializers;
          applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);
        }
        function Child(parent) {
          this._childLevel = (parent._childLevel | 0) + 1;
          this.error = bind(parent, bindings, "error");
          this.fatal = bind(parent, bindings, "fatal");
          this.warn = bind(parent, bindings, "warn");
          this.info = bind(parent, bindings, "info");
          this.debug = bind(parent, bindings, "debug");
          this.trace = bind(parent, bindings, "trace");
          if (childSerializers) {
            this.serializers = childSerializers;
            this._serialize = childSerialize;
          }
          if (transmit2) {
            this._logEvent = createLogEventShape(
              [].concat(parent._logEvent.bindings, bindings)
            );
          }
        }
        Child.prototype = this;
        return new Child(this);
      }
      return logger;
    }
    pino.levels = {
      values: {
        fatal: 60,
        error: 50,
        warn: 40,
        info: 30,
        debug: 20,
        trace: 10
      },
      labels: {
        10: "trace",
        20: "debug",
        30: "info",
        40: "warn",
        50: "error",
        60: "fatal"
      }
    };
    pino.stdSerializers = stdSerializers;
    pino.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });
    function set2(opts, logger, level, fallback) {
      const proto = Object.getPrototypeOf(logger);
      logger[level] = logger.levelVal > logger.levels.values[level] ? noop : proto[level] ? proto[level] : _console[level] || _console[fallback] || noop;
      wrap(opts, logger, level);
    }
    function wrap(opts, logger, level) {
      if (!opts.transmit && logger[level] === noop)
        return;
      logger[level] = /* @__PURE__ */ function(write) {
        return function LOG() {
          const ts = opts.timestamp();
          const args = new Array(arguments.length);
          const proto = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
          for (var i2 = 0; i2 < args.length; i2++)
            args[i2] = arguments[i2];
          if (opts.serialize && !opts.asObject) {
            applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
          }
          if (opts.asObject)
            write.call(proto, asObject(this, level, args, ts));
          else
            write.apply(proto, args);
          if (opts.transmit) {
            const transmitLevel = opts.transmit.level || logger.level;
            const transmitValue = pino.levels.values[transmitLevel];
            const methodValue = pino.levels.values[level];
            if (methodValue < transmitValue)
              return;
            transmit(this, {
              ts,
              methodLevel: level,
              methodValue,
              transmitLevel,
              transmitValue: pino.levels.values[opts.transmit.level || logger.level],
              send: opts.transmit.send,
              val: logger.levelVal
            }, args);
          }
        };
      }(logger[level]);
    }
    function asObject(logger, level, args, ts) {
      if (logger._serialize)
        applySerializers(args, logger._serialize, logger.serializers, logger._stdErrSerialize);
      const argsCloned = args.slice();
      let msg = argsCloned[0];
      const o2 = {};
      if (ts) {
        o2.time = ts;
      }
      o2.level = pino.levels.values[level];
      let lvl = (logger._childLevel | 0) + 1;
      if (lvl < 1)
        lvl = 1;
      if (msg !== null && typeof msg === "object") {
        while (lvl-- && typeof argsCloned[0] === "object") {
          Object.assign(o2, argsCloned.shift());
        }
        msg = argsCloned.length ? format(argsCloned.shift(), argsCloned) : void 0;
      } else if (typeof msg === "string")
        msg = format(argsCloned.shift(), argsCloned);
      if (msg !== void 0)
        o2.msg = msg;
      return o2;
    }
    function applySerializers(args, serialize, serializers, stdErrSerialize) {
      for (const i2 in args) {
        if (stdErrSerialize && args[i2] instanceof Error) {
          args[i2] = pino.stdSerializers.err(args[i2]);
        } else if (typeof args[i2] === "object" && !Array.isArray(args[i2])) {
          for (const k4 in args[i2]) {
            if (serialize && serialize.indexOf(k4) > -1 && k4 in serializers) {
              args[i2][k4] = serializers[k4](args[i2][k4]);
            }
          }
        }
      }
    }
    function bind(parent, bindings, level) {
      return function() {
        const args = new Array(1 + arguments.length);
        args[0] = bindings;
        for (var i2 = 1; i2 < args.length; i2++) {
          args[i2] = arguments[i2 - 1];
        }
        return parent[level].apply(this, args);
      };
    }
    function transmit(logger, opts, args) {
      const send = opts.send;
      const ts = opts.ts;
      const methodLevel = opts.methodLevel;
      const methodValue = opts.methodValue;
      const val = opts.val;
      const bindings = logger._logEvent.bindings;
      applySerializers(
        args,
        logger._serialize || Object.keys(logger.serializers),
        logger.serializers,
        logger._stdErrSerialize === void 0 ? true : logger._stdErrSerialize
      );
      logger._logEvent.ts = ts;
      logger._logEvent.messages = args.filter(function(arg) {
        return bindings.indexOf(arg) === -1;
      });
      logger._logEvent.level.label = methodLevel;
      logger._logEvent.level.value = methodValue;
      send(methodLevel, logger._logEvent, val);
      logger._logEvent = createLogEventShape(bindings);
    }
    function createLogEventShape(bindings) {
      return {
        ts: 0,
        messages: [],
        bindings: bindings || [],
        level: { label: "", value: 0 }
      };
    }
    function asErrValue(err) {
      const obj = {
        type: err.constructor.name,
        msg: err.message,
        stack: err.stack
      };
      for (const key in err) {
        if (obj[key] === void 0) {
          obj[key] = err[key];
        }
      }
      return obj;
    }
    function getTimeFunction(opts) {
      if (typeof opts.timestamp === "function") {
        return opts.timestamp;
      }
      if (opts.timestamp === false) {
        return nullTime;
      }
      return epochTime;
    }
    function mock() {
      return {};
    }
    function passthrough(a3) {
      return a3;
    }
    function noop() {
    }
    function nullTime() {
      return false;
    }
    function epochTime() {
      return Date.now();
    }
    function unixTime() {
      return Math.round(Date.now() / 1e3);
    }
    function isoTime() {
      return new Date(Date.now()).toISOString();
    }
    function pfGlobalThisOrFallback() {
      function defd(o2) {
        return typeof o2 !== "undefined" && o2;
      }
      try {
        if (typeof globalThis !== "undefined")
          return globalThis;
        Object.defineProperty(Object.prototype, "globalThis", {
          get: function() {
            delete Object.prototype.globalThis;
            return this.globalThis = this;
          },
          configurable: true
        });
        return globalThis;
      } catch (e2) {
        return defd(self) || defd(window) || defd(this) || {};
      }
    }
  }
});

// node_modules/@walletconnect/logger/dist/index.es.js
var index_es_exports2 = {};
__export(index_es_exports2, {
  MAX_LOG_SIZE_IN_BYTES_DEFAULT: () => l2,
  PINO_CUSTOM_CONTEXT_KEY: () => n,
  PINO_LOGGER_DEFAULTS: () => c2,
  formatChildLoggerContext: () => w,
  generateChildLogger: () => E2,
  generateClientLogger: () => C,
  generatePlatformLogger: () => A,
  generateServerLogger: () => I,
  getBrowserLoggerContext: () => v,
  getDefaultLoggerOptions: () => k2,
  getLoggerContext: () => y2,
  pino: () => import_pino2.default,
  setBrowserLoggerContext: () => b
});
function k2(r) {
  return g(i({}, r), { level: r?.level || c2.level });
}
function v(r, e2 = n) {
  return r[e2] || "";
}
function b(r, e2, t = n) {
  return r[t] = e2, r;
}
function y2(r, e2 = n) {
  let t = "";
  return typeof r.bindings > "u" ? t = v(r, e2) : t = r.bindings().context || "", t;
}
function w(r, e2, t = n) {
  const o2 = y2(r, t);
  return o2.trim() ? `${o2}/${e2}` : e2;
}
function E2(r, e2, t = n) {
  const o2 = w(r, e2, t), a3 = r.child({ context: o2 });
  return b(a3, o2, t);
}
function C(r) {
  var e2, t;
  const o2 = new m((e2 = r.opts) == null ? void 0 : e2.level, r.maxSizeInBytes);
  return { logger: (0, import_pino.default)(g(i({}, r.opts), { level: "trace", browser: g(i({}, (t = r.opts) == null ? void 0 : t.browser), { write: (a3) => o2.write(a3) }) })), chunkLoggerController: o2 };
}
function I(r) {
  var e2;
  const t = new B((e2 = r.opts) == null ? void 0 : e2.level, r.maxSizeInBytes);
  return { logger: (0, import_pino.default)(g(i({}, r.opts), { level: "trace" }), t), chunkLoggerController: t };
}
function A(r) {
  return typeof r.loggerOverride < "u" && typeof r.loggerOverride != "string" ? { logger: r.loggerOverride, chunkLoggerController: null } : typeof window < "u" ? C(r) : I(r);
}
var import_pino, import_pino2, c2, n, l2, O2, d, L, m, B, x2, S, _2, p, T, z2, f, i, g;
var init_index_es2 = __esm({
  "node_modules/@walletconnect/logger/dist/index.es.js"() {
    init_shim();
    import_pino = __toESM(require_browser3());
    import_pino2 = __toESM(require_browser3());
    init_esm();
    c2 = { level: "info" };
    n = "custom_context";
    l2 = 1e3 * 1024;
    O2 = class {
      constructor(e2) {
        this.nodeValue = e2, this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length, this.next = null;
      }
      get value() {
        return this.nodeValue;
      }
      get size() {
        return this.sizeInBytes;
      }
    };
    d = class {
      constructor(e2) {
        this.head = null, this.tail = null, this.lengthInNodes = 0, this.maxSizeInBytes = e2, this.sizeInBytes = 0;
      }
      append(e2) {
        const t = new O2(e2);
        if (t.size > this.maxSizeInBytes)
          throw new Error(`[LinkedList] Value too big to insert into list: ${e2} with size ${t.size}`);
        for (; this.size + t.size > this.maxSizeInBytes; )
          this.shift();
        this.head ? (this.tail && (this.tail.next = t), this.tail = t) : (this.head = t, this.tail = t), this.lengthInNodes++, this.sizeInBytes += t.size;
      }
      shift() {
        if (!this.head)
          return;
        const e2 = this.head;
        this.head = this.head.next, this.head || (this.tail = null), this.lengthInNodes--, this.sizeInBytes -= e2.size;
      }
      toArray() {
        const e2 = [];
        let t = this.head;
        for (; t !== null; )
          e2.push(t.value), t = t.next;
        return e2;
      }
      get length() {
        return this.lengthInNodes;
      }
      get size() {
        return this.sizeInBytes;
      }
      toOrderedArray() {
        return Array.from(this);
      }
      [Symbol.iterator]() {
        let e2 = this.head;
        return { next: () => {
          if (!e2)
            return { done: true, value: null };
          const t = e2.value;
          return e2 = e2.next, { done: false, value: t };
        } };
      }
    };
    L = class {
      constructor(e2, t = l2) {
        this.level = e2 ?? "error", this.levelValue = import_pino.levels.values[this.level], this.MAX_LOG_SIZE_IN_BYTES = t, this.logs = new d(this.MAX_LOG_SIZE_IN_BYTES);
      }
      forwardToConsole(e2, t) {
        t === import_pino.levels.values.error ? console.error(e2) : t === import_pino.levels.values.warn ? console.warn(e2) : t === import_pino.levels.values.debug ? console.debug(e2) : t === import_pino.levels.values.trace ? console.trace(e2) : console.log(e2);
      }
      appendToLogs(e2) {
        this.logs.append(safeJsonStringify({ timestamp: (/* @__PURE__ */ new Date()).toISOString(), log: e2 }));
        const t = typeof e2 == "string" ? JSON.parse(e2).level : e2.level;
        t >= this.levelValue && this.forwardToConsole(e2, t);
      }
      getLogs() {
        return this.logs;
      }
      clearLogs() {
        this.logs = new d(this.MAX_LOG_SIZE_IN_BYTES);
      }
      getLogArray() {
        return Array.from(this.logs);
      }
      logsToBlob(e2) {
        const t = this.getLogArray();
        return t.push(safeJsonStringify({ extraMetadata: e2 })), new Blob(t, { type: "application/json" });
      }
    };
    m = class {
      constructor(e2, t = l2) {
        this.baseChunkLogger = new L(e2, t);
      }
      write(e2) {
        this.baseChunkLogger.appendToLogs(e2);
      }
      getLogs() {
        return this.baseChunkLogger.getLogs();
      }
      clearLogs() {
        this.baseChunkLogger.clearLogs();
      }
      getLogArray() {
        return this.baseChunkLogger.getLogArray();
      }
      logsToBlob(e2) {
        return this.baseChunkLogger.logsToBlob(e2);
      }
      downloadLogsBlobInBrowser(e2) {
        const t = URL.createObjectURL(this.logsToBlob(e2)), o2 = document.createElement("a");
        o2.href = t, o2.download = `walletconnect-logs-${(/* @__PURE__ */ new Date()).toISOString()}.txt`, document.body.appendChild(o2), o2.click(), document.body.removeChild(o2), URL.revokeObjectURL(t);
      }
    };
    B = class {
      constructor(e2, t = l2) {
        this.baseChunkLogger = new L(e2, t);
      }
      write(e2) {
        this.baseChunkLogger.appendToLogs(e2);
      }
      getLogs() {
        return this.baseChunkLogger.getLogs();
      }
      clearLogs() {
        this.baseChunkLogger.clearLogs();
      }
      getLogArray() {
        return this.baseChunkLogger.getLogArray();
      }
      logsToBlob(e2) {
        return this.baseChunkLogger.logsToBlob(e2);
      }
    };
    x2 = Object.defineProperty;
    S = Object.defineProperties;
    _2 = Object.getOwnPropertyDescriptors;
    p = Object.getOwnPropertySymbols;
    T = Object.prototype.hasOwnProperty;
    z2 = Object.prototype.propertyIsEnumerable;
    f = (r, e2, t) => e2 in r ? x2(r, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r[e2] = t;
    i = (r, e2) => {
      for (var t in e2 || (e2 = {}))
        T.call(e2, t) && f(r, t, e2[t]);
      if (p)
        for (var t of p(e2))
          z2.call(e2, t) && f(r, t, e2[t]);
      return r;
    };
    g = (r, e2) => S(r, _2(e2));
  }
});

// node_modules/@walletconnect/types/dist/index.cjs.js
var require_index_cjs = __commonJS({
  "node_modules/@walletconnect/types/dist/index.cjs.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var r = (init_esm2(), __toCommonJS(esm_exports2));
    var c4 = require_events();
    function i2(t) {
      return t && typeof t == "object" && "default" in t ? t : { default: t };
    }
    var n3 = i2(c4);
    var l4 = class extends r.IEvents {
      constructor(s2) {
        super(), this.opts = s2, this.protocol = "wc", this.version = 2;
      }
    };
    var a3 = class {
      constructor(s2, e2, o2) {
        this.core = s2, this.logger = e2;
      }
    };
    var u3 = class extends r.IEvents {
      constructor(s2, e2) {
        super(), this.core = s2, this.logger = e2, this.records = /* @__PURE__ */ new Map();
      }
    };
    var I2 = class {
      constructor(s2, e2) {
        this.logger = s2, this.core = e2;
      }
    };
    var h5 = class extends r.IEvents {
      constructor(s2, e2) {
        super(), this.relayer = s2, this.logger = e2;
      }
    };
    var g3 = class extends r.IEvents {
      constructor(s2) {
        super();
      }
    };
    var p3 = class {
      constructor(s2, e2, o2, _4) {
        this.core = s2, this.logger = e2, this.name = o2;
      }
    };
    var E4 = class {
      constructor() {
        this.map = /* @__PURE__ */ new Map();
      }
    };
    var v2 = class extends r.IEvents {
      constructor(s2, e2) {
        super(), this.relayer = s2, this.logger = e2;
      }
    };
    var d3 = class {
      constructor(s2, e2) {
        this.core = s2, this.logger = e2;
      }
    };
    var y4 = class extends r.IEvents {
      constructor(s2, e2) {
        super(), this.core = s2, this.logger = e2;
      }
    };
    var b4 = class {
      constructor(s2, e2) {
        this.logger = s2, this.core = e2;
      }
    };
    var C3 = class {
      constructor(s2, e2) {
        this.projectId = s2, this.logger = e2;
      }
    };
    var f4 = class {
      constructor(s2, e2) {
        this.projectId = s2, this.logger = e2;
      }
    };
    var x3 = class extends n3.default {
      constructor() {
        super();
      }
    };
    var S4 = class {
      constructor(s2) {
        this.opts = s2, this.protocol = "wc", this.version = 2;
      }
    };
    var M = class extends c4.EventEmitter {
      constructor() {
        super();
      }
    };
    var P2 = class {
      constructor(s2) {
        this.client = s2;
      }
    };
    exports2.ICore = l4, exports2.ICrypto = a3, exports2.IEchoClient = f4, exports2.IEngine = P2, exports2.IEngineEvents = M, exports2.IExpirer = y4, exports2.IJsonRpcHistory = u3, exports2.IKeyChain = d3, exports2.IMessageTracker = I2, exports2.IPairing = b4, exports2.IPublisher = h5, exports2.IRelayer = g3, exports2.ISignClient = S4, exports2.ISignClientEvents = x3, exports2.IStore = p3, exports2.ISubscriber = v2, exports2.ISubscriberTopicMap = E4, exports2.IVerify = C3;
  }
});

// node_modules/@stablelib/random/lib/source/browser.js
var require_browser4 = __commonJS({
  "node_modules/@stablelib/random/lib/source/browser.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BrowserRandomSource = void 0;
    var QUOTA = 65536;
    var BrowserRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        const browserCrypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (browserCrypto && browserCrypto.getRandomValues !== void 0) {
          this._crypto = browserCrypto;
          this.isAvailable = true;
          this.isInstantiated = true;
        }
      }
      randomBytes(length2) {
        if (!this.isAvailable || !this._crypto) {
          throw new Error("Browser random byte generator is not available.");
        }
        const out = new Uint8Array(length2);
        for (let i2 = 0; i2 < out.length; i2 += QUOTA) {
          this._crypto.getRandomValues(out.subarray(i2, i2 + Math.min(out.length - i2, QUOTA)));
        }
        return out;
      }
    };
    exports2.BrowserRandomSource = BrowserRandomSource;
  }
});

// node_modules/@stablelib/wipe/lib/wipe.js
var require_wipe = __commonJS({
  "node_modules/@stablelib/wipe/lib/wipe.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    function wipe(array) {
      for (var i2 = 0; i2 < array.length; i2++) {
        array[i2] = 0;
      }
      return array;
    }
    exports2.wipe = wipe;
  }
});

// (disabled):crypto
var require_crypto = __commonJS({
  "(disabled):crypto"() {
    init_shim();
  }
});

// node_modules/@stablelib/random/lib/source/node.js
var require_node = __commonJS({
  "node_modules/@stablelib/random/lib/source/node.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NodeRandomSource = void 0;
    var wipe_1 = require_wipe();
    var NodeRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        if (typeof __require !== "undefined") {
          const nodeCrypto = require_crypto();
          if (nodeCrypto && nodeCrypto.randomBytes) {
            this._crypto = nodeCrypto;
            this.isAvailable = true;
            this.isInstantiated = true;
          }
        }
      }
      randomBytes(length2) {
        if (!this.isAvailable || !this._crypto) {
          throw new Error("Node.js random byte generator is not available.");
        }
        let buffer = this._crypto.randomBytes(length2);
        if (buffer.length !== length2) {
          throw new Error("NodeRandomSource: got fewer bytes than requested");
        }
        const out = new Uint8Array(length2);
        for (let i2 = 0; i2 < out.length; i2++) {
          out[i2] = buffer[i2];
        }
        (0, wipe_1.wipe)(buffer);
        return out;
      }
    };
    exports2.NodeRandomSource = NodeRandomSource;
  }
});

// node_modules/@stablelib/random/lib/source/system.js
var require_system = __commonJS({
  "node_modules/@stablelib/random/lib/source/system.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SystemRandomSource = void 0;
    var browser_1 = require_browser4();
    var node_1 = require_node();
    var SystemRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.name = "";
        this._source = new browser_1.BrowserRandomSource();
        if (this._source.isAvailable) {
          this.isAvailable = true;
          this.name = "Browser";
          return;
        }
        this._source = new node_1.NodeRandomSource();
        if (this._source.isAvailable) {
          this.isAvailable = true;
          this.name = "Node";
          return;
        }
      }
      randomBytes(length2) {
        if (!this.isAvailable) {
          throw new Error("System random byte generator is not available.");
        }
        return this._source.randomBytes(length2);
      }
    };
    exports2.SystemRandomSource = SystemRandomSource;
  }
});

// node_modules/@stablelib/int/lib/int.js
var require_int = __commonJS({
  "node_modules/@stablelib/int/lib/int.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    function imulShim(a3, b4) {
      var ah = a3 >>> 16 & 65535, al = a3 & 65535;
      var bh = b4 >>> 16 & 65535, bl = b4 & 65535;
      return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
    }
    exports2.mul = Math.imul || imulShim;
    function add(a3, b4) {
      return a3 + b4 | 0;
    }
    exports2.add = add;
    function sub(a3, b4) {
      return a3 - b4 | 0;
    }
    exports2.sub = sub;
    function rotl(x3, n3) {
      return x3 << n3 | x3 >>> 32 - n3;
    }
    exports2.rotl = rotl;
    function rotr(x3, n3) {
      return x3 << 32 - n3 | x3 >>> n3;
    }
    exports2.rotr = rotr;
    function isIntegerShim(n3) {
      return typeof n3 === "number" && isFinite(n3) && Math.floor(n3) === n3;
    }
    exports2.isInteger = Number.isInteger || isIntegerShim;
    exports2.MAX_SAFE_INTEGER = 9007199254740991;
    exports2.isSafeInteger = function(n3) {
      return exports2.isInteger(n3) && (n3 >= -exports2.MAX_SAFE_INTEGER && n3 <= exports2.MAX_SAFE_INTEGER);
    };
  }
});

// node_modules/@stablelib/binary/lib/binary.js
var require_binary2 = __commonJS({
  "node_modules/@stablelib/binary/lib/binary.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var int_1 = require_int();
    function readInt16BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;
    }
    exports2.readInt16BE = readInt16BE;
    function readUint16BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 0] << 8 | array[offset + 1]) >>> 0;
    }
    exports2.readUint16BE = readUint16BE;
    function readInt16LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 1] << 8 | array[offset]) << 16 >> 16;
    }
    exports2.readInt16LE = readInt16LE;
    function readUint16LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 1] << 8 | array[offset]) >>> 0;
    }
    exports2.readUint16LE = readUint16LE;
    function writeUint16BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(2);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 8;
      out[offset + 1] = value >>> 0;
      return out;
    }
    exports2.writeUint16BE = writeUint16BE;
    exports2.writeInt16BE = writeUint16BE;
    function writeUint16LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(2);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 0;
      out[offset + 1] = value >>> 8;
      return out;
    }
    exports2.writeUint16LE = writeUint16LE;
    exports2.writeInt16LE = writeUint16LE;
    function readInt32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];
    }
    exports2.readInt32BE = readInt32BE;
    function readUint32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;
    }
    exports2.readUint32BE = readUint32BE;
    function readInt32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];
    }
    exports2.readInt32LE = readInt32LE;
    function readUint32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;
    }
    exports2.readUint32LE = readUint32LE;
    function writeUint32BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 24;
      out[offset + 1] = value >>> 16;
      out[offset + 2] = value >>> 8;
      out[offset + 3] = value >>> 0;
      return out;
    }
    exports2.writeUint32BE = writeUint32BE;
    exports2.writeInt32BE = writeUint32BE;
    function writeUint32LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 0;
      out[offset + 1] = value >>> 8;
      out[offset + 2] = value >>> 16;
      out[offset + 3] = value >>> 24;
      return out;
    }
    exports2.writeUint32LE = writeUint32LE;
    exports2.writeInt32LE = writeUint32LE;
    function readInt64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var hi = readInt32BE(array, offset);
      var lo = readInt32BE(array, offset + 4);
      return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
    }
    exports2.readInt64BE = readInt64BE;
    function readUint64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var hi = readUint32BE(array, offset);
      var lo = readUint32BE(array, offset + 4);
      return hi * 4294967296 + lo;
    }
    exports2.readUint64BE = readUint64BE;
    function readInt64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var lo = readInt32LE(array, offset);
      var hi = readInt32LE(array, offset + 4);
      return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
    }
    exports2.readInt64LE = readInt64LE;
    function readUint64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var lo = readUint32LE(array, offset);
      var hi = readUint32LE(array, offset + 4);
      return hi * 4294967296 + lo;
    }
    exports2.readUint64LE = readUint64LE;
    function writeUint64BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      writeUint32BE(value / 4294967296 >>> 0, out, offset);
      writeUint32BE(value >>> 0, out, offset + 4);
      return out;
    }
    exports2.writeUint64BE = writeUint64BE;
    exports2.writeInt64BE = writeUint64BE;
    function writeUint64LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      writeUint32LE(value >>> 0, out, offset);
      writeUint32LE(value / 4294967296 >>> 0, out, offset + 4);
      return out;
    }
    exports2.writeUint64LE = writeUint64LE;
    exports2.writeInt64LE = writeUint64LE;
    function readUintBE(bitLength, array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("readUintBE supports only bitLengths divisible by 8");
      }
      if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintBE: array is too short for the given bitLength");
      }
      var result = 0;
      var mul = 1;
      for (var i2 = bitLength / 8 + offset - 1; i2 >= offset; i2--) {
        result += array[i2] * mul;
        mul *= 256;
      }
      return result;
    }
    exports2.readUintBE = readUintBE;
    function readUintLE(bitLength, array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("readUintLE supports only bitLengths divisible by 8");
      }
      if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintLE: array is too short for the given bitLength");
      }
      var result = 0;
      var mul = 1;
      for (var i2 = offset; i2 < offset + bitLength / 8; i2++) {
        result += array[i2] * mul;
        mul *= 256;
      }
      return result;
    }
    exports2.readUintLE = readUintLE;
    function writeUintBE(bitLength, value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("writeUintBE supports only bitLengths divisible by 8");
      }
      if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintBE value must be an integer");
      }
      var div = 1;
      for (var i2 = bitLength / 8 + offset - 1; i2 >= offset; i2--) {
        out[i2] = value / div & 255;
        div *= 256;
      }
      return out;
    }
    exports2.writeUintBE = writeUintBE;
    function writeUintLE(bitLength, value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("writeUintLE supports only bitLengths divisible by 8");
      }
      if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintLE value must be an integer");
      }
      var div = 1;
      for (var i2 = offset; i2 < offset + bitLength / 8; i2++) {
        out[i2] = value / div & 255;
        div *= 256;
      }
      return out;
    }
    exports2.writeUintLE = writeUintLE;
    function readFloat32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat32(offset);
    }
    exports2.readFloat32BE = readFloat32BE;
    function readFloat32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat32(offset, true);
    }
    exports2.readFloat32LE = readFloat32LE;
    function readFloat64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat64(offset);
    }
    exports2.readFloat64BE = readFloat64BE;
    function readFloat64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat64(offset, true);
    }
    exports2.readFloat64LE = readFloat64LE;
    function writeFloat32BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat32(offset, value);
      return out;
    }
    exports2.writeFloat32BE = writeFloat32BE;
    function writeFloat32LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat32(offset, value, true);
      return out;
    }
    exports2.writeFloat32LE = writeFloat32LE;
    function writeFloat64BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat64(offset, value);
      return out;
    }
    exports2.writeFloat64BE = writeFloat64BE;
    function writeFloat64LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat64(offset, value, true);
      return out;
    }
    exports2.writeFloat64LE = writeFloat64LE;
  }
});

// node_modules/@stablelib/random/lib/random.js
var require_random = __commonJS({
  "node_modules/@stablelib/random/lib/random.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.randomStringForEntropy = exports2.randomString = exports2.randomUint32 = exports2.randomBytes = exports2.defaultRandomSource = void 0;
    var system_1 = require_system();
    var binary_1 = require_binary2();
    var wipe_1 = require_wipe();
    exports2.defaultRandomSource = new system_1.SystemRandomSource();
    function randomBytes2(length2, prng = exports2.defaultRandomSource) {
      return prng.randomBytes(length2);
    }
    exports2.randomBytes = randomBytes2;
    function randomUint32(prng = exports2.defaultRandomSource) {
      const buf = randomBytes2(4, prng);
      const result = (0, binary_1.readUint32LE)(buf);
      (0, wipe_1.wipe)(buf);
      return result;
    }
    exports2.randomUint32 = randomUint32;
    var ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    function randomString(length2, charset = ALPHANUMERIC, prng = exports2.defaultRandomSource) {
      if (charset.length < 2) {
        throw new Error("randomString charset is too short");
      }
      if (charset.length > 256) {
        throw new Error("randomString charset is too long");
      }
      let out = "";
      const charsLen = charset.length;
      const maxByte = 256 - 256 % charsLen;
      while (length2 > 0) {
        const buf = randomBytes2(Math.ceil(length2 * 256 / maxByte), prng);
        for (let i2 = 0; i2 < buf.length && length2 > 0; i2++) {
          const randomByte = buf[i2];
          if (randomByte < maxByte) {
            out += charset.charAt(randomByte % charsLen);
            length2--;
          }
        }
        (0, wipe_1.wipe)(buf);
      }
      return out;
    }
    exports2.randomString = randomString;
    function randomStringForEntropy(bits, charset = ALPHANUMERIC, prng = exports2.defaultRandomSource) {
      const length2 = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
      return randomString(length2, charset, prng);
    }
    exports2.randomStringForEntropy = randomStringForEntropy;
  }
});

// node_modules/@stablelib/sha512/lib/sha512.js
var require_sha512 = __commonJS({
  "node_modules/@stablelib/sha512/lib/sha512.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var binary_1 = require_binary2();
    var wipe_1 = require_wipe();
    exports2.DIGEST_LENGTH = 64;
    exports2.BLOCK_SIZE = 128;
    var SHA512 = (
      /** @class */
      function() {
        function SHA5122() {
          this.digestLength = exports2.DIGEST_LENGTH;
          this.blockSize = exports2.BLOCK_SIZE;
          this._stateHi = new Int32Array(8);
          this._stateLo = new Int32Array(8);
          this._tempHi = new Int32Array(16);
          this._tempLo = new Int32Array(16);
          this._buffer = new Uint8Array(256);
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          this.reset();
        }
        SHA5122.prototype._initState = function() {
          this._stateHi[0] = 1779033703;
          this._stateHi[1] = 3144134277;
          this._stateHi[2] = 1013904242;
          this._stateHi[3] = 2773480762;
          this._stateHi[4] = 1359893119;
          this._stateHi[5] = 2600822924;
          this._stateHi[6] = 528734635;
          this._stateHi[7] = 1541459225;
          this._stateLo[0] = 4089235720;
          this._stateLo[1] = 2227873595;
          this._stateLo[2] = 4271175723;
          this._stateLo[3] = 1595750129;
          this._stateLo[4] = 2917565137;
          this._stateLo[5] = 725511199;
          this._stateLo[6] = 4215389547;
          this._stateLo[7] = 327033209;
        };
        SHA5122.prototype.reset = function() {
          this._initState();
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          return this;
        };
        SHA5122.prototype.clean = function() {
          wipe_1.wipe(this._buffer);
          wipe_1.wipe(this._tempHi);
          wipe_1.wipe(this._tempLo);
          this.reset();
        };
        SHA5122.prototype.update = function(data, dataLength) {
          if (dataLength === void 0) {
            dataLength = data.length;
          }
          if (this._finished) {
            throw new Error("SHA512: can't update because hash was finished.");
          }
          var dataPos = 0;
          this._bytesHashed += dataLength;
          if (this._bufferLength > 0) {
            while (this._bufferLength < exports2.BLOCK_SIZE && dataLength > 0) {
              this._buffer[this._bufferLength++] = data[dataPos++];
              dataLength--;
            }
            if (this._bufferLength === this.blockSize) {
              hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize);
              this._bufferLength = 0;
            }
          }
          if (dataLength >= this.blockSize) {
            dataPos = hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, data, dataPos, dataLength);
            dataLength %= this.blockSize;
          }
          while (dataLength > 0) {
            this._buffer[this._bufferLength++] = data[dataPos++];
            dataLength--;
          }
          return this;
        };
        SHA5122.prototype.finish = function(out) {
          if (!this._finished) {
            var bytesHashed = this._bytesHashed;
            var left = this._bufferLength;
            var bitLenHi = bytesHashed / 536870912 | 0;
            var bitLenLo = bytesHashed << 3;
            var padLength = bytesHashed % 128 < 112 ? 128 : 256;
            this._buffer[left] = 128;
            for (var i2 = left + 1; i2 < padLength - 8; i2++) {
              this._buffer[i2] = 0;
            }
            binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
            binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
            hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, padLength);
            this._finished = true;
          }
          for (var i2 = 0; i2 < this.digestLength / 8; i2++) {
            binary_1.writeUint32BE(this._stateHi[i2], out, i2 * 8);
            binary_1.writeUint32BE(this._stateLo[i2], out, i2 * 8 + 4);
          }
          return this;
        };
        SHA5122.prototype.digest = function() {
          var out = new Uint8Array(this.digestLength);
          this.finish(out);
          return out;
        };
        SHA5122.prototype.saveState = function() {
          if (this._finished) {
            throw new Error("SHA256: cannot save finished state");
          }
          return {
            stateHi: new Int32Array(this._stateHi),
            stateLo: new Int32Array(this._stateLo),
            buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
            bufferLength: this._bufferLength,
            bytesHashed: this._bytesHashed
          };
        };
        SHA5122.prototype.restoreState = function(savedState) {
          this._stateHi.set(savedState.stateHi);
          this._stateLo.set(savedState.stateLo);
          this._bufferLength = savedState.bufferLength;
          if (savedState.buffer) {
            this._buffer.set(savedState.buffer);
          }
          this._bytesHashed = savedState.bytesHashed;
          this._finished = false;
          return this;
        };
        SHA5122.prototype.cleanSavedState = function(savedState) {
          wipe_1.wipe(savedState.stateHi);
          wipe_1.wipe(savedState.stateLo);
          if (savedState.buffer) {
            wipe_1.wipe(savedState.buffer);
          }
          savedState.bufferLength = 0;
          savedState.bytesHashed = 0;
        };
        return SHA5122;
      }()
    );
    exports2.SHA512 = SHA512;
    var K2 = new Int32Array([
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ]);
    function hashBlocks(wh, wl, hh, hl, m3, pos, len) {
      var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
      var h5, l4;
      var th, tl;
      var a3, b4, c4, d3;
      while (len >= 128) {
        for (var i2 = 0; i2 < 16; i2++) {
          var j2 = 8 * i2 + pos;
          wh[i2] = binary_1.readUint32BE(m3, j2);
          wl[i2] = binary_1.readUint32BE(m3, j2 + 4);
        }
        for (var i2 = 0; i2 < 80; i2++) {
          var bh0 = ah0;
          var bh1 = ah1;
          var bh2 = ah2;
          var bh3 = ah3;
          var bh4 = ah4;
          var bh5 = ah5;
          var bh6 = ah6;
          var bh7 = ah7;
          var bl0 = al0;
          var bl1 = al1;
          var bl2 = al2;
          var bl3 = al3;
          var bl4 = al4;
          var bl5 = al5;
          var bl6 = al6;
          var bl7 = al7;
          h5 = ah7;
          l4 = al7;
          a3 = l4 & 65535;
          b4 = l4 >>> 16;
          c4 = h5 & 65535;
          d3 = h5 >>> 16;
          h5 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
          l4 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
          a3 += l4 & 65535;
          b4 += l4 >>> 16;
          c4 += h5 & 65535;
          d3 += h5 >>> 16;
          h5 = ah4 & ah5 ^ ~ah4 & ah6;
          l4 = al4 & al5 ^ ~al4 & al6;
          a3 += l4 & 65535;
          b4 += l4 >>> 16;
          c4 += h5 & 65535;
          d3 += h5 >>> 16;
          h5 = K2[i2 * 2];
          l4 = K2[i2 * 2 + 1];
          a3 += l4 & 65535;
          b4 += l4 >>> 16;
          c4 += h5 & 65535;
          d3 += h5 >>> 16;
          h5 = wh[i2 % 16];
          l4 = wl[i2 % 16];
          a3 += l4 & 65535;
          b4 += l4 >>> 16;
          c4 += h5 & 65535;
          d3 += h5 >>> 16;
          b4 += a3 >>> 16;
          c4 += b4 >>> 16;
          d3 += c4 >>> 16;
          th = c4 & 65535 | d3 << 16;
          tl = a3 & 65535 | b4 << 16;
          h5 = th;
          l4 = tl;
          a3 = l4 & 65535;
          b4 = l4 >>> 16;
          c4 = h5 & 65535;
          d3 = h5 >>> 16;
          h5 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
          l4 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
          a3 += l4 & 65535;
          b4 += l4 >>> 16;
          c4 += h5 & 65535;
          d3 += h5 >>> 16;
          h5 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
          l4 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
          a3 += l4 & 65535;
          b4 += l4 >>> 16;
          c4 += h5 & 65535;
          d3 += h5 >>> 16;
          b4 += a3 >>> 16;
          c4 += b4 >>> 16;
          d3 += c4 >>> 16;
          bh7 = c4 & 65535 | d3 << 16;
          bl7 = a3 & 65535 | b4 << 16;
          h5 = bh3;
          l4 = bl3;
          a3 = l4 & 65535;
          b4 = l4 >>> 16;
          c4 = h5 & 65535;
          d3 = h5 >>> 16;
          h5 = th;
          l4 = tl;
          a3 += l4 & 65535;
          b4 += l4 >>> 16;
          c4 += h5 & 65535;
          d3 += h5 >>> 16;
          b4 += a3 >>> 16;
          c4 += b4 >>> 16;
          d3 += c4 >>> 16;
          bh3 = c4 & 65535 | d3 << 16;
          bl3 = a3 & 65535 | b4 << 16;
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;
          if (i2 % 16 === 15) {
            for (var j2 = 0; j2 < 16; j2++) {
              h5 = wh[j2];
              l4 = wl[j2];
              a3 = l4 & 65535;
              b4 = l4 >>> 16;
              c4 = h5 & 65535;
              d3 = h5 >>> 16;
              h5 = wh[(j2 + 9) % 16];
              l4 = wl[(j2 + 9) % 16];
              a3 += l4 & 65535;
              b4 += l4 >>> 16;
              c4 += h5 & 65535;
              d3 += h5 >>> 16;
              th = wh[(j2 + 1) % 16];
              tl = wl[(j2 + 1) % 16];
              h5 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
              l4 = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
              a3 += l4 & 65535;
              b4 += l4 >>> 16;
              c4 += h5 & 65535;
              d3 += h5 >>> 16;
              th = wh[(j2 + 14) % 16];
              tl = wl[(j2 + 14) % 16];
              h5 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
              l4 = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
              a3 += l4 & 65535;
              b4 += l4 >>> 16;
              c4 += h5 & 65535;
              d3 += h5 >>> 16;
              b4 += a3 >>> 16;
              c4 += b4 >>> 16;
              d3 += c4 >>> 16;
              wh[j2] = c4 & 65535 | d3 << 16;
              wl[j2] = a3 & 65535 | b4 << 16;
            }
          }
        }
        h5 = ah0;
        l4 = al0;
        a3 = l4 & 65535;
        b4 = l4 >>> 16;
        c4 = h5 & 65535;
        d3 = h5 >>> 16;
        h5 = hh[0];
        l4 = hl[0];
        a3 += l4 & 65535;
        b4 += l4 >>> 16;
        c4 += h5 & 65535;
        d3 += h5 >>> 16;
        b4 += a3 >>> 16;
        c4 += b4 >>> 16;
        d3 += c4 >>> 16;
        hh[0] = ah0 = c4 & 65535 | d3 << 16;
        hl[0] = al0 = a3 & 65535 | b4 << 16;
        h5 = ah1;
        l4 = al1;
        a3 = l4 & 65535;
        b4 = l4 >>> 16;
        c4 = h5 & 65535;
        d3 = h5 >>> 16;
        h5 = hh[1];
        l4 = hl[1];
        a3 += l4 & 65535;
        b4 += l4 >>> 16;
        c4 += h5 & 65535;
        d3 += h5 >>> 16;
        b4 += a3 >>> 16;
        c4 += b4 >>> 16;
        d3 += c4 >>> 16;
        hh[1] = ah1 = c4 & 65535 | d3 << 16;
        hl[1] = al1 = a3 & 65535 | b4 << 16;
        h5 = ah2;
        l4 = al2;
        a3 = l4 & 65535;
        b4 = l4 >>> 16;
        c4 = h5 & 65535;
        d3 = h5 >>> 16;
        h5 = hh[2];
        l4 = hl[2];
        a3 += l4 & 65535;
        b4 += l4 >>> 16;
        c4 += h5 & 65535;
        d3 += h5 >>> 16;
        b4 += a3 >>> 16;
        c4 += b4 >>> 16;
        d3 += c4 >>> 16;
        hh[2] = ah2 = c4 & 65535 | d3 << 16;
        hl[2] = al2 = a3 & 65535 | b4 << 16;
        h5 = ah3;
        l4 = al3;
        a3 = l4 & 65535;
        b4 = l4 >>> 16;
        c4 = h5 & 65535;
        d3 = h5 >>> 16;
        h5 = hh[3];
        l4 = hl[3];
        a3 += l4 & 65535;
        b4 += l4 >>> 16;
        c4 += h5 & 65535;
        d3 += h5 >>> 16;
        b4 += a3 >>> 16;
        c4 += b4 >>> 16;
        d3 += c4 >>> 16;
        hh[3] = ah3 = c4 & 65535 | d3 << 16;
        hl[3] = al3 = a3 & 65535 | b4 << 16;
        h5 = ah4;
        l4 = al4;
        a3 = l4 & 65535;
        b4 = l4 >>> 16;
        c4 = h5 & 65535;
        d3 = h5 >>> 16;
        h5 = hh[4];
        l4 = hl[4];
        a3 += l4 & 65535;
        b4 += l4 >>> 16;
        c4 += h5 & 65535;
        d3 += h5 >>> 16;
        b4 += a3 >>> 16;
        c4 += b4 >>> 16;
        d3 += c4 >>> 16;
        hh[4] = ah4 = c4 & 65535 | d3 << 16;
        hl[4] = al4 = a3 & 65535 | b4 << 16;
        h5 = ah5;
        l4 = al5;
        a3 = l4 & 65535;
        b4 = l4 >>> 16;
        c4 = h5 & 65535;
        d3 = h5 >>> 16;
        h5 = hh[5];
        l4 = hl[5];
        a3 += l4 & 65535;
        b4 += l4 >>> 16;
        c4 += h5 & 65535;
        d3 += h5 >>> 16;
        b4 += a3 >>> 16;
        c4 += b4 >>> 16;
        d3 += c4 >>> 16;
        hh[5] = ah5 = c4 & 65535 | d3 << 16;
        hl[5] = al5 = a3 & 65535 | b4 << 16;
        h5 = ah6;
        l4 = al6;
        a3 = l4 & 65535;
        b4 = l4 >>> 16;
        c4 = h5 & 65535;
        d3 = h5 >>> 16;
        h5 = hh[6];
        l4 = hl[6];
        a3 += l4 & 65535;
        b4 += l4 >>> 16;
        c4 += h5 & 65535;
        d3 += h5 >>> 16;
        b4 += a3 >>> 16;
        c4 += b4 >>> 16;
        d3 += c4 >>> 16;
        hh[6] = ah6 = c4 & 65535 | d3 << 16;
        hl[6] = al6 = a3 & 65535 | b4 << 16;
        h5 = ah7;
        l4 = al7;
        a3 = l4 & 65535;
        b4 = l4 >>> 16;
        c4 = h5 & 65535;
        d3 = h5 >>> 16;
        h5 = hh[7];
        l4 = hl[7];
        a3 += l4 & 65535;
        b4 += l4 >>> 16;
        c4 += h5 & 65535;
        d3 += h5 >>> 16;
        b4 += a3 >>> 16;
        c4 += b4 >>> 16;
        d3 += c4 >>> 16;
        hh[7] = ah7 = c4 & 65535 | d3 << 16;
        hl[7] = al7 = a3 & 65535 | b4 << 16;
        pos += 128;
        len -= 128;
      }
      return pos;
    }
    function hash(data) {
      var h5 = new SHA512();
      h5.update(data);
      var digest2 = h5.digest();
      h5.clean();
      return digest2;
    }
    exports2.hash = hash;
  }
});

// node_modules/@stablelib/ed25519/lib/ed25519.js
var require_ed25519 = __commonJS({
  "node_modules/@stablelib/ed25519/lib/ed25519.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.convertSecretKeyToX25519 = exports2.convertPublicKeyToX25519 = exports2.verify = exports2.sign = exports2.extractPublicKeyFromSecretKey = exports2.generateKeyPair = exports2.generateKeyPairFromSeed = exports2.SEED_LENGTH = exports2.SECRET_KEY_LENGTH = exports2.PUBLIC_KEY_LENGTH = exports2.SIGNATURE_LENGTH = void 0;
    var random_1 = require_random();
    var sha512_1 = require_sha512();
    var wipe_1 = require_wipe();
    exports2.SIGNATURE_LENGTH = 64;
    exports2.PUBLIC_KEY_LENGTH = 32;
    exports2.SECRET_KEY_LENGTH = 64;
    exports2.SEED_LENGTH = 32;
    function gf(init) {
      const r = new Float64Array(16);
      if (init) {
        for (let i2 = 0; i2 < init.length; i2++) {
          r[i2] = init[i2];
        }
      }
      return r;
    }
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var gf0 = gf();
    var gf1 = gf([1]);
    var D2 = gf([
      30883,
      4953,
      19914,
      30187,
      55467,
      16705,
      2637,
      112,
      59544,
      30585,
      16505,
      36039,
      65139,
      11119,
      27886,
      20995
    ]);
    var D22 = gf([
      61785,
      9906,
      39828,
      60374,
      45398,
      33411,
      5274,
      224,
      53552,
      61171,
      33010,
      6542,
      64743,
      22239,
      55772,
      9222
    ]);
    var X = gf([
      54554,
      36645,
      11616,
      51542,
      42930,
      38181,
      51040,
      26924,
      56412,
      64982,
      57905,
      49316,
      21502,
      52590,
      14035,
      8553
    ]);
    var Y = gf([
      26200,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214
    ]);
    var I2 = gf([
      41136,
      18958,
      6951,
      50414,
      58488,
      44335,
      6150,
      12099,
      55207,
      15867,
      153,
      11085,
      57099,
      20417,
      9344,
      11139
    ]);
    function set25519(r, a3) {
      for (let i2 = 0; i2 < 16; i2++) {
        r[i2] = a3[i2] | 0;
      }
    }
    function car25519(o2) {
      let c4 = 1;
      for (let i2 = 0; i2 < 16; i2++) {
        let v2 = o2[i2] + c4 + 65535;
        c4 = Math.floor(v2 / 65536);
        o2[i2] = v2 - c4 * 65536;
      }
      o2[0] += c4 - 1 + 37 * (c4 - 1);
    }
    function sel25519(p3, q2, b4) {
      const c4 = ~(b4 - 1);
      for (let i2 = 0; i2 < 16; i2++) {
        const t = c4 & (p3[i2] ^ q2[i2]);
        p3[i2] ^= t;
        q2[i2] ^= t;
      }
    }
    function pack25519(o2, n3) {
      const m3 = gf();
      const t = gf();
      for (let i2 = 0; i2 < 16; i2++) {
        t[i2] = n3[i2];
      }
      car25519(t);
      car25519(t);
      car25519(t);
      for (let j2 = 0; j2 < 2; j2++) {
        m3[0] = t[0] - 65517;
        for (let i2 = 1; i2 < 15; i2++) {
          m3[i2] = t[i2] - 65535 - (m3[i2 - 1] >> 16 & 1);
          m3[i2 - 1] &= 65535;
        }
        m3[15] = t[15] - 32767 - (m3[14] >> 16 & 1);
        const b4 = m3[15] >> 16 & 1;
        m3[14] &= 65535;
        sel25519(t, m3, 1 - b4);
      }
      for (let i2 = 0; i2 < 16; i2++) {
        o2[2 * i2] = t[i2] & 255;
        o2[2 * i2 + 1] = t[i2] >> 8;
      }
    }
    function verify32(x3, y4) {
      let d3 = 0;
      for (let i2 = 0; i2 < 32; i2++) {
        d3 |= x3[i2] ^ y4[i2];
      }
      return (1 & d3 - 1 >>> 8) - 1;
    }
    function neq25519(a3, b4) {
      const c4 = new Uint8Array(32);
      const d3 = new Uint8Array(32);
      pack25519(c4, a3);
      pack25519(d3, b4);
      return verify32(c4, d3);
    }
    function par25519(a3) {
      const d3 = new Uint8Array(32);
      pack25519(d3, a3);
      return d3[0] & 1;
    }
    function unpack25519(o2, n3) {
      for (let i2 = 0; i2 < 16; i2++) {
        o2[i2] = n3[2 * i2] + (n3[2 * i2 + 1] << 8);
      }
      o2[15] &= 32767;
    }
    function add(o2, a3, b4) {
      for (let i2 = 0; i2 < 16; i2++) {
        o2[i2] = a3[i2] + b4[i2];
      }
    }
    function sub(o2, a3, b4) {
      for (let i2 = 0; i2 < 16; i2++) {
        o2[i2] = a3[i2] - b4[i2];
      }
    }
    function mul(o2, a3, b4) {
      let v2, c4, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b4[0], b1 = b4[1], b22 = b4[2], b32 = b4[3], b42 = b4[4], b5 = b4[5], b6 = b4[6], b7 = b4[7], b8 = b4[8], b9 = b4[9], b10 = b4[10], b11 = b4[11], b12 = b4[12], b13 = b4[13], b14 = b4[14], b15 = b4[15];
      v2 = a3[0];
      t0 += v2 * b0;
      t1 += v2 * b1;
      t2 += v2 * b22;
      t3 += v2 * b32;
      t4 += v2 * b42;
      t5 += v2 * b5;
      t6 += v2 * b6;
      t7 += v2 * b7;
      t8 += v2 * b8;
      t9 += v2 * b9;
      t10 += v2 * b10;
      t11 += v2 * b11;
      t12 += v2 * b12;
      t13 += v2 * b13;
      t14 += v2 * b14;
      t15 += v2 * b15;
      v2 = a3[1];
      t1 += v2 * b0;
      t2 += v2 * b1;
      t3 += v2 * b22;
      t4 += v2 * b32;
      t5 += v2 * b42;
      t6 += v2 * b5;
      t7 += v2 * b6;
      t8 += v2 * b7;
      t9 += v2 * b8;
      t10 += v2 * b9;
      t11 += v2 * b10;
      t12 += v2 * b11;
      t13 += v2 * b12;
      t14 += v2 * b13;
      t15 += v2 * b14;
      t16 += v2 * b15;
      v2 = a3[2];
      t2 += v2 * b0;
      t3 += v2 * b1;
      t4 += v2 * b22;
      t5 += v2 * b32;
      t6 += v2 * b42;
      t7 += v2 * b5;
      t8 += v2 * b6;
      t9 += v2 * b7;
      t10 += v2 * b8;
      t11 += v2 * b9;
      t12 += v2 * b10;
      t13 += v2 * b11;
      t14 += v2 * b12;
      t15 += v2 * b13;
      t16 += v2 * b14;
      t17 += v2 * b15;
      v2 = a3[3];
      t3 += v2 * b0;
      t4 += v2 * b1;
      t5 += v2 * b22;
      t6 += v2 * b32;
      t7 += v2 * b42;
      t8 += v2 * b5;
      t9 += v2 * b6;
      t10 += v2 * b7;
      t11 += v2 * b8;
      t12 += v2 * b9;
      t13 += v2 * b10;
      t14 += v2 * b11;
      t15 += v2 * b12;
      t16 += v2 * b13;
      t17 += v2 * b14;
      t18 += v2 * b15;
      v2 = a3[4];
      t4 += v2 * b0;
      t5 += v2 * b1;
      t6 += v2 * b22;
      t7 += v2 * b32;
      t8 += v2 * b42;
      t9 += v2 * b5;
      t10 += v2 * b6;
      t11 += v2 * b7;
      t12 += v2 * b8;
      t13 += v2 * b9;
      t14 += v2 * b10;
      t15 += v2 * b11;
      t16 += v2 * b12;
      t17 += v2 * b13;
      t18 += v2 * b14;
      t19 += v2 * b15;
      v2 = a3[5];
      t5 += v2 * b0;
      t6 += v2 * b1;
      t7 += v2 * b22;
      t8 += v2 * b32;
      t9 += v2 * b42;
      t10 += v2 * b5;
      t11 += v2 * b6;
      t12 += v2 * b7;
      t13 += v2 * b8;
      t14 += v2 * b9;
      t15 += v2 * b10;
      t16 += v2 * b11;
      t17 += v2 * b12;
      t18 += v2 * b13;
      t19 += v2 * b14;
      t20 += v2 * b15;
      v2 = a3[6];
      t6 += v2 * b0;
      t7 += v2 * b1;
      t8 += v2 * b22;
      t9 += v2 * b32;
      t10 += v2 * b42;
      t11 += v2 * b5;
      t12 += v2 * b6;
      t13 += v2 * b7;
      t14 += v2 * b8;
      t15 += v2 * b9;
      t16 += v2 * b10;
      t17 += v2 * b11;
      t18 += v2 * b12;
      t19 += v2 * b13;
      t20 += v2 * b14;
      t21 += v2 * b15;
      v2 = a3[7];
      t7 += v2 * b0;
      t8 += v2 * b1;
      t9 += v2 * b22;
      t10 += v2 * b32;
      t11 += v2 * b42;
      t12 += v2 * b5;
      t13 += v2 * b6;
      t14 += v2 * b7;
      t15 += v2 * b8;
      t16 += v2 * b9;
      t17 += v2 * b10;
      t18 += v2 * b11;
      t19 += v2 * b12;
      t20 += v2 * b13;
      t21 += v2 * b14;
      t22 += v2 * b15;
      v2 = a3[8];
      t8 += v2 * b0;
      t9 += v2 * b1;
      t10 += v2 * b22;
      t11 += v2 * b32;
      t12 += v2 * b42;
      t13 += v2 * b5;
      t14 += v2 * b6;
      t15 += v2 * b7;
      t16 += v2 * b8;
      t17 += v2 * b9;
      t18 += v2 * b10;
      t19 += v2 * b11;
      t20 += v2 * b12;
      t21 += v2 * b13;
      t22 += v2 * b14;
      t23 += v2 * b15;
      v2 = a3[9];
      t9 += v2 * b0;
      t10 += v2 * b1;
      t11 += v2 * b22;
      t12 += v2 * b32;
      t13 += v2 * b42;
      t14 += v2 * b5;
      t15 += v2 * b6;
      t16 += v2 * b7;
      t17 += v2 * b8;
      t18 += v2 * b9;
      t19 += v2 * b10;
      t20 += v2 * b11;
      t21 += v2 * b12;
      t22 += v2 * b13;
      t23 += v2 * b14;
      t24 += v2 * b15;
      v2 = a3[10];
      t10 += v2 * b0;
      t11 += v2 * b1;
      t12 += v2 * b22;
      t13 += v2 * b32;
      t14 += v2 * b42;
      t15 += v2 * b5;
      t16 += v2 * b6;
      t17 += v2 * b7;
      t18 += v2 * b8;
      t19 += v2 * b9;
      t20 += v2 * b10;
      t21 += v2 * b11;
      t22 += v2 * b12;
      t23 += v2 * b13;
      t24 += v2 * b14;
      t25 += v2 * b15;
      v2 = a3[11];
      t11 += v2 * b0;
      t12 += v2 * b1;
      t13 += v2 * b22;
      t14 += v2 * b32;
      t15 += v2 * b42;
      t16 += v2 * b5;
      t17 += v2 * b6;
      t18 += v2 * b7;
      t19 += v2 * b8;
      t20 += v2 * b9;
      t21 += v2 * b10;
      t22 += v2 * b11;
      t23 += v2 * b12;
      t24 += v2 * b13;
      t25 += v2 * b14;
      t26 += v2 * b15;
      v2 = a3[12];
      t12 += v2 * b0;
      t13 += v2 * b1;
      t14 += v2 * b22;
      t15 += v2 * b32;
      t16 += v2 * b42;
      t17 += v2 * b5;
      t18 += v2 * b6;
      t19 += v2 * b7;
      t20 += v2 * b8;
      t21 += v2 * b9;
      t22 += v2 * b10;
      t23 += v2 * b11;
      t24 += v2 * b12;
      t25 += v2 * b13;
      t26 += v2 * b14;
      t27 += v2 * b15;
      v2 = a3[13];
      t13 += v2 * b0;
      t14 += v2 * b1;
      t15 += v2 * b22;
      t16 += v2 * b32;
      t17 += v2 * b42;
      t18 += v2 * b5;
      t19 += v2 * b6;
      t20 += v2 * b7;
      t21 += v2 * b8;
      t22 += v2 * b9;
      t23 += v2 * b10;
      t24 += v2 * b11;
      t25 += v2 * b12;
      t26 += v2 * b13;
      t27 += v2 * b14;
      t28 += v2 * b15;
      v2 = a3[14];
      t14 += v2 * b0;
      t15 += v2 * b1;
      t16 += v2 * b22;
      t17 += v2 * b32;
      t18 += v2 * b42;
      t19 += v2 * b5;
      t20 += v2 * b6;
      t21 += v2 * b7;
      t22 += v2 * b8;
      t23 += v2 * b9;
      t24 += v2 * b10;
      t25 += v2 * b11;
      t26 += v2 * b12;
      t27 += v2 * b13;
      t28 += v2 * b14;
      t29 += v2 * b15;
      v2 = a3[15];
      t15 += v2 * b0;
      t16 += v2 * b1;
      t17 += v2 * b22;
      t18 += v2 * b32;
      t19 += v2 * b42;
      t20 += v2 * b5;
      t21 += v2 * b6;
      t22 += v2 * b7;
      t23 += v2 * b8;
      t24 += v2 * b9;
      t25 += v2 * b10;
      t26 += v2 * b11;
      t27 += v2 * b12;
      t28 += v2 * b13;
      t29 += v2 * b14;
      t30 += v2 * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c4 = 1;
      v2 = t0 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t0 = v2 - c4 * 65536;
      v2 = t1 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t1 = v2 - c4 * 65536;
      v2 = t2 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t2 = v2 - c4 * 65536;
      v2 = t3 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t3 = v2 - c4 * 65536;
      v2 = t4 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t4 = v2 - c4 * 65536;
      v2 = t5 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t5 = v2 - c4 * 65536;
      v2 = t6 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t6 = v2 - c4 * 65536;
      v2 = t7 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t7 = v2 - c4 * 65536;
      v2 = t8 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t8 = v2 - c4 * 65536;
      v2 = t9 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t9 = v2 - c4 * 65536;
      v2 = t10 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t10 = v2 - c4 * 65536;
      v2 = t11 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t11 = v2 - c4 * 65536;
      v2 = t12 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t12 = v2 - c4 * 65536;
      v2 = t13 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t13 = v2 - c4 * 65536;
      v2 = t14 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t14 = v2 - c4 * 65536;
      v2 = t15 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t15 = v2 - c4 * 65536;
      t0 += c4 - 1 + 37 * (c4 - 1);
      c4 = 1;
      v2 = t0 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t0 = v2 - c4 * 65536;
      v2 = t1 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t1 = v2 - c4 * 65536;
      v2 = t2 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t2 = v2 - c4 * 65536;
      v2 = t3 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t3 = v2 - c4 * 65536;
      v2 = t4 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t4 = v2 - c4 * 65536;
      v2 = t5 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t5 = v2 - c4 * 65536;
      v2 = t6 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t6 = v2 - c4 * 65536;
      v2 = t7 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t7 = v2 - c4 * 65536;
      v2 = t8 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t8 = v2 - c4 * 65536;
      v2 = t9 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t9 = v2 - c4 * 65536;
      v2 = t10 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t10 = v2 - c4 * 65536;
      v2 = t11 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t11 = v2 - c4 * 65536;
      v2 = t12 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t12 = v2 - c4 * 65536;
      v2 = t13 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t13 = v2 - c4 * 65536;
      v2 = t14 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t14 = v2 - c4 * 65536;
      v2 = t15 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t15 = v2 - c4 * 65536;
      t0 += c4 - 1 + 37 * (c4 - 1);
      o2[0] = t0;
      o2[1] = t1;
      o2[2] = t2;
      o2[3] = t3;
      o2[4] = t4;
      o2[5] = t5;
      o2[6] = t6;
      o2[7] = t7;
      o2[8] = t8;
      o2[9] = t9;
      o2[10] = t10;
      o2[11] = t11;
      o2[12] = t12;
      o2[13] = t13;
      o2[14] = t14;
      o2[15] = t15;
    }
    function square(o2, a3) {
      mul(o2, a3, a3);
    }
    function inv25519(o2, i2) {
      const c4 = gf();
      let a3;
      for (a3 = 0; a3 < 16; a3++) {
        c4[a3] = i2[a3];
      }
      for (a3 = 253; a3 >= 0; a3--) {
        square(c4, c4);
        if (a3 !== 2 && a3 !== 4) {
          mul(c4, c4, i2);
        }
      }
      for (a3 = 0; a3 < 16; a3++) {
        o2[a3] = c4[a3];
      }
    }
    function pow2523(o2, i2) {
      const c4 = gf();
      let a3;
      for (a3 = 0; a3 < 16; a3++) {
        c4[a3] = i2[a3];
      }
      for (a3 = 250; a3 >= 0; a3--) {
        square(c4, c4);
        if (a3 !== 1) {
          mul(c4, c4, i2);
        }
      }
      for (a3 = 0; a3 < 16; a3++) {
        o2[a3] = c4[a3];
      }
    }
    function edadd(p3, q2) {
      const a3 = gf(), b4 = gf(), c4 = gf(), d3 = gf(), e2 = gf(), f4 = gf(), g3 = gf(), h5 = gf(), t = gf();
      sub(a3, p3[1], p3[0]);
      sub(t, q2[1], q2[0]);
      mul(a3, a3, t);
      add(b4, p3[0], p3[1]);
      add(t, q2[0], q2[1]);
      mul(b4, b4, t);
      mul(c4, p3[3], q2[3]);
      mul(c4, c4, D22);
      mul(d3, p3[2], q2[2]);
      add(d3, d3, d3);
      sub(e2, b4, a3);
      sub(f4, d3, c4);
      add(g3, d3, c4);
      add(h5, b4, a3);
      mul(p3[0], e2, f4);
      mul(p3[1], h5, g3);
      mul(p3[2], g3, f4);
      mul(p3[3], e2, h5);
    }
    function cswap(p3, q2, b4) {
      for (let i2 = 0; i2 < 4; i2++) {
        sel25519(p3[i2], q2[i2], b4);
      }
    }
    function pack(r, p3) {
      const tx = gf(), ty = gf(), zi = gf();
      inv25519(zi, p3[2]);
      mul(tx, p3[0], zi);
      mul(ty, p3[1], zi);
      pack25519(r, ty);
      r[31] ^= par25519(tx) << 7;
    }
    function scalarmult(p3, q2, s2) {
      set25519(p3[0], gf0);
      set25519(p3[1], gf1);
      set25519(p3[2], gf1);
      set25519(p3[3], gf0);
      for (let i2 = 255; i2 >= 0; --i2) {
        const b4 = s2[i2 / 8 | 0] >> (i2 & 7) & 1;
        cswap(p3, q2, b4);
        edadd(q2, p3);
        edadd(p3, p3);
        cswap(p3, q2, b4);
      }
    }
    function scalarbase(p3, s2) {
      const q2 = [gf(), gf(), gf(), gf()];
      set25519(q2[0], X);
      set25519(q2[1], Y);
      set25519(q2[2], gf1);
      mul(q2[3], X, Y);
      scalarmult(p3, q2, s2);
    }
    function generateKeyPairFromSeed2(seed) {
      if (seed.length !== exports2.SEED_LENGTH) {
        throw new Error(`ed25519: seed must be ${exports2.SEED_LENGTH} bytes`);
      }
      const d3 = (0, sha512_1.hash)(seed);
      d3[0] &= 248;
      d3[31] &= 127;
      d3[31] |= 64;
      const publicKey = new Uint8Array(32);
      const p3 = [gf(), gf(), gf(), gf()];
      scalarbase(p3, d3);
      pack(publicKey, p3);
      const secretKey = new Uint8Array(64);
      secretKey.set(seed);
      secretKey.set(publicKey, 32);
      return {
        publicKey,
        secretKey
      };
    }
    exports2.generateKeyPairFromSeed = generateKeyPairFromSeed2;
    function generateKeyPair2(prng) {
      const seed = (0, random_1.randomBytes)(32, prng);
      const result = generateKeyPairFromSeed2(seed);
      (0, wipe_1.wipe)(seed);
      return result;
    }
    exports2.generateKeyPair = generateKeyPair2;
    function extractPublicKeyFromSecretKey(secretKey) {
      if (secretKey.length !== exports2.SECRET_KEY_LENGTH) {
        throw new Error(`ed25519: secret key must be ${exports2.SECRET_KEY_LENGTH} bytes`);
      }
      return new Uint8Array(secretKey.subarray(32));
    }
    exports2.extractPublicKeyFromSecretKey = extractPublicKeyFromSecretKey;
    var L2 = new Float64Array([
      237,
      211,
      245,
      92,
      26,
      99,
      18,
      88,
      214,
      156,
      247,
      162,
      222,
      249,
      222,
      20,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      16
    ]);
    function modL(r, x3) {
      let carry;
      let i2;
      let j2;
      let k4;
      for (i2 = 63; i2 >= 32; --i2) {
        carry = 0;
        for (j2 = i2 - 32, k4 = i2 - 12; j2 < k4; ++j2) {
          x3[j2] += carry - 16 * x3[i2] * L2[j2 - (i2 - 32)];
          carry = Math.floor((x3[j2] + 128) / 256);
          x3[j2] -= carry * 256;
        }
        x3[j2] += carry;
        x3[i2] = 0;
      }
      carry = 0;
      for (j2 = 0; j2 < 32; j2++) {
        x3[j2] += carry - (x3[31] >> 4) * L2[j2];
        carry = x3[j2] >> 8;
        x3[j2] &= 255;
      }
      for (j2 = 0; j2 < 32; j2++) {
        x3[j2] -= carry * L2[j2];
      }
      for (i2 = 0; i2 < 32; i2++) {
        x3[i2 + 1] += x3[i2] >> 8;
        r[i2] = x3[i2] & 255;
      }
    }
    function reduce(r) {
      const x3 = new Float64Array(64);
      for (let i2 = 0; i2 < 64; i2++) {
        x3[i2] = r[i2];
      }
      for (let i2 = 0; i2 < 64; i2++) {
        r[i2] = 0;
      }
      modL(r, x3);
    }
    function sign2(secretKey, message) {
      const x3 = new Float64Array(64);
      const p3 = [gf(), gf(), gf(), gf()];
      const d3 = (0, sha512_1.hash)(secretKey.subarray(0, 32));
      d3[0] &= 248;
      d3[31] &= 127;
      d3[31] |= 64;
      const signature = new Uint8Array(64);
      signature.set(d3.subarray(32), 32);
      const hs = new sha512_1.SHA512();
      hs.update(signature.subarray(32));
      hs.update(message);
      const r = hs.digest();
      hs.clean();
      reduce(r);
      scalarbase(p3, r);
      pack(signature, p3);
      hs.reset();
      hs.update(signature.subarray(0, 32));
      hs.update(secretKey.subarray(32));
      hs.update(message);
      const h5 = hs.digest();
      reduce(h5);
      for (let i2 = 0; i2 < 32; i2++) {
        x3[i2] = r[i2];
      }
      for (let i2 = 0; i2 < 32; i2++) {
        for (let j2 = 0; j2 < 32; j2++) {
          x3[i2 + j2] += h5[i2] * d3[j2];
        }
      }
      modL(signature.subarray(32), x3);
      return signature;
    }
    exports2.sign = sign2;
    function unpackneg(r, p3) {
      const t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
      set25519(r[2], gf1);
      unpack25519(r[1], p3);
      square(num, r[1]);
      mul(den, num, D2);
      sub(num, num, r[2]);
      add(den, r[2], den);
      square(den2, den);
      square(den4, den2);
      mul(den6, den4, den2);
      mul(t, den6, num);
      mul(t, t, den);
      pow2523(t, t);
      mul(t, t, num);
      mul(t, t, den);
      mul(t, t, den);
      mul(r[0], t, den);
      square(chk, r[0]);
      mul(chk, chk, den);
      if (neq25519(chk, num)) {
        mul(r[0], r[0], I2);
      }
      square(chk, r[0]);
      mul(chk, chk, den);
      if (neq25519(chk, num)) {
        return -1;
      }
      if (par25519(r[0]) === p3[31] >> 7) {
        sub(r[0], gf0, r[0]);
      }
      mul(r[3], r[0], r[1]);
      return 0;
    }
    function verify2(publicKey, message, signature) {
      const t = new Uint8Array(32);
      const p3 = [gf(), gf(), gf(), gf()];
      const q2 = [gf(), gf(), gf(), gf()];
      if (signature.length !== exports2.SIGNATURE_LENGTH) {
        throw new Error(`ed25519: signature must be ${exports2.SIGNATURE_LENGTH} bytes`);
      }
      if (unpackneg(q2, publicKey)) {
        return false;
      }
      const hs = new sha512_1.SHA512();
      hs.update(signature.subarray(0, 32));
      hs.update(publicKey);
      hs.update(message);
      const h5 = hs.digest();
      reduce(h5);
      scalarmult(p3, q2, h5);
      scalarbase(q2, signature.subarray(32));
      edadd(p3, q2);
      pack(t, p3);
      if (verify32(signature, t)) {
        return false;
      }
      return true;
    }
    exports2.verify = verify2;
    function convertPublicKeyToX25519(publicKey) {
      let q2 = [gf(), gf(), gf(), gf()];
      if (unpackneg(q2, publicKey)) {
        throw new Error("Ed25519: invalid public key");
      }
      let a3 = gf();
      let b4 = gf();
      let y4 = q2[1];
      add(a3, gf1, y4);
      sub(b4, gf1, y4);
      inv25519(b4, b4);
      mul(a3, a3, b4);
      let z3 = new Uint8Array(32);
      pack25519(z3, a3);
      return z3;
    }
    exports2.convertPublicKeyToX25519 = convertPublicKeyToX25519;
    function convertSecretKeyToX25519(secretKey) {
      const d3 = (0, sha512_1.hash)(secretKey.subarray(0, 32));
      d3[0] &= 248;
      d3[31] &= 127;
      d3[31] |= 64;
      const o2 = new Uint8Array(d3.subarray(0, 32));
      (0, wipe_1.wipe)(d3);
      return o2;
    }
    exports2.convertSecretKeyToX25519 = convertSecretKeyToX25519;
  }
});

// node_modules/@walletconnect/relay-auth/dist/esm/constants.js
var JWT_IRIDIUM_ALG, JWT_IRIDIUM_TYP, JWT_DELIMITER, JWT_ENCODING, JSON_ENCODING, DATA_ENCODING, DID_DELIMITER, DID_PREFIX, DID_METHOD, MULTICODEC_ED25519_ENCODING, MULTICODEC_ED25519_BASE, MULTICODEC_ED25519_HEADER, MULTICODEC_ED25519_LENGTH, KEY_PAIR_SEED_LENGTH;
var init_constants = __esm({
  "node_modules/@walletconnect/relay-auth/dist/esm/constants.js"() {
    init_shim();
    JWT_IRIDIUM_ALG = "EdDSA";
    JWT_IRIDIUM_TYP = "JWT";
    JWT_DELIMITER = ".";
    JWT_ENCODING = "base64url";
    JSON_ENCODING = "utf8";
    DATA_ENCODING = "utf8";
    DID_DELIMITER = ":";
    DID_PREFIX = "did";
    DID_METHOD = "key";
    MULTICODEC_ED25519_ENCODING = "base58btc";
    MULTICODEC_ED25519_BASE = "z";
    MULTICODEC_ED25519_HEADER = "K36";
    MULTICODEC_ED25519_LENGTH = 32;
    KEY_PAIR_SEED_LENGTH = 32;
  }
});

// node_modules/uint8arrays/esm/src/util/as-uint8array.js
function asUint8Array(buf) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return buf;
}
var init_as_uint8array = __esm({
  "node_modules/uint8arrays/esm/src/util/as-uint8array.js"() {
    init_shim();
  }
});

// node_modules/uint8arrays/esm/src/alloc.js
function allocUnsafe(size = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}
var init_alloc = __esm({
  "node_modules/uint8arrays/esm/src/alloc.js"() {
    init_shim();
    init_as_uint8array();
  }
});

// node_modules/uint8arrays/esm/src/concat.js
function concat(arrays, length2) {
  if (!length2) {
    length2 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe(length2);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array(output);
}
var init_concat = __esm({
  "node_modules/uint8arrays/esm/src/concat.js"() {
    init_shim();
    init_alloc();
    init_as_uint8array();
  }
});

// node_modules/multiformats/esm/vendor/base-x.js
function base(ALPHABET, name2) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j2 = 0; j2 < BASE_MAP.length; j2++) {
    BASE_MAP[j2] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x3 = ALPHABET.charAt(i2);
    var xc = x3.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x3 + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE2 = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE2) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE2);
  function encode5(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length2) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE2 >>> 0;
        carry = carry / BASE2 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      pbegin++;
    }
    var it2 = size - length2;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length2) && it3 !== -1; it3--, i3++) {
        carry += BASE2 * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length2;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j3 = zeroes;
    while (it4 !== size) {
      vch[j3++] = b256[it4++];
    }
    return vch;
  }
  function decode6(string2) {
    var buffer = decodeUnsafe(string2);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name2} character`);
  }
  return {
    encode: encode5,
    decodeUnsafe,
    decode: decode6
  };
}
var src, _brrp__multiformats_scope_baseX, base_x_default;
var init_base_x = __esm({
  "node_modules/multiformats/esm/vendor/base-x.js"() {
    init_shim();
    src = base;
    _brrp__multiformats_scope_baseX = src;
    base_x_default = _brrp__multiformats_scope_baseX;
  }
});

// node_modules/multiformats/esm/src/bytes.js
var empty, equals, coerce, fromString, toString;
var init_bytes = __esm({
  "node_modules/multiformats/esm/src/bytes.js"() {
    init_shim();
    empty = new Uint8Array(0);
    equals = (aa, bb) => {
      if (aa === bb)
        return true;
      if (aa.byteLength !== bb.byteLength) {
        return false;
      }
      for (let ii = 0; ii < aa.byteLength; ii++) {
        if (aa[ii] !== bb[ii]) {
          return false;
        }
      }
      return true;
    };
    coerce = (o2) => {
      if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array")
        return o2;
      if (o2 instanceof ArrayBuffer)
        return new Uint8Array(o2);
      if (ArrayBuffer.isView(o2)) {
        return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
      }
      throw new Error("Unknown type, must be binary type");
    };
    fromString = (str) => new TextEncoder().encode(str);
    toString = (b4) => new TextDecoder().decode(b4);
  }
});

// node_modules/multiformats/esm/src/bases/base.js
var Encoder, Decoder, ComposedDecoder, or, Codec, from, baseX, decode, encode, rfc4648;
var init_base = __esm({
  "node_modules/multiformats/esm/src/bases/base.js"() {
    init_shim();
    init_base_x();
    init_bytes();
    Encoder = class {
      constructor(name2, prefix, baseEncode) {
        this.name = name2;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
      }
      encode(bytes) {
        if (bytes instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    Decoder = class {
      constructor(name2, prefix, baseDecode) {
        this.name = name2;
        this.prefix = prefix;
        if (prefix.codePointAt(0) === void 0) {
          throw new Error("Invalid prefix character");
        }
        this.prefixCodePoint = prefix.codePointAt(0);
        this.baseDecode = baseDecode;
      }
      decode(text) {
        if (typeof text === "string") {
          if (text.codePointAt(0) !== this.prefixCodePoint) {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          }
          return this.baseDecode(text.slice(this.prefix.length));
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      or(decoder) {
        return or(this, decoder);
      }
    };
    ComposedDecoder = class {
      constructor(decoders) {
        this.decoders = decoders;
      }
      or(decoder) {
        return or(this, decoder);
      }
      decode(input) {
        const prefix = input[0];
        const decoder = this.decoders[prefix];
        if (decoder) {
          return decoder.decode(input);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    or = (left, right) => new ComposedDecoder({
      ...left.decoders || { [left.prefix]: left },
      ...right.decoders || { [right.prefix]: right }
    });
    Codec = class {
      constructor(name2, prefix, baseEncode, baseDecode) {
        this.name = name2;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder(name2, prefix, baseEncode);
        this.decoder = new Decoder(name2, prefix, baseDecode);
      }
      encode(input) {
        return this.encoder.encode(input);
      }
      decode(input) {
        return this.decoder.decode(input);
      }
    };
    from = ({ name: name2, prefix, encode: encode5, decode: decode6 }) => new Codec(name2, prefix, encode5, decode6);
    baseX = ({ prefix, name: name2, alphabet: alphabet2 }) => {
      const { encode: encode5, decode: decode6 } = base_x_default(alphabet2, name2);
      return from({
        prefix,
        name: name2,
        encode: encode5,
        decode: (text) => coerce(decode6(text))
      });
    };
    decode = (string2, alphabet2, bitsPerChar, name2) => {
      const codes = {};
      for (let i2 = 0; i2 < alphabet2.length; ++i2) {
        codes[alphabet2[i2]] = i2;
      }
      let end = string2.length;
      while (string2[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer = 0;
      let written = 0;
      for (let i2 = 0; i2 < end; ++i2) {
        const value = codes[string2[i2]];
        if (value === void 0) {
          throw new SyntaxError(`Non-${name2} character`);
        }
        buffer = buffer << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    encode = (data, alphabet2, bitsPerChar) => {
      const pad = alphabet2[alphabet2.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer = 0;
      for (let i2 = 0; i2 < data.length; ++i2) {
        buffer = buffer << 8 | data[i2];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet2[mask & buffer >> bits];
        }
      }
      if (bits) {
        out += alphabet2[mask & buffer << bitsPerChar - bits];
      }
      if (pad) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    rfc4648 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
      return from({
        prefix,
        name: name2,
        encode(input) {
          return encode(input, alphabet2, bitsPerChar);
        },
        decode(input) {
          return decode(input, alphabet2, bitsPerChar, name2);
        }
      });
    };
  }
});

// node_modules/multiformats/esm/src/bases/identity.js
var identity_exports = {};
__export(identity_exports, {
  identity: () => identity
});
var identity;
var init_identity = __esm({
  "node_modules/multiformats/esm/src/bases/identity.js"() {
    init_shim();
    init_base();
    init_bytes();
    identity = from({
      prefix: "\0",
      name: "identity",
      encode: (buf) => toString(buf),
      decode: (str) => fromString(str)
    });
  }
});

// node_modules/multiformats/esm/src/bases/base2.js
var base2_exports = {};
__export(base2_exports, {
  base2: () => base2
});
var base2;
var init_base2 = __esm({
  "node_modules/multiformats/esm/src/bases/base2.js"() {
    init_shim();
    init_base();
    base2 = rfc4648({
      prefix: "0",
      name: "base2",
      alphabet: "01",
      bitsPerChar: 1
    });
  }
});

// node_modules/multiformats/esm/src/bases/base8.js
var base8_exports = {};
__export(base8_exports, {
  base8: () => base8
});
var base8;
var init_base8 = __esm({
  "node_modules/multiformats/esm/src/bases/base8.js"() {
    init_shim();
    init_base();
    base8 = rfc4648({
      prefix: "7",
      name: "base8",
      alphabet: "01234567",
      bitsPerChar: 3
    });
  }
});

// node_modules/multiformats/esm/src/bases/base10.js
var base10_exports = {};
__export(base10_exports, {
  base10: () => base10
});
var base10;
var init_base10 = __esm({
  "node_modules/multiformats/esm/src/bases/base10.js"() {
    init_shim();
    init_base();
    base10 = baseX({
      prefix: "9",
      name: "base10",
      alphabet: "0123456789"
    });
  }
});

// node_modules/multiformats/esm/src/bases/base16.js
var base16_exports = {};
__export(base16_exports, {
  base16: () => base16,
  base16upper: () => base16upper
});
var base16, base16upper;
var init_base16 = __esm({
  "node_modules/multiformats/esm/src/bases/base16.js"() {
    init_shim();
    init_base();
    base16 = rfc4648({
      prefix: "f",
      name: "base16",
      alphabet: "0123456789abcdef",
      bitsPerChar: 4
    });
    base16upper = rfc4648({
      prefix: "F",
      name: "base16upper",
      alphabet: "0123456789ABCDEF",
      bitsPerChar: 4
    });
  }
});

// node_modules/multiformats/esm/src/bases/base32.js
var base32_exports = {};
__export(base32_exports, {
  base32: () => base32,
  base32hex: () => base32hex,
  base32hexpad: () => base32hexpad,
  base32hexpadupper: () => base32hexpadupper,
  base32hexupper: () => base32hexupper,
  base32pad: () => base32pad,
  base32padupper: () => base32padupper,
  base32upper: () => base32upper,
  base32z: () => base32z
});
var base32, base32upper, base32pad, base32padupper, base32hex, base32hexupper, base32hexpad, base32hexpadupper, base32z;
var init_base32 = __esm({
  "node_modules/multiformats/esm/src/bases/base32.js"() {
    init_shim();
    init_base();
    base32 = rfc4648({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    base32upper = rfc4648({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    base32pad = rfc4648({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    base32padupper = rfc4648({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    base32hex = rfc4648({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    base32hexupper = rfc4648({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    base32hexpad = rfc4648({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    base32hexpadupper = rfc4648({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    base32z = rfc4648({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
  }
});

// node_modules/multiformats/esm/src/bases/base36.js
var base36_exports = {};
__export(base36_exports, {
  base36: () => base36,
  base36upper: () => base36upper
});
var base36, base36upper;
var init_base36 = __esm({
  "node_modules/multiformats/esm/src/bases/base36.js"() {
    init_shim();
    init_base();
    base36 = baseX({
      prefix: "k",
      name: "base36",
      alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    });
    base36upper = baseX({
      prefix: "K",
      name: "base36upper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    });
  }
});

// node_modules/multiformats/esm/src/bases/base58.js
var base58_exports = {};
__export(base58_exports, {
  base58btc: () => base58btc,
  base58flickr: () => base58flickr
});
var base58btc, base58flickr;
var init_base58 = __esm({
  "node_modules/multiformats/esm/src/bases/base58.js"() {
    init_shim();
    init_base();
    base58btc = baseX({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    base58flickr = baseX({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
  }
});

// node_modules/multiformats/esm/src/bases/base64.js
var base64_exports = {};
__export(base64_exports, {
  base64: () => base64,
  base64pad: () => base64pad,
  base64url: () => base64url,
  base64urlpad: () => base64urlpad
});
var base64, base64pad, base64url, base64urlpad;
var init_base64 = __esm({
  "node_modules/multiformats/esm/src/bases/base64.js"() {
    init_shim();
    init_base();
    base64 = rfc4648({
      prefix: "m",
      name: "base64",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      bitsPerChar: 6
    });
    base64pad = rfc4648({
      prefix: "M",
      name: "base64pad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      bitsPerChar: 6
    });
    base64url = rfc4648({
      prefix: "u",
      name: "base64url",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
      bitsPerChar: 6
    });
    base64urlpad = rfc4648({
      prefix: "U",
      name: "base64urlpad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
      bitsPerChar: 6
    });
  }
});

// node_modules/multiformats/esm/src/bases/base256emoji.js
var base256emoji_exports = {};
__export(base256emoji_exports, {
  base256emoji: () => base256emoji
});
function encode2(data) {
  return data.reduce((p3, c4) => {
    p3 += alphabetBytesToChars[c4];
    return p3;
  }, "");
}
function decode2(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var alphabet, alphabetBytesToChars, alphabetCharsToBytes, base256emoji;
var init_base256emoji = __esm({
  "node_modules/multiformats/esm/src/bases/base256emoji.js"() {
    init_shim();
    init_base();
    alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
    alphabetBytesToChars = alphabet.reduce((p3, c4, i2) => {
      p3[i2] = c4;
      return p3;
    }, []);
    alphabetCharsToBytes = alphabet.reduce((p3, c4, i2) => {
      p3[c4.codePointAt(0)] = i2;
      return p3;
    }, []);
    base256emoji = from({
      prefix: "\u{1F680}",
      name: "base256emoji",
      encode: encode2,
      decode: decode2
    });
  }
});

// node_modules/multiformats/esm/vendor/varint.js
function encode3(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode3.bytes = offset - oldOffset + 1;
  return out;
}
function read(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b4, l4 = buf.length;
  do {
    if (counter >= l4) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b4 = buf[counter++];
    res += shift < 28 ? (b4 & REST$1) << shift : (b4 & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b4 >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var encode_1, MSB, REST, MSBALL, INT, decode3, MSB$1, REST$1, N1, N2, N3, N4, N5, N6, N7, N8, N9, length, varint, _brrp_varint, varint_default;
var init_varint = __esm({
  "node_modules/multiformats/esm/vendor/varint.js"() {
    init_shim();
    encode_1 = encode3;
    MSB = 128;
    REST = 127;
    MSBALL = ~REST;
    INT = Math.pow(2, 31);
    decode3 = read;
    MSB$1 = 128;
    REST$1 = 127;
    N1 = Math.pow(2, 7);
    N2 = Math.pow(2, 14);
    N3 = Math.pow(2, 21);
    N4 = Math.pow(2, 28);
    N5 = Math.pow(2, 35);
    N6 = Math.pow(2, 42);
    N7 = Math.pow(2, 49);
    N8 = Math.pow(2, 56);
    N9 = Math.pow(2, 63);
    length = function(value) {
      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
    };
    varint = {
      encode: encode_1,
      decode: decode3,
      encodingLength: length
    };
    _brrp_varint = varint;
    varint_default = _brrp_varint;
  }
});

// node_modules/multiformats/esm/src/varint.js
var decode4, encodeTo, encodingLength;
var init_varint2 = __esm({
  "node_modules/multiformats/esm/src/varint.js"() {
    init_shim();
    init_varint();
    decode4 = (data, offset = 0) => {
      const code2 = varint_default.decode(data, offset);
      return [
        code2,
        varint_default.decode.bytes
      ];
    };
    encodeTo = (int, target, offset = 0) => {
      varint_default.encode(int, target, offset);
      return target;
    };
    encodingLength = (int) => {
      return varint_default.encodingLength(int);
    };
  }
});

// node_modules/multiformats/esm/src/hashes/digest.js
var create, decode5, equals2, Digest;
var init_digest = __esm({
  "node_modules/multiformats/esm/src/hashes/digest.js"() {
    init_shim();
    init_bytes();
    init_varint2();
    create = (code2, digest2) => {
      const size = digest2.byteLength;
      const sizeOffset = encodingLength(code2);
      const digestOffset = sizeOffset + encodingLength(size);
      const bytes = new Uint8Array(digestOffset + size);
      encodeTo(code2, bytes, 0);
      encodeTo(size, bytes, sizeOffset);
      bytes.set(digest2, digestOffset);
      return new Digest(code2, size, digest2, bytes);
    };
    decode5 = (multihash) => {
      const bytes = coerce(multihash);
      const [code2, sizeOffset] = decode4(bytes);
      const [size, digestOffset] = decode4(bytes.subarray(sizeOffset));
      const digest2 = bytes.subarray(sizeOffset + digestOffset);
      if (digest2.byteLength !== size) {
        throw new Error("Incorrect length");
      }
      return new Digest(code2, size, digest2, bytes);
    };
    equals2 = (a3, b4) => {
      if (a3 === b4) {
        return true;
      } else {
        return a3.code === b4.code && a3.size === b4.size && equals(a3.bytes, b4.bytes);
      }
    };
    Digest = class {
      constructor(code2, size, digest2, bytes) {
        this.code = code2;
        this.size = size;
        this.digest = digest2;
        this.bytes = bytes;
      }
    };
  }
});

// node_modules/multiformats/esm/src/hashes/hasher.js
var from2, Hasher;
var init_hasher = __esm({
  "node_modules/multiformats/esm/src/hashes/hasher.js"() {
    init_shim();
    init_digest();
    from2 = ({ name: name2, code: code2, encode: encode5 }) => new Hasher(name2, code2, encode5);
    Hasher = class {
      constructor(name2, code2, encode5) {
        this.name = name2;
        this.code = code2;
        this.encode = encode5;
      }
      digest(input) {
        if (input instanceof Uint8Array) {
          const result = this.encode(input);
          return result instanceof Uint8Array ? create(this.code, result) : result.then((digest2) => create(this.code, digest2));
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
  }
});

// node_modules/multiformats/esm/src/hashes/sha2-browser.js
var sha2_browser_exports = {};
__export(sha2_browser_exports, {
  sha256: () => sha256,
  sha512: () => sha512
});
var sha, sha256, sha512;
var init_sha2_browser = __esm({
  "node_modules/multiformats/esm/src/hashes/sha2-browser.js"() {
    init_shim();
    init_hasher();
    sha = (name2) => async (data) => new Uint8Array(await crypto.subtle.digest(name2, data));
    sha256 = from2({
      name: "sha2-256",
      code: 18,
      encode: sha("SHA-256")
    });
    sha512 = from2({
      name: "sha2-512",
      code: 19,
      encode: sha("SHA-512")
    });
  }
});

// node_modules/multiformats/esm/src/hashes/identity.js
var identity_exports2 = {};
__export(identity_exports2, {
  identity: () => identity2
});
var code, name, encode4, digest, identity2;
var init_identity2 = __esm({
  "node_modules/multiformats/esm/src/hashes/identity.js"() {
    init_shim();
    init_bytes();
    init_digest();
    code = 0;
    name = "identity";
    encode4 = coerce;
    digest = (input) => create(code, encode4(input));
    identity2 = {
      code,
      name,
      encode: encode4,
      digest
    };
  }
});

// node_modules/multiformats/esm/src/codecs/raw.js
var init_raw = __esm({
  "node_modules/multiformats/esm/src/codecs/raw.js"() {
    init_shim();
    init_bytes();
  }
});

// node_modules/multiformats/esm/src/codecs/json.js
var textEncoder, textDecoder;
var init_json = __esm({
  "node_modules/multiformats/esm/src/codecs/json.js"() {
    init_shim();
    textEncoder = new TextEncoder();
    textDecoder = new TextDecoder();
  }
});

// node_modules/multiformats/esm/src/cid.js
var CID, parseCIDtoBytes, toStringV0, toStringV1, DAG_PB_CODE, SHA_256_CODE, encodeCID, cidSymbol, readonly, hidden, version, deprecate, IS_CID_DEPRECATION;
var init_cid = __esm({
  "node_modules/multiformats/esm/src/cid.js"() {
    init_shim();
    init_varint2();
    init_digest();
    init_base58();
    init_base32();
    init_bytes();
    CID = class _CID {
      constructor(version2, code2, multihash, bytes) {
        this.code = code2;
        this.version = version2;
        this.multihash = multihash;
        this.bytes = bytes;
        this.byteOffset = bytes.byteOffset;
        this.byteLength = bytes.byteLength;
        this.asCID = this;
        this._baseCache = /* @__PURE__ */ new Map();
        Object.defineProperties(this, {
          byteOffset: hidden,
          byteLength: hidden,
          code: readonly,
          version: readonly,
          multihash: readonly,
          bytes: readonly,
          _baseCache: hidden,
          asCID: hidden
        });
      }
      toV0() {
        switch (this.version) {
          case 0: {
            return this;
          }
          default: {
            const { code: code2, multihash } = this;
            if (code2 !== DAG_PB_CODE) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return _CID.createV0(multihash);
          }
        }
      }
      toV1() {
        switch (this.version) {
          case 0: {
            const { code: code2, digest: digest2 } = this.multihash;
            const multihash = create(code2, digest2);
            return _CID.createV1(this.code, multihash);
          }
          case 1: {
            return this;
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
          }
        }
      }
      equals(other) {
        return other && this.code === other.code && this.version === other.version && equals2(this.multihash, other.multihash);
      }
      toString(base3) {
        const { bytes, version: version2, _baseCache } = this;
        switch (version2) {
          case 0:
            return toStringV0(bytes, _baseCache, base3 || base58btc.encoder);
          default:
            return toStringV1(bytes, _baseCache, base3 || base32.encoder);
        }
      }
      toJSON() {
        return {
          code: this.code,
          version: this.version,
          hash: this.multihash.bytes
        };
      }
      get [Symbol.toStringTag]() {
        return "CID";
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return "CID(" + this.toString() + ")";
      }
      static isCID(value) {
        deprecate(/^0\.0/, IS_CID_DEPRECATION);
        return !!(value && (value[cidSymbol] || value.asCID === value));
      }
      get toBaseEncodedString() {
        throw new Error("Deprecated, use .toString()");
      }
      get codec() {
        throw new Error('"codec" property is deprecated, use integer "code" property instead');
      }
      get buffer() {
        throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
      }
      get multibaseName() {
        throw new Error('"multibaseName" property is deprecated');
      }
      get prefix() {
        throw new Error('"prefix" property is deprecated');
      }
      static asCID(value) {
        if (value instanceof _CID) {
          return value;
        } else if (value != null && value.asCID === value) {
          const { version: version2, code: code2, multihash, bytes } = value;
          return new _CID(version2, code2, multihash, bytes || encodeCID(version2, code2, multihash.bytes));
        } else if (value != null && value[cidSymbol] === true) {
          const { version: version2, multihash, code: code2 } = value;
          const digest2 = decode5(multihash);
          return _CID.create(version2, code2, digest2);
        } else {
          return null;
        }
      }
      static create(version2, code2, digest2) {
        if (typeof code2 !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        switch (version2) {
          case 0: {
            if (code2 !== DAG_PB_CODE) {
              throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
            } else {
              return new _CID(version2, code2, digest2, digest2.bytes);
            }
          }
          case 1: {
            const bytes = encodeCID(version2, code2, digest2.bytes);
            return new _CID(version2, code2, digest2, bytes);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      static createV0(digest2) {
        return _CID.create(0, DAG_PB_CODE, digest2);
      }
      static createV1(code2, digest2) {
        return _CID.create(1, code2, digest2);
      }
      static decode(bytes) {
        const [cid, remainder] = _CID.decodeFirst(bytes);
        if (remainder.length) {
          throw new Error("Incorrect length");
        }
        return cid;
      }
      static decodeFirst(bytes) {
        const specs = _CID.inspectBytes(bytes);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest2 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? _CID.createV0(digest2) : _CID.createV1(specs.codec, digest2);
        return [
          cid,
          bytes.subarray(specs.size)
        ];
      }
      static inspectBytes(initialBytes) {
        let offset = 0;
        const next = () => {
          const [i2, length2] = decode4(initialBytes.subarray(offset));
          offset += length2;
          return i2;
        };
        let version2 = next();
        let codec = DAG_PB_CODE;
        if (version2 === 18) {
          version2 = 0;
          offset = 0;
        } else if (version2 === 1) {
          codec = next();
        }
        if (version2 !== 0 && version2 !== 1) {
          throw new RangeError(`Invalid CID version ${version2}`);
        }
        const prefixSize = offset;
        const multihashCode = next();
        const digestSize = next();
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return {
          version: version2,
          codec,
          multihashCode,
          digestSize,
          multihashSize,
          size
        };
      }
      static parse(source, base3) {
        const [prefix, bytes] = parseCIDtoBytes(source, base3);
        const cid = _CID.decode(bytes);
        cid._baseCache.set(prefix, source);
        return cid;
      }
    };
    parseCIDtoBytes = (source, base3) => {
      switch (source[0]) {
        case "Q": {
          const decoder = base3 || base58btc;
          return [
            base58btc.prefix,
            decoder.decode(`${base58btc.prefix}${source}`)
          ];
        }
        case base58btc.prefix: {
          const decoder = base3 || base58btc;
          return [
            base58btc.prefix,
            decoder.decode(source)
          ];
        }
        case base32.prefix: {
          const decoder = base3 || base32;
          return [
            base32.prefix,
            decoder.decode(source)
          ];
        }
        default: {
          if (base3 == null) {
            throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
          }
          return [
            source[0],
            base3.decode(source)
          ];
        }
      }
    };
    toStringV0 = (bytes, cache, base3) => {
      const { prefix } = base3;
      if (prefix !== base58btc.prefix) {
        throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
      }
      const cid = cache.get(prefix);
      if (cid == null) {
        const cid2 = base3.encode(bytes).slice(1);
        cache.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    toStringV1 = (bytes, cache, base3) => {
      const { prefix } = base3;
      const cid = cache.get(prefix);
      if (cid == null) {
        const cid2 = base3.encode(bytes);
        cache.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    DAG_PB_CODE = 112;
    SHA_256_CODE = 18;
    encodeCID = (version2, code2, multihash) => {
      const codeOffset = encodingLength(version2);
      const hashOffset = codeOffset + encodingLength(code2);
      const bytes = new Uint8Array(hashOffset + multihash.byteLength);
      encodeTo(version2, bytes, 0);
      encodeTo(code2, bytes, codeOffset);
      bytes.set(multihash, hashOffset);
      return bytes;
    };
    cidSymbol = Symbol.for("@ipld/js-cid/CID");
    readonly = {
      writable: false,
      configurable: false,
      enumerable: true
    };
    hidden = {
      writable: false,
      enumerable: false,
      configurable: false
    };
    version = "0.0.0-dev";
    deprecate = (range, message) => {
      if (range.test(version)) {
        console.warn(message);
      } else {
        throw new Error(message);
      }
    };
    IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
  }
});

// node_modules/multiformats/esm/src/index.js
var init_src = __esm({
  "node_modules/multiformats/esm/src/index.js"() {
    init_shim();
    init_cid();
    init_varint2();
    init_bytes();
    init_hasher();
    init_digest();
  }
});

// node_modules/multiformats/esm/src/basics.js
var bases, hashes;
var init_basics = __esm({
  "node_modules/multiformats/esm/src/basics.js"() {
    init_shim();
    init_identity();
    init_base2();
    init_base8();
    init_base10();
    init_base16();
    init_base32();
    init_base36();
    init_base58();
    init_base64();
    init_base256emoji();
    init_sha2_browser();
    init_identity2();
    init_raw();
    init_json();
    init_src();
    bases = {
      ...identity_exports,
      ...base2_exports,
      ...base8_exports,
      ...base10_exports,
      ...base16_exports,
      ...base32_exports,
      ...base36_exports,
      ...base58_exports,
      ...base64_exports,
      ...base256emoji_exports
    };
    hashes = {
      ...sha2_browser_exports,
      ...identity_exports2
    };
  }
});

// node_modules/uint8arrays/esm/src/util/bases.js
function createCodec(name2, prefix, encode5, decode6) {
  return {
    name: name2,
    prefix,
    encoder: {
      name: name2,
      prefix,
      encode: encode5
    },
    decoder: { decode: decode6 }
  };
}
var string, ascii, BASES, bases_default;
var init_bases = __esm({
  "node_modules/uint8arrays/esm/src/util/bases.js"() {
    init_shim();
    init_basics();
    init_alloc();
    string = createCodec("utf8", "u", (buf) => {
      const decoder = new TextDecoder("utf8");
      return "u" + decoder.decode(buf);
    }, (str) => {
      const encoder = new TextEncoder();
      return encoder.encode(str.substring(1));
    });
    ascii = createCodec("ascii", "a", (buf) => {
      let string2 = "a";
      for (let i2 = 0; i2 < buf.length; i2++) {
        string2 += String.fromCharCode(buf[i2]);
      }
      return string2;
    }, (str) => {
      str = str.substring(1);
      const buf = allocUnsafe(str.length);
      for (let i2 = 0; i2 < str.length; i2++) {
        buf[i2] = str.charCodeAt(i2);
      }
      return buf;
    });
    BASES = {
      utf8: string,
      "utf-8": string,
      hex: bases.base16,
      latin1: ascii,
      ascii,
      binary: ascii,
      ...bases
    };
    bases_default = BASES;
  }
});

// node_modules/uint8arrays/esm/src/to-string.js
function toString2(array, encoding = "utf8") {
  const base3 = bases_default[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base3.encoder.encode(array).substring(1);
}
var init_to_string = __esm({
  "node_modules/uint8arrays/esm/src/to-string.js"() {
    init_shim();
    init_bases();
  }
});

// node_modules/uint8arrays/esm/src/from-string.js
function fromString2(string2, encoding = "utf8") {
  const base3 = bases_default[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string2, "utf-8"));
  }
  return base3.decoder.decode(`${base3.prefix}${string2}`);
}
var init_from_string = __esm({
  "node_modules/uint8arrays/esm/src/from-string.js"() {
    init_shim();
    init_bases();
    init_as_uint8array();
  }
});

// node_modules/@walletconnect/relay-auth/dist/esm/utils.js
function decodeJSON(str) {
  return safeJsonParse(toString2(fromString2(str, JWT_ENCODING), JSON_ENCODING));
}
function encodeJSON(val) {
  return toString2(fromString2(safeJsonStringify(val), JSON_ENCODING), JWT_ENCODING);
}
function encodeIss(publicKey) {
  const header = fromString2(MULTICODEC_ED25519_HEADER, MULTICODEC_ED25519_ENCODING);
  const multicodec = MULTICODEC_ED25519_BASE + toString2(concat([header, publicKey]), MULTICODEC_ED25519_ENCODING);
  return [DID_PREFIX, DID_METHOD, multicodec].join(DID_DELIMITER);
}
function decodeIss(issuer) {
  const [prefix, method, multicodec] = issuer.split(DID_DELIMITER);
  if (prefix !== DID_PREFIX || method !== DID_METHOD) {
    throw new Error(`Issuer must be a DID with method "key"`);
  }
  const base3 = multicodec.slice(0, 1);
  if (base3 !== MULTICODEC_ED25519_BASE) {
    throw new Error(`Issuer must be a key in mulicodec format`);
  }
  const bytes = fromString2(multicodec.slice(1), MULTICODEC_ED25519_ENCODING);
  const type = toString2(bytes.slice(0, 2), MULTICODEC_ED25519_ENCODING);
  if (type !== MULTICODEC_ED25519_HEADER) {
    throw new Error(`Issuer must be a public key with type "Ed25519"`);
  }
  const publicKey = bytes.slice(2);
  if (publicKey.length !== MULTICODEC_ED25519_LENGTH) {
    throw new Error(`Issuer must be a public key with length 32 bytes`);
  }
  return publicKey;
}
function encodeSig(bytes) {
  return toString2(bytes, JWT_ENCODING);
}
function decodeSig(encoded) {
  return fromString2(encoded, JWT_ENCODING);
}
function encodeData(params) {
  return fromString2([encodeJSON(params.header), encodeJSON(params.payload)].join(JWT_DELIMITER), DATA_ENCODING);
}
function decodeData(data) {
  const params = toString2(data, DATA_ENCODING).split(JWT_DELIMITER);
  const header = decodeJSON(params[0]);
  const payload = decodeJSON(params[1]);
  return { header, payload };
}
function encodeJWT(params) {
  return [
    encodeJSON(params.header),
    encodeJSON(params.payload),
    encodeSig(params.signature)
  ].join(JWT_DELIMITER);
}
function decodeJWT(jwt) {
  const params = jwt.split(JWT_DELIMITER);
  const header = decodeJSON(params[0]);
  const payload = decodeJSON(params[1]);
  const signature = decodeSig(params[2]);
  const data = fromString2(params.slice(0, 2).join(JWT_DELIMITER), DATA_ENCODING);
  return { header, payload, signature, data };
}
var init_utils = __esm({
  "node_modules/@walletconnect/relay-auth/dist/esm/utils.js"() {
    init_shim();
    init_concat();
    init_to_string();
    init_from_string();
    init_esm();
    init_constants();
  }
});

// node_modules/@walletconnect/relay-auth/dist/esm/api.js
function generateKeyPair(seed = (0, import_random.randomBytes)(KEY_PAIR_SEED_LENGTH)) {
  return ed25519.generateKeyPairFromSeed(seed);
}
async function signJWT(sub, aud, ttl, keyPair, iat = (0, import_time.fromMiliseconds)(Date.now())) {
  const header = { alg: JWT_IRIDIUM_ALG, typ: JWT_IRIDIUM_TYP };
  const iss = encodeIss(keyPair.publicKey);
  const exp = iat + ttl;
  const payload = { iss, sub, aud, iat, exp };
  const data = encodeData({ header, payload });
  const signature = ed25519.sign(keyPair.secretKey, data);
  return encodeJWT({ header, payload, signature });
}
async function verifyJWT(jwt) {
  const { header, payload, data, signature } = decodeJWT(jwt);
  if (header.alg !== JWT_IRIDIUM_ALG || header.typ !== JWT_IRIDIUM_TYP) {
    throw new Error("JWT must use EdDSA algorithm");
  }
  const publicKey = decodeIss(payload.iss);
  return ed25519.verify(publicKey, data, signature);
}
var ed25519, import_random, import_time;
var init_api = __esm({
  "node_modules/@walletconnect/relay-auth/dist/esm/api.js"() {
    init_shim();
    ed25519 = __toESM(require_ed25519());
    import_random = __toESM(require_random());
    import_time = __toESM(require_cjs());
    init_constants();
    init_utils();
  }
});

// node_modules/@walletconnect/relay-auth/dist/esm/types.js
var init_types = __esm({
  "node_modules/@walletconnect/relay-auth/dist/esm/types.js"() {
    init_shim();
  }
});

// node_modules/@walletconnect/relay-auth/dist/esm/index.js
var esm_exports3 = {};
__export(esm_exports3, {
  DATA_ENCODING: () => DATA_ENCODING,
  DID_DELIMITER: () => DID_DELIMITER,
  DID_METHOD: () => DID_METHOD,
  DID_PREFIX: () => DID_PREFIX,
  JSON_ENCODING: () => JSON_ENCODING,
  JWT_DELIMITER: () => JWT_DELIMITER,
  JWT_ENCODING: () => JWT_ENCODING,
  JWT_IRIDIUM_ALG: () => JWT_IRIDIUM_ALG,
  JWT_IRIDIUM_TYP: () => JWT_IRIDIUM_TYP,
  KEY_PAIR_SEED_LENGTH: () => KEY_PAIR_SEED_LENGTH,
  MULTICODEC_ED25519_BASE: () => MULTICODEC_ED25519_BASE,
  MULTICODEC_ED25519_ENCODING: () => MULTICODEC_ED25519_ENCODING,
  MULTICODEC_ED25519_HEADER: () => MULTICODEC_ED25519_HEADER,
  MULTICODEC_ED25519_LENGTH: () => MULTICODEC_ED25519_LENGTH,
  decodeData: () => decodeData,
  decodeIss: () => decodeIss,
  decodeJSON: () => decodeJSON,
  decodeJWT: () => decodeJWT,
  decodeSig: () => decodeSig,
  encodeData: () => encodeData,
  encodeIss: () => encodeIss,
  encodeJSON: () => encodeJSON,
  encodeJWT: () => encodeJWT,
  encodeSig: () => encodeSig,
  generateKeyPair: () => generateKeyPair,
  signJWT: () => signJWT,
  verifyJWT: () => verifyJWT
});
var init_esm3 = __esm({
  "node_modules/@walletconnect/relay-auth/dist/esm/index.js"() {
    init_shim();
    init_api();
    init_constants();
    init_types();
    init_utils();
  }
});

// node_modules/detect-browser/index.js
var require_detect_browser = __commonJS({
  "node_modules/detect-browser/index.js"(exports2) {
    "use strict";
    init_shim();
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from3, pack) {
      if (pack || arguments.length === 2)
        for (var i2 = 0, l4 = from3.length, ar; i2 < l4; i2++) {
          if (ar || !(i2 in from3)) {
            if (!ar)
              ar = Array.prototype.slice.call(from3, 0, i2);
            ar[i2] = from3[i2];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from3));
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getNodeVersion = exports2.detectOS = exports2.parseUserAgent = exports2.browserName = exports2.detect = exports2.ReactNativeInfo = exports2.BotInfo = exports2.SearchBotDeviceInfo = exports2.NodeInfo = exports2.BrowserInfo = void 0;
    var BrowserInfo = (
      /** @class */
      /* @__PURE__ */ function() {
        function BrowserInfo2(name2, version2, os) {
          this.name = name2;
          this.version = version2;
          this.os = os;
          this.type = "browser";
        }
        return BrowserInfo2;
      }()
    );
    exports2.BrowserInfo = BrowserInfo;
    var NodeInfo = (
      /** @class */
      /* @__PURE__ */ function() {
        function NodeInfo2(version2) {
          this.version = version2;
          this.type = "node";
          this.name = "node";
          this.os = import_process.default.platform;
        }
        return NodeInfo2;
      }()
    );
    exports2.NodeInfo = NodeInfo;
    var SearchBotDeviceInfo = (
      /** @class */
      /* @__PURE__ */ function() {
        function SearchBotDeviceInfo2(name2, version2, os, bot) {
          this.name = name2;
          this.version = version2;
          this.os = os;
          this.bot = bot;
          this.type = "bot-device";
        }
        return SearchBotDeviceInfo2;
      }()
    );
    exports2.SearchBotDeviceInfo = SearchBotDeviceInfo;
    var BotInfo = (
      /** @class */
      /* @__PURE__ */ function() {
        function BotInfo2() {
          this.type = "bot";
          this.bot = true;
          this.name = "bot";
          this.version = null;
          this.os = null;
        }
        return BotInfo2;
      }()
    );
    exports2.BotInfo = BotInfo;
    var ReactNativeInfo = (
      /** @class */
      /* @__PURE__ */ function() {
        function ReactNativeInfo2() {
          this.type = "react-native";
          this.name = "react-native";
          this.version = null;
          this.os = null;
        }
        return ReactNativeInfo2;
      }()
    );
    exports2.ReactNativeInfo = ReactNativeInfo;
    var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
    var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
    var REQUIRED_VERSION_PARTS = 3;
    var userAgentRules = [
      ["aol", /AOLShield\/([0-9\._]+)/],
      ["edge", /Edge\/([0-9\._]+)/],
      ["edge-ios", /EdgiOS\/([0-9\._]+)/],
      ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
      ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
      ["samsung", /SamsungBrowser\/([0-9\.]+)/],
      ["silk", /\bSilk\/([0-9._-]+)\b/],
      ["miui", /MiuiBrowser\/([0-9\.]+)$/],
      ["beaker", /BeakerBrowser\/([0-9\.]+)/],
      ["edge-chromium", /EdgA?\/([0-9\.]+)/],
      [
        "chromium-webview",
        /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
      ],
      ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
      ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
      ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
      ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
      ["fxios", /FxiOS\/([0-9\.]+)/],
      ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
      ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
      ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
      ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
      ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
      ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
      ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
      ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
      ["ie", /MSIE\s(7\.0)/],
      ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
      ["android", /Android\s([0-9\.]+)/],
      ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
      ["safari", /Version\/([0-9\._]+).*Safari/],
      ["facebook", /FB[AS]V\/([0-9\.]+)/],
      ["instagram", /Instagram\s([0-9\.]+)/],
      ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
      ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
      ["curl", /^curl\/([0-9\.]+)$/],
      ["searchbot", SEARCHBOX_UA_REGEX]
    ];
    var operatingSystemRules = [
      ["iOS", /iP(hone|od|ad)/],
      ["Android OS", /Android/],
      ["BlackBerry OS", /BlackBerry|BB10/],
      ["Windows Mobile", /IEMobile/],
      ["Amazon OS", /Kindle/],
      ["Windows 3.11", /Win16/],
      ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
      ["Windows 98", /(Windows 98)|(Win98)/],
      ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
      ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
      ["Windows Server 2003", /(Windows NT 5.2)/],
      ["Windows Vista", /(Windows NT 6.0)/],
      ["Windows 7", /(Windows NT 6.1)/],
      ["Windows 8", /(Windows NT 6.2)/],
      ["Windows 8.1", /(Windows NT 6.3)/],
      ["Windows 10", /(Windows NT 10.0)/],
      ["Windows ME", /Windows ME/],
      ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
      ["Open BSD", /OpenBSD/],
      ["Sun OS", /SunOS/],
      ["Chrome OS", /CrOS/],
      ["Linux", /(Linux)|(X11)/],
      ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
      ["QNX", /QNX/],
      ["BeOS", /BeOS/],
      ["OS/2", /OS\/2/]
    ];
    function detect(userAgent) {
      if (!!userAgent) {
        return parseUserAgent(userAgent);
      }
      if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
        return new ReactNativeInfo();
      }
      if (typeof navigator !== "undefined") {
        return parseUserAgent(navigator.userAgent);
      }
      return getNodeVersion();
    }
    exports2.detect = detect;
    function matchUserAgent(ua) {
      return ua !== "" && userAgentRules.reduce(function(matched, _a) {
        var browser = _a[0], regex = _a[1];
        if (matched) {
          return matched;
        }
        var uaMatch = regex.exec(ua);
        return !!uaMatch && [browser, uaMatch];
      }, false);
    }
    function browserName(ua) {
      var data = matchUserAgent(ua);
      return data ? data[0] : null;
    }
    exports2.browserName = browserName;
    function parseUserAgent(ua) {
      var matchedRule = matchUserAgent(ua);
      if (!matchedRule) {
        return null;
      }
      var name2 = matchedRule[0], match = matchedRule[1];
      if (name2 === "searchbot") {
        return new BotInfo();
      }
      var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
      if (versionParts) {
        if (versionParts.length < REQUIRED_VERSION_PARTS) {
          versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
        }
      } else {
        versionParts = [];
      }
      var version2 = versionParts.join(".");
      var os = detectOS(ua);
      var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
      if (searchBotMatch && searchBotMatch[1]) {
        return new SearchBotDeviceInfo(name2, version2, os, searchBotMatch[1]);
      }
      return new BrowserInfo(name2, version2, os);
    }
    exports2.parseUserAgent = parseUserAgent;
    function detectOS(ua) {
      for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
        var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];
        var match = regex.exec(ua);
        if (match) {
          return os;
        }
      }
      return null;
    }
    exports2.detectOS = detectOS;
    function getNodeVersion() {
      var isNode2 = typeof import_process.default !== "undefined" && import_process.default.version;
      return isNode2 ? new NodeInfo(import_process.default.version.slice(1)) : null;
    }
    exports2.getNodeVersion = getNodeVersion;
    function createVersionParts(count) {
      var output = [];
      for (var ii = 0; ii < count; ii++) {
        output.push("0");
      }
      return output;
    }
  }
});

// node_modules/@walletconnect/window-getters/dist/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/@walletconnect/window-getters/dist/cjs/index.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getLocalStorage = exports2.getLocalStorageOrThrow = exports2.getCrypto = exports2.getCryptoOrThrow = exports2.getLocation = exports2.getLocationOrThrow = exports2.getNavigator = exports2.getNavigatorOrThrow = exports2.getDocument = exports2.getDocumentOrThrow = exports2.getFromWindowOrThrow = exports2.getFromWindow = void 0;
    function getFromWindow(name2) {
      let res = void 0;
      if (typeof window !== "undefined" && typeof window[name2] !== "undefined") {
        res = window[name2];
      }
      return res;
    }
    exports2.getFromWindow = getFromWindow;
    function getFromWindowOrThrow(name2) {
      const res = getFromWindow(name2);
      if (!res) {
        throw new Error(`${name2} is not defined in Window`);
      }
      return res;
    }
    exports2.getFromWindowOrThrow = getFromWindowOrThrow;
    function getDocumentOrThrow() {
      return getFromWindowOrThrow("document");
    }
    exports2.getDocumentOrThrow = getDocumentOrThrow;
    function getDocument() {
      return getFromWindow("document");
    }
    exports2.getDocument = getDocument;
    function getNavigatorOrThrow() {
      return getFromWindowOrThrow("navigator");
    }
    exports2.getNavigatorOrThrow = getNavigatorOrThrow;
    function getNavigator() {
      return getFromWindow("navigator");
    }
    exports2.getNavigator = getNavigator;
    function getLocationOrThrow() {
      return getFromWindowOrThrow("location");
    }
    exports2.getLocationOrThrow = getLocationOrThrow;
    function getLocation() {
      return getFromWindow("location");
    }
    exports2.getLocation = getLocation;
    function getCryptoOrThrow() {
      return getFromWindowOrThrow("crypto");
    }
    exports2.getCryptoOrThrow = getCryptoOrThrow;
    function getCrypto() {
      return getFromWindow("crypto");
    }
    exports2.getCrypto = getCrypto;
    function getLocalStorageOrThrow() {
      return getFromWindowOrThrow("localStorage");
    }
    exports2.getLocalStorageOrThrow = getLocalStorageOrThrow;
    function getLocalStorage() {
      return getFromWindow("localStorage");
    }
    exports2.getLocalStorage = getLocalStorage;
  }
});

// node_modules/@walletconnect/window-metadata/dist/cjs/index.js
var require_cjs4 = __commonJS({
  "node_modules/@walletconnect/window-metadata/dist/cjs/index.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getWindowMetadata = void 0;
    var window_getters_1 = require_cjs3();
    function getWindowMetadata() {
      let doc;
      let loc;
      try {
        doc = window_getters_1.getDocumentOrThrow();
        loc = window_getters_1.getLocationOrThrow();
      } catch (e2) {
        return null;
      }
      function getIcons() {
        const links = doc.getElementsByTagName("link");
        const icons2 = [];
        for (let i2 = 0; i2 < links.length; i2++) {
          const link = links[i2];
          const rel = link.getAttribute("rel");
          if (rel) {
            if (rel.toLowerCase().indexOf("icon") > -1) {
              const href = link.getAttribute("href");
              if (href) {
                if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
                  let absoluteHref = loc.protocol + "//" + loc.host;
                  if (href.indexOf("/") === 0) {
                    absoluteHref += href;
                  } else {
                    const path = loc.pathname.split("/");
                    path.pop();
                    const finalPath = path.join("/");
                    absoluteHref += finalPath + "/" + href;
                  }
                  icons2.push(absoluteHref);
                } else if (href.indexOf("//") === 0) {
                  const absoluteUrl = loc.protocol + href;
                  icons2.push(absoluteUrl);
                } else {
                  icons2.push(href);
                }
              }
            }
          }
        }
        return icons2;
      }
      function getWindowMetadataOfAny(...args) {
        const metaTags = doc.getElementsByTagName("meta");
        for (let i2 = 0; i2 < metaTags.length; i2++) {
          const tag = metaTags[i2];
          const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
            if (attr) {
              return args.includes(attr);
            }
            return false;
          });
          if (attributes.length && attributes) {
            const content = tag.getAttribute("content");
            if (content) {
              return content;
            }
          }
        }
        return "";
      }
      function getName() {
        let name3 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
        if (!name3) {
          name3 = doc.title;
        }
        return name3;
      }
      function getDescription() {
        const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
        return description2;
      }
      const name2 = getName();
      const description = getDescription();
      const url = loc.origin;
      const icons = getIcons();
      const meta = {
        description,
        url,
        icons,
        name: name2
      };
      return meta;
    }
    exports2.getWindowMetadata = getWindowMetadata;
  }
});

// node_modules/strict-uri-encode/index.js
var require_strict_uri_encode = __commonJS({
  "node_modules/strict-uri-encode/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    module2.exports = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x3) => `%${x3.charCodeAt(0).toString(16).toUpperCase()}`);
  }
});

// node_modules/decode-uri-component/index.js
var require_decode_uri_component = __commonJS({
  "node_modules/decode-uri-component/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    var token = "%[a-f0-9]{2}";
    var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
    var multiMatcher = new RegExp("(" + token + ")+", "gi");
    function decodeComponents(components, split) {
      try {
        return [decodeURIComponent(components.join(""))];
      } catch (err) {
      }
      if (components.length === 1) {
        return components;
      }
      split = split || 1;
      var left = components.slice(0, split);
      var right = components.slice(split);
      return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
    }
    function decode6(input) {
      try {
        return decodeURIComponent(input);
      } catch (err) {
        var tokens = input.match(singleMatcher) || [];
        for (var i2 = 1; i2 < tokens.length; i2++) {
          input = decodeComponents(tokens, i2).join("");
          tokens = input.match(singleMatcher) || [];
        }
        return input;
      }
    }
    function customDecodeURIComponent(input) {
      var replaceMap = {
        "%FE%FF": "\uFFFD\uFFFD",
        "%FF%FE": "\uFFFD\uFFFD"
      };
      var match = multiMatcher.exec(input);
      while (match) {
        try {
          replaceMap[match[0]] = decodeURIComponent(match[0]);
        } catch (err) {
          var result = decode6(match[0]);
          if (result !== match[0]) {
            replaceMap[match[0]] = result;
          }
        }
        match = multiMatcher.exec(input);
      }
      replaceMap["%C2"] = "\uFFFD";
      var entries = Object.keys(replaceMap);
      for (var i2 = 0; i2 < entries.length; i2++) {
        var key = entries[i2];
        input = input.replace(new RegExp(key, "g"), replaceMap[key]);
      }
      return input;
    }
    module2.exports = function(encodedURI) {
      if (typeof encodedURI !== "string") {
        throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
      }
      try {
        encodedURI = encodedURI.replace(/\+/g, " ");
        return decodeURIComponent(encodedURI);
      } catch (err) {
        return customDecodeURIComponent(encodedURI);
      }
    };
  }
});

// node_modules/split-on-first/index.js
var require_split_on_first = __commonJS({
  "node_modules/split-on-first/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    module2.exports = (string2, separator) => {
      if (!(typeof string2 === "string" && typeof separator === "string")) {
        throw new TypeError("Expected the arguments to be of type `string`");
      }
      if (separator === "") {
        return [string2];
      }
      const separatorIndex = string2.indexOf(separator);
      if (separatorIndex === -1) {
        return [string2];
      }
      return [
        string2.slice(0, separatorIndex),
        string2.slice(separatorIndex + separator.length)
      ];
    };
  }
});

// node_modules/filter-obj/index.js
var require_filter_obj = __commonJS({
  "node_modules/filter-obj/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    module2.exports = function(obj, predicate) {
      var ret = {};
      var keys2 = Object.keys(obj);
      var isArr = Array.isArray(predicate);
      for (var i2 = 0; i2 < keys2.length; i2++) {
        var key = keys2[i2];
        var val = obj[key];
        if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
          ret[key] = val;
        }
      }
      return ret;
    };
  }
});

// node_modules/query-string/index.js
var require_query_string = __commonJS({
  "node_modules/query-string/index.js"(exports2) {
    "use strict";
    init_shim();
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var filterObject = require_filter_obj();
    var isNullOrUndefined = (value) => value === null || value === void 0;
    var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode5(key, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode5(key, options), "[", encode5(index, options), "]=", encode5(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode5(key, options), "[]"].join("")];
            }
            return [...result, [encode5(key, options), "[]=", encode5(value, options)].join("")];
          };
        case "colon-list-separator":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode5(key, options), ":list="].join("")];
            }
            return [...result, [encode5(key, options), ":list=", encode5(value, options)].join("")];
          };
        case "comma":
        case "separator":
        case "bracket-separator": {
          const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            value = value === null ? "" : value;
            if (result.length === 0) {
              return [[encode5(key, options), keyValueSep, encode5(value, options)].join("")];
            }
            return [[result, encode5(value, options)].join(options.arrayFormatSeparator)];
          };
        }
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode5(key, options)];
            }
            return [...result, [encode5(key, options), "=", encode5(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "colon-list-separator":
          return (key, value, accumulator) => {
            result = /(:list)$/.exec(key);
            key = key.replace(/:list$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray = typeof value === "string" && value.includes(options.arrayFormatSeparator);
            const isEncodedArray = typeof value === "string" && !isArray && decode6(value, options).includes(options.arrayFormatSeparator);
            value = isEncodedArray ? decode6(value, options) : value;
            const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode6(item, options)) : value === null ? value : decode6(value, options);
            accumulator[key] = newValue;
          };
        case "bracket-separator":
          return (key, value, accumulator) => {
            const isArray = /(\[\])$/.test(key);
            key = key.replace(/\[\]$/, "");
            if (!isArray) {
              accumulator[key] = value ? decode6(value, options) : value;
              return;
            }
            const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode6(item, options));
            if (accumulator[key] === void 0) {
              accumulator[key] = arrayValue;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], arrayValue);
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode5(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode6(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a3, b4) => Number(a3) - Number(b4)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash = url.slice(hashStart);
      }
      return hash;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse(query, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof query !== "string") {
        return ret;
      }
      query = query.trim().replace(/^[?#&]/, "");
      if (!query) {
        return ret;
      }
      for (const param of query.split("&")) {
        if (param === "") {
          continue;
        }
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode6(value, options);
        formatter(decode6(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k4 of Object.keys(value)) {
            value[k4] = parseValue(value[k4], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports2.extract = extract;
    exports2.parse = parse;
    exports2.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys2 = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys2.sort(options.sort);
      }
      return keys2.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode5(key, options);
        }
        if (Array.isArray(value)) {
          if (value.length === 0 && options.arrayFormat === "bracket-separator") {
            return encode5(key, options) + "[]";
          }
          return value.reduce(formatter(key), []).join("&");
        }
        return encode5(key, options) + "=" + encode5(value, options);
      }).filter((x3) => x3.length > 0).join("&");
    };
    exports2.parseUrl = (url, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url_, hash] = splitOnFirst(url, "#");
      return Object.assign(
        {
          url: url_.split("?")[0] || "",
          query: parse(extract(url), options)
        },
        options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode6(hash, options) } : {}
      );
    };
    exports2.stringifyUrl = (object, options) => {
      options = Object.assign({
        encode: true,
        strict: true,
        [encodeFragmentIdentifier]: true
      }, options);
      const url = removeHash(object.url).split("?")[0] || "";
      const queryFromUrl = exports2.extract(object.url);
      const parsedQueryFromUrl = exports2.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, object.query);
      let queryString = exports2.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash = getHash(object.url);
      if (object.fragmentIdentifier) {
        hash = `#${options[encodeFragmentIdentifier] ? encode5(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
      }
      return `${url}${queryString}${hash}`;
    };
    exports2.pick = (input, filter, options) => {
      options = Object.assign({
        parseFragmentIdentifier: true,
        [encodeFragmentIdentifier]: false
      }, options);
      const { url, query, fragmentIdentifier } = exports2.parseUrl(input, options);
      return exports2.stringifyUrl({
        url,
        query: filterObject(query, filter),
        fragmentIdentifier
      }, options);
    };
    exports2.exclude = (input, filter, options) => {
      const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
      return exports2.pick(input, exclusionFilter, options);
    };
  }
});

// node_modules/@stablelib/chacha/lib/chacha.js
var require_chacha = __commonJS({
  "node_modules/@stablelib/chacha/lib/chacha.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var binary_1 = require_binary2();
    var wipe_1 = require_wipe();
    var ROUNDS = 20;
    function core(out, input, key) {
      var j0 = 1634760805;
      var j1 = 857760878;
      var j2 = 2036477234;
      var j3 = 1797285236;
      var j4 = key[3] << 24 | key[2] << 16 | key[1] << 8 | key[0];
      var j5 = key[7] << 24 | key[6] << 16 | key[5] << 8 | key[4];
      var j6 = key[11] << 24 | key[10] << 16 | key[9] << 8 | key[8];
      var j7 = key[15] << 24 | key[14] << 16 | key[13] << 8 | key[12];
      var j8 = key[19] << 24 | key[18] << 16 | key[17] << 8 | key[16];
      var j9 = key[23] << 24 | key[22] << 16 | key[21] << 8 | key[20];
      var j10 = key[27] << 24 | key[26] << 16 | key[25] << 8 | key[24];
      var j11 = key[31] << 24 | key[30] << 16 | key[29] << 8 | key[28];
      var j12 = input[3] << 24 | input[2] << 16 | input[1] << 8 | input[0];
      var j13 = input[7] << 24 | input[6] << 16 | input[5] << 8 | input[4];
      var j14 = input[11] << 24 | input[10] << 16 | input[9] << 8 | input[8];
      var j15 = input[15] << 24 | input[14] << 16 | input[13] << 8 | input[12];
      var x0 = j0;
      var x1 = j1;
      var x22 = j2;
      var x3 = j3;
      var x4 = j4;
      var x5 = j5;
      var x6 = j6;
      var x7 = j7;
      var x8 = j8;
      var x9 = j9;
      var x10 = j10;
      var x11 = j11;
      var x12 = j12;
      var x13 = j13;
      var x14 = j14;
      var x15 = j15;
      for (var i2 = 0; i2 < ROUNDS; i2 += 2) {
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> 32 - 16 | x12 << 16;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> 32 - 12 | x4 << 12;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> 32 - 16 | x13 << 16;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> 32 - 12 | x5 << 12;
        x22 = x22 + x6 | 0;
        x14 ^= x22;
        x14 = x14 >>> 32 - 16 | x14 << 16;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> 32 - 12 | x6 << 12;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> 32 - 16 | x15 << 16;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> 32 - 12 | x7 << 12;
        x22 = x22 + x6 | 0;
        x14 ^= x22;
        x14 = x14 >>> 32 - 8 | x14 << 8;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> 32 - 7 | x6 << 7;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> 32 - 8 | x15 << 8;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> 32 - 7 | x7 << 7;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> 32 - 8 | x13 << 8;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> 32 - 7 | x5 << 7;
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> 32 - 8 | x12 << 8;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> 32 - 7 | x4 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> 32 - 16 | x15 << 16;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> 32 - 12 | x5 << 12;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> 32 - 16 | x12 << 16;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> 32 - 12 | x6 << 12;
        x22 = x22 + x7 | 0;
        x13 ^= x22;
        x13 = x13 >>> 32 - 16 | x13 << 16;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> 32 - 12 | x7 << 12;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> 32 - 16 | x14 << 16;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> 32 - 12 | x4 << 12;
        x22 = x22 + x7 | 0;
        x13 ^= x22;
        x13 = x13 >>> 32 - 8 | x13 << 8;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> 32 - 7 | x7 << 7;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> 32 - 8 | x14 << 8;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> 32 - 7 | x4 << 7;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> 32 - 8 | x12 << 8;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> 32 - 7 | x6 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> 32 - 8 | x15 << 8;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> 32 - 7 | x5 << 7;
      }
      binary_1.writeUint32LE(x0 + j0 | 0, out, 0);
      binary_1.writeUint32LE(x1 + j1 | 0, out, 4);
      binary_1.writeUint32LE(x22 + j2 | 0, out, 8);
      binary_1.writeUint32LE(x3 + j3 | 0, out, 12);
      binary_1.writeUint32LE(x4 + j4 | 0, out, 16);
      binary_1.writeUint32LE(x5 + j5 | 0, out, 20);
      binary_1.writeUint32LE(x6 + j6 | 0, out, 24);
      binary_1.writeUint32LE(x7 + j7 | 0, out, 28);
      binary_1.writeUint32LE(x8 + j8 | 0, out, 32);
      binary_1.writeUint32LE(x9 + j9 | 0, out, 36);
      binary_1.writeUint32LE(x10 + j10 | 0, out, 40);
      binary_1.writeUint32LE(x11 + j11 | 0, out, 44);
      binary_1.writeUint32LE(x12 + j12 | 0, out, 48);
      binary_1.writeUint32LE(x13 + j13 | 0, out, 52);
      binary_1.writeUint32LE(x14 + j14 | 0, out, 56);
      binary_1.writeUint32LE(x15 + j15 | 0, out, 60);
    }
    function streamXOR(key, nonce, src2, dst, nonceInplaceCounterLength) {
      if (nonceInplaceCounterLength === void 0) {
        nonceInplaceCounterLength = 0;
      }
      if (key.length !== 32) {
        throw new Error("ChaCha: key size must be 32 bytes");
      }
      if (dst.length < src2.length) {
        throw new Error("ChaCha: destination is shorter than source");
      }
      var nc;
      var counterLength;
      if (nonceInplaceCounterLength === 0) {
        if (nonce.length !== 8 && nonce.length !== 12) {
          throw new Error("ChaCha nonce must be 8 or 12 bytes");
        }
        nc = new Uint8Array(16);
        counterLength = nc.length - nonce.length;
        nc.set(nonce, counterLength);
      } else {
        if (nonce.length !== 16) {
          throw new Error("ChaCha nonce with counter must be 16 bytes");
        }
        nc = nonce;
        counterLength = nonceInplaceCounterLength;
      }
      var block = new Uint8Array(64);
      for (var i2 = 0; i2 < src2.length; i2 += 64) {
        core(block, nc, key);
        for (var j2 = i2; j2 < i2 + 64 && j2 < src2.length; j2++) {
          dst[j2] = src2[j2] ^ block[j2 - i2];
        }
        incrementCounter(nc, 0, counterLength);
      }
      wipe_1.wipe(block);
      if (nonceInplaceCounterLength === 0) {
        wipe_1.wipe(nc);
      }
      return dst;
    }
    exports2.streamXOR = streamXOR;
    function stream(key, nonce, dst, nonceInplaceCounterLength) {
      if (nonceInplaceCounterLength === void 0) {
        nonceInplaceCounterLength = 0;
      }
      wipe_1.wipe(dst);
      return streamXOR(key, nonce, dst, dst, nonceInplaceCounterLength);
    }
    exports2.stream = stream;
    function incrementCounter(counter, pos, len) {
      var carry = 1;
      while (len--) {
        carry = carry + (counter[pos] & 255) | 0;
        counter[pos] = carry & 255;
        carry >>>= 8;
        pos++;
      }
      if (carry > 0) {
        throw new Error("ChaCha: counter overflow");
      }
    }
  }
});

// node_modules/@stablelib/constant-time/lib/constant-time.js
var require_constant_time = __commonJS({
  "node_modules/@stablelib/constant-time/lib/constant-time.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    function select(subject, resultIfOne, resultIfZero) {
      return ~(subject - 1) & resultIfOne | subject - 1 & resultIfZero;
    }
    exports2.select = select;
    function lessOrEqual(a3, b4) {
      return (a3 | 0) - (b4 | 0) - 1 >>> 31 & 1;
    }
    exports2.lessOrEqual = lessOrEqual;
    function compare3(a3, b4) {
      if (a3.length !== b4.length) {
        return 0;
      }
      var result = 0;
      for (var i2 = 0; i2 < a3.length; i2++) {
        result |= a3[i2] ^ b4[i2];
      }
      return 1 & result - 1 >>> 8;
    }
    exports2.compare = compare3;
    function equal(a3, b4) {
      if (a3.length === 0 || b4.length === 0) {
        return false;
      }
      return compare3(a3, b4) !== 0;
    }
    exports2.equal = equal;
  }
});

// node_modules/@stablelib/poly1305/lib/poly1305.js
var require_poly1305 = __commonJS({
  "node_modules/@stablelib/poly1305/lib/poly1305.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var constant_time_1 = require_constant_time();
    var wipe_1 = require_wipe();
    exports2.DIGEST_LENGTH = 16;
    var Poly1305 = (
      /** @class */
      function() {
        function Poly13052(key) {
          this.digestLength = exports2.DIGEST_LENGTH;
          this._buffer = new Uint8Array(16);
          this._r = new Uint16Array(10);
          this._h = new Uint16Array(10);
          this._pad = new Uint16Array(8);
          this._leftover = 0;
          this._fin = 0;
          this._finished = false;
          var t0 = key[0] | key[1] << 8;
          this._r[0] = t0 & 8191;
          var t1 = key[2] | key[3] << 8;
          this._r[1] = (t0 >>> 13 | t1 << 3) & 8191;
          var t2 = key[4] | key[5] << 8;
          this._r[2] = (t1 >>> 10 | t2 << 6) & 7939;
          var t3 = key[6] | key[7] << 8;
          this._r[3] = (t2 >>> 7 | t3 << 9) & 8191;
          var t4 = key[8] | key[9] << 8;
          this._r[4] = (t3 >>> 4 | t4 << 12) & 255;
          this._r[5] = t4 >>> 1 & 8190;
          var t5 = key[10] | key[11] << 8;
          this._r[6] = (t4 >>> 14 | t5 << 2) & 8191;
          var t6 = key[12] | key[13] << 8;
          this._r[7] = (t5 >>> 11 | t6 << 5) & 8065;
          var t7 = key[14] | key[15] << 8;
          this._r[8] = (t6 >>> 8 | t7 << 8) & 8191;
          this._r[9] = t7 >>> 5 & 127;
          this._pad[0] = key[16] | key[17] << 8;
          this._pad[1] = key[18] | key[19] << 8;
          this._pad[2] = key[20] | key[21] << 8;
          this._pad[3] = key[22] | key[23] << 8;
          this._pad[4] = key[24] | key[25] << 8;
          this._pad[5] = key[26] | key[27] << 8;
          this._pad[6] = key[28] | key[29] << 8;
          this._pad[7] = key[30] | key[31] << 8;
        }
        Poly13052.prototype._blocks = function(m3, mpos, bytes) {
          var hibit = this._fin ? 0 : 1 << 11;
          var h0 = this._h[0], h1 = this._h[1], h22 = this._h[2], h32 = this._h[3], h42 = this._h[4], h5 = this._h[5], h6 = this._h[6], h7 = this._h[7], h8 = this._h[8], h9 = this._h[9];
          var r0 = this._r[0], r1 = this._r[1], r2 = this._r[2], r3 = this._r[3], r4 = this._r[4], r5 = this._r[5], r6 = this._r[6], r7 = this._r[7], r8 = this._r[8], r9 = this._r[9];
          while (bytes >= 16) {
            var t0 = m3[mpos + 0] | m3[mpos + 1] << 8;
            h0 += t0 & 8191;
            var t1 = m3[mpos + 2] | m3[mpos + 3] << 8;
            h1 += (t0 >>> 13 | t1 << 3) & 8191;
            var t2 = m3[mpos + 4] | m3[mpos + 5] << 8;
            h22 += (t1 >>> 10 | t2 << 6) & 8191;
            var t3 = m3[mpos + 6] | m3[mpos + 7] << 8;
            h32 += (t2 >>> 7 | t3 << 9) & 8191;
            var t4 = m3[mpos + 8] | m3[mpos + 9] << 8;
            h42 += (t3 >>> 4 | t4 << 12) & 8191;
            h5 += t4 >>> 1 & 8191;
            var t5 = m3[mpos + 10] | m3[mpos + 11] << 8;
            h6 += (t4 >>> 14 | t5 << 2) & 8191;
            var t6 = m3[mpos + 12] | m3[mpos + 13] << 8;
            h7 += (t5 >>> 11 | t6 << 5) & 8191;
            var t7 = m3[mpos + 14] | m3[mpos + 15] << 8;
            h8 += (t6 >>> 8 | t7 << 8) & 8191;
            h9 += t7 >>> 5 | hibit;
            var c4 = 0;
            var d0 = c4;
            d0 += h0 * r0;
            d0 += h1 * (5 * r9);
            d0 += h22 * (5 * r8);
            d0 += h32 * (5 * r7);
            d0 += h42 * (5 * r6);
            c4 = d0 >>> 13;
            d0 &= 8191;
            d0 += h5 * (5 * r5);
            d0 += h6 * (5 * r4);
            d0 += h7 * (5 * r3);
            d0 += h8 * (5 * r2);
            d0 += h9 * (5 * r1);
            c4 += d0 >>> 13;
            d0 &= 8191;
            var d1 = c4;
            d1 += h0 * r1;
            d1 += h1 * r0;
            d1 += h22 * (5 * r9);
            d1 += h32 * (5 * r8);
            d1 += h42 * (5 * r7);
            c4 = d1 >>> 13;
            d1 &= 8191;
            d1 += h5 * (5 * r6);
            d1 += h6 * (5 * r5);
            d1 += h7 * (5 * r4);
            d1 += h8 * (5 * r3);
            d1 += h9 * (5 * r2);
            c4 += d1 >>> 13;
            d1 &= 8191;
            var d22 = c4;
            d22 += h0 * r2;
            d22 += h1 * r1;
            d22 += h22 * r0;
            d22 += h32 * (5 * r9);
            d22 += h42 * (5 * r8);
            c4 = d22 >>> 13;
            d22 &= 8191;
            d22 += h5 * (5 * r7);
            d22 += h6 * (5 * r6);
            d22 += h7 * (5 * r5);
            d22 += h8 * (5 * r4);
            d22 += h9 * (5 * r3);
            c4 += d22 >>> 13;
            d22 &= 8191;
            var d3 = c4;
            d3 += h0 * r3;
            d3 += h1 * r2;
            d3 += h22 * r1;
            d3 += h32 * r0;
            d3 += h42 * (5 * r9);
            c4 = d3 >>> 13;
            d3 &= 8191;
            d3 += h5 * (5 * r8);
            d3 += h6 * (5 * r7);
            d3 += h7 * (5 * r6);
            d3 += h8 * (5 * r5);
            d3 += h9 * (5 * r4);
            c4 += d3 >>> 13;
            d3 &= 8191;
            var d4 = c4;
            d4 += h0 * r4;
            d4 += h1 * r3;
            d4 += h22 * r2;
            d4 += h32 * r1;
            d4 += h42 * r0;
            c4 = d4 >>> 13;
            d4 &= 8191;
            d4 += h5 * (5 * r9);
            d4 += h6 * (5 * r8);
            d4 += h7 * (5 * r7);
            d4 += h8 * (5 * r6);
            d4 += h9 * (5 * r5);
            c4 += d4 >>> 13;
            d4 &= 8191;
            var d5 = c4;
            d5 += h0 * r5;
            d5 += h1 * r4;
            d5 += h22 * r3;
            d5 += h32 * r2;
            d5 += h42 * r1;
            c4 = d5 >>> 13;
            d5 &= 8191;
            d5 += h5 * r0;
            d5 += h6 * (5 * r9);
            d5 += h7 * (5 * r8);
            d5 += h8 * (5 * r7);
            d5 += h9 * (5 * r6);
            c4 += d5 >>> 13;
            d5 &= 8191;
            var d6 = c4;
            d6 += h0 * r6;
            d6 += h1 * r5;
            d6 += h22 * r4;
            d6 += h32 * r3;
            d6 += h42 * r2;
            c4 = d6 >>> 13;
            d6 &= 8191;
            d6 += h5 * r1;
            d6 += h6 * r0;
            d6 += h7 * (5 * r9);
            d6 += h8 * (5 * r8);
            d6 += h9 * (5 * r7);
            c4 += d6 >>> 13;
            d6 &= 8191;
            var d7 = c4;
            d7 += h0 * r7;
            d7 += h1 * r6;
            d7 += h22 * r5;
            d7 += h32 * r4;
            d7 += h42 * r3;
            c4 = d7 >>> 13;
            d7 &= 8191;
            d7 += h5 * r2;
            d7 += h6 * r1;
            d7 += h7 * r0;
            d7 += h8 * (5 * r9);
            d7 += h9 * (5 * r8);
            c4 += d7 >>> 13;
            d7 &= 8191;
            var d8 = c4;
            d8 += h0 * r8;
            d8 += h1 * r7;
            d8 += h22 * r6;
            d8 += h32 * r5;
            d8 += h42 * r4;
            c4 = d8 >>> 13;
            d8 &= 8191;
            d8 += h5 * r3;
            d8 += h6 * r2;
            d8 += h7 * r1;
            d8 += h8 * r0;
            d8 += h9 * (5 * r9);
            c4 += d8 >>> 13;
            d8 &= 8191;
            var d9 = c4;
            d9 += h0 * r9;
            d9 += h1 * r8;
            d9 += h22 * r7;
            d9 += h32 * r6;
            d9 += h42 * r5;
            c4 = d9 >>> 13;
            d9 &= 8191;
            d9 += h5 * r4;
            d9 += h6 * r3;
            d9 += h7 * r2;
            d9 += h8 * r1;
            d9 += h9 * r0;
            c4 += d9 >>> 13;
            d9 &= 8191;
            c4 = (c4 << 2) + c4 | 0;
            c4 = c4 + d0 | 0;
            d0 = c4 & 8191;
            c4 = c4 >>> 13;
            d1 += c4;
            h0 = d0;
            h1 = d1;
            h22 = d22;
            h32 = d3;
            h42 = d4;
            h5 = d5;
            h6 = d6;
            h7 = d7;
            h8 = d8;
            h9 = d9;
            mpos += 16;
            bytes -= 16;
          }
          this._h[0] = h0;
          this._h[1] = h1;
          this._h[2] = h22;
          this._h[3] = h32;
          this._h[4] = h42;
          this._h[5] = h5;
          this._h[6] = h6;
          this._h[7] = h7;
          this._h[8] = h8;
          this._h[9] = h9;
        };
        Poly13052.prototype.finish = function(mac, macpos) {
          if (macpos === void 0) {
            macpos = 0;
          }
          var g3 = new Uint16Array(10);
          var c4;
          var mask;
          var f4;
          var i2;
          if (this._leftover) {
            i2 = this._leftover;
            this._buffer[i2++] = 1;
            for (; i2 < 16; i2++) {
              this._buffer[i2] = 0;
            }
            this._fin = 1;
            this._blocks(this._buffer, 0, 16);
          }
          c4 = this._h[1] >>> 13;
          this._h[1] &= 8191;
          for (i2 = 2; i2 < 10; i2++) {
            this._h[i2] += c4;
            c4 = this._h[i2] >>> 13;
            this._h[i2] &= 8191;
          }
          this._h[0] += c4 * 5;
          c4 = this._h[0] >>> 13;
          this._h[0] &= 8191;
          this._h[1] += c4;
          c4 = this._h[1] >>> 13;
          this._h[1] &= 8191;
          this._h[2] += c4;
          g3[0] = this._h[0] + 5;
          c4 = g3[0] >>> 13;
          g3[0] &= 8191;
          for (i2 = 1; i2 < 10; i2++) {
            g3[i2] = this._h[i2] + c4;
            c4 = g3[i2] >>> 13;
            g3[i2] &= 8191;
          }
          g3[9] -= 1 << 13;
          mask = (c4 ^ 1) - 1;
          for (i2 = 0; i2 < 10; i2++) {
            g3[i2] &= mask;
          }
          mask = ~mask;
          for (i2 = 0; i2 < 10; i2++) {
            this._h[i2] = this._h[i2] & mask | g3[i2];
          }
          this._h[0] = (this._h[0] | this._h[1] << 13) & 65535;
          this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535;
          this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535;
          this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535;
          this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535;
          this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535;
          this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535;
          this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535;
          f4 = this._h[0] + this._pad[0];
          this._h[0] = f4 & 65535;
          for (i2 = 1; i2 < 8; i2++) {
            f4 = (this._h[i2] + this._pad[i2] | 0) + (f4 >>> 16) | 0;
            this._h[i2] = f4 & 65535;
          }
          mac[macpos + 0] = this._h[0] >>> 0;
          mac[macpos + 1] = this._h[0] >>> 8;
          mac[macpos + 2] = this._h[1] >>> 0;
          mac[macpos + 3] = this._h[1] >>> 8;
          mac[macpos + 4] = this._h[2] >>> 0;
          mac[macpos + 5] = this._h[2] >>> 8;
          mac[macpos + 6] = this._h[3] >>> 0;
          mac[macpos + 7] = this._h[3] >>> 8;
          mac[macpos + 8] = this._h[4] >>> 0;
          mac[macpos + 9] = this._h[4] >>> 8;
          mac[macpos + 10] = this._h[5] >>> 0;
          mac[macpos + 11] = this._h[5] >>> 8;
          mac[macpos + 12] = this._h[6] >>> 0;
          mac[macpos + 13] = this._h[6] >>> 8;
          mac[macpos + 14] = this._h[7] >>> 0;
          mac[macpos + 15] = this._h[7] >>> 8;
          this._finished = true;
          return this;
        };
        Poly13052.prototype.update = function(m3) {
          var mpos = 0;
          var bytes = m3.length;
          var want;
          if (this._leftover) {
            want = 16 - this._leftover;
            if (want > bytes) {
              want = bytes;
            }
            for (var i2 = 0; i2 < want; i2++) {
              this._buffer[this._leftover + i2] = m3[mpos + i2];
            }
            bytes -= want;
            mpos += want;
            this._leftover += want;
            if (this._leftover < 16) {
              return this;
            }
            this._blocks(this._buffer, 0, 16);
            this._leftover = 0;
          }
          if (bytes >= 16) {
            want = bytes - bytes % 16;
            this._blocks(m3, mpos, want);
            mpos += want;
            bytes -= want;
          }
          if (bytes) {
            for (var i2 = 0; i2 < bytes; i2++) {
              this._buffer[this._leftover + i2] = m3[mpos + i2];
            }
            this._leftover += bytes;
          }
          return this;
        };
        Poly13052.prototype.digest = function() {
          if (this._finished) {
            throw new Error("Poly1305 was finished");
          }
          var mac = new Uint8Array(16);
          this.finish(mac);
          return mac;
        };
        Poly13052.prototype.clean = function() {
          wipe_1.wipe(this._buffer);
          wipe_1.wipe(this._r);
          wipe_1.wipe(this._h);
          wipe_1.wipe(this._pad);
          this._leftover = 0;
          this._fin = 0;
          this._finished = true;
          return this;
        };
        return Poly13052;
      }()
    );
    exports2.Poly1305 = Poly1305;
    function oneTimeAuth(key, data) {
      var h5 = new Poly1305(key);
      h5.update(data);
      var digest2 = h5.digest();
      h5.clean();
      return digest2;
    }
    exports2.oneTimeAuth = oneTimeAuth;
    function equal(a3, b4) {
      if (a3.length !== exports2.DIGEST_LENGTH || b4.length !== exports2.DIGEST_LENGTH) {
        return false;
      }
      return constant_time_1.equal(a3, b4);
    }
    exports2.equal = equal;
  }
});

// node_modules/@stablelib/chacha20poly1305/lib/chacha20poly1305.js
var require_chacha20poly1305 = __commonJS({
  "node_modules/@stablelib/chacha20poly1305/lib/chacha20poly1305.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var chacha_1 = require_chacha();
    var poly1305_1 = require_poly1305();
    var wipe_1 = require_wipe();
    var binary_1 = require_binary2();
    var constant_time_1 = require_constant_time();
    exports2.KEY_LENGTH = 32;
    exports2.NONCE_LENGTH = 12;
    exports2.TAG_LENGTH = 16;
    var ZEROS = new Uint8Array(16);
    var ChaCha20Poly1305 = (
      /** @class */
      function() {
        function ChaCha20Poly13052(key) {
          this.nonceLength = exports2.NONCE_LENGTH;
          this.tagLength = exports2.TAG_LENGTH;
          if (key.length !== exports2.KEY_LENGTH) {
            throw new Error("ChaCha20Poly1305 needs 32-byte key");
          }
          this._key = new Uint8Array(key);
        }
        ChaCha20Poly13052.prototype.seal = function(nonce, plaintext, associatedData, dst) {
          if (nonce.length > 16) {
            throw new Error("ChaCha20Poly1305: incorrect nonce length");
          }
          var counter = new Uint8Array(16);
          counter.set(nonce, counter.length - nonce.length);
          var authKey = new Uint8Array(32);
          chacha_1.stream(this._key, counter, authKey, 4);
          var resultLength = plaintext.length + this.tagLength;
          var result;
          if (dst) {
            if (dst.length !== resultLength) {
              throw new Error("ChaCha20Poly1305: incorrect destination length");
            }
            result = dst;
          } else {
            result = new Uint8Array(resultLength);
          }
          chacha_1.streamXOR(this._key, counter, plaintext, result, 4);
          this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData);
          wipe_1.wipe(counter);
          return result;
        };
        ChaCha20Poly13052.prototype.open = function(nonce, sealed, associatedData, dst) {
          if (nonce.length > 16) {
            throw new Error("ChaCha20Poly1305: incorrect nonce length");
          }
          if (sealed.length < this.tagLength) {
            return null;
          }
          var counter = new Uint8Array(16);
          counter.set(nonce, counter.length - nonce.length);
          var authKey = new Uint8Array(32);
          chacha_1.stream(this._key, counter, authKey, 4);
          var calculatedTag = new Uint8Array(this.tagLength);
          this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData);
          if (!constant_time_1.equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length))) {
            return null;
          }
          var resultLength = sealed.length - this.tagLength;
          var result;
          if (dst) {
            if (dst.length !== resultLength) {
              throw new Error("ChaCha20Poly1305: incorrect destination length");
            }
            result = dst;
          } else {
            result = new Uint8Array(resultLength);
          }
          chacha_1.streamXOR(this._key, counter, sealed.subarray(0, sealed.length - this.tagLength), result, 4);
          wipe_1.wipe(counter);
          return result;
        };
        ChaCha20Poly13052.prototype.clean = function() {
          wipe_1.wipe(this._key);
          return this;
        };
        ChaCha20Poly13052.prototype._authenticate = function(tagOut, authKey, ciphertext, associatedData) {
          var h5 = new poly1305_1.Poly1305(authKey);
          if (associatedData) {
            h5.update(associatedData);
            if (associatedData.length % 16 > 0) {
              h5.update(ZEROS.subarray(associatedData.length % 16));
            }
          }
          h5.update(ciphertext);
          if (ciphertext.length % 16 > 0) {
            h5.update(ZEROS.subarray(ciphertext.length % 16));
          }
          var length2 = new Uint8Array(8);
          if (associatedData) {
            binary_1.writeUint64LE(associatedData.length, length2);
          }
          h5.update(length2);
          binary_1.writeUint64LE(ciphertext.length, length2);
          h5.update(length2);
          var tag = h5.digest();
          for (var i2 = 0; i2 < tag.length; i2++) {
            tagOut[i2] = tag[i2];
          }
          h5.clean();
          wipe_1.wipe(tag);
          wipe_1.wipe(length2);
        };
        return ChaCha20Poly13052;
      }()
    );
    exports2.ChaCha20Poly1305 = ChaCha20Poly1305;
  }
});

// node_modules/@stablelib/hash/lib/hash.js
var require_hash2 = __commonJS({
  "node_modules/@stablelib/hash/lib/hash.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    function isSerializableHash(h5) {
      return typeof h5.saveState !== "undefined" && typeof h5.restoreState !== "undefined" && typeof h5.cleanSavedState !== "undefined";
    }
    exports2.isSerializableHash = isSerializableHash;
  }
});

// node_modules/@stablelib/hmac/lib/hmac.js
var require_hmac = __commonJS({
  "node_modules/@stablelib/hmac/lib/hmac.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var hash_1 = require_hash2();
    var constant_time_1 = require_constant_time();
    var wipe_1 = require_wipe();
    var HMAC = (
      /** @class */
      function() {
        function HMAC2(hash, key) {
          this._finished = false;
          this._inner = new hash();
          this._outer = new hash();
          this.blockSize = this._outer.blockSize;
          this.digestLength = this._outer.digestLength;
          var pad = new Uint8Array(this.blockSize);
          if (key.length > this.blockSize) {
            this._inner.update(key).finish(pad).clean();
          } else {
            pad.set(key);
          }
          for (var i2 = 0; i2 < pad.length; i2++) {
            pad[i2] ^= 54;
          }
          this._inner.update(pad);
          for (var i2 = 0; i2 < pad.length; i2++) {
            pad[i2] ^= 54 ^ 92;
          }
          this._outer.update(pad);
          if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {
            this._innerKeyedState = this._inner.saveState();
            this._outerKeyedState = this._outer.saveState();
          }
          wipe_1.wipe(pad);
        }
        HMAC2.prototype.reset = function() {
          if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
            throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
          }
          this._inner.restoreState(this._innerKeyedState);
          this._outer.restoreState(this._outerKeyedState);
          this._finished = false;
          return this;
        };
        HMAC2.prototype.clean = function() {
          if (hash_1.isSerializableHash(this._inner)) {
            this._inner.cleanSavedState(this._innerKeyedState);
          }
          if (hash_1.isSerializableHash(this._outer)) {
            this._outer.cleanSavedState(this._outerKeyedState);
          }
          this._inner.clean();
          this._outer.clean();
        };
        HMAC2.prototype.update = function(data) {
          this._inner.update(data);
          return this;
        };
        HMAC2.prototype.finish = function(out) {
          if (this._finished) {
            this._outer.finish(out);
            return this;
          }
          this._inner.finish(out);
          this._outer.update(out.subarray(0, this.digestLength)).finish(out);
          this._finished = true;
          return this;
        };
        HMAC2.prototype.digest = function() {
          var out = new Uint8Array(this.digestLength);
          this.finish(out);
          return out;
        };
        HMAC2.prototype.saveState = function() {
          if (!hash_1.isSerializableHash(this._inner)) {
            throw new Error("hmac: can't saveState() because hash doesn't implement it");
          }
          return this._inner.saveState();
        };
        HMAC2.prototype.restoreState = function(savedState) {
          if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
            throw new Error("hmac: can't restoreState() because hash doesn't implement it");
          }
          this._inner.restoreState(savedState);
          this._outer.restoreState(this._outerKeyedState);
          this._finished = false;
          return this;
        };
        HMAC2.prototype.cleanSavedState = function(savedState) {
          if (!hash_1.isSerializableHash(this._inner)) {
            throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
          }
          this._inner.cleanSavedState(savedState);
        };
        return HMAC2;
      }()
    );
    exports2.HMAC = HMAC;
    function hmac(hash, key, data) {
      var h5 = new HMAC(hash, key);
      h5.update(data);
      var digest2 = h5.digest();
      h5.clean();
      return digest2;
    }
    exports2.hmac = hmac;
    exports2.equal = constant_time_1.equal;
  }
});

// node_modules/@stablelib/hkdf/lib/hkdf.js
var require_hkdf = __commonJS({
  "node_modules/@stablelib/hkdf/lib/hkdf.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var hmac_1 = require_hmac();
    var wipe_1 = require_wipe();
    var HKDF = (
      /** @class */
      function() {
        function HKDF2(hash, key, salt, info) {
          if (salt === void 0) {
            salt = new Uint8Array(0);
          }
          this._counter = new Uint8Array(1);
          this._hash = hash;
          this._info = info;
          var okm = hmac_1.hmac(this._hash, salt, key);
          this._hmac = new hmac_1.HMAC(hash, okm);
          this._buffer = new Uint8Array(this._hmac.digestLength);
          this._bufpos = this._buffer.length;
        }
        HKDF2.prototype._fillBuffer = function() {
          this._counter[0]++;
          var ctr = this._counter[0];
          if (ctr === 0) {
            throw new Error("hkdf: cannot expand more");
          }
          this._hmac.reset();
          if (ctr > 1) {
            this._hmac.update(this._buffer);
          }
          if (this._info) {
            this._hmac.update(this._info);
          }
          this._hmac.update(this._counter);
          this._hmac.finish(this._buffer);
          this._bufpos = 0;
        };
        HKDF2.prototype.expand = function(length2) {
          var out = new Uint8Array(length2);
          for (var i2 = 0; i2 < out.length; i2++) {
            if (this._bufpos === this._buffer.length) {
              this._fillBuffer();
            }
            out[i2] = this._buffer[this._bufpos++];
          }
          return out;
        };
        HKDF2.prototype.clean = function() {
          this._hmac.clean();
          wipe_1.wipe(this._buffer);
          wipe_1.wipe(this._counter);
          this._bufpos = 0;
        };
        return HKDF2;
      }()
    );
    exports2.HKDF = HKDF;
  }
});

// node_modules/@stablelib/sha256/lib/sha256.js
var require_sha256 = __commonJS({
  "node_modules/@stablelib/sha256/lib/sha256.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var binary_1 = require_binary2();
    var wipe_1 = require_wipe();
    exports2.DIGEST_LENGTH = 32;
    exports2.BLOCK_SIZE = 64;
    var SHA256 = (
      /** @class */
      function() {
        function SHA2562() {
          this.digestLength = exports2.DIGEST_LENGTH;
          this.blockSize = exports2.BLOCK_SIZE;
          this._state = new Int32Array(8);
          this._temp = new Int32Array(64);
          this._buffer = new Uint8Array(128);
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          this.reset();
        }
        SHA2562.prototype._initState = function() {
          this._state[0] = 1779033703;
          this._state[1] = 3144134277;
          this._state[2] = 1013904242;
          this._state[3] = 2773480762;
          this._state[4] = 1359893119;
          this._state[5] = 2600822924;
          this._state[6] = 528734635;
          this._state[7] = 1541459225;
        };
        SHA2562.prototype.reset = function() {
          this._initState();
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          return this;
        };
        SHA2562.prototype.clean = function() {
          wipe_1.wipe(this._buffer);
          wipe_1.wipe(this._temp);
          this.reset();
        };
        SHA2562.prototype.update = function(data, dataLength) {
          if (dataLength === void 0) {
            dataLength = data.length;
          }
          if (this._finished) {
            throw new Error("SHA256: can't update because hash was finished.");
          }
          var dataPos = 0;
          this._bytesHashed += dataLength;
          if (this._bufferLength > 0) {
            while (this._bufferLength < this.blockSize && dataLength > 0) {
              this._buffer[this._bufferLength++] = data[dataPos++];
              dataLength--;
            }
            if (this._bufferLength === this.blockSize) {
              hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize);
              this._bufferLength = 0;
            }
          }
          if (dataLength >= this.blockSize) {
            dataPos = hashBlocks(this._temp, this._state, data, dataPos, dataLength);
            dataLength %= this.blockSize;
          }
          while (dataLength > 0) {
            this._buffer[this._bufferLength++] = data[dataPos++];
            dataLength--;
          }
          return this;
        };
        SHA2562.prototype.finish = function(out) {
          if (!this._finished) {
            var bytesHashed = this._bytesHashed;
            var left = this._bufferLength;
            var bitLenHi = bytesHashed / 536870912 | 0;
            var bitLenLo = bytesHashed << 3;
            var padLength = bytesHashed % 64 < 56 ? 64 : 128;
            this._buffer[left] = 128;
            for (var i2 = left + 1; i2 < padLength - 8; i2++) {
              this._buffer[i2] = 0;
            }
            binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
            binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
            hashBlocks(this._temp, this._state, this._buffer, 0, padLength);
            this._finished = true;
          }
          for (var i2 = 0; i2 < this.digestLength / 4; i2++) {
            binary_1.writeUint32BE(this._state[i2], out, i2 * 4);
          }
          return this;
        };
        SHA2562.prototype.digest = function() {
          var out = new Uint8Array(this.digestLength);
          this.finish(out);
          return out;
        };
        SHA2562.prototype.saveState = function() {
          if (this._finished) {
            throw new Error("SHA256: cannot save finished state");
          }
          return {
            state: new Int32Array(this._state),
            buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
            bufferLength: this._bufferLength,
            bytesHashed: this._bytesHashed
          };
        };
        SHA2562.prototype.restoreState = function(savedState) {
          this._state.set(savedState.state);
          this._bufferLength = savedState.bufferLength;
          if (savedState.buffer) {
            this._buffer.set(savedState.buffer);
          }
          this._bytesHashed = savedState.bytesHashed;
          this._finished = false;
          return this;
        };
        SHA2562.prototype.cleanSavedState = function(savedState) {
          wipe_1.wipe(savedState.state);
          if (savedState.buffer) {
            wipe_1.wipe(savedState.buffer);
          }
          savedState.bufferLength = 0;
          savedState.bytesHashed = 0;
        };
        return SHA2562;
      }()
    );
    exports2.SHA256 = SHA256;
    var K2 = new Int32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    function hashBlocks(w4, v2, p3, pos, len) {
      while (len >= 64) {
        var a3 = v2[0];
        var b4 = v2[1];
        var c4 = v2[2];
        var d3 = v2[3];
        var e2 = v2[4];
        var f4 = v2[5];
        var g3 = v2[6];
        var h5 = v2[7];
        for (var i2 = 0; i2 < 16; i2++) {
          var j2 = pos + i2 * 4;
          w4[i2] = binary_1.readUint32BE(p3, j2);
        }
        for (var i2 = 16; i2 < 64; i2++) {
          var u3 = w4[i2 - 2];
          var t1 = (u3 >>> 17 | u3 << 32 - 17) ^ (u3 >>> 19 | u3 << 32 - 19) ^ u3 >>> 10;
          u3 = w4[i2 - 15];
          var t2 = (u3 >>> 7 | u3 << 32 - 7) ^ (u3 >>> 18 | u3 << 32 - 18) ^ u3 >>> 3;
          w4[i2] = (t1 + w4[i2 - 7] | 0) + (t2 + w4[i2 - 16] | 0);
        }
        for (var i2 = 0; i2 < 64; i2++) {
          var t1 = (((e2 >>> 6 | e2 << 32 - 6) ^ (e2 >>> 11 | e2 << 32 - 11) ^ (e2 >>> 25 | e2 << 32 - 25)) + (e2 & f4 ^ ~e2 & g3) | 0) + (h5 + (K2[i2] + w4[i2] | 0) | 0) | 0;
          var t2 = ((a3 >>> 2 | a3 << 32 - 2) ^ (a3 >>> 13 | a3 << 32 - 13) ^ (a3 >>> 22 | a3 << 32 - 22)) + (a3 & b4 ^ a3 & c4 ^ b4 & c4) | 0;
          h5 = g3;
          g3 = f4;
          f4 = e2;
          e2 = d3 + t1 | 0;
          d3 = c4;
          c4 = b4;
          b4 = a3;
          a3 = t1 + t2 | 0;
        }
        v2[0] += a3;
        v2[1] += b4;
        v2[2] += c4;
        v2[3] += d3;
        v2[4] += e2;
        v2[5] += f4;
        v2[6] += g3;
        v2[7] += h5;
        pos += 64;
        len -= 64;
      }
      return pos;
    }
    function hash(data) {
      var h5 = new SHA256();
      h5.update(data);
      var digest2 = h5.digest();
      h5.clean();
      return digest2;
    }
    exports2.hash = hash;
  }
});

// node_modules/@stablelib/x25519/lib/x25519.js
var require_x25519 = __commonJS({
  "node_modules/@stablelib/x25519/lib/x25519.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sharedKey = exports2.generateKeyPair = exports2.generateKeyPairFromSeed = exports2.scalarMultBase = exports2.scalarMult = exports2.SHARED_KEY_LENGTH = exports2.SECRET_KEY_LENGTH = exports2.PUBLIC_KEY_LENGTH = void 0;
    var random_1 = require_random();
    var wipe_1 = require_wipe();
    exports2.PUBLIC_KEY_LENGTH = 32;
    exports2.SECRET_KEY_LENGTH = 32;
    exports2.SHARED_KEY_LENGTH = 32;
    function gf(init) {
      const r = new Float64Array(16);
      if (init) {
        for (let i2 = 0; i2 < init.length; i2++) {
          r[i2] = init[i2];
        }
      }
      return r;
    }
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var _121665 = gf([56129, 1]);
    function car25519(o2) {
      let c4 = 1;
      for (let i2 = 0; i2 < 16; i2++) {
        let v2 = o2[i2] + c4 + 65535;
        c4 = Math.floor(v2 / 65536);
        o2[i2] = v2 - c4 * 65536;
      }
      o2[0] += c4 - 1 + 37 * (c4 - 1);
    }
    function sel25519(p3, q2, b4) {
      const c4 = ~(b4 - 1);
      for (let i2 = 0; i2 < 16; i2++) {
        const t = c4 & (p3[i2] ^ q2[i2]);
        p3[i2] ^= t;
        q2[i2] ^= t;
      }
    }
    function pack25519(o2, n3) {
      const m3 = gf();
      const t = gf();
      for (let i2 = 0; i2 < 16; i2++) {
        t[i2] = n3[i2];
      }
      car25519(t);
      car25519(t);
      car25519(t);
      for (let j2 = 0; j2 < 2; j2++) {
        m3[0] = t[0] - 65517;
        for (let i2 = 1; i2 < 15; i2++) {
          m3[i2] = t[i2] - 65535 - (m3[i2 - 1] >> 16 & 1);
          m3[i2 - 1] &= 65535;
        }
        m3[15] = t[15] - 32767 - (m3[14] >> 16 & 1);
        const b4 = m3[15] >> 16 & 1;
        m3[14] &= 65535;
        sel25519(t, m3, 1 - b4);
      }
      for (let i2 = 0; i2 < 16; i2++) {
        o2[2 * i2] = t[i2] & 255;
        o2[2 * i2 + 1] = t[i2] >> 8;
      }
    }
    function unpack25519(o2, n3) {
      for (let i2 = 0; i2 < 16; i2++) {
        o2[i2] = n3[2 * i2] + (n3[2 * i2 + 1] << 8);
      }
      o2[15] &= 32767;
    }
    function add(o2, a3, b4) {
      for (let i2 = 0; i2 < 16; i2++) {
        o2[i2] = a3[i2] + b4[i2];
      }
    }
    function sub(o2, a3, b4) {
      for (let i2 = 0; i2 < 16; i2++) {
        o2[i2] = a3[i2] - b4[i2];
      }
    }
    function mul(o2, a3, b4) {
      let v2, c4, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b4[0], b1 = b4[1], b22 = b4[2], b32 = b4[3], b42 = b4[4], b5 = b4[5], b6 = b4[6], b7 = b4[7], b8 = b4[8], b9 = b4[9], b10 = b4[10], b11 = b4[11], b12 = b4[12], b13 = b4[13], b14 = b4[14], b15 = b4[15];
      v2 = a3[0];
      t0 += v2 * b0;
      t1 += v2 * b1;
      t2 += v2 * b22;
      t3 += v2 * b32;
      t4 += v2 * b42;
      t5 += v2 * b5;
      t6 += v2 * b6;
      t7 += v2 * b7;
      t8 += v2 * b8;
      t9 += v2 * b9;
      t10 += v2 * b10;
      t11 += v2 * b11;
      t12 += v2 * b12;
      t13 += v2 * b13;
      t14 += v2 * b14;
      t15 += v2 * b15;
      v2 = a3[1];
      t1 += v2 * b0;
      t2 += v2 * b1;
      t3 += v2 * b22;
      t4 += v2 * b32;
      t5 += v2 * b42;
      t6 += v2 * b5;
      t7 += v2 * b6;
      t8 += v2 * b7;
      t9 += v2 * b8;
      t10 += v2 * b9;
      t11 += v2 * b10;
      t12 += v2 * b11;
      t13 += v2 * b12;
      t14 += v2 * b13;
      t15 += v2 * b14;
      t16 += v2 * b15;
      v2 = a3[2];
      t2 += v2 * b0;
      t3 += v2 * b1;
      t4 += v2 * b22;
      t5 += v2 * b32;
      t6 += v2 * b42;
      t7 += v2 * b5;
      t8 += v2 * b6;
      t9 += v2 * b7;
      t10 += v2 * b8;
      t11 += v2 * b9;
      t12 += v2 * b10;
      t13 += v2 * b11;
      t14 += v2 * b12;
      t15 += v2 * b13;
      t16 += v2 * b14;
      t17 += v2 * b15;
      v2 = a3[3];
      t3 += v2 * b0;
      t4 += v2 * b1;
      t5 += v2 * b22;
      t6 += v2 * b32;
      t7 += v2 * b42;
      t8 += v2 * b5;
      t9 += v2 * b6;
      t10 += v2 * b7;
      t11 += v2 * b8;
      t12 += v2 * b9;
      t13 += v2 * b10;
      t14 += v2 * b11;
      t15 += v2 * b12;
      t16 += v2 * b13;
      t17 += v2 * b14;
      t18 += v2 * b15;
      v2 = a3[4];
      t4 += v2 * b0;
      t5 += v2 * b1;
      t6 += v2 * b22;
      t7 += v2 * b32;
      t8 += v2 * b42;
      t9 += v2 * b5;
      t10 += v2 * b6;
      t11 += v2 * b7;
      t12 += v2 * b8;
      t13 += v2 * b9;
      t14 += v2 * b10;
      t15 += v2 * b11;
      t16 += v2 * b12;
      t17 += v2 * b13;
      t18 += v2 * b14;
      t19 += v2 * b15;
      v2 = a3[5];
      t5 += v2 * b0;
      t6 += v2 * b1;
      t7 += v2 * b22;
      t8 += v2 * b32;
      t9 += v2 * b42;
      t10 += v2 * b5;
      t11 += v2 * b6;
      t12 += v2 * b7;
      t13 += v2 * b8;
      t14 += v2 * b9;
      t15 += v2 * b10;
      t16 += v2 * b11;
      t17 += v2 * b12;
      t18 += v2 * b13;
      t19 += v2 * b14;
      t20 += v2 * b15;
      v2 = a3[6];
      t6 += v2 * b0;
      t7 += v2 * b1;
      t8 += v2 * b22;
      t9 += v2 * b32;
      t10 += v2 * b42;
      t11 += v2 * b5;
      t12 += v2 * b6;
      t13 += v2 * b7;
      t14 += v2 * b8;
      t15 += v2 * b9;
      t16 += v2 * b10;
      t17 += v2 * b11;
      t18 += v2 * b12;
      t19 += v2 * b13;
      t20 += v2 * b14;
      t21 += v2 * b15;
      v2 = a3[7];
      t7 += v2 * b0;
      t8 += v2 * b1;
      t9 += v2 * b22;
      t10 += v2 * b32;
      t11 += v2 * b42;
      t12 += v2 * b5;
      t13 += v2 * b6;
      t14 += v2 * b7;
      t15 += v2 * b8;
      t16 += v2 * b9;
      t17 += v2 * b10;
      t18 += v2 * b11;
      t19 += v2 * b12;
      t20 += v2 * b13;
      t21 += v2 * b14;
      t22 += v2 * b15;
      v2 = a3[8];
      t8 += v2 * b0;
      t9 += v2 * b1;
      t10 += v2 * b22;
      t11 += v2 * b32;
      t12 += v2 * b42;
      t13 += v2 * b5;
      t14 += v2 * b6;
      t15 += v2 * b7;
      t16 += v2 * b8;
      t17 += v2 * b9;
      t18 += v2 * b10;
      t19 += v2 * b11;
      t20 += v2 * b12;
      t21 += v2 * b13;
      t22 += v2 * b14;
      t23 += v2 * b15;
      v2 = a3[9];
      t9 += v2 * b0;
      t10 += v2 * b1;
      t11 += v2 * b22;
      t12 += v2 * b32;
      t13 += v2 * b42;
      t14 += v2 * b5;
      t15 += v2 * b6;
      t16 += v2 * b7;
      t17 += v2 * b8;
      t18 += v2 * b9;
      t19 += v2 * b10;
      t20 += v2 * b11;
      t21 += v2 * b12;
      t22 += v2 * b13;
      t23 += v2 * b14;
      t24 += v2 * b15;
      v2 = a3[10];
      t10 += v2 * b0;
      t11 += v2 * b1;
      t12 += v2 * b22;
      t13 += v2 * b32;
      t14 += v2 * b42;
      t15 += v2 * b5;
      t16 += v2 * b6;
      t17 += v2 * b7;
      t18 += v2 * b8;
      t19 += v2 * b9;
      t20 += v2 * b10;
      t21 += v2 * b11;
      t22 += v2 * b12;
      t23 += v2 * b13;
      t24 += v2 * b14;
      t25 += v2 * b15;
      v2 = a3[11];
      t11 += v2 * b0;
      t12 += v2 * b1;
      t13 += v2 * b22;
      t14 += v2 * b32;
      t15 += v2 * b42;
      t16 += v2 * b5;
      t17 += v2 * b6;
      t18 += v2 * b7;
      t19 += v2 * b8;
      t20 += v2 * b9;
      t21 += v2 * b10;
      t22 += v2 * b11;
      t23 += v2 * b12;
      t24 += v2 * b13;
      t25 += v2 * b14;
      t26 += v2 * b15;
      v2 = a3[12];
      t12 += v2 * b0;
      t13 += v2 * b1;
      t14 += v2 * b22;
      t15 += v2 * b32;
      t16 += v2 * b42;
      t17 += v2 * b5;
      t18 += v2 * b6;
      t19 += v2 * b7;
      t20 += v2 * b8;
      t21 += v2 * b9;
      t22 += v2 * b10;
      t23 += v2 * b11;
      t24 += v2 * b12;
      t25 += v2 * b13;
      t26 += v2 * b14;
      t27 += v2 * b15;
      v2 = a3[13];
      t13 += v2 * b0;
      t14 += v2 * b1;
      t15 += v2 * b22;
      t16 += v2 * b32;
      t17 += v2 * b42;
      t18 += v2 * b5;
      t19 += v2 * b6;
      t20 += v2 * b7;
      t21 += v2 * b8;
      t22 += v2 * b9;
      t23 += v2 * b10;
      t24 += v2 * b11;
      t25 += v2 * b12;
      t26 += v2 * b13;
      t27 += v2 * b14;
      t28 += v2 * b15;
      v2 = a3[14];
      t14 += v2 * b0;
      t15 += v2 * b1;
      t16 += v2 * b22;
      t17 += v2 * b32;
      t18 += v2 * b42;
      t19 += v2 * b5;
      t20 += v2 * b6;
      t21 += v2 * b7;
      t22 += v2 * b8;
      t23 += v2 * b9;
      t24 += v2 * b10;
      t25 += v2 * b11;
      t26 += v2 * b12;
      t27 += v2 * b13;
      t28 += v2 * b14;
      t29 += v2 * b15;
      v2 = a3[15];
      t15 += v2 * b0;
      t16 += v2 * b1;
      t17 += v2 * b22;
      t18 += v2 * b32;
      t19 += v2 * b42;
      t20 += v2 * b5;
      t21 += v2 * b6;
      t22 += v2 * b7;
      t23 += v2 * b8;
      t24 += v2 * b9;
      t25 += v2 * b10;
      t26 += v2 * b11;
      t27 += v2 * b12;
      t28 += v2 * b13;
      t29 += v2 * b14;
      t30 += v2 * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c4 = 1;
      v2 = t0 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t0 = v2 - c4 * 65536;
      v2 = t1 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t1 = v2 - c4 * 65536;
      v2 = t2 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t2 = v2 - c4 * 65536;
      v2 = t3 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t3 = v2 - c4 * 65536;
      v2 = t4 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t4 = v2 - c4 * 65536;
      v2 = t5 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t5 = v2 - c4 * 65536;
      v2 = t6 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t6 = v2 - c4 * 65536;
      v2 = t7 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t7 = v2 - c4 * 65536;
      v2 = t8 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t8 = v2 - c4 * 65536;
      v2 = t9 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t9 = v2 - c4 * 65536;
      v2 = t10 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t10 = v2 - c4 * 65536;
      v2 = t11 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t11 = v2 - c4 * 65536;
      v2 = t12 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t12 = v2 - c4 * 65536;
      v2 = t13 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t13 = v2 - c4 * 65536;
      v2 = t14 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t14 = v2 - c4 * 65536;
      v2 = t15 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t15 = v2 - c4 * 65536;
      t0 += c4 - 1 + 37 * (c4 - 1);
      c4 = 1;
      v2 = t0 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t0 = v2 - c4 * 65536;
      v2 = t1 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t1 = v2 - c4 * 65536;
      v2 = t2 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t2 = v2 - c4 * 65536;
      v2 = t3 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t3 = v2 - c4 * 65536;
      v2 = t4 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t4 = v2 - c4 * 65536;
      v2 = t5 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t5 = v2 - c4 * 65536;
      v2 = t6 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t6 = v2 - c4 * 65536;
      v2 = t7 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t7 = v2 - c4 * 65536;
      v2 = t8 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t8 = v2 - c4 * 65536;
      v2 = t9 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t9 = v2 - c4 * 65536;
      v2 = t10 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t10 = v2 - c4 * 65536;
      v2 = t11 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t11 = v2 - c4 * 65536;
      v2 = t12 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t12 = v2 - c4 * 65536;
      v2 = t13 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t13 = v2 - c4 * 65536;
      v2 = t14 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t14 = v2 - c4 * 65536;
      v2 = t15 + c4 + 65535;
      c4 = Math.floor(v2 / 65536);
      t15 = v2 - c4 * 65536;
      t0 += c4 - 1 + 37 * (c4 - 1);
      o2[0] = t0;
      o2[1] = t1;
      o2[2] = t2;
      o2[3] = t3;
      o2[4] = t4;
      o2[5] = t5;
      o2[6] = t6;
      o2[7] = t7;
      o2[8] = t8;
      o2[9] = t9;
      o2[10] = t10;
      o2[11] = t11;
      o2[12] = t12;
      o2[13] = t13;
      o2[14] = t14;
      o2[15] = t15;
    }
    function square(o2, a3) {
      mul(o2, a3, a3);
    }
    function inv25519(o2, inp) {
      const c4 = gf();
      for (let i2 = 0; i2 < 16; i2++) {
        c4[i2] = inp[i2];
      }
      for (let i2 = 253; i2 >= 0; i2--) {
        square(c4, c4);
        if (i2 !== 2 && i2 !== 4) {
          mul(c4, c4, inp);
        }
      }
      for (let i2 = 0; i2 < 16; i2++) {
        o2[i2] = c4[i2];
      }
    }
    function scalarMult(n3, p3) {
      const z3 = new Uint8Array(32);
      const x3 = new Float64Array(80);
      const a3 = gf(), b4 = gf(), c4 = gf(), d3 = gf(), e2 = gf(), f4 = gf();
      for (let i2 = 0; i2 < 31; i2++) {
        z3[i2] = n3[i2];
      }
      z3[31] = n3[31] & 127 | 64;
      z3[0] &= 248;
      unpack25519(x3, p3);
      for (let i2 = 0; i2 < 16; i2++) {
        b4[i2] = x3[i2];
      }
      a3[0] = d3[0] = 1;
      for (let i2 = 254; i2 >= 0; --i2) {
        const r = z3[i2 >>> 3] >>> (i2 & 7) & 1;
        sel25519(a3, b4, r);
        sel25519(c4, d3, r);
        add(e2, a3, c4);
        sub(a3, a3, c4);
        add(c4, b4, d3);
        sub(b4, b4, d3);
        square(d3, e2);
        square(f4, a3);
        mul(a3, c4, a3);
        mul(c4, b4, e2);
        add(e2, a3, c4);
        sub(a3, a3, c4);
        square(b4, a3);
        sub(c4, d3, f4);
        mul(a3, c4, _121665);
        add(a3, a3, d3);
        mul(c4, c4, a3);
        mul(a3, d3, f4);
        mul(d3, b4, x3);
        square(b4, e2);
        sel25519(a3, b4, r);
        sel25519(c4, d3, r);
      }
      for (let i2 = 0; i2 < 16; i2++) {
        x3[i2 + 16] = a3[i2];
        x3[i2 + 32] = c4[i2];
        x3[i2 + 48] = b4[i2];
        x3[i2 + 64] = d3[i2];
      }
      const x32 = x3.subarray(32);
      const x16 = x3.subarray(16);
      inv25519(x32, x32);
      mul(x16, x16, x32);
      const q2 = new Uint8Array(32);
      pack25519(q2, x16);
      return q2;
    }
    exports2.scalarMult = scalarMult;
    function scalarMultBase(n3) {
      return scalarMult(n3, _9);
    }
    exports2.scalarMultBase = scalarMultBase;
    function generateKeyPairFromSeed2(seed) {
      if (seed.length !== exports2.SECRET_KEY_LENGTH) {
        throw new Error(`x25519: seed must be ${exports2.SECRET_KEY_LENGTH} bytes`);
      }
      const secretKey = new Uint8Array(seed);
      const publicKey = scalarMultBase(secretKey);
      return {
        publicKey,
        secretKey
      };
    }
    exports2.generateKeyPairFromSeed = generateKeyPairFromSeed2;
    function generateKeyPair2(prng) {
      const seed = (0, random_1.randomBytes)(32, prng);
      const result = generateKeyPairFromSeed2(seed);
      (0, wipe_1.wipe)(seed);
      return result;
    }
    exports2.generateKeyPair = generateKeyPair2;
    function sharedKey(mySecretKey, theirPublicKey, rejectZero = false) {
      if (mySecretKey.length !== exports2.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect secret key length");
      }
      if (theirPublicKey.length !== exports2.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect public key length");
      }
      const result = scalarMult(mySecretKey, theirPublicKey);
      if (rejectZero) {
        let zeros = 0;
        for (let i2 = 0; i2 < result.length; i2++) {
          zeros |= result[i2];
        }
        if (zeros === 0) {
          throw new Error("X25519: invalid shared key");
        }
      }
      return result;
    }
    exports2.sharedKey = sharedKey;
  }
});

// node_modules/uint8arrays/esm/src/compare.js
function compare(a3, b4) {
  for (let i2 = 0; i2 < a3.byteLength; i2++) {
    if (a3[i2] < b4[i2]) {
      return -1;
    }
    if (a3[i2] > b4[i2]) {
      return 1;
    }
  }
  if (a3.byteLength > b4.byteLength) {
    return 1;
  }
  if (a3.byteLength < b4.byteLength) {
    return -1;
  }
  return 0;
}
var init_compare = __esm({
  "node_modules/uint8arrays/esm/src/compare.js"() {
    init_shim();
  }
});

// node_modules/uint8arrays/esm/src/equals.js
function equals3(a3, b4) {
  if (a3 === b4) {
    return true;
  }
  if (a3.byteLength !== b4.byteLength) {
    return false;
  }
  for (let i2 = 0; i2 < a3.byteLength; i2++) {
    if (a3[i2] !== b4[i2]) {
      return false;
    }
  }
  return true;
}
var init_equals = __esm({
  "node_modules/uint8arrays/esm/src/equals.js"() {
    init_shim();
  }
});

// node_modules/uint8arrays/esm/src/xor.js
function xor(a3, b4) {
  if (a3.length !== b4.length) {
    throw new Error("Inputs should have the same length");
  }
  const result = allocUnsafe(a3.length);
  for (let i2 = 0; i2 < a3.length; i2++) {
    result[i2] = a3[i2] ^ b4[i2];
  }
  return asUint8Array(result);
}
var init_xor = __esm({
  "node_modules/uint8arrays/esm/src/xor.js"() {
    init_shim();
    init_alloc();
    init_as_uint8array();
  }
});

// node_modules/uint8arrays/esm/src/index.js
var src_exports = {};
__export(src_exports, {
  compare: () => compare,
  concat: () => concat,
  equals: () => equals3,
  fromString: () => fromString2,
  toString: () => toString2,
  xor: () => xor
});
var init_src2 = __esm({
  "node_modules/uint8arrays/esm/src/index.js"() {
    init_shim();
    init_compare();
    init_concat();
    init_equals();
    init_from_string();
    init_to_string();
    init_xor();
  }
});

// node_modules/@walletconnect/relay-api/dist/index.es.js
var index_es_exports3 = {};
__export(index_es_exports3, {
  RELAY_JSONRPC: () => C2,
  isPublishMethod: () => c3,
  isPublishParams: () => h3,
  isPublishRequest: () => P,
  isSubscribeMethod: () => b2,
  isSubscribeParams: () => a,
  isSubscribeRequest: () => R,
  isSubscriptionMethod: () => m2,
  isSubscriptionParams: () => d2,
  isSubscriptionRequest: () => S2,
  isUnsubscribeMethod: () => o,
  isUnsubscribeParams: () => p2,
  isUnsubscribeRequest: () => _3,
  parsePublishRequest: () => q,
  parseSubscribeRequest: () => g2,
  parseSubscriptionRequest: () => k3,
  parseUnsubscribeRequest: () => E3
});
function e(s2, r, i2 = "string") {
  if (!s2[r] || typeof s2[r] !== i2)
    throw new Error(`Missing or invalid "${r}" param`);
}
function l3(s2, r) {
  let i2 = true;
  return r.forEach((t) => {
    t in s2 || (i2 = false);
  }), i2;
}
function f2(s2, r) {
  return Array.isArray(s2) ? s2.length === r : Object.keys(s2).length === r;
}
function w2(s2, r) {
  return Array.isArray(s2) ? s2.length >= r : Object.keys(s2).length >= r;
}
function u(s2, r, i2) {
  return (i2.length ? w2(s2, r.length) : f2(s2, r.length)) ? l3(s2, r) : false;
}
function n2(s2, r, i2 = "_") {
  const t = s2.split(i2);
  return t[t.length - 1].trim().toLowerCase() === r.trim().toLowerCase();
}
function R(s2) {
  return b2(s2.method) && a(s2.params);
}
function b2(s2) {
  return n2(s2, "subscribe");
}
function a(s2) {
  return u(s2, ["topic"], []);
}
function P(s2) {
  return c3(s2.method) && h3(s2.params);
}
function c3(s2) {
  return n2(s2, "publish");
}
function h3(s2) {
  return u(s2, ["message", "topic", "ttl"], ["prompt", "tag"]);
}
function _3(s2) {
  return o(s2.method) && p2(s2.params);
}
function o(s2) {
  return n2(s2, "unsubscribe");
}
function p2(s2) {
  return u(s2, ["id", "topic"], []);
}
function S2(s2) {
  return m2(s2.method) && d2(s2.params);
}
function m2(s2) {
  return n2(s2, "subscription");
}
function d2(s2) {
  return u(s2, ["id", "data"], []);
}
function g2(s2) {
  if (!b2(s2.method))
    throw new Error("JSON-RPC Request has invalid subscribe method");
  if (!a(s2.params))
    throw new Error("JSON-RPC Request has invalid subscribe params");
  const r = s2.params;
  return e(r, "topic"), r;
}
function q(s2) {
  if (!c3(s2.method))
    throw new Error("JSON-RPC Request has invalid publish method");
  if (!h3(s2.params))
    throw new Error("JSON-RPC Request has invalid publish params");
  const r = s2.params;
  return e(r, "topic"), e(r, "message"), e(r, "ttl", "number"), r;
}
function E3(s2) {
  if (!o(s2.method))
    throw new Error("JSON-RPC Request has invalid unsubscribe method");
  if (!p2(s2.params))
    throw new Error("JSON-RPC Request has invalid unsubscribe params");
  const r = s2.params;
  return e(r, "id"), r;
}
function k3(s2) {
  if (!m2(s2.method))
    throw new Error("JSON-RPC Request has invalid subscription method");
  if (!d2(s2.params))
    throw new Error("JSON-RPC Request has invalid subscription params");
  const r = s2.params;
  return e(r, "id"), e(r, "data"), r;
}
var C2;
var init_index_es3 = __esm({
  "node_modules/@walletconnect/relay-api/dist/index.es.js"() {
    init_shim();
    C2 = { waku: { publish: "waku_publish", batchPublish: "waku_batchPublish", subscribe: "waku_subscribe", batchSubscribe: "waku_batchSubscribe", subscription: "waku_subscription", unsubscribe: "waku_unsubscribe", batchUnsubscribe: "waku_batchUnsubscribe", batchFetchMessages: "waku_batchFetchMessages" }, irn: { publish: "irn_publish", batchPublish: "irn_batchPublish", subscribe: "irn_subscribe", batchSubscribe: "irn_batchSubscribe", subscription: "irn_subscription", unsubscribe: "irn_unsubscribe", batchUnsubscribe: "irn_batchUnsubscribe", batchFetchMessages: "irn_batchFetchMessages" }, iridium: { publish: "iridium_publish", batchPublish: "iridium_batchPublish", subscribe: "iridium_subscribe", batchSubscribe: "iridium_batchSubscribe", subscription: "iridium_subscription", unsubscribe: "iridium_unsubscribe", batchUnsubscribe: "iridium_batchUnsubscribe", batchFetchMessages: "iridium_batchFetchMessages" } };
  }
});

// node_modules/@walletconnect/utils/dist/index.cjs.js
var require_index_cjs2 = __commonJS({
  "node_modules/@walletconnect/utils/dist/index.cjs.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Ro = require_detect_browser();
    var tr = require_cjs();
    var er = require_cjs3();
    var Co = require_cjs4();
    var Oo = require_query_string();
    var fn = require_chacha20poly1305();
    var Po = require_hkdf();
    var on = require_random();
    var ci = require_sha256();
    var To = require_x25519();
    var Rt = (init_src2(), __toCommonJS(src_exports));
    var Fo = (init_index_es3(), __toCommonJS(index_es_exports3));
    function sn(e2) {
      if (e2 && e2.__esModule)
        return e2;
      var t = /* @__PURE__ */ Object.create(null);
      return e2 && Object.keys(e2).forEach(function(r) {
        if (r !== "default") {
          var i2 = Object.getOwnPropertyDescriptor(e2, r);
          Object.defineProperty(t, r, i2.get ? i2 : { enumerable: true, get: function() {
            return e2[r];
          } });
        }
      }), t.default = e2, Object.freeze(t);
    }
    var Ir = sn(Oo);
    var an = sn(To);
    var _r = ":";
    function un(e2) {
      const [t, r] = e2.split(_r);
      return { namespace: t, reference: r };
    }
    function hn(e2) {
      const { namespace: t, reference: r } = e2;
      return [t, r].join(_r);
    }
    function li(e2) {
      const [t, r, i2] = e2.split(_r);
      return { namespace: t, reference: r, address: i2 };
    }
    function cn(e2) {
      const { namespace: t, reference: r, address: i2 } = e2;
      return [t, r, i2].join(_r);
    }
    function di(e2, t) {
      const r = [];
      return e2.forEach((i2) => {
        const n3 = t(i2);
        r.includes(n3) || r.push(n3);
      }), r;
    }
    function ln(e2) {
      const { address: t } = li(e2);
      return t;
    }
    function dn(e2) {
      const { namespace: t, reference: r } = li(e2);
      return hn({ namespace: t, reference: r });
    }
    function Do(e2, t) {
      const { namespace: r, reference: i2 } = un(t);
      return cn({ namespace: r, reference: i2, address: e2 });
    }
    function Uo(e2) {
      return di(e2, ln);
    }
    function pn(e2) {
      return di(e2, dn);
    }
    function ko(e2, t = []) {
      const r = [];
      return Object.keys(e2).forEach((i2) => {
        if (t.length && !t.includes(i2))
          return;
        const n3 = e2[i2];
        r.push(...n3.accounts);
      }), r;
    }
    function qo(e2, t = []) {
      const r = [];
      return Object.keys(e2).forEach((i2) => {
        if (t.length && !t.includes(i2))
          return;
        const n3 = e2[i2];
        r.push(...pn(n3.accounts));
      }), r;
    }
    function Ko(e2, t = []) {
      const r = [];
      return Object.keys(e2).forEach((i2) => {
        if (t.length && !t.includes(i2))
          return;
        const n3 = e2[i2];
        r.push(...Br(i2, n3));
      }), r;
    }
    function Br(e2, t) {
      return e2.includes(":") ? [e2] : t.chains || [];
    }
    var Ho = Object.defineProperty;
    var vn = Object.getOwnPropertySymbols;
    var Lo = Object.prototype.hasOwnProperty;
    var zo = Object.prototype.propertyIsEnumerable;
    var gn = (e2, t, r) => t in e2 ? Ho(e2, t, { enumerable: true, configurable: true, writable: true, value: r }) : e2[t] = r;
    var mn = (e2, t) => {
      for (var r in t || (t = {}))
        Lo.call(t, r) && gn(e2, r, t[r]);
      if (vn)
        for (var r of vn(t))
          zo.call(t, r) && gn(e2, r, t[r]);
      return e2;
    };
    var An = "ReactNative";
    var Kt = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
    var Rr = " ";
    var jo = ":";
    var bn = "/";
    var pi = 2;
    var Vo = 1e3;
    var yn = "js";
    function vi() {
      return typeof import_process.default < "u" && typeof import_process.default.versions < "u" && typeof import_process.default.versions.node < "u";
    }
    function rr() {
      return !er.getDocument() && !!er.getNavigator() && navigator.product === An;
    }
    function vr() {
      return !vi() && !!er.getNavigator() && !!er.getDocument();
    }
    function Ge() {
      return rr() ? Kt.reactNative : vi() ? Kt.node : vr() ? Kt.browser : Kt.unknown;
    }
    function Qo() {
      var e2;
      try {
        return rr() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (e2 = global.Application) == null ? void 0 : e2.applicationId : void 0;
      } catch {
        return;
      }
    }
    function wn(e2, t) {
      let r = Ir.parse(e2);
      return r = mn(mn({}, r), t), e2 = Ir.stringify(r), e2;
    }
    function Jo() {
      return Co.getWindowMetadata() || { name: "", description: "", url: "", icons: [""] };
    }
    function Yo(e2, t) {
      var r;
      const i2 = Ge(), n3 = { protocol: e2, version: t, env: i2 };
      return i2 === "browser" && (n3.host = ((r = er.getLocation()) == null ? void 0 : r.host) || "unknown"), n3;
    }
    function xn() {
      if (Ge() === Kt.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
        const { OS: r, Version: i2 } = global.Platform;
        return [r, i2].join("-");
      }
      const e2 = Ro.detect();
      if (e2 === null)
        return "unknown";
      const t = e2.os ? e2.os.replace(" ", "").toLowerCase() : "unknown";
      return e2.type === "browser" ? [t, e2.name, e2.version].join("-") : [t, e2.version].join("-");
    }
    function Mn() {
      var e2;
      const t = Ge();
      return t === Kt.browser ? [t, ((e2 = er.getLocation()) == null ? void 0 : e2.host) || "unknown"].join(":") : t;
    }
    function En(e2, t, r) {
      const i2 = xn(), n3 = Mn();
      return [[e2, t].join("-"), [yn, r].join("-"), i2, n3].join("/");
    }
    function Go({ protocol: e2, version: t, relayUrl: r, sdkVersion: i2, auth: n3, projectId: o2, useOnCloseEvent: h5, bundleId: p3 }) {
      const b4 = r.split("?"), g3 = En(e2, t, i2), w4 = { auth: n3, ua: g3, projectId: o2, useOnCloseEvent: h5 || void 0, origin: p3 || void 0 }, y4 = wn(b4[1] || "", w4);
      return b4[0] + "?" + y4;
    }
    function Wo(e2) {
      let t = (e2.match(/^[^:]+(?=:\/\/)/gi) || [])[0];
      const r = typeof t < "u" ? e2.split("://")[1] : e2;
      return t = t === "wss" ? "https" : "http", [t, r].join("://");
    }
    function Xo(e2, t, r) {
      if (!e2[t] || typeof e2[t] !== r)
        throw new Error(`Missing or invalid "${t}" param`);
    }
    function Sn(e2, t = pi) {
      return Nn(e2.split(bn), t);
    }
    function Zo(e2) {
      return Sn(e2).join(Rr);
    }
    function Ie(e2, t) {
      return e2.filter((r) => t.includes(r)).length === e2.length;
    }
    function Nn(e2, t = pi) {
      return e2.slice(Math.max(e2.length - t, 0));
    }
    function $o(e2) {
      return Object.fromEntries(e2.entries());
    }
    function ts(e2) {
      return new Map(Object.entries(e2));
    }
    function es(e2, t) {
      const r = {};
      return Object.keys(e2).forEach((i2) => {
        r[i2] = t(e2[i2]);
      }), r;
    }
    var rs = (e2) => e2;
    function In(e2) {
      return e2.trim().replace(/^\w/, (t) => t.toUpperCase());
    }
    function is(e2) {
      return e2.split(Rr).map((t) => In(t)).join(Rr);
    }
    function ns(e2 = tr.FIVE_MINUTES, t) {
      const r = tr.toMiliseconds(e2 || tr.FIVE_MINUTES);
      let i2, n3, o2;
      return { resolve: (h5) => {
        o2 && i2 && (clearTimeout(o2), i2(h5));
      }, reject: (h5) => {
        o2 && n3 && (clearTimeout(o2), n3(h5));
      }, done: () => new Promise((h5, p3) => {
        o2 = setTimeout(() => {
          p3(new Error(t));
        }, r), i2 = h5, n3 = p3;
      }) };
    }
    function fs(e2, t, r) {
      return new Promise(async (i2, n3) => {
        const o2 = setTimeout(() => n3(new Error(r)), t);
        try {
          const h5 = await e2;
          i2(h5);
        } catch (h5) {
          n3(h5);
        }
        clearTimeout(o2);
      });
    }
    function gi(e2, t) {
      if (typeof t == "string" && t.startsWith(`${e2}:`))
        return t;
      if (e2.toLowerCase() === "topic") {
        if (typeof t != "string")
          throw new Error('Value must be "string" for expirer target type: topic');
        return `topic:${t}`;
      } else if (e2.toLowerCase() === "id") {
        if (typeof t != "number")
          throw new Error('Value must be "number" for expirer target type: id');
        return `id:${t}`;
      }
      throw new Error(`Unknown expirer target type: ${e2}`);
    }
    function os(e2) {
      return gi("topic", e2);
    }
    function ss(e2) {
      return gi("id", e2);
    }
    function as(e2) {
      const [t, r] = e2.split(":"), i2 = { id: void 0, topic: void 0 };
      if (t === "topic" && typeof r == "string")
        i2.topic = r;
      else if (t === "id" && Number.isInteger(Number(r)))
        i2.id = Number(r);
      else
        throw new Error(`Invalid target, expected id:number or topic:string, got ${t}:${r}`);
      return i2;
    }
    function us(e2, t) {
      return tr.fromMiliseconds((t || Date.now()) + tr.toMiliseconds(e2));
    }
    function hs(e2) {
      return Date.now() >= tr.toMiliseconds(e2);
    }
    function cs(e2, t) {
      return `${e2}${t ? `:${t}` : ""}`;
    }
    function ge(e2 = [], t = []) {
      return [.../* @__PURE__ */ new Set([...e2, ...t])];
    }
    async function ls2({ id: e2, topic: t, wcDeepLink: r }) {
      try {
        if (!r)
          return;
        const i2 = typeof r == "string" ? JSON.parse(r) : r;
        let n3 = i2?.href;
        if (typeof n3 != "string")
          return;
        n3.endsWith("/") && (n3 = n3.slice(0, -1));
        const o2 = `${n3}/wc?requestId=${e2}&sessionTopic=${t}`, h5 = Ge();
        h5 === Kt.browser ? o2.startsWith("https://") || o2.startsWith("http://") ? window.open(o2, "_blank", "noreferrer noopener") : window.open(o2, "_self", "noreferrer noopener") : h5 === Kt.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(o2);
      } catch (i2) {
        console.error(i2);
      }
    }
    async function ds(e2, t) {
      try {
        return await e2.getItem(t) || (vr() ? localStorage.getItem(t) : void 0);
      } catch (r) {
        console.error(r);
      }
    }
    function mi(e2, t) {
      return e2.filter((r) => t.includes(r));
    }
    var _n = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
    function ps(e2) {
      var t = e2.default;
      if (typeof t == "function") {
        var r = function() {
          return t.apply(this, arguments);
        };
        r.prototype = t.prototype;
      } else
        r = {};
      return Object.defineProperty(r, "__esModule", { value: true }), Object.keys(e2).forEach(function(i2) {
        var n3 = Object.getOwnPropertyDescriptor(e2, i2);
        Object.defineProperty(r, i2, n3.get ? n3 : { enumerable: true, get: function() {
          return e2[i2];
        } });
      }), r;
    }
    var Bn = { exports: {} };
    (function(e2) {
      (function() {
        var t = "input is invalid type", r = "finalize already called", i2 = typeof window == "object", n3 = i2 ? window : {};
        n3.JS_SHA3_NO_WINDOW && (i2 = false);
        var o2 = !i2 && typeof self == "object", h5 = !n3.JS_SHA3_NO_NODE_JS && typeof import_process.default == "object" && import_process.default.versions && import_process.default.versions.node;
        h5 ? n3 = _n : o2 && (n3 = self);
        var p3 = !n3.JS_SHA3_NO_COMMON_JS && true && e2.exports, b4 = !n3.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", g3 = "0123456789abcdef".split(""), w4 = [31, 7936, 2031616, 520093696], y4 = [4, 1024, 262144, 67108864], S4 = [1, 256, 65536, 16777216], I2 = [6, 1536, 393216, 100663296], N10 = [0, 8, 16, 24], R2 = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648], F = [224, 256, 384, 512], U2 = [128, 256], Q = ["hex", "buffer", "arrayBuffer", "array", "digest"], Bt = { 128: 168, 256: 136 };
        (n3.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(u3) {
          return Object.prototype.toString.call(u3) === "[object Array]";
        }), b4 && (n3.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(u3) {
          return typeof u3 == "object" && u3.buffer && u3.buffer.constructor === ArrayBuffer;
        });
        for (var J = function(u3, E4, _4) {
          return function(B2) {
            return new s2(u3, E4, u3).update(B2)[_4]();
          };
        }, H = function(u3, E4, _4) {
          return function(B2, C3) {
            return new s2(u3, E4, C3).update(B2)[_4]();
          };
        }, L2 = function(u3, E4, _4) {
          return function(B2, C3, D2, P2) {
            return f4["cshake" + u3].update(B2, C3, D2, P2)[_4]();
          };
        }, Tt = function(u3, E4, _4) {
          return function(B2, C3, D2, P2) {
            return f4["kmac" + u3].update(B2, C3, D2, P2)[_4]();
          };
        }, W = function(u3, E4, _4, B2) {
          for (var C3 = 0; C3 < Q.length; ++C3) {
            var D2 = Q[C3];
            u3[D2] = E4(_4, B2, D2);
          }
          return u3;
        }, Ot = function(u3, E4) {
          var _4 = J(u3, E4, "hex");
          return _4.create = function() {
            return new s2(u3, E4, u3);
          }, _4.update = function(B2) {
            return _4.create().update(B2);
          }, W(_4, J, u3, E4);
        }, Gt = function(u3, E4) {
          var _4 = H(u3, E4, "hex");
          return _4.create = function(B2) {
            return new s2(u3, E4, B2);
          }, _4.update = function(B2, C3) {
            return _4.create(C3).update(B2);
          }, W(_4, H, u3, E4);
        }, Y = function(u3, E4) {
          var _4 = Bt[u3], B2 = L2(u3, E4, "hex");
          return B2.create = function(C3, D2, P2) {
            return !D2 && !P2 ? f4["shake" + u3].create(C3) : new s2(u3, E4, C3).bytepad([D2, P2], _4);
          }, B2.update = function(C3, D2, P2, O3) {
            return B2.create(D2, P2, O3).update(C3);
          }, W(B2, L2, u3, E4);
        }, Wt = function(u3, E4) {
          var _4 = Bt[u3], B2 = Tt(u3, E4, "hex");
          return B2.create = function(C3, D2, P2) {
            return new v2(u3, E4, D2).bytepad(["KMAC", P2], _4).bytepad([C3], _4);
          }, B2.update = function(C3, D2, P2, O3) {
            return B2.create(C3, P2, O3).update(D2);
          }, W(B2, Tt, u3, E4);
        }, A2 = [{ name: "keccak", padding: S4, bits: F, createMethod: Ot }, { name: "sha3", padding: I2, bits: F, createMethod: Ot }, { name: "shake", padding: w4, bits: U2, createMethod: Gt }, { name: "cshake", padding: y4, bits: U2, createMethod: Y }, { name: "kmac", padding: y4, bits: U2, createMethod: Wt }], f4 = {}, a3 = [], c4 = 0; c4 < A2.length; ++c4)
          for (var d3 = A2[c4], m3 = d3.bits, x3 = 0; x3 < m3.length; ++x3) {
            var M = d3.name + "_" + m3[x3];
            if (a3.push(M), f4[M] = d3.createMethod(m3[x3], d3.padding), d3.name !== "sha3") {
              var l4 = d3.name + m3[x3];
              a3.push(l4), f4[l4] = f4[M];
            }
          }
        function s2(u3, E4, _4) {
          this.blocks = [], this.s = [], this.padding = E4, this.outputBits = _4, this.reset = true, this.finalized = false, this.block = 0, this.start = 0, this.blockCount = 1600 - (u3 << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = _4 >> 5, this.extraBytes = (_4 & 31) >> 3;
          for (var B2 = 0; B2 < 50; ++B2)
            this.s[B2] = 0;
        }
        s2.prototype.update = function(u3) {
          if (this.finalized)
            throw new Error(r);
          var E4, _4 = typeof u3;
          if (_4 !== "string") {
            if (_4 === "object") {
              if (u3 === null)
                throw new Error(t);
              if (b4 && u3.constructor === ArrayBuffer)
                u3 = new Uint8Array(u3);
              else if (!Array.isArray(u3) && (!b4 || !ArrayBuffer.isView(u3)))
                throw new Error(t);
            } else
              throw new Error(t);
            E4 = true;
          }
          for (var B2 = this.blocks, C3 = this.byteCount, D2 = u3.length, P2 = this.blockCount, O3 = 0, Ct = this.s, T2, q2; O3 < D2; ) {
            if (this.reset)
              for (this.reset = false, B2[0] = this.block, T2 = 1; T2 < P2 + 1; ++T2)
                B2[T2] = 0;
            if (E4)
              for (T2 = this.start; O3 < D2 && T2 < C3; ++O3)
                B2[T2 >> 2] |= u3[O3] << N10[T2++ & 3];
            else
              for (T2 = this.start; O3 < D2 && T2 < C3; ++O3)
                q2 = u3.charCodeAt(O3), q2 < 128 ? B2[T2 >> 2] |= q2 << N10[T2++ & 3] : q2 < 2048 ? (B2[T2 >> 2] |= (192 | q2 >> 6) << N10[T2++ & 3], B2[T2 >> 2] |= (128 | q2 & 63) << N10[T2++ & 3]) : q2 < 55296 || q2 >= 57344 ? (B2[T2 >> 2] |= (224 | q2 >> 12) << N10[T2++ & 3], B2[T2 >> 2] |= (128 | q2 >> 6 & 63) << N10[T2++ & 3], B2[T2 >> 2] |= (128 | q2 & 63) << N10[T2++ & 3]) : (q2 = 65536 + ((q2 & 1023) << 10 | u3.charCodeAt(++O3) & 1023), B2[T2 >> 2] |= (240 | q2 >> 18) << N10[T2++ & 3], B2[T2 >> 2] |= (128 | q2 >> 12 & 63) << N10[T2++ & 3], B2[T2 >> 2] |= (128 | q2 >> 6 & 63) << N10[T2++ & 3], B2[T2 >> 2] |= (128 | q2 & 63) << N10[T2++ & 3]);
            if (this.lastByteIndex = T2, T2 >= C3) {
              for (this.start = T2 - C3, this.block = B2[P2], T2 = 0; T2 < P2; ++T2)
                Ct[T2] ^= B2[T2];
              k4(Ct), this.reset = true;
            } else
              this.start = T2;
          }
          return this;
        }, s2.prototype.encode = function(u3, E4) {
          var _4 = u3 & 255, B2 = 1, C3 = [_4];
          for (u3 = u3 >> 8, _4 = u3 & 255; _4 > 0; )
            C3.unshift(_4), u3 = u3 >> 8, _4 = u3 & 255, ++B2;
          return E4 ? C3.push(B2) : C3.unshift(B2), this.update(C3), C3.length;
        }, s2.prototype.encodeString = function(u3) {
          var E4, _4 = typeof u3;
          if (_4 !== "string") {
            if (_4 === "object") {
              if (u3 === null)
                throw new Error(t);
              if (b4 && u3.constructor === ArrayBuffer)
                u3 = new Uint8Array(u3);
              else if (!Array.isArray(u3) && (!b4 || !ArrayBuffer.isView(u3)))
                throw new Error(t);
            } else
              throw new Error(t);
            E4 = true;
          }
          var B2 = 0, C3 = u3.length;
          if (E4)
            B2 = C3;
          else
            for (var D2 = 0; D2 < u3.length; ++D2) {
              var P2 = u3.charCodeAt(D2);
              P2 < 128 ? B2 += 1 : P2 < 2048 ? B2 += 2 : P2 < 55296 || P2 >= 57344 ? B2 += 3 : (P2 = 65536 + ((P2 & 1023) << 10 | u3.charCodeAt(++D2) & 1023), B2 += 4);
            }
          return B2 += this.encode(B2 * 8), this.update(u3), B2;
        }, s2.prototype.bytepad = function(u3, E4) {
          for (var _4 = this.encode(E4), B2 = 0; B2 < u3.length; ++B2)
            _4 += this.encodeString(u3[B2]);
          var C3 = E4 - _4 % E4, D2 = [];
          return D2.length = C3, this.update(D2), this;
        }, s2.prototype.finalize = function() {
          if (!this.finalized) {
            this.finalized = true;
            var u3 = this.blocks, E4 = this.lastByteIndex, _4 = this.blockCount, B2 = this.s;
            if (u3[E4 >> 2] |= this.padding[E4 & 3], this.lastByteIndex === this.byteCount)
              for (u3[0] = u3[_4], E4 = 1; E4 < _4 + 1; ++E4)
                u3[E4] = 0;
            for (u3[_4 - 1] |= 2147483648, E4 = 0; E4 < _4; ++E4)
              B2[E4] ^= u3[E4];
            k4(B2);
          }
        }, s2.prototype.toString = s2.prototype.hex = function() {
          this.finalize();
          for (var u3 = this.blockCount, E4 = this.s, _4 = this.outputBlocks, B2 = this.extraBytes, C3 = 0, D2 = 0, P2 = "", O3; D2 < _4; ) {
            for (C3 = 0; C3 < u3 && D2 < _4; ++C3, ++D2)
              O3 = E4[C3], P2 += g3[O3 >> 4 & 15] + g3[O3 & 15] + g3[O3 >> 12 & 15] + g3[O3 >> 8 & 15] + g3[O3 >> 20 & 15] + g3[O3 >> 16 & 15] + g3[O3 >> 28 & 15] + g3[O3 >> 24 & 15];
            D2 % u3 === 0 && (k4(E4), C3 = 0);
          }
          return B2 && (O3 = E4[C3], P2 += g3[O3 >> 4 & 15] + g3[O3 & 15], B2 > 1 && (P2 += g3[O3 >> 12 & 15] + g3[O3 >> 8 & 15]), B2 > 2 && (P2 += g3[O3 >> 20 & 15] + g3[O3 >> 16 & 15])), P2;
        }, s2.prototype.arrayBuffer = function() {
          this.finalize();
          var u3 = this.blockCount, E4 = this.s, _4 = this.outputBlocks, B2 = this.extraBytes, C3 = 0, D2 = 0, P2 = this.outputBits >> 3, O3;
          B2 ? O3 = new ArrayBuffer(_4 + 1 << 2) : O3 = new ArrayBuffer(P2);
          for (var Ct = new Uint32Array(O3); D2 < _4; ) {
            for (C3 = 0; C3 < u3 && D2 < _4; ++C3, ++D2)
              Ct[D2] = E4[C3];
            D2 % u3 === 0 && k4(E4);
          }
          return B2 && (Ct[C3] = E4[C3], O3 = O3.slice(0, P2)), O3;
        }, s2.prototype.buffer = s2.prototype.arrayBuffer, s2.prototype.digest = s2.prototype.array = function() {
          this.finalize();
          for (var u3 = this.blockCount, E4 = this.s, _4 = this.outputBlocks, B2 = this.extraBytes, C3 = 0, D2 = 0, P2 = [], O3, Ct; D2 < _4; ) {
            for (C3 = 0; C3 < u3 && D2 < _4; ++C3, ++D2)
              O3 = D2 << 2, Ct = E4[C3], P2[O3] = Ct & 255, P2[O3 + 1] = Ct >> 8 & 255, P2[O3 + 2] = Ct >> 16 & 255, P2[O3 + 3] = Ct >> 24 & 255;
            D2 % u3 === 0 && k4(E4);
          }
          return B2 && (O3 = D2 << 2, Ct = E4[C3], P2[O3] = Ct & 255, B2 > 1 && (P2[O3 + 1] = Ct >> 8 & 255), B2 > 2 && (P2[O3 + 2] = Ct >> 16 & 255)), P2;
        };
        function v2(u3, E4, _4) {
          s2.call(this, u3, E4, _4);
        }
        v2.prototype = new s2(), v2.prototype.finalize = function() {
          return this.encode(this.outputBits, true), s2.prototype.finalize.call(this);
        };
        var k4 = function(u3) {
          var E4, _4, B2, C3, D2, P2, O3, Ct, T2, q2, Pe, X, Z, Te, $, tt, Fe, et, rt, De, it, nt, Ue, ft, ot, ke, st, at, qe, ut, ht, Ke, ct, lt, He, dt, pt, Le, vt, gt, ze, mt, At, je, bt, yt, Ve, wt, xt, Qe, Mt, Et, Je, St, Nt, Ye, It, _t, xe, Me, Ee, Se, Ne;
          for (B2 = 0; B2 < 48; B2 += 2)
            C3 = u3[0] ^ u3[10] ^ u3[20] ^ u3[30] ^ u3[40], D2 = u3[1] ^ u3[11] ^ u3[21] ^ u3[31] ^ u3[41], P2 = u3[2] ^ u3[12] ^ u3[22] ^ u3[32] ^ u3[42], O3 = u3[3] ^ u3[13] ^ u3[23] ^ u3[33] ^ u3[43], Ct = u3[4] ^ u3[14] ^ u3[24] ^ u3[34] ^ u3[44], T2 = u3[5] ^ u3[15] ^ u3[25] ^ u3[35] ^ u3[45], q2 = u3[6] ^ u3[16] ^ u3[26] ^ u3[36] ^ u3[46], Pe = u3[7] ^ u3[17] ^ u3[27] ^ u3[37] ^ u3[47], X = u3[8] ^ u3[18] ^ u3[28] ^ u3[38] ^ u3[48], Z = u3[9] ^ u3[19] ^ u3[29] ^ u3[39] ^ u3[49], E4 = X ^ (P2 << 1 | O3 >>> 31), _4 = Z ^ (O3 << 1 | P2 >>> 31), u3[0] ^= E4, u3[1] ^= _4, u3[10] ^= E4, u3[11] ^= _4, u3[20] ^= E4, u3[21] ^= _4, u3[30] ^= E4, u3[31] ^= _4, u3[40] ^= E4, u3[41] ^= _4, E4 = C3 ^ (Ct << 1 | T2 >>> 31), _4 = D2 ^ (T2 << 1 | Ct >>> 31), u3[2] ^= E4, u3[3] ^= _4, u3[12] ^= E4, u3[13] ^= _4, u3[22] ^= E4, u3[23] ^= _4, u3[32] ^= E4, u3[33] ^= _4, u3[42] ^= E4, u3[43] ^= _4, E4 = P2 ^ (q2 << 1 | Pe >>> 31), _4 = O3 ^ (Pe << 1 | q2 >>> 31), u3[4] ^= E4, u3[5] ^= _4, u3[14] ^= E4, u3[15] ^= _4, u3[24] ^= E4, u3[25] ^= _4, u3[34] ^= E4, u3[35] ^= _4, u3[44] ^= E4, u3[45] ^= _4, E4 = Ct ^ (X << 1 | Z >>> 31), _4 = T2 ^ (Z << 1 | X >>> 31), u3[6] ^= E4, u3[7] ^= _4, u3[16] ^= E4, u3[17] ^= _4, u3[26] ^= E4, u3[27] ^= _4, u3[36] ^= E4, u3[37] ^= _4, u3[46] ^= E4, u3[47] ^= _4, E4 = q2 ^ (C3 << 1 | D2 >>> 31), _4 = Pe ^ (D2 << 1 | C3 >>> 31), u3[8] ^= E4, u3[9] ^= _4, u3[18] ^= E4, u3[19] ^= _4, u3[28] ^= E4, u3[29] ^= _4, u3[38] ^= E4, u3[39] ^= _4, u3[48] ^= E4, u3[49] ^= _4, Te = u3[0], $ = u3[1], yt = u3[11] << 4 | u3[10] >>> 28, Ve = u3[10] << 4 | u3[11] >>> 28, at = u3[20] << 3 | u3[21] >>> 29, qe = u3[21] << 3 | u3[20] >>> 29, Me = u3[31] << 9 | u3[30] >>> 23, Ee = u3[30] << 9 | u3[31] >>> 23, mt = u3[40] << 18 | u3[41] >>> 14, At = u3[41] << 18 | u3[40] >>> 14, lt = u3[2] << 1 | u3[3] >>> 31, He = u3[3] << 1 | u3[2] >>> 31, tt = u3[13] << 12 | u3[12] >>> 20, Fe = u3[12] << 12 | u3[13] >>> 20, wt = u3[22] << 10 | u3[23] >>> 22, xt = u3[23] << 10 | u3[22] >>> 22, ut = u3[33] << 13 | u3[32] >>> 19, ht = u3[32] << 13 | u3[33] >>> 19, Se = u3[42] << 2 | u3[43] >>> 30, Ne = u3[43] << 2 | u3[42] >>> 30, St = u3[5] << 30 | u3[4] >>> 2, Nt = u3[4] << 30 | u3[5] >>> 2, dt = u3[14] << 6 | u3[15] >>> 26, pt = u3[15] << 6 | u3[14] >>> 26, et = u3[25] << 11 | u3[24] >>> 21, rt = u3[24] << 11 | u3[25] >>> 21, Qe = u3[34] << 15 | u3[35] >>> 17, Mt = u3[35] << 15 | u3[34] >>> 17, Ke = u3[45] << 29 | u3[44] >>> 3, ct = u3[44] << 29 | u3[45] >>> 3, ft = u3[6] << 28 | u3[7] >>> 4, ot = u3[7] << 28 | u3[6] >>> 4, Ye = u3[17] << 23 | u3[16] >>> 9, It = u3[16] << 23 | u3[17] >>> 9, Le = u3[26] << 25 | u3[27] >>> 7, vt = u3[27] << 25 | u3[26] >>> 7, De = u3[36] << 21 | u3[37] >>> 11, it = u3[37] << 21 | u3[36] >>> 11, Et = u3[47] << 24 | u3[46] >>> 8, Je = u3[46] << 24 | u3[47] >>> 8, je = u3[8] << 27 | u3[9] >>> 5, bt = u3[9] << 27 | u3[8] >>> 5, ke = u3[18] << 20 | u3[19] >>> 12, st = u3[19] << 20 | u3[18] >>> 12, _t = u3[29] << 7 | u3[28] >>> 25, xe = u3[28] << 7 | u3[29] >>> 25, gt = u3[38] << 8 | u3[39] >>> 24, ze = u3[39] << 8 | u3[38] >>> 24, nt = u3[48] << 14 | u3[49] >>> 18, Ue = u3[49] << 14 | u3[48] >>> 18, u3[0] = Te ^ ~tt & et, u3[1] = $ ^ ~Fe & rt, u3[10] = ft ^ ~ke & at, u3[11] = ot ^ ~st & qe, u3[20] = lt ^ ~dt & Le, u3[21] = He ^ ~pt & vt, u3[30] = je ^ ~yt & wt, u3[31] = bt ^ ~Ve & xt, u3[40] = St ^ ~Ye & _t, u3[41] = Nt ^ ~It & xe, u3[2] = tt ^ ~et & De, u3[3] = Fe ^ ~rt & it, u3[12] = ke ^ ~at & ut, u3[13] = st ^ ~qe & ht, u3[22] = dt ^ ~Le & gt, u3[23] = pt ^ ~vt & ze, u3[32] = yt ^ ~wt & Qe, u3[33] = Ve ^ ~xt & Mt, u3[42] = Ye ^ ~_t & Me, u3[43] = It ^ ~xe & Ee, u3[4] = et ^ ~De & nt, u3[5] = rt ^ ~it & Ue, u3[14] = at ^ ~ut & Ke, u3[15] = qe ^ ~ht & ct, u3[24] = Le ^ ~gt & mt, u3[25] = vt ^ ~ze & At, u3[34] = wt ^ ~Qe & Et, u3[35] = xt ^ ~Mt & Je, u3[44] = _t ^ ~Me & Se, u3[45] = xe ^ ~Ee & Ne, u3[6] = De ^ ~nt & Te, u3[7] = it ^ ~Ue & $, u3[16] = ut ^ ~Ke & ft, u3[17] = ht ^ ~ct & ot, u3[26] = gt ^ ~mt & lt, u3[27] = ze ^ ~At & He, u3[36] = Qe ^ ~Et & je, u3[37] = Mt ^ ~Je & bt, u3[46] = Me ^ ~Se & St, u3[47] = Ee ^ ~Ne & Nt, u3[8] = nt ^ ~Te & tt, u3[9] = Ue ^ ~$ & Fe, u3[18] = Ke ^ ~ft & ke, u3[19] = ct ^ ~ot & st, u3[28] = mt ^ ~lt & dt, u3[29] = At ^ ~He & pt, u3[38] = Et ^ ~je & yt, u3[39] = Je ^ ~bt & Ve, u3[48] = Se ^ ~St & Ye, u3[49] = Ne ^ ~Nt & It, u3[0] ^= R2[B2], u3[1] ^= R2[B2 + 1];
        };
        if (p3)
          e2.exports = f4;
        else
          for (c4 = 0; c4 < a3.length; ++c4)
            n3[a3[c4]] = f4[a3[c4]];
      })();
    })(Bn);
    var vs = Bn.exports;
    var gs = "logger/5.7.0";
    var Rn = false;
    var Cn = false;
    var Cr = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
    var On = Cr.default;
    var Ai = null;
    function ms() {
      try {
        const e2 = [];
        if (["NFD", "NFC", "NFKD", "NFKC"].forEach((t) => {
          try {
            if ("test".normalize(t) !== "test")
              throw new Error("bad normalize");
          } catch {
            e2.push(t);
          }
        }), e2.length)
          throw new Error("missing " + e2.join(", "));
        if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769))
          throw new Error("broken implementation");
      } catch (e2) {
        return e2.message;
      }
      return null;
    }
    var Pn = ms();
    var bi;
    (function(e2) {
      e2.DEBUG = "DEBUG", e2.INFO = "INFO", e2.WARNING = "WARNING", e2.ERROR = "ERROR", e2.OFF = "OFF";
    })(bi || (bi = {}));
    var ee;
    (function(e2) {
      e2.UNKNOWN_ERROR = "UNKNOWN_ERROR", e2.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", e2.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", e2.NETWORK_ERROR = "NETWORK_ERROR", e2.SERVER_ERROR = "SERVER_ERROR", e2.TIMEOUT = "TIMEOUT", e2.BUFFER_OVERRUN = "BUFFER_OVERRUN", e2.NUMERIC_FAULT = "NUMERIC_FAULT", e2.MISSING_NEW = "MISSING_NEW", e2.INVALID_ARGUMENT = "INVALID_ARGUMENT", e2.MISSING_ARGUMENT = "MISSING_ARGUMENT", e2.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", e2.CALL_EXCEPTION = "CALL_EXCEPTION", e2.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", e2.NONCE_EXPIRED = "NONCE_EXPIRED", e2.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", e2.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", e2.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", e2.ACTION_REJECTED = "ACTION_REJECTED";
    })(ee || (ee = {}));
    var Tn = "0123456789abcdef";
    var z3 = class _z {
      constructor(t) {
        Object.defineProperty(this, "version", { enumerable: true, value: t, writable: false });
      }
      _log(t, r) {
        const i2 = t.toLowerCase();
        Cr[i2] == null && this.throwArgumentError("invalid log level name", "logLevel", t), !(On > Cr[i2]) && console.log.apply(console, r);
      }
      debug(...t) {
        this._log(_z.levels.DEBUG, t);
      }
      info(...t) {
        this._log(_z.levels.INFO, t);
      }
      warn(...t) {
        this._log(_z.levels.WARNING, t);
      }
      makeError(t, r, i2) {
        if (Cn)
          return this.makeError("censored error", r, {});
        r || (r = _z.errors.UNKNOWN_ERROR), i2 || (i2 = {});
        const n3 = [];
        Object.keys(i2).forEach((b4) => {
          const g3 = i2[b4];
          try {
            if (g3 instanceof Uint8Array) {
              let w4 = "";
              for (let y4 = 0; y4 < g3.length; y4++)
                w4 += Tn[g3[y4] >> 4], w4 += Tn[g3[y4] & 15];
              n3.push(b4 + "=Uint8Array(0x" + w4 + ")");
            } else
              n3.push(b4 + "=" + JSON.stringify(g3));
          } catch {
            n3.push(b4 + "=" + JSON.stringify(i2[b4].toString()));
          }
        }), n3.push(`code=${r}`), n3.push(`version=${this.version}`);
        const o2 = t;
        let h5 = "";
        switch (r) {
          case ee.NUMERIC_FAULT: {
            h5 = "NUMERIC_FAULT";
            const b4 = t;
            switch (b4) {
              case "overflow":
              case "underflow":
              case "division-by-zero":
                h5 += "-" + b4;
                break;
              case "negative-power":
              case "negative-width":
                h5 += "-unsupported";
                break;
              case "unbound-bitwise-result":
                h5 += "-unbound-result";
                break;
            }
            break;
          }
          case ee.CALL_EXCEPTION:
          case ee.INSUFFICIENT_FUNDS:
          case ee.MISSING_NEW:
          case ee.NONCE_EXPIRED:
          case ee.REPLACEMENT_UNDERPRICED:
          case ee.TRANSACTION_REPLACED:
          case ee.UNPREDICTABLE_GAS_LIMIT:
            h5 = r;
            break;
        }
        h5 && (t += " [ See: https://links.ethers.org/v5-errors-" + h5 + " ]"), n3.length && (t += " (" + n3.join(", ") + ")");
        const p3 = new Error(t);
        return p3.reason = o2, p3.code = r, Object.keys(i2).forEach(function(b4) {
          p3[b4] = i2[b4];
        }), p3;
      }
      throwError(t, r, i2) {
        throw this.makeError(t, r, i2);
      }
      throwArgumentError(t, r, i2) {
        return this.throwError(t, _z.errors.INVALID_ARGUMENT, { argument: r, value: i2 });
      }
      assert(t, r, i2, n3) {
        t || this.throwError(r, i2, n3);
      }
      assertArgument(t, r, i2, n3) {
        t || this.throwArgumentError(r, i2, n3);
      }
      checkNormalize(t) {
        Pn && this.throwError("platform missing String.prototype.normalize", _z.errors.UNSUPPORTED_OPERATION, { operation: "String.prototype.normalize", form: Pn });
      }
      checkSafeUint53(t, r) {
        typeof t == "number" && (r == null && (r = "value not safe"), (t < 0 || t >= 9007199254740991) && this.throwError(r, _z.errors.NUMERIC_FAULT, { operation: "checkSafeInteger", fault: "out-of-safe-range", value: t }), t % 1 && this.throwError(r, _z.errors.NUMERIC_FAULT, { operation: "checkSafeInteger", fault: "non-integer", value: t }));
      }
      checkArgumentCount(t, r, i2) {
        i2 ? i2 = ": " + i2 : i2 = "", t < r && this.throwError("missing argument" + i2, _z.errors.MISSING_ARGUMENT, { count: t, expectedCount: r }), t > r && this.throwError("too many arguments" + i2, _z.errors.UNEXPECTED_ARGUMENT, { count: t, expectedCount: r });
      }
      checkNew(t, r) {
        (t === Object || t == null) && this.throwError("missing new", _z.errors.MISSING_NEW, { name: r.name });
      }
      checkAbstract(t, r) {
        t === r ? this.throwError("cannot instantiate abstract class " + JSON.stringify(r.name) + " directly; use a sub-class", _z.errors.UNSUPPORTED_OPERATION, { name: t.name, operation: "new" }) : (t === Object || t == null) && this.throwError("missing new", _z.errors.MISSING_NEW, { name: r.name });
      }
      static globalLogger() {
        return Ai || (Ai = new _z(gs)), Ai;
      }
      static setCensorship(t, r) {
        if (!t && r && this.globalLogger().throwError("cannot permanently disable censorship", _z.errors.UNSUPPORTED_OPERATION, { operation: "setCensorship" }), Rn) {
          if (!t)
            return;
          this.globalLogger().throwError("error censorship permanent", _z.errors.UNSUPPORTED_OPERATION, { operation: "setCensorship" });
        }
        Cn = !!t, Rn = !!r;
      }
      static setLogLevel(t) {
        const r = Cr[t.toLowerCase()];
        if (r == null) {
          _z.globalLogger().warn("invalid log level - " + t);
          return;
        }
        On = r;
      }
      static from(t) {
        return new _z(t);
      }
    };
    z3.errors = ee, z3.levels = bi;
    var As = "bytes/5.7.0";
    var Ft = new z3(As);
    function Fn(e2) {
      return !!e2.toHexString;
    }
    function ir(e2) {
      return e2.slice || (e2.slice = function() {
        const t = Array.prototype.slice.call(arguments);
        return ir(new Uint8Array(Array.prototype.slice.apply(e2, t)));
      }), e2;
    }
    function bs(e2) {
      return Qt(e2) && !(e2.length % 2) || nr(e2);
    }
    function Dn(e2) {
      return typeof e2 == "number" && e2 == e2 && e2 % 1 === 0;
    }
    function nr(e2) {
      if (e2 == null)
        return false;
      if (e2.constructor === Uint8Array)
        return true;
      if (typeof e2 == "string" || !Dn(e2.length) || e2.length < 0)
        return false;
      for (let t = 0; t < e2.length; t++) {
        const r = e2[t];
        if (!Dn(r) || r < 0 || r >= 256)
          return false;
      }
      return true;
    }
    function Pt(e2, t) {
      if (t || (t = {}), typeof e2 == "number") {
        Ft.checkSafeUint53(e2, "invalid arrayify value");
        const r = [];
        for (; e2; )
          r.unshift(e2 & 255), e2 = parseInt(String(e2 / 256));
        return r.length === 0 && r.push(0), ir(new Uint8Array(r));
      }
      if (t.allowMissingPrefix && typeof e2 == "string" && e2.substring(0, 2) !== "0x" && (e2 = "0x" + e2), Fn(e2) && (e2 = e2.toHexString()), Qt(e2)) {
        let r = e2.substring(2);
        r.length % 2 && (t.hexPad === "left" ? r = "0" + r : t.hexPad === "right" ? r += "0" : Ft.throwArgumentError("hex data is odd-length", "value", e2));
        const i2 = [];
        for (let n3 = 0; n3 < r.length; n3 += 2)
          i2.push(parseInt(r.substring(n3, n3 + 2), 16));
        return ir(new Uint8Array(i2));
      }
      return nr(e2) ? ir(new Uint8Array(e2)) : Ft.throwArgumentError("invalid arrayify value", "value", e2);
    }
    function ys(e2) {
      const t = e2.map((n3) => Pt(n3)), r = t.reduce((n3, o2) => n3 + o2.length, 0), i2 = new Uint8Array(r);
      return t.reduce((n3, o2) => (i2.set(o2, n3), n3 + o2.length), 0), ir(i2);
    }
    function ws(e2, t) {
      e2 = Pt(e2), e2.length > t && Ft.throwArgumentError("value out of range", "value", arguments[0]);
      const r = new Uint8Array(t);
      return r.set(e2, t - e2.length), ir(r);
    }
    function Qt(e2, t) {
      return !(typeof e2 != "string" || !e2.match(/^0x[0-9A-Fa-f]*$/) || t && e2.length !== 2 + 2 * t);
    }
    var yi = "0123456789abcdef";
    function Ht(e2, t) {
      if (t || (t = {}), typeof e2 == "number") {
        Ft.checkSafeUint53(e2, "invalid hexlify value");
        let r = "";
        for (; e2; )
          r = yi[e2 & 15] + r, e2 = Math.floor(e2 / 16);
        return r.length ? (r.length % 2 && (r = "0" + r), "0x" + r) : "0x00";
      }
      if (typeof e2 == "bigint")
        return e2 = e2.toString(16), e2.length % 2 ? "0x0" + e2 : "0x" + e2;
      if (t.allowMissingPrefix && typeof e2 == "string" && e2.substring(0, 2) !== "0x" && (e2 = "0x" + e2), Fn(e2))
        return e2.toHexString();
      if (Qt(e2))
        return e2.length % 2 && (t.hexPad === "left" ? e2 = "0x0" + e2.substring(2) : t.hexPad === "right" ? e2 += "0" : Ft.throwArgumentError("hex data is odd-length", "value", e2)), e2.toLowerCase();
      if (nr(e2)) {
        let r = "0x";
        for (let i2 = 0; i2 < e2.length; i2++) {
          let n3 = e2[i2];
          r += yi[(n3 & 240) >> 4] + yi[n3 & 15];
        }
        return r;
      }
      return Ft.throwArgumentError("invalid hexlify value", "value", e2);
    }
    function xs(e2) {
      if (typeof e2 != "string")
        e2 = Ht(e2);
      else if (!Qt(e2) || e2.length % 2)
        return null;
      return (e2.length - 2) / 2;
    }
    function Un(e2, t, r) {
      return typeof e2 != "string" ? e2 = Ht(e2) : (!Qt(e2) || e2.length % 2) && Ft.throwArgumentError("invalid hexData", "value", e2), t = 2 + 2 * t, r != null ? "0x" + e2.substring(t, 2 + 2 * r) : "0x" + e2.substring(t);
    }
    function fe(e2, t) {
      for (typeof e2 != "string" ? e2 = Ht(e2) : Qt(e2) || Ft.throwArgumentError("invalid hex string", "value", e2), e2.length > 2 * t + 2 && Ft.throwArgumentError("value out of range", "value", arguments[1]); e2.length < 2 * t + 2; )
        e2 = "0x0" + e2.substring(2);
      return e2;
    }
    function kn(e2) {
      const t = { r: "0x", s: "0x", _vs: "0x", recoveryParam: 0, v: 0, yParityAndS: "0x", compact: "0x" };
      if (bs(e2)) {
        let r = Pt(e2);
        r.length === 64 ? (t.v = 27 + (r[32] >> 7), r[32] &= 127, t.r = Ht(r.slice(0, 32)), t.s = Ht(r.slice(32, 64))) : r.length === 65 ? (t.r = Ht(r.slice(0, 32)), t.s = Ht(r.slice(32, 64)), t.v = r[64]) : Ft.throwArgumentError("invalid signature string", "signature", e2), t.v < 27 && (t.v === 0 || t.v === 1 ? t.v += 27 : Ft.throwArgumentError("signature invalid v byte", "signature", e2)), t.recoveryParam = 1 - t.v % 2, t.recoveryParam && (r[32] |= 128), t._vs = Ht(r.slice(32, 64));
      } else {
        if (t.r = e2.r, t.s = e2.s, t.v = e2.v, t.recoveryParam = e2.recoveryParam, t._vs = e2._vs, t._vs != null) {
          const n3 = ws(Pt(t._vs), 32);
          t._vs = Ht(n3);
          const o2 = n3[0] >= 128 ? 1 : 0;
          t.recoveryParam == null ? t.recoveryParam = o2 : t.recoveryParam !== o2 && Ft.throwArgumentError("signature recoveryParam mismatch _vs", "signature", e2), n3[0] &= 127;
          const h5 = Ht(n3);
          t.s == null ? t.s = h5 : t.s !== h5 && Ft.throwArgumentError("signature v mismatch _vs", "signature", e2);
        }
        if (t.recoveryParam == null)
          t.v == null ? Ft.throwArgumentError("signature missing v and recoveryParam", "signature", e2) : t.v === 0 || t.v === 1 ? t.recoveryParam = t.v : t.recoveryParam = 1 - t.v % 2;
        else if (t.v == null)
          t.v = 27 + t.recoveryParam;
        else {
          const n3 = t.v === 0 || t.v === 1 ? t.v : 1 - t.v % 2;
          t.recoveryParam !== n3 && Ft.throwArgumentError("signature recoveryParam mismatch v", "signature", e2);
        }
        t.r == null || !Qt(t.r) ? Ft.throwArgumentError("signature missing or invalid r", "signature", e2) : t.r = fe(t.r, 32), t.s == null || !Qt(t.s) ? Ft.throwArgumentError("signature missing or invalid s", "signature", e2) : t.s = fe(t.s, 32);
        const r = Pt(t.s);
        r[0] >= 128 && Ft.throwArgumentError("signature s out of range", "signature", e2), t.recoveryParam && (r[0] |= 128);
        const i2 = Ht(r);
        t._vs && (Qt(t._vs) || Ft.throwArgumentError("signature invalid _vs", "signature", e2), t._vs = fe(t._vs, 32)), t._vs == null ? t._vs = i2 : t._vs !== i2 && Ft.throwArgumentError("signature _vs mismatch v and s", "signature", e2);
      }
      return t.yParityAndS = t._vs, t.compact = t.r + t.yParityAndS.substring(2), t;
    }
    function wi(e2) {
      return "0x" + vs.keccak_256(Pt(e2));
    }
    var qn = { exports: {} };
    var Ms = {};
    var Es = Object.freeze({ __proto__: null, default: Ms });
    var Ss = ps(Es);
    (function(e2) {
      (function(t, r) {
        function i2(A2, f4) {
          if (!A2)
            throw new Error(f4 || "Assertion failed");
        }
        function n3(A2, f4) {
          A2.super_ = f4;
          var a3 = function() {
          };
          a3.prototype = f4.prototype, A2.prototype = new a3(), A2.prototype.constructor = A2;
        }
        function o2(A2, f4, a3) {
          if (o2.isBN(A2))
            return A2;
          this.negative = 0, this.words = null, this.length = 0, this.red = null, A2 !== null && ((f4 === "le" || f4 === "be") && (a3 = f4, f4 = 10), this._init(A2 || 0, f4 || 10, a3 || "be"));
        }
        typeof t == "object" ? t.exports = o2 : r.BN = o2, o2.BN = o2, o2.wordSize = 26;
        var h5;
        try {
          typeof window < "u" && typeof window.Buffer < "u" ? h5 = window.Buffer : h5 = Ss.Buffer;
        } catch {
        }
        o2.isBN = function(f4) {
          return f4 instanceof o2 ? true : f4 !== null && typeof f4 == "object" && f4.constructor.wordSize === o2.wordSize && Array.isArray(f4.words);
        }, o2.max = function(f4, a3) {
          return f4.cmp(a3) > 0 ? f4 : a3;
        }, o2.min = function(f4, a3) {
          return f4.cmp(a3) < 0 ? f4 : a3;
        }, o2.prototype._init = function(f4, a3, c4) {
          if (typeof f4 == "number")
            return this._initNumber(f4, a3, c4);
          if (typeof f4 == "object")
            return this._initArray(f4, a3, c4);
          a3 === "hex" && (a3 = 16), i2(a3 === (a3 | 0) && a3 >= 2 && a3 <= 36), f4 = f4.toString().replace(/\s+/g, "");
          var d3 = 0;
          f4[0] === "-" && (d3++, this.negative = 1), d3 < f4.length && (a3 === 16 ? this._parseHex(f4, d3, c4) : (this._parseBase(f4, a3, d3), c4 === "le" && this._initArray(this.toArray(), a3, c4)));
        }, o2.prototype._initNumber = function(f4, a3, c4) {
          f4 < 0 && (this.negative = 1, f4 = -f4), f4 < 67108864 ? (this.words = [f4 & 67108863], this.length = 1) : f4 < 4503599627370496 ? (this.words = [f4 & 67108863, f4 / 67108864 & 67108863], this.length = 2) : (i2(f4 < 9007199254740992), this.words = [f4 & 67108863, f4 / 67108864 & 67108863, 1], this.length = 3), c4 === "le" && this._initArray(this.toArray(), a3, c4);
        }, o2.prototype._initArray = function(f4, a3, c4) {
          if (i2(typeof f4.length == "number"), f4.length <= 0)
            return this.words = [0], this.length = 1, this;
          this.length = Math.ceil(f4.length / 3), this.words = new Array(this.length);
          for (var d3 = 0; d3 < this.length; d3++)
            this.words[d3] = 0;
          var m3, x3, M = 0;
          if (c4 === "be")
            for (d3 = f4.length - 1, m3 = 0; d3 >= 0; d3 -= 3)
              x3 = f4[d3] | f4[d3 - 1] << 8 | f4[d3 - 2] << 16, this.words[m3] |= x3 << M & 67108863, this.words[m3 + 1] = x3 >>> 26 - M & 67108863, M += 24, M >= 26 && (M -= 26, m3++);
          else if (c4 === "le")
            for (d3 = 0, m3 = 0; d3 < f4.length; d3 += 3)
              x3 = f4[d3] | f4[d3 + 1] << 8 | f4[d3 + 2] << 16, this.words[m3] |= x3 << M & 67108863, this.words[m3 + 1] = x3 >>> 26 - M & 67108863, M += 24, M >= 26 && (M -= 26, m3++);
          return this._strip();
        };
        function p3(A2, f4) {
          var a3 = A2.charCodeAt(f4);
          if (a3 >= 48 && a3 <= 57)
            return a3 - 48;
          if (a3 >= 65 && a3 <= 70)
            return a3 - 55;
          if (a3 >= 97 && a3 <= 102)
            return a3 - 87;
          i2(false, "Invalid character in " + A2);
        }
        function b4(A2, f4, a3) {
          var c4 = p3(A2, a3);
          return a3 - 1 >= f4 && (c4 |= p3(A2, a3 - 1) << 4), c4;
        }
        o2.prototype._parseHex = function(f4, a3, c4) {
          this.length = Math.ceil((f4.length - a3) / 6), this.words = new Array(this.length);
          for (var d3 = 0; d3 < this.length; d3++)
            this.words[d3] = 0;
          var m3 = 0, x3 = 0, M;
          if (c4 === "be")
            for (d3 = f4.length - 1; d3 >= a3; d3 -= 2)
              M = b4(f4, a3, d3) << m3, this.words[x3] |= M & 67108863, m3 >= 18 ? (m3 -= 18, x3 += 1, this.words[x3] |= M >>> 26) : m3 += 8;
          else {
            var l4 = f4.length - a3;
            for (d3 = l4 % 2 === 0 ? a3 + 1 : a3; d3 < f4.length; d3 += 2)
              M = b4(f4, a3, d3) << m3, this.words[x3] |= M & 67108863, m3 >= 18 ? (m3 -= 18, x3 += 1, this.words[x3] |= M >>> 26) : m3 += 8;
          }
          this._strip();
        };
        function g3(A2, f4, a3, c4) {
          for (var d3 = 0, m3 = 0, x3 = Math.min(A2.length, a3), M = f4; M < x3; M++) {
            var l4 = A2.charCodeAt(M) - 48;
            d3 *= c4, l4 >= 49 ? m3 = l4 - 49 + 10 : l4 >= 17 ? m3 = l4 - 17 + 10 : m3 = l4, i2(l4 >= 0 && m3 < c4, "Invalid character"), d3 += m3;
          }
          return d3;
        }
        o2.prototype._parseBase = function(f4, a3, c4) {
          this.words = [0], this.length = 1;
          for (var d3 = 0, m3 = 1; m3 <= 67108863; m3 *= a3)
            d3++;
          d3--, m3 = m3 / a3 | 0;
          for (var x3 = f4.length - c4, M = x3 % d3, l4 = Math.min(x3, x3 - M) + c4, s2 = 0, v2 = c4; v2 < l4; v2 += d3)
            s2 = g3(f4, v2, v2 + d3, a3), this.imuln(m3), this.words[0] + s2 < 67108864 ? this.words[0] += s2 : this._iaddn(s2);
          if (M !== 0) {
            var k4 = 1;
            for (s2 = g3(f4, v2, f4.length, a3), v2 = 0; v2 < M; v2++)
              k4 *= a3;
            this.imuln(k4), this.words[0] + s2 < 67108864 ? this.words[0] += s2 : this._iaddn(s2);
          }
          this._strip();
        }, o2.prototype.copy = function(f4) {
          f4.words = new Array(this.length);
          for (var a3 = 0; a3 < this.length; a3++)
            f4.words[a3] = this.words[a3];
          f4.length = this.length, f4.negative = this.negative, f4.red = this.red;
        };
        function w4(A2, f4) {
          A2.words = f4.words, A2.length = f4.length, A2.negative = f4.negative, A2.red = f4.red;
        }
        if (o2.prototype._move = function(f4) {
          w4(f4, this);
        }, o2.prototype.clone = function() {
          var f4 = new o2(null);
          return this.copy(f4), f4;
        }, o2.prototype._expand = function(f4) {
          for (; this.length < f4; )
            this.words[this.length++] = 0;
          return this;
        }, o2.prototype._strip = function() {
          for (; this.length > 1 && this.words[this.length - 1] === 0; )
            this.length--;
          return this._normSign();
        }, o2.prototype._normSign = function() {
          return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
        }, typeof Symbol < "u" && typeof Symbol.for == "function")
          try {
            o2.prototype[Symbol.for("nodejs.util.inspect.custom")] = y4;
          } catch {
            o2.prototype.inspect = y4;
          }
        else
          o2.prototype.inspect = y4;
        function y4() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        }
        var S4 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], I2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], N10 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        o2.prototype.toString = function(f4, a3) {
          f4 = f4 || 10, a3 = a3 | 0 || 1;
          var c4;
          if (f4 === 16 || f4 === "hex") {
            c4 = "";
            for (var d3 = 0, m3 = 0, x3 = 0; x3 < this.length; x3++) {
              var M = this.words[x3], l4 = ((M << d3 | m3) & 16777215).toString(16);
              m3 = M >>> 24 - d3 & 16777215, d3 += 2, d3 >= 26 && (d3 -= 26, x3--), m3 !== 0 || x3 !== this.length - 1 ? c4 = S4[6 - l4.length] + l4 + c4 : c4 = l4 + c4;
            }
            for (m3 !== 0 && (c4 = m3.toString(16) + c4); c4.length % a3 !== 0; )
              c4 = "0" + c4;
            return this.negative !== 0 && (c4 = "-" + c4), c4;
          }
          if (f4 === (f4 | 0) && f4 >= 2 && f4 <= 36) {
            var s2 = I2[f4], v2 = N10[f4];
            c4 = "";
            var k4 = this.clone();
            for (k4.negative = 0; !k4.isZero(); ) {
              var u3 = k4.modrn(v2).toString(f4);
              k4 = k4.idivn(v2), k4.isZero() ? c4 = u3 + c4 : c4 = S4[s2 - u3.length] + u3 + c4;
            }
            for (this.isZero() && (c4 = "0" + c4); c4.length % a3 !== 0; )
              c4 = "0" + c4;
            return this.negative !== 0 && (c4 = "-" + c4), c4;
          }
          i2(false, "Base should be between 2 and 36");
        }, o2.prototype.toNumber = function() {
          var f4 = this.words[0];
          return this.length === 2 ? f4 += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? f4 += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && i2(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -f4 : f4;
        }, o2.prototype.toJSON = function() {
          return this.toString(16, 2);
        }, h5 && (o2.prototype.toBuffer = function(f4, a3) {
          return this.toArrayLike(h5, f4, a3);
        }), o2.prototype.toArray = function(f4, a3) {
          return this.toArrayLike(Array, f4, a3);
        };
        var R2 = function(f4, a3) {
          return f4.allocUnsafe ? f4.allocUnsafe(a3) : new f4(a3);
        };
        o2.prototype.toArrayLike = function(f4, a3, c4) {
          this._strip();
          var d3 = this.byteLength(), m3 = c4 || Math.max(1, d3);
          i2(d3 <= m3, "byte array longer than desired length"), i2(m3 > 0, "Requested array length <= 0");
          var x3 = R2(f4, m3), M = a3 === "le" ? "LE" : "BE";
          return this["_toArrayLike" + M](x3, d3), x3;
        }, o2.prototype._toArrayLikeLE = function(f4, a3) {
          for (var c4 = 0, d3 = 0, m3 = 0, x3 = 0; m3 < this.length; m3++) {
            var M = this.words[m3] << x3 | d3;
            f4[c4++] = M & 255, c4 < f4.length && (f4[c4++] = M >> 8 & 255), c4 < f4.length && (f4[c4++] = M >> 16 & 255), x3 === 6 ? (c4 < f4.length && (f4[c4++] = M >> 24 & 255), d3 = 0, x3 = 0) : (d3 = M >>> 24, x3 += 2);
          }
          if (c4 < f4.length)
            for (f4[c4++] = d3; c4 < f4.length; )
              f4[c4++] = 0;
        }, o2.prototype._toArrayLikeBE = function(f4, a3) {
          for (var c4 = f4.length - 1, d3 = 0, m3 = 0, x3 = 0; m3 < this.length; m3++) {
            var M = this.words[m3] << x3 | d3;
            f4[c4--] = M & 255, c4 >= 0 && (f4[c4--] = M >> 8 & 255), c4 >= 0 && (f4[c4--] = M >> 16 & 255), x3 === 6 ? (c4 >= 0 && (f4[c4--] = M >> 24 & 255), d3 = 0, x3 = 0) : (d3 = M >>> 24, x3 += 2);
          }
          if (c4 >= 0)
            for (f4[c4--] = d3; c4 >= 0; )
              f4[c4--] = 0;
        }, Math.clz32 ? o2.prototype._countBits = function(f4) {
          return 32 - Math.clz32(f4);
        } : o2.prototype._countBits = function(f4) {
          var a3 = f4, c4 = 0;
          return a3 >= 4096 && (c4 += 13, a3 >>>= 13), a3 >= 64 && (c4 += 7, a3 >>>= 7), a3 >= 8 && (c4 += 4, a3 >>>= 4), a3 >= 2 && (c4 += 2, a3 >>>= 2), c4 + a3;
        }, o2.prototype._zeroBits = function(f4) {
          if (f4 === 0)
            return 26;
          var a3 = f4, c4 = 0;
          return a3 & 8191 || (c4 += 13, a3 >>>= 13), a3 & 127 || (c4 += 7, a3 >>>= 7), a3 & 15 || (c4 += 4, a3 >>>= 4), a3 & 3 || (c4 += 2, a3 >>>= 2), a3 & 1 || c4++, c4;
        }, o2.prototype.bitLength = function() {
          var f4 = this.words[this.length - 1], a3 = this._countBits(f4);
          return (this.length - 1) * 26 + a3;
        };
        function F(A2) {
          for (var f4 = new Array(A2.bitLength()), a3 = 0; a3 < f4.length; a3++) {
            var c4 = a3 / 26 | 0, d3 = a3 % 26;
            f4[a3] = A2.words[c4] >>> d3 & 1;
          }
          return f4;
        }
        o2.prototype.zeroBits = function() {
          if (this.isZero())
            return 0;
          for (var f4 = 0, a3 = 0; a3 < this.length; a3++) {
            var c4 = this._zeroBits(this.words[a3]);
            if (f4 += c4, c4 !== 26)
              break;
          }
          return f4;
        }, o2.prototype.byteLength = function() {
          return Math.ceil(this.bitLength() / 8);
        }, o2.prototype.toTwos = function(f4) {
          return this.negative !== 0 ? this.abs().inotn(f4).iaddn(1) : this.clone();
        }, o2.prototype.fromTwos = function(f4) {
          return this.testn(f4 - 1) ? this.notn(f4).iaddn(1).ineg() : this.clone();
        }, o2.prototype.isNeg = function() {
          return this.negative !== 0;
        }, o2.prototype.neg = function() {
          return this.clone().ineg();
        }, o2.prototype.ineg = function() {
          return this.isZero() || (this.negative ^= 1), this;
        }, o2.prototype.iuor = function(f4) {
          for (; this.length < f4.length; )
            this.words[this.length++] = 0;
          for (var a3 = 0; a3 < f4.length; a3++)
            this.words[a3] = this.words[a3] | f4.words[a3];
          return this._strip();
        }, o2.prototype.ior = function(f4) {
          return i2((this.negative | f4.negative) === 0), this.iuor(f4);
        }, o2.prototype.or = function(f4) {
          return this.length > f4.length ? this.clone().ior(f4) : f4.clone().ior(this);
        }, o2.prototype.uor = function(f4) {
          return this.length > f4.length ? this.clone().iuor(f4) : f4.clone().iuor(this);
        }, o2.prototype.iuand = function(f4) {
          var a3;
          this.length > f4.length ? a3 = f4 : a3 = this;
          for (var c4 = 0; c4 < a3.length; c4++)
            this.words[c4] = this.words[c4] & f4.words[c4];
          return this.length = a3.length, this._strip();
        }, o2.prototype.iand = function(f4) {
          return i2((this.negative | f4.negative) === 0), this.iuand(f4);
        }, o2.prototype.and = function(f4) {
          return this.length > f4.length ? this.clone().iand(f4) : f4.clone().iand(this);
        }, o2.prototype.uand = function(f4) {
          return this.length > f4.length ? this.clone().iuand(f4) : f4.clone().iuand(this);
        }, o2.prototype.iuxor = function(f4) {
          var a3, c4;
          this.length > f4.length ? (a3 = this, c4 = f4) : (a3 = f4, c4 = this);
          for (var d3 = 0; d3 < c4.length; d3++)
            this.words[d3] = a3.words[d3] ^ c4.words[d3];
          if (this !== a3)
            for (; d3 < a3.length; d3++)
              this.words[d3] = a3.words[d3];
          return this.length = a3.length, this._strip();
        }, o2.prototype.ixor = function(f4) {
          return i2((this.negative | f4.negative) === 0), this.iuxor(f4);
        }, o2.prototype.xor = function(f4) {
          return this.length > f4.length ? this.clone().ixor(f4) : f4.clone().ixor(this);
        }, o2.prototype.uxor = function(f4) {
          return this.length > f4.length ? this.clone().iuxor(f4) : f4.clone().iuxor(this);
        }, o2.prototype.inotn = function(f4) {
          i2(typeof f4 == "number" && f4 >= 0);
          var a3 = Math.ceil(f4 / 26) | 0, c4 = f4 % 26;
          this._expand(a3), c4 > 0 && a3--;
          for (var d3 = 0; d3 < a3; d3++)
            this.words[d3] = ~this.words[d3] & 67108863;
          return c4 > 0 && (this.words[d3] = ~this.words[d3] & 67108863 >> 26 - c4), this._strip();
        }, o2.prototype.notn = function(f4) {
          return this.clone().inotn(f4);
        }, o2.prototype.setn = function(f4, a3) {
          i2(typeof f4 == "number" && f4 >= 0);
          var c4 = f4 / 26 | 0, d3 = f4 % 26;
          return this._expand(c4 + 1), a3 ? this.words[c4] = this.words[c4] | 1 << d3 : this.words[c4] = this.words[c4] & ~(1 << d3), this._strip();
        }, o2.prototype.iadd = function(f4) {
          var a3;
          if (this.negative !== 0 && f4.negative === 0)
            return this.negative = 0, a3 = this.isub(f4), this.negative ^= 1, this._normSign();
          if (this.negative === 0 && f4.negative !== 0)
            return f4.negative = 0, a3 = this.isub(f4), f4.negative = 1, a3._normSign();
          var c4, d3;
          this.length > f4.length ? (c4 = this, d3 = f4) : (c4 = f4, d3 = this);
          for (var m3 = 0, x3 = 0; x3 < d3.length; x3++)
            a3 = (c4.words[x3] | 0) + (d3.words[x3] | 0) + m3, this.words[x3] = a3 & 67108863, m3 = a3 >>> 26;
          for (; m3 !== 0 && x3 < c4.length; x3++)
            a3 = (c4.words[x3] | 0) + m3, this.words[x3] = a3 & 67108863, m3 = a3 >>> 26;
          if (this.length = c4.length, m3 !== 0)
            this.words[this.length] = m3, this.length++;
          else if (c4 !== this)
            for (; x3 < c4.length; x3++)
              this.words[x3] = c4.words[x3];
          return this;
        }, o2.prototype.add = function(f4) {
          var a3;
          return f4.negative !== 0 && this.negative === 0 ? (f4.negative = 0, a3 = this.sub(f4), f4.negative ^= 1, a3) : f4.negative === 0 && this.negative !== 0 ? (this.negative = 0, a3 = f4.sub(this), this.negative = 1, a3) : this.length > f4.length ? this.clone().iadd(f4) : f4.clone().iadd(this);
        }, o2.prototype.isub = function(f4) {
          if (f4.negative !== 0) {
            f4.negative = 0;
            var a3 = this.iadd(f4);
            return f4.negative = 1, a3._normSign();
          } else if (this.negative !== 0)
            return this.negative = 0, this.iadd(f4), this.negative = 1, this._normSign();
          var c4 = this.cmp(f4);
          if (c4 === 0)
            return this.negative = 0, this.length = 1, this.words[0] = 0, this;
          var d3, m3;
          c4 > 0 ? (d3 = this, m3 = f4) : (d3 = f4, m3 = this);
          for (var x3 = 0, M = 0; M < m3.length; M++)
            a3 = (d3.words[M] | 0) - (m3.words[M] | 0) + x3, x3 = a3 >> 26, this.words[M] = a3 & 67108863;
          for (; x3 !== 0 && M < d3.length; M++)
            a3 = (d3.words[M] | 0) + x3, x3 = a3 >> 26, this.words[M] = a3 & 67108863;
          if (x3 === 0 && M < d3.length && d3 !== this)
            for (; M < d3.length; M++)
              this.words[M] = d3.words[M];
          return this.length = Math.max(this.length, M), d3 !== this && (this.negative = 1), this._strip();
        }, o2.prototype.sub = function(f4) {
          return this.clone().isub(f4);
        };
        function U2(A2, f4, a3) {
          a3.negative = f4.negative ^ A2.negative;
          var c4 = A2.length + f4.length | 0;
          a3.length = c4, c4 = c4 - 1 | 0;
          var d3 = A2.words[0] | 0, m3 = f4.words[0] | 0, x3 = d3 * m3, M = x3 & 67108863, l4 = x3 / 67108864 | 0;
          a3.words[0] = M;
          for (var s2 = 1; s2 < c4; s2++) {
            for (var v2 = l4 >>> 26, k4 = l4 & 67108863, u3 = Math.min(s2, f4.length - 1), E4 = Math.max(0, s2 - A2.length + 1); E4 <= u3; E4++) {
              var _4 = s2 - E4 | 0;
              d3 = A2.words[_4] | 0, m3 = f4.words[E4] | 0, x3 = d3 * m3 + k4, v2 += x3 / 67108864 | 0, k4 = x3 & 67108863;
            }
            a3.words[s2] = k4 | 0, l4 = v2 | 0;
          }
          return l4 !== 0 ? a3.words[s2] = l4 | 0 : a3.length--, a3._strip();
        }
        var Q = function(f4, a3, c4) {
          var d3 = f4.words, m3 = a3.words, x3 = c4.words, M = 0, l4, s2, v2, k4 = d3[0] | 0, u3 = k4 & 8191, E4 = k4 >>> 13, _4 = d3[1] | 0, B2 = _4 & 8191, C3 = _4 >>> 13, D2 = d3[2] | 0, P2 = D2 & 8191, O3 = D2 >>> 13, Ct = d3[3] | 0, T2 = Ct & 8191, q2 = Ct >>> 13, Pe = d3[4] | 0, X = Pe & 8191, Z = Pe >>> 13, Te = d3[5] | 0, $ = Te & 8191, tt = Te >>> 13, Fe = d3[6] | 0, et = Fe & 8191, rt = Fe >>> 13, De = d3[7] | 0, it = De & 8191, nt = De >>> 13, Ue = d3[8] | 0, ft = Ue & 8191, ot = Ue >>> 13, ke = d3[9] | 0, st = ke & 8191, at = ke >>> 13, qe = m3[0] | 0, ut = qe & 8191, ht = qe >>> 13, Ke = m3[1] | 0, ct = Ke & 8191, lt = Ke >>> 13, He = m3[2] | 0, dt = He & 8191, pt = He >>> 13, Le = m3[3] | 0, vt = Le & 8191, gt = Le >>> 13, ze = m3[4] | 0, mt = ze & 8191, At = ze >>> 13, je = m3[5] | 0, bt = je & 8191, yt = je >>> 13, Ve = m3[6] | 0, wt = Ve & 8191, xt = Ve >>> 13, Qe = m3[7] | 0, Mt = Qe & 8191, Et = Qe >>> 13, Je = m3[8] | 0, St = Je & 8191, Nt = Je >>> 13, Ye = m3[9] | 0, It = Ye & 8191, _t = Ye >>> 13;
          c4.negative = f4.negative ^ a3.negative, c4.length = 19, l4 = Math.imul(u3, ut), s2 = Math.imul(u3, ht), s2 = s2 + Math.imul(E4, ut) | 0, v2 = Math.imul(E4, ht);
          var xe = (M + l4 | 0) + ((s2 & 8191) << 13) | 0;
          M = (v2 + (s2 >>> 13) | 0) + (xe >>> 26) | 0, xe &= 67108863, l4 = Math.imul(B2, ut), s2 = Math.imul(B2, ht), s2 = s2 + Math.imul(C3, ut) | 0, v2 = Math.imul(C3, ht), l4 = l4 + Math.imul(u3, ct) | 0, s2 = s2 + Math.imul(u3, lt) | 0, s2 = s2 + Math.imul(E4, ct) | 0, v2 = v2 + Math.imul(E4, lt) | 0;
          var Me = (M + l4 | 0) + ((s2 & 8191) << 13) | 0;
          M = (v2 + (s2 >>> 13) | 0) + (Me >>> 26) | 0, Me &= 67108863, l4 = Math.imul(P2, ut), s2 = Math.imul(P2, ht), s2 = s2 + Math.imul(O3, ut) | 0, v2 = Math.imul(O3, ht), l4 = l4 + Math.imul(B2, ct) | 0, s2 = s2 + Math.imul(B2, lt) | 0, s2 = s2 + Math.imul(C3, ct) | 0, v2 = v2 + Math.imul(C3, lt) | 0, l4 = l4 + Math.imul(u3, dt) | 0, s2 = s2 + Math.imul(u3, pt) | 0, s2 = s2 + Math.imul(E4, dt) | 0, v2 = v2 + Math.imul(E4, pt) | 0;
          var Ee = (M + l4 | 0) + ((s2 & 8191) << 13) | 0;
          M = (v2 + (s2 >>> 13) | 0) + (Ee >>> 26) | 0, Ee &= 67108863, l4 = Math.imul(T2, ut), s2 = Math.imul(T2, ht), s2 = s2 + Math.imul(q2, ut) | 0, v2 = Math.imul(q2, ht), l4 = l4 + Math.imul(P2, ct) | 0, s2 = s2 + Math.imul(P2, lt) | 0, s2 = s2 + Math.imul(O3, ct) | 0, v2 = v2 + Math.imul(O3, lt) | 0, l4 = l4 + Math.imul(B2, dt) | 0, s2 = s2 + Math.imul(B2, pt) | 0, s2 = s2 + Math.imul(C3, dt) | 0, v2 = v2 + Math.imul(C3, pt) | 0, l4 = l4 + Math.imul(u3, vt) | 0, s2 = s2 + Math.imul(u3, gt) | 0, s2 = s2 + Math.imul(E4, vt) | 0, v2 = v2 + Math.imul(E4, gt) | 0;
          var Se = (M + l4 | 0) + ((s2 & 8191) << 13) | 0;
          M = (v2 + (s2 >>> 13) | 0) + (Se >>> 26) | 0, Se &= 67108863, l4 = Math.imul(X, ut), s2 = Math.imul(X, ht), s2 = s2 + Math.imul(Z, ut) | 0, v2 = Math.imul(Z, ht), l4 = l4 + Math.imul(T2, ct) | 0, s2 = s2 + Math.imul(T2, lt) | 0, s2 = s2 + Math.imul(q2, ct) | 0, v2 = v2 + Math.imul(q2, lt) | 0, l4 = l4 + Math.imul(P2, dt) | 0, s2 = s2 + Math.imul(P2, pt) | 0, s2 = s2 + Math.imul(O3, dt) | 0, v2 = v2 + Math.imul(O3, pt) | 0, l4 = l4 + Math.imul(B2, vt) | 0, s2 = s2 + Math.imul(B2, gt) | 0, s2 = s2 + Math.imul(C3, vt) | 0, v2 = v2 + Math.imul(C3, gt) | 0, l4 = l4 + Math.imul(u3, mt) | 0, s2 = s2 + Math.imul(u3, At) | 0, s2 = s2 + Math.imul(E4, mt) | 0, v2 = v2 + Math.imul(E4, At) | 0;
          var Ne = (M + l4 | 0) + ((s2 & 8191) << 13) | 0;
          M = (v2 + (s2 >>> 13) | 0) + (Ne >>> 26) | 0, Ne &= 67108863, l4 = Math.imul($, ut), s2 = Math.imul($, ht), s2 = s2 + Math.imul(tt, ut) | 0, v2 = Math.imul(tt, ht), l4 = l4 + Math.imul(X, ct) | 0, s2 = s2 + Math.imul(X, lt) | 0, s2 = s2 + Math.imul(Z, ct) | 0, v2 = v2 + Math.imul(Z, lt) | 0, l4 = l4 + Math.imul(T2, dt) | 0, s2 = s2 + Math.imul(T2, pt) | 0, s2 = s2 + Math.imul(q2, dt) | 0, v2 = v2 + Math.imul(q2, pt) | 0, l4 = l4 + Math.imul(P2, vt) | 0, s2 = s2 + Math.imul(P2, gt) | 0, s2 = s2 + Math.imul(O3, vt) | 0, v2 = v2 + Math.imul(O3, gt) | 0, l4 = l4 + Math.imul(B2, mt) | 0, s2 = s2 + Math.imul(B2, At) | 0, s2 = s2 + Math.imul(C3, mt) | 0, v2 = v2 + Math.imul(C3, At) | 0, l4 = l4 + Math.imul(u3, bt) | 0, s2 = s2 + Math.imul(u3, yt) | 0, s2 = s2 + Math.imul(E4, bt) | 0, v2 = v2 + Math.imul(E4, yt) | 0;
          var Xr = (M + l4 | 0) + ((s2 & 8191) << 13) | 0;
          M = (v2 + (s2 >>> 13) | 0) + (Xr >>> 26) | 0, Xr &= 67108863, l4 = Math.imul(et, ut), s2 = Math.imul(et, ht), s2 = s2 + Math.imul(rt, ut) | 0, v2 = Math.imul(rt, ht), l4 = l4 + Math.imul($, ct) | 0, s2 = s2 + Math.imul($, lt) | 0, s2 = s2 + Math.imul(tt, ct) | 0, v2 = v2 + Math.imul(tt, lt) | 0, l4 = l4 + Math.imul(X, dt) | 0, s2 = s2 + Math.imul(X, pt) | 0, s2 = s2 + Math.imul(Z, dt) | 0, v2 = v2 + Math.imul(Z, pt) | 0, l4 = l4 + Math.imul(T2, vt) | 0, s2 = s2 + Math.imul(T2, gt) | 0, s2 = s2 + Math.imul(q2, vt) | 0, v2 = v2 + Math.imul(q2, gt) | 0, l4 = l4 + Math.imul(P2, mt) | 0, s2 = s2 + Math.imul(P2, At) | 0, s2 = s2 + Math.imul(O3, mt) | 0, v2 = v2 + Math.imul(O3, At) | 0, l4 = l4 + Math.imul(B2, bt) | 0, s2 = s2 + Math.imul(B2, yt) | 0, s2 = s2 + Math.imul(C3, bt) | 0, v2 = v2 + Math.imul(C3, yt) | 0, l4 = l4 + Math.imul(u3, wt) | 0, s2 = s2 + Math.imul(u3, xt) | 0, s2 = s2 + Math.imul(E4, wt) | 0, v2 = v2 + Math.imul(E4, xt) | 0;
          var Zr = (M + l4 | 0) + ((s2 & 8191) << 13) | 0;
          M = (v2 + (s2 >>> 13) | 0) + (Zr >>> 26) | 0, Zr &= 67108863, l4 = Math.imul(it, ut), s2 = Math.imul(it, ht), s2 = s2 + Math.imul(nt, ut) | 0, v2 = Math.imul(nt, ht), l4 = l4 + Math.imul(et, ct) | 0, s2 = s2 + Math.imul(et, lt) | 0, s2 = s2 + Math.imul(rt, ct) | 0, v2 = v2 + Math.imul(rt, lt) | 0, l4 = l4 + Math.imul($, dt) | 0, s2 = s2 + Math.imul($, pt) | 0, s2 = s2 + Math.imul(tt, dt) | 0, v2 = v2 + Math.imul(tt, pt) | 0, l4 = l4 + Math.imul(X, vt) | 0, s2 = s2 + Math.imul(X, gt) | 0, s2 = s2 + Math.imul(Z, vt) | 0, v2 = v2 + Math.imul(Z, gt) | 0, l4 = l4 + Math.imul(T2, mt) | 0, s2 = s2 + Math.imul(T2, At) | 0, s2 = s2 + Math.imul(q2, mt) | 0, v2 = v2 + Math.imul(q2, At) | 0, l4 = l4 + Math.imul(P2, bt) | 0, s2 = s2 + Math.imul(P2, yt) | 0, s2 = s2 + Math.imul(O3, bt) | 0, v2 = v2 + Math.imul(O3, yt) | 0, l4 = l4 + Math.imul(B2, wt) | 0, s2 = s2 + Math.imul(B2, xt) | 0, s2 = s2 + Math.imul(C3, wt) | 0, v2 = v2 + Math.imul(C3, xt) | 0, l4 = l4 + Math.imul(u3, Mt) | 0, s2 = s2 + Math.imul(u3, Et) | 0, s2 = s2 + Math.imul(E4, Mt) | 0, v2 = v2 + Math.imul(E4, Et) | 0;
          var $r = (M + l4 | 0) + ((s2 & 8191) << 13) | 0;
          M = (v2 + (s2 >>> 13) | 0) + ($r >>> 26) | 0, $r &= 67108863, l4 = Math.imul(ft, ut), s2 = Math.imul(ft, ht), s2 = s2 + Math.imul(ot, ut) | 0, v2 = Math.imul(ot, ht), l4 = l4 + Math.imul(it, ct) | 0, s2 = s2 + Math.imul(it, lt) | 0, s2 = s2 + Math.imul(nt, ct) | 0, v2 = v2 + Math.imul(nt, lt) | 0, l4 = l4 + Math.imul(et, dt) | 0, s2 = s2 + Math.imul(et, pt) | 0, s2 = s2 + Math.imul(rt, dt) | 0, v2 = v2 + Math.imul(rt, pt) | 0, l4 = l4 + Math.imul($, vt) | 0, s2 = s2 + Math.imul($, gt) | 0, s2 = s2 + Math.imul(tt, vt) | 0, v2 = v2 + Math.imul(tt, gt) | 0, l4 = l4 + Math.imul(X, mt) | 0, s2 = s2 + Math.imul(X, At) | 0, s2 = s2 + Math.imul(Z, mt) | 0, v2 = v2 + Math.imul(Z, At) | 0, l4 = l4 + Math.imul(T2, bt) | 0, s2 = s2 + Math.imul(T2, yt) | 0, s2 = s2 + Math.imul(q2, bt) | 0, v2 = v2 + Math.imul(q2, yt) | 0, l4 = l4 + Math.imul(P2, wt) | 0, s2 = s2 + Math.imul(P2, xt) | 0, s2 = s2 + Math.imul(O3, wt) | 0, v2 = v2 + Math.imul(O3, xt) | 0, l4 = l4 + Math.imul(B2, Mt) | 0, s2 = s2 + Math.imul(B2, Et) | 0, s2 = s2 + Math.imul(C3, Mt) | 0, v2 = v2 + Math.imul(C3, Et) | 0, l4 = l4 + Math.imul(u3, St) | 0, s2 = s2 + Math.imul(u3, Nt) | 0, s2 = s2 + Math.imul(E4, St) | 0, v2 = v2 + Math.imul(E4, Nt) | 0;
          var ti = (M + l4 | 0) + ((s2 & 8191) << 13) | 0;
          M = (v2 + (s2 >>> 13) | 0) + (ti >>> 26) | 0, ti &= 67108863, l4 = Math.imul(st, ut), s2 = Math.imul(st, ht), s2 = s2 + Math.imul(at, ut) | 0, v2 = Math.imul(at, ht), l4 = l4 + Math.imul(ft, ct) | 0, s2 = s2 + Math.imul(ft, lt) | 0, s2 = s2 + Math.imul(ot, ct) | 0, v2 = v2 + Math.imul(ot, lt) | 0, l4 = l4 + Math.imul(it, dt) | 0, s2 = s2 + Math.imul(it, pt) | 0, s2 = s2 + Math.imul(nt, dt) | 0, v2 = v2 + Math.imul(nt, pt) | 0, l4 = l4 + Math.imul(et, vt) | 0, s2 = s2 + Math.imul(et, gt) | 0, s2 = s2 + Math.imul(rt, vt) | 0, v2 = v2 + Math.imul(rt, gt) | 0, l4 = l4 + Math.imul($, mt) | 0, s2 = s2 + Math.imul($, At) | 0, s2 = s2 + Math.imul(tt, mt) | 0, v2 = v2 + Math.imul(tt, At) | 0, l4 = l4 + Math.imul(X, bt) | 0, s2 = s2 + Math.imul(X, yt) | 0, s2 = s2 + Math.imul(Z, bt) | 0, v2 = v2 + Math.imul(Z, yt) | 0, l4 = l4 + Math.imul(T2, wt) | 0, s2 = s2 + Math.imul(T2, xt) | 0, s2 = s2 + Math.imul(q2, wt) | 0, v2 = v2 + Math.imul(q2, xt) | 0, l4 = l4 + Math.imul(P2, Mt) | 0, s2 = s2 + Math.imul(P2, Et) | 0, s2 = s2 + Math.imul(O3, Mt) | 0, v2 = v2 + Math.imul(O3, Et) | 0, l4 = l4 + Math.imul(B2, St) | 0, s2 = s2 + Math.imul(B2, Nt) | 0, s2 = s2 + Math.imul(C3, St) | 0, v2 = v2 + Math.imul(C3, Nt) | 0, l4 = l4 + Math.imul(u3, It) | 0, s2 = s2 + Math.imul(u3, _t) | 0, s2 = s2 + Math.imul(E4, It) | 0, v2 = v2 + Math.imul(E4, _t) | 0;
          var ei = (M + l4 | 0) + ((s2 & 8191) << 13) | 0;
          M = (v2 + (s2 >>> 13) | 0) + (ei >>> 26) | 0, ei &= 67108863, l4 = Math.imul(st, ct), s2 = Math.imul(st, lt), s2 = s2 + Math.imul(at, ct) | 0, v2 = Math.imul(at, lt), l4 = l4 + Math.imul(ft, dt) | 0, s2 = s2 + Math.imul(ft, pt) | 0, s2 = s2 + Math.imul(ot, dt) | 0, v2 = v2 + Math.imul(ot, pt) | 0, l4 = l4 + Math.imul(it, vt) | 0, s2 = s2 + Math.imul(it, gt) | 0, s2 = s2 + Math.imul(nt, vt) | 0, v2 = v2 + Math.imul(nt, gt) | 0, l4 = l4 + Math.imul(et, mt) | 0, s2 = s2 + Math.imul(et, At) | 0, s2 = s2 + Math.imul(rt, mt) | 0, v2 = v2 + Math.imul(rt, At) | 0, l4 = l4 + Math.imul($, bt) | 0, s2 = s2 + Math.imul($, yt) | 0, s2 = s2 + Math.imul(tt, bt) | 0, v2 = v2 + Math.imul(tt, yt) | 0, l4 = l4 + Math.imul(X, wt) | 0, s2 = s2 + Math.imul(X, xt) | 0, s2 = s2 + Math.imul(Z, wt) | 0, v2 = v2 + Math.imul(Z, xt) | 0, l4 = l4 + Math.imul(T2, Mt) | 0, s2 = s2 + Math.imul(T2, Et) | 0, s2 = s2 + Math.imul(q2, Mt) | 0, v2 = v2 + Math.imul(q2, Et) | 0, l4 = l4 + Math.imul(P2, St) | 0, s2 = s2 + Math.imul(P2, Nt) | 0, s2 = s2 + Math.imul(O3, St) | 0, v2 = v2 + Math.imul(O3, Nt) | 0, l4 = l4 + Math.imul(B2, It) | 0, s2 = s2 + Math.imul(B2, _t) | 0, s2 = s2 + Math.imul(C3, It) | 0, v2 = v2 + Math.imul(C3, _t) | 0;
          var ri = (M + l4 | 0) + ((s2 & 8191) << 13) | 0;
          M = (v2 + (s2 >>> 13) | 0) + (ri >>> 26) | 0, ri &= 67108863, l4 = Math.imul(st, dt), s2 = Math.imul(st, pt), s2 = s2 + Math.imul(at, dt) | 0, v2 = Math.imul(at, pt), l4 = l4 + Math.imul(ft, vt) | 0, s2 = s2 + Math.imul(ft, gt) | 0, s2 = s2 + Math.imul(ot, vt) | 0, v2 = v2 + Math.imul(ot, gt) | 0, l4 = l4 + Math.imul(it, mt) | 0, s2 = s2 + Math.imul(it, At) | 0, s2 = s2 + Math.imul(nt, mt) | 0, v2 = v2 + Math.imul(nt, At) | 0, l4 = l4 + Math.imul(et, bt) | 0, s2 = s2 + Math.imul(et, yt) | 0, s2 = s2 + Math.imul(rt, bt) | 0, v2 = v2 + Math.imul(rt, yt) | 0, l4 = l4 + Math.imul($, wt) | 0, s2 = s2 + Math.imul($, xt) | 0, s2 = s2 + Math.imul(tt, wt) | 0, v2 = v2 + Math.imul(tt, xt) | 0, l4 = l4 + Math.imul(X, Mt) | 0, s2 = s2 + Math.imul(X, Et) | 0, s2 = s2 + Math.imul(Z, Mt) | 0, v2 = v2 + Math.imul(Z, Et) | 0, l4 = l4 + Math.imul(T2, St) | 0, s2 = s2 + Math.imul(T2, Nt) | 0, s2 = s2 + Math.imul(q2, St) | 0, v2 = v2 + Math.imul(q2, Nt) | 0, l4 = l4 + Math.imul(P2, It) | 0, s2 = s2 + Math.imul(P2, _t) | 0, s2 = s2 + Math.imul(O3, It) | 0, v2 = v2 + Math.imul(O3, _t) | 0;
          var ii = (M + l4 | 0) + ((s2 & 8191) << 13) | 0;
          M = (v2 + (s2 >>> 13) | 0) + (ii >>> 26) | 0, ii &= 67108863, l4 = Math.imul(st, vt), s2 = Math.imul(st, gt), s2 = s2 + Math.imul(at, vt) | 0, v2 = Math.imul(at, gt), l4 = l4 + Math.imul(ft, mt) | 0, s2 = s2 + Math.imul(ft, At) | 0, s2 = s2 + Math.imul(ot, mt) | 0, v2 = v2 + Math.imul(ot, At) | 0, l4 = l4 + Math.imul(it, bt) | 0, s2 = s2 + Math.imul(it, yt) | 0, s2 = s2 + Math.imul(nt, bt) | 0, v2 = v2 + Math.imul(nt, yt) | 0, l4 = l4 + Math.imul(et, wt) | 0, s2 = s2 + Math.imul(et, xt) | 0, s2 = s2 + Math.imul(rt, wt) | 0, v2 = v2 + Math.imul(rt, xt) | 0, l4 = l4 + Math.imul($, Mt) | 0, s2 = s2 + Math.imul($, Et) | 0, s2 = s2 + Math.imul(tt, Mt) | 0, v2 = v2 + Math.imul(tt, Et) | 0, l4 = l4 + Math.imul(X, St) | 0, s2 = s2 + Math.imul(X, Nt) | 0, s2 = s2 + Math.imul(Z, St) | 0, v2 = v2 + Math.imul(Z, Nt) | 0, l4 = l4 + Math.imul(T2, It) | 0, s2 = s2 + Math.imul(T2, _t) | 0, s2 = s2 + Math.imul(q2, It) | 0, v2 = v2 + Math.imul(q2, _t) | 0;
          var ni = (M + l4 | 0) + ((s2 & 8191) << 13) | 0;
          M = (v2 + (s2 >>> 13) | 0) + (ni >>> 26) | 0, ni &= 67108863, l4 = Math.imul(st, mt), s2 = Math.imul(st, At), s2 = s2 + Math.imul(at, mt) | 0, v2 = Math.imul(at, At), l4 = l4 + Math.imul(ft, bt) | 0, s2 = s2 + Math.imul(ft, yt) | 0, s2 = s2 + Math.imul(ot, bt) | 0, v2 = v2 + Math.imul(ot, yt) | 0, l4 = l4 + Math.imul(it, wt) | 0, s2 = s2 + Math.imul(it, xt) | 0, s2 = s2 + Math.imul(nt, wt) | 0, v2 = v2 + Math.imul(nt, xt) | 0, l4 = l4 + Math.imul(et, Mt) | 0, s2 = s2 + Math.imul(et, Et) | 0, s2 = s2 + Math.imul(rt, Mt) | 0, v2 = v2 + Math.imul(rt, Et) | 0, l4 = l4 + Math.imul($, St) | 0, s2 = s2 + Math.imul($, Nt) | 0, s2 = s2 + Math.imul(tt, St) | 0, v2 = v2 + Math.imul(tt, Nt) | 0, l4 = l4 + Math.imul(X, It) | 0, s2 = s2 + Math.imul(X, _t) | 0, s2 = s2 + Math.imul(Z, It) | 0, v2 = v2 + Math.imul(Z, _t) | 0;
          var fi = (M + l4 | 0) + ((s2 & 8191) << 13) | 0;
          M = (v2 + (s2 >>> 13) | 0) + (fi >>> 26) | 0, fi &= 67108863, l4 = Math.imul(st, bt), s2 = Math.imul(st, yt), s2 = s2 + Math.imul(at, bt) | 0, v2 = Math.imul(at, yt), l4 = l4 + Math.imul(ft, wt) | 0, s2 = s2 + Math.imul(ft, xt) | 0, s2 = s2 + Math.imul(ot, wt) | 0, v2 = v2 + Math.imul(ot, xt) | 0, l4 = l4 + Math.imul(it, Mt) | 0, s2 = s2 + Math.imul(it, Et) | 0, s2 = s2 + Math.imul(nt, Mt) | 0, v2 = v2 + Math.imul(nt, Et) | 0, l4 = l4 + Math.imul(et, St) | 0, s2 = s2 + Math.imul(et, Nt) | 0, s2 = s2 + Math.imul(rt, St) | 0, v2 = v2 + Math.imul(rt, Nt) | 0, l4 = l4 + Math.imul($, It) | 0, s2 = s2 + Math.imul($, _t) | 0, s2 = s2 + Math.imul(tt, It) | 0, v2 = v2 + Math.imul(tt, _t) | 0;
          var oi = (M + l4 | 0) + ((s2 & 8191) << 13) | 0;
          M = (v2 + (s2 >>> 13) | 0) + (oi >>> 26) | 0, oi &= 67108863, l4 = Math.imul(st, wt), s2 = Math.imul(st, xt), s2 = s2 + Math.imul(at, wt) | 0, v2 = Math.imul(at, xt), l4 = l4 + Math.imul(ft, Mt) | 0, s2 = s2 + Math.imul(ft, Et) | 0, s2 = s2 + Math.imul(ot, Mt) | 0, v2 = v2 + Math.imul(ot, Et) | 0, l4 = l4 + Math.imul(it, St) | 0, s2 = s2 + Math.imul(it, Nt) | 0, s2 = s2 + Math.imul(nt, St) | 0, v2 = v2 + Math.imul(nt, Nt) | 0, l4 = l4 + Math.imul(et, It) | 0, s2 = s2 + Math.imul(et, _t) | 0, s2 = s2 + Math.imul(rt, It) | 0, v2 = v2 + Math.imul(rt, _t) | 0;
          var si = (M + l4 | 0) + ((s2 & 8191) << 13) | 0;
          M = (v2 + (s2 >>> 13) | 0) + (si >>> 26) | 0, si &= 67108863, l4 = Math.imul(st, Mt), s2 = Math.imul(st, Et), s2 = s2 + Math.imul(at, Mt) | 0, v2 = Math.imul(at, Et), l4 = l4 + Math.imul(ft, St) | 0, s2 = s2 + Math.imul(ft, Nt) | 0, s2 = s2 + Math.imul(ot, St) | 0, v2 = v2 + Math.imul(ot, Nt) | 0, l4 = l4 + Math.imul(it, It) | 0, s2 = s2 + Math.imul(it, _t) | 0, s2 = s2 + Math.imul(nt, It) | 0, v2 = v2 + Math.imul(nt, _t) | 0;
          var ai = (M + l4 | 0) + ((s2 & 8191) << 13) | 0;
          M = (v2 + (s2 >>> 13) | 0) + (ai >>> 26) | 0, ai &= 67108863, l4 = Math.imul(st, St), s2 = Math.imul(st, Nt), s2 = s2 + Math.imul(at, St) | 0, v2 = Math.imul(at, Nt), l4 = l4 + Math.imul(ft, It) | 0, s2 = s2 + Math.imul(ft, _t) | 0, s2 = s2 + Math.imul(ot, It) | 0, v2 = v2 + Math.imul(ot, _t) | 0;
          var ui = (M + l4 | 0) + ((s2 & 8191) << 13) | 0;
          M = (v2 + (s2 >>> 13) | 0) + (ui >>> 26) | 0, ui &= 67108863, l4 = Math.imul(st, It), s2 = Math.imul(st, _t), s2 = s2 + Math.imul(at, It) | 0, v2 = Math.imul(at, _t);
          var hi = (M + l4 | 0) + ((s2 & 8191) << 13) | 0;
          return M = (v2 + (s2 >>> 13) | 0) + (hi >>> 26) | 0, hi &= 67108863, x3[0] = xe, x3[1] = Me, x3[2] = Ee, x3[3] = Se, x3[4] = Ne, x3[5] = Xr, x3[6] = Zr, x3[7] = $r, x3[8] = ti, x3[9] = ei, x3[10] = ri, x3[11] = ii, x3[12] = ni, x3[13] = fi, x3[14] = oi, x3[15] = si, x3[16] = ai, x3[17] = ui, x3[18] = hi, M !== 0 && (x3[19] = M, c4.length++), c4;
        };
        Math.imul || (Q = U2);
        function Bt(A2, f4, a3) {
          a3.negative = f4.negative ^ A2.negative, a3.length = A2.length + f4.length;
          for (var c4 = 0, d3 = 0, m3 = 0; m3 < a3.length - 1; m3++) {
            var x3 = d3;
            d3 = 0;
            for (var M = c4 & 67108863, l4 = Math.min(m3, f4.length - 1), s2 = Math.max(0, m3 - A2.length + 1); s2 <= l4; s2++) {
              var v2 = m3 - s2, k4 = A2.words[v2] | 0, u3 = f4.words[s2] | 0, E4 = k4 * u3, _4 = E4 & 67108863;
              x3 = x3 + (E4 / 67108864 | 0) | 0, _4 = _4 + M | 0, M = _4 & 67108863, x3 = x3 + (_4 >>> 26) | 0, d3 += x3 >>> 26, x3 &= 67108863;
            }
            a3.words[m3] = M, c4 = x3, x3 = d3;
          }
          return c4 !== 0 ? a3.words[m3] = c4 : a3.length--, a3._strip();
        }
        function J(A2, f4, a3) {
          return Bt(A2, f4, a3);
        }
        o2.prototype.mulTo = function(f4, a3) {
          var c4, d3 = this.length + f4.length;
          return this.length === 10 && f4.length === 10 ? c4 = Q(this, f4, a3) : d3 < 63 ? c4 = U2(this, f4, a3) : d3 < 1024 ? c4 = Bt(this, f4, a3) : c4 = J(this, f4, a3), c4;
        }, o2.prototype.mul = function(f4) {
          var a3 = new o2(null);
          return a3.words = new Array(this.length + f4.length), this.mulTo(f4, a3);
        }, o2.prototype.mulf = function(f4) {
          var a3 = new o2(null);
          return a3.words = new Array(this.length + f4.length), J(this, f4, a3);
        }, o2.prototype.imul = function(f4) {
          return this.clone().mulTo(f4, this);
        }, o2.prototype.imuln = function(f4) {
          var a3 = f4 < 0;
          a3 && (f4 = -f4), i2(typeof f4 == "number"), i2(f4 < 67108864);
          for (var c4 = 0, d3 = 0; d3 < this.length; d3++) {
            var m3 = (this.words[d3] | 0) * f4, x3 = (m3 & 67108863) + (c4 & 67108863);
            c4 >>= 26, c4 += m3 / 67108864 | 0, c4 += x3 >>> 26, this.words[d3] = x3 & 67108863;
          }
          return c4 !== 0 && (this.words[d3] = c4, this.length++), a3 ? this.ineg() : this;
        }, o2.prototype.muln = function(f4) {
          return this.clone().imuln(f4);
        }, o2.prototype.sqr = function() {
          return this.mul(this);
        }, o2.prototype.isqr = function() {
          return this.imul(this.clone());
        }, o2.prototype.pow = function(f4) {
          var a3 = F(f4);
          if (a3.length === 0)
            return new o2(1);
          for (var c4 = this, d3 = 0; d3 < a3.length && a3[d3] === 0; d3++, c4 = c4.sqr())
            ;
          if (++d3 < a3.length)
            for (var m3 = c4.sqr(); d3 < a3.length; d3++, m3 = m3.sqr())
              a3[d3] !== 0 && (c4 = c4.mul(m3));
          return c4;
        }, o2.prototype.iushln = function(f4) {
          i2(typeof f4 == "number" && f4 >= 0);
          var a3 = f4 % 26, c4 = (f4 - a3) / 26, d3 = 67108863 >>> 26 - a3 << 26 - a3, m3;
          if (a3 !== 0) {
            var x3 = 0;
            for (m3 = 0; m3 < this.length; m3++) {
              var M = this.words[m3] & d3, l4 = (this.words[m3] | 0) - M << a3;
              this.words[m3] = l4 | x3, x3 = M >>> 26 - a3;
            }
            x3 && (this.words[m3] = x3, this.length++);
          }
          if (c4 !== 0) {
            for (m3 = this.length - 1; m3 >= 0; m3--)
              this.words[m3 + c4] = this.words[m3];
            for (m3 = 0; m3 < c4; m3++)
              this.words[m3] = 0;
            this.length += c4;
          }
          return this._strip();
        }, o2.prototype.ishln = function(f4) {
          return i2(this.negative === 0), this.iushln(f4);
        }, o2.prototype.iushrn = function(f4, a3, c4) {
          i2(typeof f4 == "number" && f4 >= 0);
          var d3;
          a3 ? d3 = (a3 - a3 % 26) / 26 : d3 = 0;
          var m3 = f4 % 26, x3 = Math.min((f4 - m3) / 26, this.length), M = 67108863 ^ 67108863 >>> m3 << m3, l4 = c4;
          if (d3 -= x3, d3 = Math.max(0, d3), l4) {
            for (var s2 = 0; s2 < x3; s2++)
              l4.words[s2] = this.words[s2];
            l4.length = x3;
          }
          if (x3 !== 0)
            if (this.length > x3)
              for (this.length -= x3, s2 = 0; s2 < this.length; s2++)
                this.words[s2] = this.words[s2 + x3];
            else
              this.words[0] = 0, this.length = 1;
          var v2 = 0;
          for (s2 = this.length - 1; s2 >= 0 && (v2 !== 0 || s2 >= d3); s2--) {
            var k4 = this.words[s2] | 0;
            this.words[s2] = v2 << 26 - m3 | k4 >>> m3, v2 = k4 & M;
          }
          return l4 && v2 !== 0 && (l4.words[l4.length++] = v2), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
        }, o2.prototype.ishrn = function(f4, a3, c4) {
          return i2(this.negative === 0), this.iushrn(f4, a3, c4);
        }, o2.prototype.shln = function(f4) {
          return this.clone().ishln(f4);
        }, o2.prototype.ushln = function(f4) {
          return this.clone().iushln(f4);
        }, o2.prototype.shrn = function(f4) {
          return this.clone().ishrn(f4);
        }, o2.prototype.ushrn = function(f4) {
          return this.clone().iushrn(f4);
        }, o2.prototype.testn = function(f4) {
          i2(typeof f4 == "number" && f4 >= 0);
          var a3 = f4 % 26, c4 = (f4 - a3) / 26, d3 = 1 << a3;
          if (this.length <= c4)
            return false;
          var m3 = this.words[c4];
          return !!(m3 & d3);
        }, o2.prototype.imaskn = function(f4) {
          i2(typeof f4 == "number" && f4 >= 0);
          var a3 = f4 % 26, c4 = (f4 - a3) / 26;
          if (i2(this.negative === 0, "imaskn works only with positive numbers"), this.length <= c4)
            return this;
          if (a3 !== 0 && c4++, this.length = Math.min(c4, this.length), a3 !== 0) {
            var d3 = 67108863 ^ 67108863 >>> a3 << a3;
            this.words[this.length - 1] &= d3;
          }
          return this._strip();
        }, o2.prototype.maskn = function(f4) {
          return this.clone().imaskn(f4);
        }, o2.prototype.iaddn = function(f4) {
          return i2(typeof f4 == "number"), i2(f4 < 67108864), f4 < 0 ? this.isubn(-f4) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= f4 ? (this.words[0] = f4 - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(f4), this.negative = 1, this) : this._iaddn(f4);
        }, o2.prototype._iaddn = function(f4) {
          this.words[0] += f4;
          for (var a3 = 0; a3 < this.length && this.words[a3] >= 67108864; a3++)
            this.words[a3] -= 67108864, a3 === this.length - 1 ? this.words[a3 + 1] = 1 : this.words[a3 + 1]++;
          return this.length = Math.max(this.length, a3 + 1), this;
        }, o2.prototype.isubn = function(f4) {
          if (i2(typeof f4 == "number"), i2(f4 < 67108864), f4 < 0)
            return this.iaddn(-f4);
          if (this.negative !== 0)
            return this.negative = 0, this.iaddn(f4), this.negative = 1, this;
          if (this.words[0] -= f4, this.length === 1 && this.words[0] < 0)
            this.words[0] = -this.words[0], this.negative = 1;
          else
            for (var a3 = 0; a3 < this.length && this.words[a3] < 0; a3++)
              this.words[a3] += 67108864, this.words[a3 + 1] -= 1;
          return this._strip();
        }, o2.prototype.addn = function(f4) {
          return this.clone().iaddn(f4);
        }, o2.prototype.subn = function(f4) {
          return this.clone().isubn(f4);
        }, o2.prototype.iabs = function() {
          return this.negative = 0, this;
        }, o2.prototype.abs = function() {
          return this.clone().iabs();
        }, o2.prototype._ishlnsubmul = function(f4, a3, c4) {
          var d3 = f4.length + c4, m3;
          this._expand(d3);
          var x3, M = 0;
          for (m3 = 0; m3 < f4.length; m3++) {
            x3 = (this.words[m3 + c4] | 0) + M;
            var l4 = (f4.words[m3] | 0) * a3;
            x3 -= l4 & 67108863, M = (x3 >> 26) - (l4 / 67108864 | 0), this.words[m3 + c4] = x3 & 67108863;
          }
          for (; m3 < this.length - c4; m3++)
            x3 = (this.words[m3 + c4] | 0) + M, M = x3 >> 26, this.words[m3 + c4] = x3 & 67108863;
          if (M === 0)
            return this._strip();
          for (i2(M === -1), M = 0, m3 = 0; m3 < this.length; m3++)
            x3 = -(this.words[m3] | 0) + M, M = x3 >> 26, this.words[m3] = x3 & 67108863;
          return this.negative = 1, this._strip();
        }, o2.prototype._wordDiv = function(f4, a3) {
          var c4 = this.length - f4.length, d3 = this.clone(), m3 = f4, x3 = m3.words[m3.length - 1] | 0, M = this._countBits(x3);
          c4 = 26 - M, c4 !== 0 && (m3 = m3.ushln(c4), d3.iushln(c4), x3 = m3.words[m3.length - 1] | 0);
          var l4 = d3.length - m3.length, s2;
          if (a3 !== "mod") {
            s2 = new o2(null), s2.length = l4 + 1, s2.words = new Array(s2.length);
            for (var v2 = 0; v2 < s2.length; v2++)
              s2.words[v2] = 0;
          }
          var k4 = d3.clone()._ishlnsubmul(m3, 1, l4);
          k4.negative === 0 && (d3 = k4, s2 && (s2.words[l4] = 1));
          for (var u3 = l4 - 1; u3 >= 0; u3--) {
            var E4 = (d3.words[m3.length + u3] | 0) * 67108864 + (d3.words[m3.length + u3 - 1] | 0);
            for (E4 = Math.min(E4 / x3 | 0, 67108863), d3._ishlnsubmul(m3, E4, u3); d3.negative !== 0; )
              E4--, d3.negative = 0, d3._ishlnsubmul(m3, 1, u3), d3.isZero() || (d3.negative ^= 1);
            s2 && (s2.words[u3] = E4);
          }
          return s2 && s2._strip(), d3._strip(), a3 !== "div" && c4 !== 0 && d3.iushrn(c4), { div: s2 || null, mod: d3 };
        }, o2.prototype.divmod = function(f4, a3, c4) {
          if (i2(!f4.isZero()), this.isZero())
            return { div: new o2(0), mod: new o2(0) };
          var d3, m3, x3;
          return this.negative !== 0 && f4.negative === 0 ? (x3 = this.neg().divmod(f4, a3), a3 !== "mod" && (d3 = x3.div.neg()), a3 !== "div" && (m3 = x3.mod.neg(), c4 && m3.negative !== 0 && m3.iadd(f4)), { div: d3, mod: m3 }) : this.negative === 0 && f4.negative !== 0 ? (x3 = this.divmod(f4.neg(), a3), a3 !== "mod" && (d3 = x3.div.neg()), { div: d3, mod: x3.mod }) : this.negative & f4.negative ? (x3 = this.neg().divmod(f4.neg(), a3), a3 !== "div" && (m3 = x3.mod.neg(), c4 && m3.negative !== 0 && m3.isub(f4)), { div: x3.div, mod: m3 }) : f4.length > this.length || this.cmp(f4) < 0 ? { div: new o2(0), mod: this } : f4.length === 1 ? a3 === "div" ? { div: this.divn(f4.words[0]), mod: null } : a3 === "mod" ? { div: null, mod: new o2(this.modrn(f4.words[0])) } : { div: this.divn(f4.words[0]), mod: new o2(this.modrn(f4.words[0])) } : this._wordDiv(f4, a3);
        }, o2.prototype.div = function(f4) {
          return this.divmod(f4, "div", false).div;
        }, o2.prototype.mod = function(f4) {
          return this.divmod(f4, "mod", false).mod;
        }, o2.prototype.umod = function(f4) {
          return this.divmod(f4, "mod", true).mod;
        }, o2.prototype.divRound = function(f4) {
          var a3 = this.divmod(f4);
          if (a3.mod.isZero())
            return a3.div;
          var c4 = a3.div.negative !== 0 ? a3.mod.isub(f4) : a3.mod, d3 = f4.ushrn(1), m3 = f4.andln(1), x3 = c4.cmp(d3);
          return x3 < 0 || m3 === 1 && x3 === 0 ? a3.div : a3.div.negative !== 0 ? a3.div.isubn(1) : a3.div.iaddn(1);
        }, o2.prototype.modrn = function(f4) {
          var a3 = f4 < 0;
          a3 && (f4 = -f4), i2(f4 <= 67108863);
          for (var c4 = (1 << 26) % f4, d3 = 0, m3 = this.length - 1; m3 >= 0; m3--)
            d3 = (c4 * d3 + (this.words[m3] | 0)) % f4;
          return a3 ? -d3 : d3;
        }, o2.prototype.modn = function(f4) {
          return this.modrn(f4);
        }, o2.prototype.idivn = function(f4) {
          var a3 = f4 < 0;
          a3 && (f4 = -f4), i2(f4 <= 67108863);
          for (var c4 = 0, d3 = this.length - 1; d3 >= 0; d3--) {
            var m3 = (this.words[d3] | 0) + c4 * 67108864;
            this.words[d3] = m3 / f4 | 0, c4 = m3 % f4;
          }
          return this._strip(), a3 ? this.ineg() : this;
        }, o2.prototype.divn = function(f4) {
          return this.clone().idivn(f4);
        }, o2.prototype.egcd = function(f4) {
          i2(f4.negative === 0), i2(!f4.isZero());
          var a3 = this, c4 = f4.clone();
          a3.negative !== 0 ? a3 = a3.umod(f4) : a3 = a3.clone();
          for (var d3 = new o2(1), m3 = new o2(0), x3 = new o2(0), M = new o2(1), l4 = 0; a3.isEven() && c4.isEven(); )
            a3.iushrn(1), c4.iushrn(1), ++l4;
          for (var s2 = c4.clone(), v2 = a3.clone(); !a3.isZero(); ) {
            for (var k4 = 0, u3 = 1; !(a3.words[0] & u3) && k4 < 26; ++k4, u3 <<= 1)
              ;
            if (k4 > 0)
              for (a3.iushrn(k4); k4-- > 0; )
                (d3.isOdd() || m3.isOdd()) && (d3.iadd(s2), m3.isub(v2)), d3.iushrn(1), m3.iushrn(1);
            for (var E4 = 0, _4 = 1; !(c4.words[0] & _4) && E4 < 26; ++E4, _4 <<= 1)
              ;
            if (E4 > 0)
              for (c4.iushrn(E4); E4-- > 0; )
                (x3.isOdd() || M.isOdd()) && (x3.iadd(s2), M.isub(v2)), x3.iushrn(1), M.iushrn(1);
            a3.cmp(c4) >= 0 ? (a3.isub(c4), d3.isub(x3), m3.isub(M)) : (c4.isub(a3), x3.isub(d3), M.isub(m3));
          }
          return { a: x3, b: M, gcd: c4.iushln(l4) };
        }, o2.prototype._invmp = function(f4) {
          i2(f4.negative === 0), i2(!f4.isZero());
          var a3 = this, c4 = f4.clone();
          a3.negative !== 0 ? a3 = a3.umod(f4) : a3 = a3.clone();
          for (var d3 = new o2(1), m3 = new o2(0), x3 = c4.clone(); a3.cmpn(1) > 0 && c4.cmpn(1) > 0; ) {
            for (var M = 0, l4 = 1; !(a3.words[0] & l4) && M < 26; ++M, l4 <<= 1)
              ;
            if (M > 0)
              for (a3.iushrn(M); M-- > 0; )
                d3.isOdd() && d3.iadd(x3), d3.iushrn(1);
            for (var s2 = 0, v2 = 1; !(c4.words[0] & v2) && s2 < 26; ++s2, v2 <<= 1)
              ;
            if (s2 > 0)
              for (c4.iushrn(s2); s2-- > 0; )
                m3.isOdd() && m3.iadd(x3), m3.iushrn(1);
            a3.cmp(c4) >= 0 ? (a3.isub(c4), d3.isub(m3)) : (c4.isub(a3), m3.isub(d3));
          }
          var k4;
          return a3.cmpn(1) === 0 ? k4 = d3 : k4 = m3, k4.cmpn(0) < 0 && k4.iadd(f4), k4;
        }, o2.prototype.gcd = function(f4) {
          if (this.isZero())
            return f4.abs();
          if (f4.isZero())
            return this.abs();
          var a3 = this.clone(), c4 = f4.clone();
          a3.negative = 0, c4.negative = 0;
          for (var d3 = 0; a3.isEven() && c4.isEven(); d3++)
            a3.iushrn(1), c4.iushrn(1);
          do {
            for (; a3.isEven(); )
              a3.iushrn(1);
            for (; c4.isEven(); )
              c4.iushrn(1);
            var m3 = a3.cmp(c4);
            if (m3 < 0) {
              var x3 = a3;
              a3 = c4, c4 = x3;
            } else if (m3 === 0 || c4.cmpn(1) === 0)
              break;
            a3.isub(c4);
          } while (true);
          return c4.iushln(d3);
        }, o2.prototype.invm = function(f4) {
          return this.egcd(f4).a.umod(f4);
        }, o2.prototype.isEven = function() {
          return (this.words[0] & 1) === 0;
        }, o2.prototype.isOdd = function() {
          return (this.words[0] & 1) === 1;
        }, o2.prototype.andln = function(f4) {
          return this.words[0] & f4;
        }, o2.prototype.bincn = function(f4) {
          i2(typeof f4 == "number");
          var a3 = f4 % 26, c4 = (f4 - a3) / 26, d3 = 1 << a3;
          if (this.length <= c4)
            return this._expand(c4 + 1), this.words[c4] |= d3, this;
          for (var m3 = d3, x3 = c4; m3 !== 0 && x3 < this.length; x3++) {
            var M = this.words[x3] | 0;
            M += m3, m3 = M >>> 26, M &= 67108863, this.words[x3] = M;
          }
          return m3 !== 0 && (this.words[x3] = m3, this.length++), this;
        }, o2.prototype.isZero = function() {
          return this.length === 1 && this.words[0] === 0;
        }, o2.prototype.cmpn = function(f4) {
          var a3 = f4 < 0;
          if (this.negative !== 0 && !a3)
            return -1;
          if (this.negative === 0 && a3)
            return 1;
          this._strip();
          var c4;
          if (this.length > 1)
            c4 = 1;
          else {
            a3 && (f4 = -f4), i2(f4 <= 67108863, "Number is too big");
            var d3 = this.words[0] | 0;
            c4 = d3 === f4 ? 0 : d3 < f4 ? -1 : 1;
          }
          return this.negative !== 0 ? -c4 | 0 : c4;
        }, o2.prototype.cmp = function(f4) {
          if (this.negative !== 0 && f4.negative === 0)
            return -1;
          if (this.negative === 0 && f4.negative !== 0)
            return 1;
          var a3 = this.ucmp(f4);
          return this.negative !== 0 ? -a3 | 0 : a3;
        }, o2.prototype.ucmp = function(f4) {
          if (this.length > f4.length)
            return 1;
          if (this.length < f4.length)
            return -1;
          for (var a3 = 0, c4 = this.length - 1; c4 >= 0; c4--) {
            var d3 = this.words[c4] | 0, m3 = f4.words[c4] | 0;
            if (d3 !== m3) {
              d3 < m3 ? a3 = -1 : d3 > m3 && (a3 = 1);
              break;
            }
          }
          return a3;
        }, o2.prototype.gtn = function(f4) {
          return this.cmpn(f4) === 1;
        }, o2.prototype.gt = function(f4) {
          return this.cmp(f4) === 1;
        }, o2.prototype.gten = function(f4) {
          return this.cmpn(f4) >= 0;
        }, o2.prototype.gte = function(f4) {
          return this.cmp(f4) >= 0;
        }, o2.prototype.ltn = function(f4) {
          return this.cmpn(f4) === -1;
        }, o2.prototype.lt = function(f4) {
          return this.cmp(f4) === -1;
        }, o2.prototype.lten = function(f4) {
          return this.cmpn(f4) <= 0;
        }, o2.prototype.lte = function(f4) {
          return this.cmp(f4) <= 0;
        }, o2.prototype.eqn = function(f4) {
          return this.cmpn(f4) === 0;
        }, o2.prototype.eq = function(f4) {
          return this.cmp(f4) === 0;
        }, o2.red = function(f4) {
          return new Y(f4);
        }, o2.prototype.toRed = function(f4) {
          return i2(!this.red, "Already a number in reduction context"), i2(this.negative === 0, "red works only with positives"), f4.convertTo(this)._forceRed(f4);
        }, o2.prototype.fromRed = function() {
          return i2(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
        }, o2.prototype._forceRed = function(f4) {
          return this.red = f4, this;
        }, o2.prototype.forceRed = function(f4) {
          return i2(!this.red, "Already a number in reduction context"), this._forceRed(f4);
        }, o2.prototype.redAdd = function(f4) {
          return i2(this.red, "redAdd works only with red numbers"), this.red.add(this, f4);
        }, o2.prototype.redIAdd = function(f4) {
          return i2(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, f4);
        }, o2.prototype.redSub = function(f4) {
          return i2(this.red, "redSub works only with red numbers"), this.red.sub(this, f4);
        }, o2.prototype.redISub = function(f4) {
          return i2(this.red, "redISub works only with red numbers"), this.red.isub(this, f4);
        }, o2.prototype.redShl = function(f4) {
          return i2(this.red, "redShl works only with red numbers"), this.red.shl(this, f4);
        }, o2.prototype.redMul = function(f4) {
          return i2(this.red, "redMul works only with red numbers"), this.red._verify2(this, f4), this.red.mul(this, f4);
        }, o2.prototype.redIMul = function(f4) {
          return i2(this.red, "redMul works only with red numbers"), this.red._verify2(this, f4), this.red.imul(this, f4);
        }, o2.prototype.redSqr = function() {
          return i2(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
        }, o2.prototype.redISqr = function() {
          return i2(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
        }, o2.prototype.redSqrt = function() {
          return i2(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
        }, o2.prototype.redInvm = function() {
          return i2(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
        }, o2.prototype.redNeg = function() {
          return i2(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
        }, o2.prototype.redPow = function(f4) {
          return i2(this.red && !f4.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, f4);
        };
        var H = { k256: null, p224: null, p192: null, p25519: null };
        function L2(A2, f4) {
          this.name = A2, this.p = new o2(f4, 16), this.n = this.p.bitLength(), this.k = new o2(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
        }
        L2.prototype._tmp = function() {
          var f4 = new o2(null);
          return f4.words = new Array(Math.ceil(this.n / 13)), f4;
        }, L2.prototype.ireduce = function(f4) {
          var a3 = f4, c4;
          do
            this.split(a3, this.tmp), a3 = this.imulK(a3), a3 = a3.iadd(this.tmp), c4 = a3.bitLength();
          while (c4 > this.n);
          var d3 = c4 < this.n ? -1 : a3.ucmp(this.p);
          return d3 === 0 ? (a3.words[0] = 0, a3.length = 1) : d3 > 0 ? a3.isub(this.p) : a3.strip !== void 0 ? a3.strip() : a3._strip(), a3;
        }, L2.prototype.split = function(f4, a3) {
          f4.iushrn(this.n, 0, a3);
        }, L2.prototype.imulK = function(f4) {
          return f4.imul(this.k);
        };
        function Tt() {
          L2.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
        }
        n3(Tt, L2), Tt.prototype.split = function(f4, a3) {
          for (var c4 = 4194303, d3 = Math.min(f4.length, 9), m3 = 0; m3 < d3; m3++)
            a3.words[m3] = f4.words[m3];
          if (a3.length = d3, f4.length <= 9) {
            f4.words[0] = 0, f4.length = 1;
            return;
          }
          var x3 = f4.words[9];
          for (a3.words[a3.length++] = x3 & c4, m3 = 10; m3 < f4.length; m3++) {
            var M = f4.words[m3] | 0;
            f4.words[m3 - 10] = (M & c4) << 4 | x3 >>> 22, x3 = M;
          }
          x3 >>>= 22, f4.words[m3 - 10] = x3, x3 === 0 && f4.length > 10 ? f4.length -= 10 : f4.length -= 9;
        }, Tt.prototype.imulK = function(f4) {
          f4.words[f4.length] = 0, f4.words[f4.length + 1] = 0, f4.length += 2;
          for (var a3 = 0, c4 = 0; c4 < f4.length; c4++) {
            var d3 = f4.words[c4] | 0;
            a3 += d3 * 977, f4.words[c4] = a3 & 67108863, a3 = d3 * 64 + (a3 / 67108864 | 0);
          }
          return f4.words[f4.length - 1] === 0 && (f4.length--, f4.words[f4.length - 1] === 0 && f4.length--), f4;
        };
        function W() {
          L2.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
        }
        n3(W, L2);
        function Ot() {
          L2.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
        }
        n3(Ot, L2);
        function Gt() {
          L2.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
        }
        n3(Gt, L2), Gt.prototype.imulK = function(f4) {
          for (var a3 = 0, c4 = 0; c4 < f4.length; c4++) {
            var d3 = (f4.words[c4] | 0) * 19 + a3, m3 = d3 & 67108863;
            d3 >>>= 26, f4.words[c4] = m3, a3 = d3;
          }
          return a3 !== 0 && (f4.words[f4.length++] = a3), f4;
        }, o2._prime = function(f4) {
          if (H[f4])
            return H[f4];
          var a3;
          if (f4 === "k256")
            a3 = new Tt();
          else if (f4 === "p224")
            a3 = new W();
          else if (f4 === "p192")
            a3 = new Ot();
          else if (f4 === "p25519")
            a3 = new Gt();
          else
            throw new Error("Unknown prime " + f4);
          return H[f4] = a3, a3;
        };
        function Y(A2) {
          if (typeof A2 == "string") {
            var f4 = o2._prime(A2);
            this.m = f4.p, this.prime = f4;
          } else
            i2(A2.gtn(1), "modulus must be greater than 1"), this.m = A2, this.prime = null;
        }
        Y.prototype._verify1 = function(f4) {
          i2(f4.negative === 0, "red works only with positives"), i2(f4.red, "red works only with red numbers");
        }, Y.prototype._verify2 = function(f4, a3) {
          i2((f4.negative | a3.negative) === 0, "red works only with positives"), i2(f4.red && f4.red === a3.red, "red works only with red numbers");
        }, Y.prototype.imod = function(f4) {
          return this.prime ? this.prime.ireduce(f4)._forceRed(this) : (w4(f4, f4.umod(this.m)._forceRed(this)), f4);
        }, Y.prototype.neg = function(f4) {
          return f4.isZero() ? f4.clone() : this.m.sub(f4)._forceRed(this);
        }, Y.prototype.add = function(f4, a3) {
          this._verify2(f4, a3);
          var c4 = f4.add(a3);
          return c4.cmp(this.m) >= 0 && c4.isub(this.m), c4._forceRed(this);
        }, Y.prototype.iadd = function(f4, a3) {
          this._verify2(f4, a3);
          var c4 = f4.iadd(a3);
          return c4.cmp(this.m) >= 0 && c4.isub(this.m), c4;
        }, Y.prototype.sub = function(f4, a3) {
          this._verify2(f4, a3);
          var c4 = f4.sub(a3);
          return c4.cmpn(0) < 0 && c4.iadd(this.m), c4._forceRed(this);
        }, Y.prototype.isub = function(f4, a3) {
          this._verify2(f4, a3);
          var c4 = f4.isub(a3);
          return c4.cmpn(0) < 0 && c4.iadd(this.m), c4;
        }, Y.prototype.shl = function(f4, a3) {
          return this._verify1(f4), this.imod(f4.ushln(a3));
        }, Y.prototype.imul = function(f4, a3) {
          return this._verify2(f4, a3), this.imod(f4.imul(a3));
        }, Y.prototype.mul = function(f4, a3) {
          return this._verify2(f4, a3), this.imod(f4.mul(a3));
        }, Y.prototype.isqr = function(f4) {
          return this.imul(f4, f4.clone());
        }, Y.prototype.sqr = function(f4) {
          return this.mul(f4, f4);
        }, Y.prototype.sqrt = function(f4) {
          if (f4.isZero())
            return f4.clone();
          var a3 = this.m.andln(3);
          if (i2(a3 % 2 === 1), a3 === 3) {
            var c4 = this.m.add(new o2(1)).iushrn(2);
            return this.pow(f4, c4);
          }
          for (var d3 = this.m.subn(1), m3 = 0; !d3.isZero() && d3.andln(1) === 0; )
            m3++, d3.iushrn(1);
          i2(!d3.isZero());
          var x3 = new o2(1).toRed(this), M = x3.redNeg(), l4 = this.m.subn(1).iushrn(1), s2 = this.m.bitLength();
          for (s2 = new o2(2 * s2 * s2).toRed(this); this.pow(s2, l4).cmp(M) !== 0; )
            s2.redIAdd(M);
          for (var v2 = this.pow(s2, d3), k4 = this.pow(f4, d3.addn(1).iushrn(1)), u3 = this.pow(f4, d3), E4 = m3; u3.cmp(x3) !== 0; ) {
            for (var _4 = u3, B2 = 0; _4.cmp(x3) !== 0; B2++)
              _4 = _4.redSqr();
            i2(B2 < E4);
            var C3 = this.pow(v2, new o2(1).iushln(E4 - B2 - 1));
            k4 = k4.redMul(C3), v2 = C3.redSqr(), u3 = u3.redMul(v2), E4 = B2;
          }
          return k4;
        }, Y.prototype.invm = function(f4) {
          var a3 = f4._invmp(this.m);
          return a3.negative !== 0 ? (a3.negative = 0, this.imod(a3).redNeg()) : this.imod(a3);
        }, Y.prototype.pow = function(f4, a3) {
          if (a3.isZero())
            return new o2(1).toRed(this);
          if (a3.cmpn(1) === 0)
            return f4.clone();
          var c4 = 4, d3 = new Array(1 << c4);
          d3[0] = new o2(1).toRed(this), d3[1] = f4;
          for (var m3 = 2; m3 < d3.length; m3++)
            d3[m3] = this.mul(d3[m3 - 1], f4);
          var x3 = d3[0], M = 0, l4 = 0, s2 = a3.bitLength() % 26;
          for (s2 === 0 && (s2 = 26), m3 = a3.length - 1; m3 >= 0; m3--) {
            for (var v2 = a3.words[m3], k4 = s2 - 1; k4 >= 0; k4--) {
              var u3 = v2 >> k4 & 1;
              if (x3 !== d3[0] && (x3 = this.sqr(x3)), u3 === 0 && M === 0) {
                l4 = 0;
                continue;
              }
              M <<= 1, M |= u3, l4++, !(l4 !== c4 && (m3 !== 0 || k4 !== 0)) && (x3 = this.mul(x3, d3[M]), l4 = 0, M = 0);
            }
            s2 = 26;
          }
          return x3;
        }, Y.prototype.convertTo = function(f4) {
          var a3 = f4.umod(this.m);
          return a3 === f4 ? a3.clone() : a3;
        }, Y.prototype.convertFrom = function(f4) {
          var a3 = f4.clone();
          return a3.red = null, a3;
        }, o2.mont = function(f4) {
          return new Wt(f4);
        };
        function Wt(A2) {
          Y.call(this, A2), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new o2(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
        }
        n3(Wt, Y), Wt.prototype.convertTo = function(f4) {
          return this.imod(f4.ushln(this.shift));
        }, Wt.prototype.convertFrom = function(f4) {
          var a3 = this.imod(f4.mul(this.rinv));
          return a3.red = null, a3;
        }, Wt.prototype.imul = function(f4, a3) {
          if (f4.isZero() || a3.isZero())
            return f4.words[0] = 0, f4.length = 1, f4;
          var c4 = f4.imul(a3), d3 = c4.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), m3 = c4.isub(d3).iushrn(this.shift), x3 = m3;
          return m3.cmp(this.m) >= 0 ? x3 = m3.isub(this.m) : m3.cmpn(0) < 0 && (x3 = m3.iadd(this.m)), x3._forceRed(this);
        }, Wt.prototype.mul = function(f4, a3) {
          if (f4.isZero() || a3.isZero())
            return new o2(0)._forceRed(this);
          var c4 = f4.mul(a3), d3 = c4.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), m3 = c4.isub(d3).iushrn(this.shift), x3 = m3;
          return m3.cmp(this.m) >= 0 ? x3 = m3.isub(this.m) : m3.cmpn(0) < 0 && (x3 = m3.iadd(this.m)), x3._forceRed(this);
        }, Wt.prototype.invm = function(f4) {
          var a3 = this.imod(f4._invmp(this.m).mul(this.r2));
          return a3._forceRed(this);
        };
      })(e2, _n);
    })(qn);
    var K2 = qn.exports;
    var Kn = "bignumber/5.7.0";
    var Or = K2.BN;
    var me = new z3(Kn);
    var xi = {};
    var Hn = 9007199254740991;
    function Ns(e2) {
      return e2 != null && (G.isBigNumber(e2) || typeof e2 == "number" && e2 % 1 === 0 || typeof e2 == "string" && !!e2.match(/^-?[0-9]+$/) || Qt(e2) || typeof e2 == "bigint" || nr(e2));
    }
    var Ln = false;
    var G = class _G {
      constructor(t, r) {
        t !== xi && me.throwError("cannot call constructor directly; use BigNumber.from", z3.errors.UNSUPPORTED_OPERATION, { operation: "new (BigNumber)" }), this._hex = r, this._isBigNumber = true, Object.freeze(this);
      }
      fromTwos(t) {
        return jt(j2(this).fromTwos(t));
      }
      toTwos(t) {
        return jt(j2(this).toTwos(t));
      }
      abs() {
        return this._hex[0] === "-" ? _G.from(this._hex.substring(1)) : this;
      }
      add(t) {
        return jt(j2(this).add(j2(t)));
      }
      sub(t) {
        return jt(j2(this).sub(j2(t)));
      }
      div(t) {
        return _G.from(t).isZero() && Xt("division-by-zero", "div"), jt(j2(this).div(j2(t)));
      }
      mul(t) {
        return jt(j2(this).mul(j2(t)));
      }
      mod(t) {
        const r = j2(t);
        return r.isNeg() && Xt("division-by-zero", "mod"), jt(j2(this).umod(r));
      }
      pow(t) {
        const r = j2(t);
        return r.isNeg() && Xt("negative-power", "pow"), jt(j2(this).pow(r));
      }
      and(t) {
        const r = j2(t);
        return (this.isNegative() || r.isNeg()) && Xt("unbound-bitwise-result", "and"), jt(j2(this).and(r));
      }
      or(t) {
        const r = j2(t);
        return (this.isNegative() || r.isNeg()) && Xt("unbound-bitwise-result", "or"), jt(j2(this).or(r));
      }
      xor(t) {
        const r = j2(t);
        return (this.isNegative() || r.isNeg()) && Xt("unbound-bitwise-result", "xor"), jt(j2(this).xor(r));
      }
      mask(t) {
        return (this.isNegative() || t < 0) && Xt("negative-width", "mask"), jt(j2(this).maskn(t));
      }
      shl(t) {
        return (this.isNegative() || t < 0) && Xt("negative-width", "shl"), jt(j2(this).shln(t));
      }
      shr(t) {
        return (this.isNegative() || t < 0) && Xt("negative-width", "shr"), jt(j2(this).shrn(t));
      }
      eq(t) {
        return j2(this).eq(j2(t));
      }
      lt(t) {
        return j2(this).lt(j2(t));
      }
      lte(t) {
        return j2(this).lte(j2(t));
      }
      gt(t) {
        return j2(this).gt(j2(t));
      }
      gte(t) {
        return j2(this).gte(j2(t));
      }
      isNegative() {
        return this._hex[0] === "-";
      }
      isZero() {
        return j2(this).isZero();
      }
      toNumber() {
        try {
          return j2(this).toNumber();
        } catch {
          Xt("overflow", "toNumber", this.toString());
        }
        return null;
      }
      toBigInt() {
        try {
          return BigInt(this.toString());
        } catch {
        }
        return me.throwError("this platform does not support BigInt", z3.errors.UNSUPPORTED_OPERATION, { value: this.toString() });
      }
      toString() {
        return arguments.length > 0 && (arguments[0] === 10 ? Ln || (Ln = true, me.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : arguments[0] === 16 ? me.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", z3.errors.UNEXPECTED_ARGUMENT, {}) : me.throwError("BigNumber.toString does not accept parameters", z3.errors.UNEXPECTED_ARGUMENT, {})), j2(this).toString(10);
      }
      toHexString() {
        return this._hex;
      }
      toJSON(t) {
        return { type: "BigNumber", hex: this.toHexString() };
      }
      static from(t) {
        if (t instanceof _G)
          return t;
        if (typeof t == "string")
          return t.match(/^-?0x[0-9a-f]+$/i) ? new _G(xi, gr(t)) : t.match(/^-?[0-9]+$/) ? new _G(xi, gr(new Or(t))) : me.throwArgumentError("invalid BigNumber string", "value", t);
        if (typeof t == "number")
          return t % 1 && Xt("underflow", "BigNumber.from", t), (t >= Hn || t <= -Hn) && Xt("overflow", "BigNumber.from", t), _G.from(String(t));
        const r = t;
        if (typeof r == "bigint")
          return _G.from(r.toString());
        if (nr(r))
          return _G.from(Ht(r));
        if (r)
          if (r.toHexString) {
            const i2 = r.toHexString();
            if (typeof i2 == "string")
              return _G.from(i2);
          } else {
            let i2 = r._hex;
            if (i2 == null && r.type === "BigNumber" && (i2 = r.hex), typeof i2 == "string" && (Qt(i2) || i2[0] === "-" && Qt(i2.substring(1))))
              return _G.from(i2);
          }
        return me.throwArgumentError("invalid BigNumber value", "value", t);
      }
      static isBigNumber(t) {
        return !!(t && t._isBigNumber);
      }
    };
    function gr(e2) {
      if (typeof e2 != "string")
        return gr(e2.toString(16));
      if (e2[0] === "-")
        return e2 = e2.substring(1), e2[0] === "-" && me.throwArgumentError("invalid hex", "value", e2), e2 = gr(e2), e2 === "0x00" ? e2 : "-" + e2;
      if (e2.substring(0, 2) !== "0x" && (e2 = "0x" + e2), e2 === "0x")
        return "0x00";
      for (e2.length % 2 && (e2 = "0x0" + e2.substring(2)); e2.length > 4 && e2.substring(0, 4) === "0x00"; )
        e2 = "0x" + e2.substring(4);
      return e2;
    }
    function jt(e2) {
      return G.from(gr(e2));
    }
    function j2(e2) {
      const t = G.from(e2).toHexString();
      return t[0] === "-" ? new Or("-" + t.substring(3), 16) : new Or(t.substring(2), 16);
    }
    function Xt(e2, t, r) {
      const i2 = { fault: e2, operation: t };
      return r != null && (i2.value = r), me.throwError(e2, z3.errors.NUMERIC_FAULT, i2);
    }
    function Is(e2) {
      return new Or(e2, 36).toString(16);
    }
    var Lt = new z3(Kn);
    var mr = {};
    var zn = G.from(0);
    var jn = G.from(-1);
    function Vn(e2, t, r, i2) {
      const n3 = { fault: t, operation: r };
      return i2 !== void 0 && (n3.value = i2), Lt.throwError(e2, z3.errors.NUMERIC_FAULT, n3);
    }
    var Ar = "0";
    for (; Ar.length < 256; )
      Ar += Ar;
    function Mi(e2) {
      if (typeof e2 != "number")
        try {
          e2 = G.from(e2).toNumber();
        } catch {
        }
      return typeof e2 == "number" && e2 >= 0 && e2 <= 256 && !(e2 % 1) ? "1" + Ar.substring(0, e2) : Lt.throwArgumentError("invalid decimal size", "decimals", e2);
    }
    function Ei(e2, t) {
      t == null && (t = 0);
      const r = Mi(t);
      e2 = G.from(e2);
      const i2 = e2.lt(zn);
      i2 && (e2 = e2.mul(jn));
      let n3 = e2.mod(r).toString();
      for (; n3.length < r.length - 1; )
        n3 = "0" + n3;
      n3 = n3.match(/^([0-9]*[1-9]|0)(0*)/)[1];
      const o2 = e2.div(r).toString();
      return r.length === 1 ? e2 = o2 : e2 = o2 + "." + n3, i2 && (e2 = "-" + e2), e2;
    }
    function Ae(e2, t) {
      t == null && (t = 0);
      const r = Mi(t);
      (typeof e2 != "string" || !e2.match(/^-?[0-9.]+$/)) && Lt.throwArgumentError("invalid decimal value", "value", e2);
      const i2 = e2.substring(0, 1) === "-";
      i2 && (e2 = e2.substring(1)), e2 === "." && Lt.throwArgumentError("missing value", "value", e2);
      const n3 = e2.split(".");
      n3.length > 2 && Lt.throwArgumentError("too many decimal points", "value", e2);
      let o2 = n3[0], h5 = n3[1];
      for (o2 || (o2 = "0"), h5 || (h5 = "0"); h5[h5.length - 1] === "0"; )
        h5 = h5.substring(0, h5.length - 1);
      for (h5.length > r.length - 1 && Vn("fractional component exceeds decimals", "underflow", "parseFixed"), h5 === "" && (h5 = "0"); h5.length < r.length - 1; )
        h5 += "0";
      const p3 = G.from(o2), b4 = G.from(h5);
      let g3 = p3.mul(r).add(b4);
      return i2 && (g3 = g3.mul(jn)), g3;
    }
    var pr = class _pr {
      constructor(t, r, i2, n3) {
        t !== mr && Lt.throwError("cannot use FixedFormat constructor; use FixedFormat.from", z3.errors.UNSUPPORTED_OPERATION, { operation: "new FixedFormat" }), this.signed = r, this.width = i2, this.decimals = n3, this.name = (r ? "" : "u") + "fixed" + String(i2) + "x" + String(n3), this._multiplier = Mi(n3), Object.freeze(this);
      }
      static from(t) {
        if (t instanceof _pr)
          return t;
        typeof t == "number" && (t = `fixed128x${t}`);
        let r = true, i2 = 128, n3 = 18;
        if (typeof t == "string") {
          if (t !== "fixed")
            if (t === "ufixed")
              r = false;
            else {
              const o2 = t.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
              o2 || Lt.throwArgumentError("invalid fixed format", "format", t), r = o2[1] !== "u", i2 = parseInt(o2[2]), n3 = parseInt(o2[3]);
            }
        } else if (t) {
          const o2 = (h5, p3, b4) => t[h5] == null ? b4 : (typeof t[h5] !== p3 && Lt.throwArgumentError("invalid fixed format (" + h5 + " not " + p3 + ")", "format." + h5, t[h5]), t[h5]);
          r = o2("signed", "boolean", r), i2 = o2("width", "number", i2), n3 = o2("decimals", "number", n3);
        }
        return i2 % 8 && Lt.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", i2), n3 > 80 && Lt.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", n3), new _pr(mr, r, i2, n3);
      }
    };
    var kt = class _kt {
      constructor(t, r, i2, n3) {
        t !== mr && Lt.throwError("cannot use FixedNumber constructor; use FixedNumber.from", z3.errors.UNSUPPORTED_OPERATION, { operation: "new FixedFormat" }), this.format = n3, this._hex = r, this._value = i2, this._isFixedNumber = true, Object.freeze(this);
      }
      _checkFormat(t) {
        this.format.name !== t.format.name && Lt.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", t);
      }
      addUnsafe(t) {
        this._checkFormat(t);
        const r = Ae(this._value, this.format.decimals), i2 = Ae(t._value, t.format.decimals);
        return _kt.fromValue(r.add(i2), this.format.decimals, this.format);
      }
      subUnsafe(t) {
        this._checkFormat(t);
        const r = Ae(this._value, this.format.decimals), i2 = Ae(t._value, t.format.decimals);
        return _kt.fromValue(r.sub(i2), this.format.decimals, this.format);
      }
      mulUnsafe(t) {
        this._checkFormat(t);
        const r = Ae(this._value, this.format.decimals), i2 = Ae(t._value, t.format.decimals);
        return _kt.fromValue(r.mul(i2).div(this.format._multiplier), this.format.decimals, this.format);
      }
      divUnsafe(t) {
        this._checkFormat(t);
        const r = Ae(this._value, this.format.decimals), i2 = Ae(t._value, t.format.decimals);
        return _kt.fromValue(r.mul(this.format._multiplier).div(i2), this.format.decimals, this.format);
      }
      floor() {
        const t = this.toString().split(".");
        t.length === 1 && t.push("0");
        let r = _kt.from(t[0], this.format);
        const i2 = !t[1].match(/^(0*)$/);
        return this.isNegative() && i2 && (r = r.subUnsafe(Qn.toFormat(r.format))), r;
      }
      ceiling() {
        const t = this.toString().split(".");
        t.length === 1 && t.push("0");
        let r = _kt.from(t[0], this.format);
        const i2 = !t[1].match(/^(0*)$/);
        return !this.isNegative() && i2 && (r = r.addUnsafe(Qn.toFormat(r.format))), r;
      }
      round(t) {
        t == null && (t = 0);
        const r = this.toString().split(".");
        if (r.length === 1 && r.push("0"), (t < 0 || t > 80 || t % 1) && Lt.throwArgumentError("invalid decimal count", "decimals", t), r[1].length <= t)
          return this;
        const i2 = _kt.from("1" + Ar.substring(0, t), this.format), n3 = _s.toFormat(this.format);
        return this.mulUnsafe(i2).addUnsafe(n3).floor().divUnsafe(i2);
      }
      isZero() {
        return this._value === "0.0" || this._value === "0";
      }
      isNegative() {
        return this._value[0] === "-";
      }
      toString() {
        return this._value;
      }
      toHexString(t) {
        if (t == null)
          return this._hex;
        t % 8 && Lt.throwArgumentError("invalid byte width", "width", t);
        const r = G.from(this._hex).fromTwos(this.format.width).toTwos(t).toHexString();
        return fe(r, t / 8);
      }
      toUnsafeFloat() {
        return parseFloat(this.toString());
      }
      toFormat(t) {
        return _kt.fromString(this._value, t);
      }
      static fromValue(t, r, i2) {
        return i2 == null && r != null && !Ns(r) && (i2 = r, r = null), r == null && (r = 0), i2 == null && (i2 = "fixed"), _kt.fromString(Ei(t, r), pr.from(i2));
      }
      static fromString(t, r) {
        r == null && (r = "fixed");
        const i2 = pr.from(r), n3 = Ae(t, i2.decimals);
        !i2.signed && n3.lt(zn) && Vn("unsigned value cannot be negative", "overflow", "value", t);
        let o2 = null;
        i2.signed ? o2 = n3.toTwos(i2.width).toHexString() : (o2 = n3.toHexString(), o2 = fe(o2, i2.width / 8));
        const h5 = Ei(n3, i2.decimals);
        return new _kt(mr, o2, h5, i2);
      }
      static fromBytes(t, r) {
        r == null && (r = "fixed");
        const i2 = pr.from(r);
        if (Pt(t).length > i2.width / 8)
          throw new Error("overflow");
        let n3 = G.from(t);
        i2.signed && (n3 = n3.fromTwos(i2.width));
        const o2 = n3.toTwos((i2.signed ? 0 : 1) + i2.width).toHexString(), h5 = Ei(n3, i2.decimals);
        return new _kt(mr, o2, h5, i2);
      }
      static from(t, r) {
        if (typeof t == "string")
          return _kt.fromString(t, r);
        if (nr(t))
          return _kt.fromBytes(t, r);
        try {
          return _kt.fromValue(t, 0, r);
        } catch (i2) {
          if (i2.code !== z3.errors.INVALID_ARGUMENT)
            throw i2;
        }
        return Lt.throwArgumentError("invalid FixedNumber value", "value", t);
      }
      static isFixedNumber(t) {
        return !!(t && t._isFixedNumber);
      }
    };
    var Qn = kt.from(1);
    var _s = kt.from("0.5");
    var Bs = "strings/5.7.0";
    var Jn = new z3(Bs);
    var Pr;
    (function(e2) {
      e2.current = "", e2.NFC = "NFC", e2.NFD = "NFD", e2.NFKC = "NFKC", e2.NFKD = "NFKD";
    })(Pr || (Pr = {}));
    var fr;
    (function(e2) {
      e2.UNEXPECTED_CONTINUE = "unexpected continuation byte", e2.BAD_PREFIX = "bad codepoint prefix", e2.OVERRUN = "string overrun", e2.MISSING_CONTINUE = "missing continuation byte", e2.OUT_OF_RANGE = "out of UTF-8 range", e2.UTF16_SURROGATE = "UTF-16 surrogate", e2.OVERLONG = "overlong representation";
    })(fr || (fr = {}));
    function Rs(e2, t, r, i2, n3) {
      return Jn.throwArgumentError(`invalid codepoint at offset ${t}; ${e2}`, "bytes", r);
    }
    function Yn(e2, t, r, i2, n3) {
      if (e2 === fr.BAD_PREFIX || e2 === fr.UNEXPECTED_CONTINUE) {
        let o2 = 0;
        for (let h5 = t + 1; h5 < r.length && r[h5] >> 6 === 2; h5++)
          o2++;
        return o2;
      }
      return e2 === fr.OVERRUN ? r.length - t - 1 : 0;
    }
    function Cs(e2, t, r, i2, n3) {
      return e2 === fr.OVERLONG ? (i2.push(n3), 0) : (i2.push(65533), Yn(e2, t, r));
    }
    Object.freeze({ error: Rs, ignore: Yn, replace: Cs });
    function Si(e2, t = Pr.current) {
      t != Pr.current && (Jn.checkNormalize(), e2 = e2.normalize(t));
      let r = [];
      for (let i2 = 0; i2 < e2.length; i2++) {
        const n3 = e2.charCodeAt(i2);
        if (n3 < 128)
          r.push(n3);
        else if (n3 < 2048)
          r.push(n3 >> 6 | 192), r.push(n3 & 63 | 128);
        else if ((n3 & 64512) == 55296) {
          i2++;
          const o2 = e2.charCodeAt(i2);
          if (i2 >= e2.length || (o2 & 64512) !== 56320)
            throw new Error("invalid utf-8 string");
          const h5 = 65536 + ((n3 & 1023) << 10) + (o2 & 1023);
          r.push(h5 >> 18 | 240), r.push(h5 >> 12 & 63 | 128), r.push(h5 >> 6 & 63 | 128), r.push(h5 & 63 | 128);
        } else
          r.push(n3 >> 12 | 224), r.push(n3 >> 6 & 63 | 128), r.push(n3 & 63 | 128);
      }
      return Pt(r);
    }
    function Os(e2) {
      if (e2.length % 4 !== 0)
        throw new Error("bad data");
      let t = [];
      for (let r = 0; r < e2.length; r += 4)
        t.push(parseInt(e2.substring(r, r + 4), 16));
      return t;
    }
    function Ni(e2, t) {
      t || (t = function(n3) {
        return [parseInt(n3, 16)];
      });
      let r = 0, i2 = {};
      return e2.split(",").forEach((n3) => {
        let o2 = n3.split(":");
        r += parseInt(o2[0], 16), i2[r] = t(o2[1]);
      }), i2;
    }
    function Gn(e2) {
      let t = 0;
      return e2.split(",").map((r) => {
        let i2 = r.split("-");
        i2.length === 1 ? i2[1] = "0" : i2[1] === "" && (i2[1] = "1");
        let n3 = t + parseInt(i2[0], 16);
        return t = parseInt(i2[1], 16), { l: n3, h: t };
      });
    }
    Gn("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d"), "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((e2) => parseInt(e2, 16)), Ni("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3"), Ni("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7"), Ni("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", Os), Gn("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
    var Wn = "hash/5.7.0";
    function Ps(e2) {
      e2 = atob(e2);
      const t = [];
      for (let r = 0; r < e2.length; r++)
        t.push(e2.charCodeAt(r));
      return Pt(t);
    }
    function Xn(e2, t) {
      t == null && (t = 1);
      const r = [], i2 = r.forEach, n3 = function(o2, h5) {
        i2.call(o2, function(p3) {
          h5 > 0 && Array.isArray(p3) ? n3(p3, h5 - 1) : r.push(p3);
        });
      };
      return n3(e2, t), r;
    }
    function Ts(e2) {
      const t = {};
      for (let r = 0; r < e2.length; r++) {
        const i2 = e2[r];
        t[i2[0]] = i2[1];
      }
      return t;
    }
    function Fs(e2) {
      let t = 0;
      function r() {
        return e2[t++] << 8 | e2[t++];
      }
      let i2 = r(), n3 = 1, o2 = [0, 1];
      for (let H = 1; H < i2; H++)
        o2.push(n3 += r());
      let h5 = r(), p3 = t;
      t += h5;
      let b4 = 0, g3 = 0;
      function w4() {
        return b4 == 0 && (g3 = g3 << 8 | e2[t++], b4 = 8), g3 >> --b4 & 1;
      }
      const y4 = 31, S4 = Math.pow(2, y4), I2 = S4 >>> 1, N10 = I2 >> 1, R2 = S4 - 1;
      let F = 0;
      for (let H = 0; H < y4; H++)
        F = F << 1 | w4();
      let U2 = [], Q = 0, Bt = S4;
      for (; ; ) {
        let H = Math.floor(((F - Q + 1) * n3 - 1) / Bt), L2 = 0, Tt = i2;
        for (; Tt - L2 > 1; ) {
          let Gt = L2 + Tt >>> 1;
          H < o2[Gt] ? Tt = Gt : L2 = Gt;
        }
        if (L2 == 0)
          break;
        U2.push(L2);
        let W = Q + Math.floor(Bt * o2[L2] / n3), Ot = Q + Math.floor(Bt * o2[L2 + 1] / n3) - 1;
        for (; !((W ^ Ot) & I2); )
          F = F << 1 & R2 | w4(), W = W << 1 & R2, Ot = Ot << 1 & R2 | 1;
        for (; W & ~Ot & N10; )
          F = F & I2 | F << 1 & R2 >>> 1 | w4(), W = W << 1 ^ I2, Ot = (Ot ^ I2) << 1 | I2 | 1;
        Q = W, Bt = 1 + Ot - W;
      }
      let J = i2 - 4;
      return U2.map((H) => {
        switch (H - J) {
          case 3:
            return J + 65792 + (e2[p3++] << 16 | e2[p3++] << 8 | e2[p3++]);
          case 2:
            return J + 256 + (e2[p3++] << 8 | e2[p3++]);
          case 1:
            return J + e2[p3++];
          default:
            return H - 1;
        }
      });
    }
    function Ds(e2) {
      let t = 0;
      return () => e2[t++];
    }
    function Us(e2) {
      return Ds(Fs(e2));
    }
    function ks(e2) {
      return e2 & 1 ? ~e2 >> 1 : e2 >> 1;
    }
    function qs(e2, t) {
      let r = Array(e2);
      for (let i2 = 0; i2 < e2; i2++)
        r[i2] = 1 + t();
      return r;
    }
    function Zn(e2, t) {
      let r = Array(e2);
      for (let i2 = 0, n3 = -1; i2 < e2; i2++)
        r[i2] = n3 += 1 + t();
      return r;
    }
    function Ks(e2, t) {
      let r = Array(e2);
      for (let i2 = 0, n3 = 0; i2 < e2; i2++)
        r[i2] = n3 += ks(t());
      return r;
    }
    function Tr(e2, t) {
      let r = Zn(e2(), e2), i2 = e2(), n3 = Zn(i2, e2), o2 = qs(i2, e2);
      for (let h5 = 0; h5 < i2; h5++)
        for (let p3 = 0; p3 < o2[h5]; p3++)
          r.push(n3[h5] + p3);
      return t ? r.map((h5) => t[h5]) : r;
    }
    function Hs(e2) {
      let t = [];
      for (; ; ) {
        let r = e2();
        if (r == 0)
          break;
        t.push(zs(r, e2));
      }
      for (; ; ) {
        let r = e2() - 1;
        if (r < 0)
          break;
        t.push(js(r, e2));
      }
      return Ts(Xn(t));
    }
    function Ls(e2) {
      let t = [];
      for (; ; ) {
        let r = e2();
        if (r == 0)
          break;
        t.push(r);
      }
      return t;
    }
    function $n(e2, t, r) {
      let i2 = Array(e2).fill(void 0).map(() => []);
      for (let n3 = 0; n3 < t; n3++)
        Ks(e2, r).forEach((o2, h5) => i2[h5].push(o2));
      return i2;
    }
    function zs(e2, t) {
      let r = 1 + t(), i2 = t(), n3 = Ls(t), o2 = $n(n3.length, 1 + e2, t);
      return Xn(o2.map((h5, p3) => {
        const b4 = h5[0], g3 = h5.slice(1);
        return Array(n3[p3]).fill(void 0).map((w4, y4) => {
          let S4 = y4 * i2;
          return [b4 + y4 * r, g3.map((I2) => I2 + S4)];
        });
      }));
    }
    function js(e2, t) {
      let r = 1 + t();
      return $n(r, 1 + e2, t).map((n3) => [n3[0], n3.slice(1)]);
    }
    function Vs(e2) {
      let t = Tr(e2).sort((i2, n3) => i2 - n3);
      return r();
      function r() {
        let i2 = [];
        for (; ; ) {
          let g3 = Tr(e2, t);
          if (g3.length == 0)
            break;
          i2.push({ set: new Set(g3), node: r() });
        }
        i2.sort((g3, w4) => w4.set.size - g3.set.size);
        let n3 = e2(), o2 = n3 % 3;
        n3 = n3 / 3 | 0;
        let h5 = !!(n3 & 1);
        n3 >>= 1;
        let p3 = n3 == 1, b4 = n3 == 2;
        return { branches: i2, valid: o2, fe0f: h5, save: p3, check: b4 };
      }
    }
    function Qs() {
      return Us(Ps("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="));
    }
    var Fr = Qs();
    new Set(Tr(Fr)), new Set(Tr(Fr)), Hs(Fr), Vs(Fr), new z3(Wn);
    var Js = new Uint8Array(32);
    Js.fill(0);
    var Ys = `Ethereum Signed Message:
`;
    function tf(e2) {
      return typeof e2 == "string" && (e2 = Si(e2)), wi(ys([Si(Ys), Si(String(e2.length)), e2]));
    }
    var Gs = "rlp/5.7.0";
    new z3(Gs);
    var Ws = "address/5.7.0";
    var br = new z3(Ws);
    function ef(e2) {
      Qt(e2, 20) || br.throwArgumentError("invalid address", "address", e2), e2 = e2.toLowerCase();
      const t = e2.substring(2).split(""), r = new Uint8Array(40);
      for (let n3 = 0; n3 < 40; n3++)
        r[n3] = t[n3].charCodeAt(0);
      const i2 = Pt(wi(r));
      for (let n3 = 0; n3 < 40; n3 += 2)
        i2[n3 >> 1] >> 4 >= 8 && (t[n3] = t[n3].toUpperCase()), (i2[n3 >> 1] & 15) >= 8 && (t[n3 + 1] = t[n3 + 1].toUpperCase());
      return "0x" + t.join("");
    }
    var Xs = 9007199254740991;
    function Zs(e2) {
      return Math.log10 ? Math.log10(e2) : Math.log(e2) / Math.LN10;
    }
    var Ii = {};
    for (let e2 = 0; e2 < 10; e2++)
      Ii[String(e2)] = String(e2);
    for (let e2 = 0; e2 < 26; e2++)
      Ii[String.fromCharCode(65 + e2)] = String(10 + e2);
    var rf = Math.floor(Zs(Xs));
    function $s(e2) {
      e2 = e2.toUpperCase(), e2 = e2.substring(4) + e2.substring(0, 2) + "00";
      let t = e2.split("").map((i2) => Ii[i2]).join("");
      for (; t.length >= rf; ) {
        let i2 = t.substring(0, rf);
        t = parseInt(i2, 10) % 97 + t.substring(i2.length);
      }
      let r = String(98 - parseInt(t, 10) % 97);
      for (; r.length < 2; )
        r = "0" + r;
      return r;
    }
    function ta(e2) {
      let t = null;
      if (typeof e2 != "string" && br.throwArgumentError("invalid address", "address", e2), e2.match(/^(0x)?[0-9a-fA-F]{40}$/))
        e2.substring(0, 2) !== "0x" && (e2 = "0x" + e2), t = ef(e2), e2.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && t !== e2 && br.throwArgumentError("bad address checksum", "address", e2);
      else if (e2.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        for (e2.substring(2, 4) !== $s(e2) && br.throwArgumentError("bad icap checksum", "address", e2), t = Is(e2.substring(4)); t.length < 40; )
          t = "0" + t;
        t = ef("0x" + t);
      } else
        br.throwArgumentError("invalid address", "address", e2);
      return t;
    }
    var ea = "properties/5.7.0";
    new z3(ea);
    function yr(e2, t, r) {
      Object.defineProperty(e2, t, { enumerable: true, value: r, writable: false });
    }
    new z3(Wn);
    var ra = new Uint8Array(32);
    ra.fill(0), G.from(-1);
    var ia = G.from(0);
    var na = G.from(1);
    G.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), fe(na.toHexString(), 32), fe(ia.toHexString(), 32);
    var oe = {};
    var V = {};
    var wr = nf;
    function nf(e2, t) {
      if (!e2)
        throw new Error(t || "Assertion failed");
    }
    nf.equal = function(t, r, i2) {
      if (t != r)
        throw new Error(i2 || "Assertion failed: " + t + " != " + r);
    };
    var _i = { exports: {} };
    typeof Object.create == "function" ? _i.exports = function(t, r) {
      r && (t.super_ = r, t.prototype = Object.create(r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }));
    } : _i.exports = function(t, r) {
      if (r) {
        t.super_ = r;
        var i2 = function() {
        };
        i2.prototype = r.prototype, t.prototype = new i2(), t.prototype.constructor = t;
      }
    };
    var fa = wr;
    var oa = _i.exports;
    V.inherits = oa;
    function sa(e2, t) {
      return (e2.charCodeAt(t) & 64512) !== 55296 || t < 0 || t + 1 >= e2.length ? false : (e2.charCodeAt(t + 1) & 64512) === 56320;
    }
    function aa(e2, t) {
      if (Array.isArray(e2))
        return e2.slice();
      if (!e2)
        return [];
      var r = [];
      if (typeof e2 == "string")
        if (t) {
          if (t === "hex")
            for (e2 = e2.replace(/[^a-z0-9]+/ig, ""), e2.length % 2 !== 0 && (e2 = "0" + e2), n3 = 0; n3 < e2.length; n3 += 2)
              r.push(parseInt(e2[n3] + e2[n3 + 1], 16));
        } else
          for (var i2 = 0, n3 = 0; n3 < e2.length; n3++) {
            var o2 = e2.charCodeAt(n3);
            o2 < 128 ? r[i2++] = o2 : o2 < 2048 ? (r[i2++] = o2 >> 6 | 192, r[i2++] = o2 & 63 | 128) : sa(e2, n3) ? (o2 = 65536 + ((o2 & 1023) << 10) + (e2.charCodeAt(++n3) & 1023), r[i2++] = o2 >> 18 | 240, r[i2++] = o2 >> 12 & 63 | 128, r[i2++] = o2 >> 6 & 63 | 128, r[i2++] = o2 & 63 | 128) : (r[i2++] = o2 >> 12 | 224, r[i2++] = o2 >> 6 & 63 | 128, r[i2++] = o2 & 63 | 128);
          }
      else
        for (n3 = 0; n3 < e2.length; n3++)
          r[n3] = e2[n3] | 0;
      return r;
    }
    V.toArray = aa;
    function ua(e2) {
      for (var t = "", r = 0; r < e2.length; r++)
        t += of(e2[r].toString(16));
      return t;
    }
    V.toHex = ua;
    function ff(e2) {
      var t = e2 >>> 24 | e2 >>> 8 & 65280 | e2 << 8 & 16711680 | (e2 & 255) << 24;
      return t >>> 0;
    }
    V.htonl = ff;
    function ha(e2, t) {
      for (var r = "", i2 = 0; i2 < e2.length; i2++) {
        var n3 = e2[i2];
        t === "little" && (n3 = ff(n3)), r += sf(n3.toString(16));
      }
      return r;
    }
    V.toHex32 = ha;
    function of(e2) {
      return e2.length === 1 ? "0" + e2 : e2;
    }
    V.zero2 = of;
    function sf(e2) {
      return e2.length === 7 ? "0" + e2 : e2.length === 6 ? "00" + e2 : e2.length === 5 ? "000" + e2 : e2.length === 4 ? "0000" + e2 : e2.length === 3 ? "00000" + e2 : e2.length === 2 ? "000000" + e2 : e2.length === 1 ? "0000000" + e2 : e2;
    }
    V.zero8 = sf;
    function ca(e2, t, r, i2) {
      var n3 = r - t;
      fa(n3 % 4 === 0);
      for (var o2 = new Array(n3 / 4), h5 = 0, p3 = t; h5 < o2.length; h5++, p3 += 4) {
        var b4;
        i2 === "big" ? b4 = e2[p3] << 24 | e2[p3 + 1] << 16 | e2[p3 + 2] << 8 | e2[p3 + 3] : b4 = e2[p3 + 3] << 24 | e2[p3 + 2] << 16 | e2[p3 + 1] << 8 | e2[p3], o2[h5] = b4 >>> 0;
      }
      return o2;
    }
    V.join32 = ca;
    function la(e2, t) {
      for (var r = new Array(e2.length * 4), i2 = 0, n3 = 0; i2 < e2.length; i2++, n3 += 4) {
        var o2 = e2[i2];
        t === "big" ? (r[n3] = o2 >>> 24, r[n3 + 1] = o2 >>> 16 & 255, r[n3 + 2] = o2 >>> 8 & 255, r[n3 + 3] = o2 & 255) : (r[n3 + 3] = o2 >>> 24, r[n3 + 2] = o2 >>> 16 & 255, r[n3 + 1] = o2 >>> 8 & 255, r[n3] = o2 & 255);
      }
      return r;
    }
    V.split32 = la;
    function da(e2, t) {
      return e2 >>> t | e2 << 32 - t;
    }
    V.rotr32 = da;
    function pa(e2, t) {
      return e2 << t | e2 >>> 32 - t;
    }
    V.rotl32 = pa;
    function va(e2, t) {
      return e2 + t >>> 0;
    }
    V.sum32 = va;
    function ga(e2, t, r) {
      return e2 + t + r >>> 0;
    }
    V.sum32_3 = ga;
    function ma(e2, t, r, i2) {
      return e2 + t + r + i2 >>> 0;
    }
    V.sum32_4 = ma;
    function Aa(e2, t, r, i2, n3) {
      return e2 + t + r + i2 + n3 >>> 0;
    }
    V.sum32_5 = Aa;
    function ba(e2, t, r, i2) {
      var n3 = e2[t], o2 = e2[t + 1], h5 = i2 + o2 >>> 0, p3 = (h5 < i2 ? 1 : 0) + r + n3;
      e2[t] = p3 >>> 0, e2[t + 1] = h5;
    }
    V.sum64 = ba;
    function ya(e2, t, r, i2) {
      var n3 = t + i2 >>> 0, o2 = (n3 < t ? 1 : 0) + e2 + r;
      return o2 >>> 0;
    }
    V.sum64_hi = ya;
    function wa(e2, t, r, i2) {
      var n3 = t + i2;
      return n3 >>> 0;
    }
    V.sum64_lo = wa;
    function xa(e2, t, r, i2, n3, o2, h5, p3) {
      var b4 = 0, g3 = t;
      g3 = g3 + i2 >>> 0, b4 += g3 < t ? 1 : 0, g3 = g3 + o2 >>> 0, b4 += g3 < o2 ? 1 : 0, g3 = g3 + p3 >>> 0, b4 += g3 < p3 ? 1 : 0;
      var w4 = e2 + r + n3 + h5 + b4;
      return w4 >>> 0;
    }
    V.sum64_4_hi = xa;
    function Ma(e2, t, r, i2, n3, o2, h5, p3) {
      var b4 = t + i2 + o2 + p3;
      return b4 >>> 0;
    }
    V.sum64_4_lo = Ma;
    function Ea(e2, t, r, i2, n3, o2, h5, p3, b4, g3) {
      var w4 = 0, y4 = t;
      y4 = y4 + i2 >>> 0, w4 += y4 < t ? 1 : 0, y4 = y4 + o2 >>> 0, w4 += y4 < o2 ? 1 : 0, y4 = y4 + p3 >>> 0, w4 += y4 < p3 ? 1 : 0, y4 = y4 + g3 >>> 0, w4 += y4 < g3 ? 1 : 0;
      var S4 = e2 + r + n3 + h5 + b4 + w4;
      return S4 >>> 0;
    }
    V.sum64_5_hi = Ea;
    function Sa(e2, t, r, i2, n3, o2, h5, p3, b4, g3) {
      var w4 = t + i2 + o2 + p3 + g3;
      return w4 >>> 0;
    }
    V.sum64_5_lo = Sa;
    function Na(e2, t, r) {
      var i2 = t << 32 - r | e2 >>> r;
      return i2 >>> 0;
    }
    V.rotr64_hi = Na;
    function Ia(e2, t, r) {
      var i2 = e2 << 32 - r | t >>> r;
      return i2 >>> 0;
    }
    V.rotr64_lo = Ia;
    function _a(e2, t, r) {
      return e2 >>> r;
    }
    V.shr64_hi = _a;
    function Ba(e2, t, r) {
      var i2 = e2 << 32 - r | t >>> r;
      return i2 >>> 0;
    }
    V.shr64_lo = Ba;
    var or2 = {};
    var af = V;
    var Ra = wr;
    function Dr() {
      this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
    }
    or2.BlockHash = Dr, Dr.prototype.update = function(t, r) {
      if (t = af.toArray(t, r), this.pending ? this.pending = this.pending.concat(t) : this.pending = t, this.pendingTotal += t.length, this.pending.length >= this._delta8) {
        t = this.pending;
        var i2 = t.length % this._delta8;
        this.pending = t.slice(t.length - i2, t.length), this.pending.length === 0 && (this.pending = null), t = af.join32(t, 0, t.length - i2, this.endian);
        for (var n3 = 0; n3 < t.length; n3 += this._delta32)
          this._update(t, n3, n3 + this._delta32);
      }
      return this;
    }, Dr.prototype.digest = function(t) {
      return this.update(this._pad()), Ra(this.pending === null), this._digest(t);
    }, Dr.prototype._pad = function() {
      var t = this.pendingTotal, r = this._delta8, i2 = r - (t + this.padLength) % r, n3 = new Array(i2 + this.padLength);
      n3[0] = 128;
      for (var o2 = 1; o2 < i2; o2++)
        n3[o2] = 0;
      if (t <<= 3, this.endian === "big") {
        for (var h5 = 8; h5 < this.padLength; h5++)
          n3[o2++] = 0;
        n3[o2++] = 0, n3[o2++] = 0, n3[o2++] = 0, n3[o2++] = 0, n3[o2++] = t >>> 24 & 255, n3[o2++] = t >>> 16 & 255, n3[o2++] = t >>> 8 & 255, n3[o2++] = t & 255;
      } else
        for (n3[o2++] = t & 255, n3[o2++] = t >>> 8 & 255, n3[o2++] = t >>> 16 & 255, n3[o2++] = t >>> 24 & 255, n3[o2++] = 0, n3[o2++] = 0, n3[o2++] = 0, n3[o2++] = 0, h5 = 8; h5 < this.padLength; h5++)
          n3[o2++] = 0;
      return n3;
    };
    var sr = {};
    var se = {};
    var Ca = V;
    var ae = Ca.rotr32;
    function Oa(e2, t, r, i2) {
      if (e2 === 0)
        return uf(t, r, i2);
      if (e2 === 1 || e2 === 3)
        return cf(t, r, i2);
      if (e2 === 2)
        return hf(t, r, i2);
    }
    se.ft_1 = Oa;
    function uf(e2, t, r) {
      return e2 & t ^ ~e2 & r;
    }
    se.ch32 = uf;
    function hf(e2, t, r) {
      return e2 & t ^ e2 & r ^ t & r;
    }
    se.maj32 = hf;
    function cf(e2, t, r) {
      return e2 ^ t ^ r;
    }
    se.p32 = cf;
    function Pa(e2) {
      return ae(e2, 2) ^ ae(e2, 13) ^ ae(e2, 22);
    }
    se.s0_256 = Pa;
    function Ta(e2) {
      return ae(e2, 6) ^ ae(e2, 11) ^ ae(e2, 25);
    }
    se.s1_256 = Ta;
    function Fa(e2) {
      return ae(e2, 7) ^ ae(e2, 18) ^ e2 >>> 3;
    }
    se.g0_256 = Fa;
    function Da(e2) {
      return ae(e2, 17) ^ ae(e2, 19) ^ e2 >>> 10;
    }
    se.g1_256 = Da;
    var ar = V;
    var Ua = or2;
    var ka = se;
    var Bi = ar.rotl32;
    var xr = ar.sum32;
    var qa = ar.sum32_5;
    var Ka = ka.ft_1;
    var lf = Ua.BlockHash;
    var Ha = [1518500249, 1859775393, 2400959708, 3395469782];
    function ue() {
      if (!(this instanceof ue))
        return new ue();
      lf.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
    }
    ar.inherits(ue, lf);
    var La = ue;
    ue.blockSize = 512, ue.outSize = 160, ue.hmacStrength = 80, ue.padLength = 64, ue.prototype._update = function(t, r) {
      for (var i2 = this.W, n3 = 0; n3 < 16; n3++)
        i2[n3] = t[r + n3];
      for (; n3 < i2.length; n3++)
        i2[n3] = Bi(i2[n3 - 3] ^ i2[n3 - 8] ^ i2[n3 - 14] ^ i2[n3 - 16], 1);
      var o2 = this.h[0], h5 = this.h[1], p3 = this.h[2], b4 = this.h[3], g3 = this.h[4];
      for (n3 = 0; n3 < i2.length; n3++) {
        var w4 = ~~(n3 / 20), y4 = qa(Bi(o2, 5), Ka(w4, h5, p3, b4), g3, i2[n3], Ha[w4]);
        g3 = b4, b4 = p3, p3 = Bi(h5, 30), h5 = o2, o2 = y4;
      }
      this.h[0] = xr(this.h[0], o2), this.h[1] = xr(this.h[1], h5), this.h[2] = xr(this.h[2], p3), this.h[3] = xr(this.h[3], b4), this.h[4] = xr(this.h[4], g3);
    }, ue.prototype._digest = function(t) {
      return t === "hex" ? ar.toHex32(this.h, "big") : ar.split32(this.h, "big");
    };
    var ur = V;
    var za = or2;
    var hr = se;
    var ja = wr;
    var re = ur.sum32;
    var Va = ur.sum32_4;
    var Qa = ur.sum32_5;
    var Ja = hr.ch32;
    var Ya = hr.maj32;
    var Ga = hr.s0_256;
    var Wa = hr.s1_256;
    var Xa = hr.g0_256;
    var Za = hr.g1_256;
    var df = za.BlockHash;
    var $a = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
    function he() {
      if (!(this instanceof he))
        return new he();
      df.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = $a, this.W = new Array(64);
    }
    ur.inherits(he, df);
    var pf = he;
    he.blockSize = 512, he.outSize = 256, he.hmacStrength = 192, he.padLength = 64, he.prototype._update = function(t, r) {
      for (var i2 = this.W, n3 = 0; n3 < 16; n3++)
        i2[n3] = t[r + n3];
      for (; n3 < i2.length; n3++)
        i2[n3] = Va(Za(i2[n3 - 2]), i2[n3 - 7], Xa(i2[n3 - 15]), i2[n3 - 16]);
      var o2 = this.h[0], h5 = this.h[1], p3 = this.h[2], b4 = this.h[3], g3 = this.h[4], w4 = this.h[5], y4 = this.h[6], S4 = this.h[7];
      for (ja(this.k.length === i2.length), n3 = 0; n3 < i2.length; n3++) {
        var I2 = Qa(S4, Wa(g3), Ja(g3, w4, y4), this.k[n3], i2[n3]), N10 = re(Ga(o2), Ya(o2, h5, p3));
        S4 = y4, y4 = w4, w4 = g3, g3 = re(b4, I2), b4 = p3, p3 = h5, h5 = o2, o2 = re(I2, N10);
      }
      this.h[0] = re(this.h[0], o2), this.h[1] = re(this.h[1], h5), this.h[2] = re(this.h[2], p3), this.h[3] = re(this.h[3], b4), this.h[4] = re(this.h[4], g3), this.h[5] = re(this.h[5], w4), this.h[6] = re(this.h[6], y4), this.h[7] = re(this.h[7], S4);
    }, he.prototype._digest = function(t) {
      return t === "hex" ? ur.toHex32(this.h, "big") : ur.split32(this.h, "big");
    };
    var Ri = V;
    var vf = pf;
    function be() {
      if (!(this instanceof be))
        return new be();
      vf.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
    }
    Ri.inherits(be, vf);
    var t0 = be;
    be.blockSize = 512, be.outSize = 224, be.hmacStrength = 192, be.padLength = 64, be.prototype._digest = function(t) {
      return t === "hex" ? Ri.toHex32(this.h.slice(0, 7), "big") : Ri.split32(this.h.slice(0, 7), "big");
    };
    var Vt = V;
    var e0 = or2;
    var r0 = wr;
    var ce = Vt.rotr64_hi;
    var le = Vt.rotr64_lo;
    var gf = Vt.shr64_hi;
    var mf = Vt.shr64_lo;
    var _e = Vt.sum64;
    var Ci = Vt.sum64_hi;
    var Oi = Vt.sum64_lo;
    var i0 = Vt.sum64_4_hi;
    var n0 = Vt.sum64_4_lo;
    var f0 = Vt.sum64_5_hi;
    var o0 = Vt.sum64_5_lo;
    var Af = e0.BlockHash;
    var s0 = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
    function ie() {
      if (!(this instanceof ie))
        return new ie();
      Af.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = s0, this.W = new Array(160);
    }
    Vt.inherits(ie, Af);
    var bf = ie;
    ie.blockSize = 1024, ie.outSize = 512, ie.hmacStrength = 192, ie.padLength = 128, ie.prototype._prepareBlock = function(t, r) {
      for (var i2 = this.W, n3 = 0; n3 < 32; n3++)
        i2[n3] = t[r + n3];
      for (; n3 < i2.length; n3 += 2) {
        var o2 = A0(i2[n3 - 4], i2[n3 - 3]), h5 = b0(i2[n3 - 4], i2[n3 - 3]), p3 = i2[n3 - 14], b4 = i2[n3 - 13], g3 = g0(i2[n3 - 30], i2[n3 - 29]), w4 = m0(i2[n3 - 30], i2[n3 - 29]), y4 = i2[n3 - 32], S4 = i2[n3 - 31];
        i2[n3] = i0(o2, h5, p3, b4, g3, w4, y4, S4), i2[n3 + 1] = n0(o2, h5, p3, b4, g3, w4, y4, S4);
      }
    }, ie.prototype._update = function(t, r) {
      this._prepareBlock(t, r);
      var i2 = this.W, n3 = this.h[0], o2 = this.h[1], h5 = this.h[2], p3 = this.h[3], b4 = this.h[4], g3 = this.h[5], w4 = this.h[6], y4 = this.h[7], S4 = this.h[8], I2 = this.h[9], N10 = this.h[10], R2 = this.h[11], F = this.h[12], U2 = this.h[13], Q = this.h[14], Bt = this.h[15];
      r0(this.k.length === i2.length);
      for (var J = 0; J < i2.length; J += 2) {
        var H = Q, L2 = Bt, Tt = p0(S4, I2), W = v0(S4, I2), Ot = a0(S4, I2, N10, R2, F), Gt = u0(S4, I2, N10, R2, F, U2), Y = this.k[J], Wt = this.k[J + 1], A2 = i2[J], f4 = i2[J + 1], a3 = f0(H, L2, Tt, W, Ot, Gt, Y, Wt, A2, f4), c4 = o0(H, L2, Tt, W, Ot, Gt, Y, Wt, A2, f4);
        H = l0(n3, o2), L2 = d0(n3, o2), Tt = h0(n3, o2, h5, p3, b4), W = c0(n3, o2, h5, p3, b4, g3);
        var d3 = Ci(H, L2, Tt, W), m3 = Oi(H, L2, Tt, W);
        Q = F, Bt = U2, F = N10, U2 = R2, N10 = S4, R2 = I2, S4 = Ci(w4, y4, a3, c4), I2 = Oi(y4, y4, a3, c4), w4 = b4, y4 = g3, b4 = h5, g3 = p3, h5 = n3, p3 = o2, n3 = Ci(a3, c4, d3, m3), o2 = Oi(a3, c4, d3, m3);
      }
      _e(this.h, 0, n3, o2), _e(this.h, 2, h5, p3), _e(this.h, 4, b4, g3), _e(this.h, 6, w4, y4), _e(this.h, 8, S4, I2), _e(this.h, 10, N10, R2), _e(this.h, 12, F, U2), _e(this.h, 14, Q, Bt);
    }, ie.prototype._digest = function(t) {
      return t === "hex" ? Vt.toHex32(this.h, "big") : Vt.split32(this.h, "big");
    };
    function a0(e2, t, r, i2, n3) {
      var o2 = e2 & r ^ ~e2 & n3;
      return o2 < 0 && (o2 += 4294967296), o2;
    }
    function u0(e2, t, r, i2, n3, o2) {
      var h5 = t & i2 ^ ~t & o2;
      return h5 < 0 && (h5 += 4294967296), h5;
    }
    function h0(e2, t, r, i2, n3) {
      var o2 = e2 & r ^ e2 & n3 ^ r & n3;
      return o2 < 0 && (o2 += 4294967296), o2;
    }
    function c0(e2, t, r, i2, n3, o2) {
      var h5 = t & i2 ^ t & o2 ^ i2 & o2;
      return h5 < 0 && (h5 += 4294967296), h5;
    }
    function l0(e2, t) {
      var r = ce(e2, t, 28), i2 = ce(t, e2, 2), n3 = ce(t, e2, 7), o2 = r ^ i2 ^ n3;
      return o2 < 0 && (o2 += 4294967296), o2;
    }
    function d0(e2, t) {
      var r = le(e2, t, 28), i2 = le(t, e2, 2), n3 = le(t, e2, 7), o2 = r ^ i2 ^ n3;
      return o2 < 0 && (o2 += 4294967296), o2;
    }
    function p0(e2, t) {
      var r = ce(e2, t, 14), i2 = ce(e2, t, 18), n3 = ce(t, e2, 9), o2 = r ^ i2 ^ n3;
      return o2 < 0 && (o2 += 4294967296), o2;
    }
    function v0(e2, t) {
      var r = le(e2, t, 14), i2 = le(e2, t, 18), n3 = le(t, e2, 9), o2 = r ^ i2 ^ n3;
      return o2 < 0 && (o2 += 4294967296), o2;
    }
    function g0(e2, t) {
      var r = ce(e2, t, 1), i2 = ce(e2, t, 8), n3 = gf(e2, t, 7), o2 = r ^ i2 ^ n3;
      return o2 < 0 && (o2 += 4294967296), o2;
    }
    function m0(e2, t) {
      var r = le(e2, t, 1), i2 = le(e2, t, 8), n3 = mf(e2, t, 7), o2 = r ^ i2 ^ n3;
      return o2 < 0 && (o2 += 4294967296), o2;
    }
    function A0(e2, t) {
      var r = ce(e2, t, 19), i2 = ce(t, e2, 29), n3 = gf(e2, t, 6), o2 = r ^ i2 ^ n3;
      return o2 < 0 && (o2 += 4294967296), o2;
    }
    function b0(e2, t) {
      var r = le(e2, t, 19), i2 = le(t, e2, 29), n3 = mf(e2, t, 6), o2 = r ^ i2 ^ n3;
      return o2 < 0 && (o2 += 4294967296), o2;
    }
    var Pi = V;
    var yf = bf;
    function ye() {
      if (!(this instanceof ye))
        return new ye();
      yf.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
    }
    Pi.inherits(ye, yf);
    var y0 = ye;
    ye.blockSize = 1024, ye.outSize = 384, ye.hmacStrength = 192, ye.padLength = 128, ye.prototype._digest = function(t) {
      return t === "hex" ? Pi.toHex32(this.h.slice(0, 12), "big") : Pi.split32(this.h.slice(0, 12), "big");
    }, sr.sha1 = La, sr.sha224 = t0, sr.sha256 = pf, sr.sha384 = y0, sr.sha512 = bf;
    var wf = {};
    var We = V;
    var w0 = or2;
    var Ur = We.rotl32;
    var xf = We.sum32;
    var Mr = We.sum32_3;
    var Mf = We.sum32_4;
    var Ef = w0.BlockHash;
    function de() {
      if (!(this instanceof de))
        return new de();
      Ef.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
    }
    We.inherits(de, Ef), wf.ripemd160 = de, de.blockSize = 512, de.outSize = 160, de.hmacStrength = 192, de.padLength = 64, de.prototype._update = function(t, r) {
      for (var i2 = this.h[0], n3 = this.h[1], o2 = this.h[2], h5 = this.h[3], p3 = this.h[4], b4 = i2, g3 = n3, w4 = o2, y4 = h5, S4 = p3, I2 = 0; I2 < 80; I2++) {
        var N10 = xf(Ur(Mf(i2, Sf(I2, n3, o2, h5), t[E0[I2] + r], x0(I2)), N0[I2]), p3);
        i2 = p3, p3 = h5, h5 = Ur(o2, 10), o2 = n3, n3 = N10, N10 = xf(Ur(Mf(b4, Sf(79 - I2, g3, w4, y4), t[S0[I2] + r], M0(I2)), I0[I2]), S4), b4 = S4, S4 = y4, y4 = Ur(w4, 10), w4 = g3, g3 = N10;
      }
      N10 = Mr(this.h[1], o2, y4), this.h[1] = Mr(this.h[2], h5, S4), this.h[2] = Mr(this.h[3], p3, b4), this.h[3] = Mr(this.h[4], i2, g3), this.h[4] = Mr(this.h[0], n3, w4), this.h[0] = N10;
    }, de.prototype._digest = function(t) {
      return t === "hex" ? We.toHex32(this.h, "little") : We.split32(this.h, "little");
    };
    function Sf(e2, t, r, i2) {
      return e2 <= 15 ? t ^ r ^ i2 : e2 <= 31 ? t & r | ~t & i2 : e2 <= 47 ? (t | ~r) ^ i2 : e2 <= 63 ? t & i2 | r & ~i2 : t ^ (r | ~i2);
    }
    function x0(e2) {
      return e2 <= 15 ? 0 : e2 <= 31 ? 1518500249 : e2 <= 47 ? 1859775393 : e2 <= 63 ? 2400959708 : 2840853838;
    }
    function M0(e2) {
      return e2 <= 15 ? 1352829926 : e2 <= 31 ? 1548603684 : e2 <= 47 ? 1836072691 : e2 <= 63 ? 2053994217 : 0;
    }
    var E0 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
    var S0 = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
    var N0 = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
    var I0 = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
    var _0 = V;
    var B0 = wr;
    function cr(e2, t, r) {
      if (!(this instanceof cr))
        return new cr(e2, t, r);
      this.Hash = e2, this.blockSize = e2.blockSize / 8, this.outSize = e2.outSize / 8, this.inner = null, this.outer = null, this._init(_0.toArray(t, r));
    }
    var R0 = cr;
    cr.prototype._init = function(t) {
      t.length > this.blockSize && (t = new this.Hash().update(t).digest()), B0(t.length <= this.blockSize);
      for (var r = t.length; r < this.blockSize; r++)
        t.push(0);
      for (r = 0; r < t.length; r++)
        t[r] ^= 54;
      for (this.inner = new this.Hash().update(t), r = 0; r < t.length; r++)
        t[r] ^= 106;
      this.outer = new this.Hash().update(t);
    }, cr.prototype.update = function(t, r) {
      return this.inner.update(t, r), this;
    }, cr.prototype.digest = function(t) {
      return this.outer.update(this.inner.digest()), this.outer.digest(t);
    }, function(e2) {
      var t = e2;
      t.utils = V, t.common = or2, t.sha = sr, t.ripemd = wf, t.hmac = R0, t.sha1 = t.sha.sha1, t.sha256 = t.sha.sha256, t.sha224 = t.sha.sha224, t.sha384 = t.sha.sha384, t.sha512 = t.sha.sha512, t.ripemd160 = t.ripemd.ripemd160;
    }(oe);
    function lr(e2, t, r) {
      return r = { path: t, exports: {}, require: function(i2, n3) {
        return C0(i2, n3 ?? r.path);
      } }, e2(r, r.exports), r.exports;
    }
    function C0() {
      throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
    }
    var Ti = Nf;
    function Nf(e2, t) {
      if (!e2)
        throw new Error(t || "Assertion failed");
    }
    Nf.equal = function(t, r, i2) {
      if (t != r)
        throw new Error(i2 || "Assertion failed: " + t + " != " + r);
    };
    var ne = lr(function(e2, t) {
      var r = t;
      function i2(h5, p3) {
        if (Array.isArray(h5))
          return h5.slice();
        if (!h5)
          return [];
        var b4 = [];
        if (typeof h5 != "string") {
          for (var g3 = 0; g3 < h5.length; g3++)
            b4[g3] = h5[g3] | 0;
          return b4;
        }
        if (p3 === "hex") {
          h5 = h5.replace(/[^a-z0-9]+/ig, ""), h5.length % 2 !== 0 && (h5 = "0" + h5);
          for (var g3 = 0; g3 < h5.length; g3 += 2)
            b4.push(parseInt(h5[g3] + h5[g3 + 1], 16));
        } else
          for (var g3 = 0; g3 < h5.length; g3++) {
            var w4 = h5.charCodeAt(g3), y4 = w4 >> 8, S4 = w4 & 255;
            y4 ? b4.push(y4, S4) : b4.push(S4);
          }
        return b4;
      }
      r.toArray = i2;
      function n3(h5) {
        return h5.length === 1 ? "0" + h5 : h5;
      }
      r.zero2 = n3;
      function o2(h5) {
        for (var p3 = "", b4 = 0; b4 < h5.length; b4++)
          p3 += n3(h5[b4].toString(16));
        return p3;
      }
      r.toHex = o2, r.encode = function(p3, b4) {
        return b4 === "hex" ? o2(p3) : p3;
      };
    });
    var Jt = lr(function(e2, t) {
      var r = t;
      r.assert = Ti, r.toArray = ne.toArray, r.zero2 = ne.zero2, r.toHex = ne.toHex, r.encode = ne.encode;
      function i2(b4, g3, w4) {
        var y4 = new Array(Math.max(b4.bitLength(), w4) + 1);
        y4.fill(0);
        for (var S4 = 1 << g3 + 1, I2 = b4.clone(), N10 = 0; N10 < y4.length; N10++) {
          var R2, F = I2.andln(S4 - 1);
          I2.isOdd() ? (F > (S4 >> 1) - 1 ? R2 = (S4 >> 1) - F : R2 = F, I2.isubn(R2)) : R2 = 0, y4[N10] = R2, I2.iushrn(1);
        }
        return y4;
      }
      r.getNAF = i2;
      function n3(b4, g3) {
        var w4 = [[], []];
        b4 = b4.clone(), g3 = g3.clone();
        for (var y4 = 0, S4 = 0, I2; b4.cmpn(-y4) > 0 || g3.cmpn(-S4) > 0; ) {
          var N10 = b4.andln(3) + y4 & 3, R2 = g3.andln(3) + S4 & 3;
          N10 === 3 && (N10 = -1), R2 === 3 && (R2 = -1);
          var F;
          N10 & 1 ? (I2 = b4.andln(7) + y4 & 7, (I2 === 3 || I2 === 5) && R2 === 2 ? F = -N10 : F = N10) : F = 0, w4[0].push(F);
          var U2;
          R2 & 1 ? (I2 = g3.andln(7) + S4 & 7, (I2 === 3 || I2 === 5) && N10 === 2 ? U2 = -R2 : U2 = R2) : U2 = 0, w4[1].push(U2), 2 * y4 === F + 1 && (y4 = 1 - y4), 2 * S4 === U2 + 1 && (S4 = 1 - S4), b4.iushrn(1), g3.iushrn(1);
        }
        return w4;
      }
      r.getJSF = n3;
      function o2(b4, g3, w4) {
        var y4 = "_" + g3;
        b4.prototype[g3] = function() {
          return this[y4] !== void 0 ? this[y4] : this[y4] = w4.call(this);
        };
      }
      r.cachedProperty = o2;
      function h5(b4) {
        return typeof b4 == "string" ? r.toArray(b4, "hex") : b4;
      }
      r.parseBytes = h5;
      function p3(b4) {
        return new K2(b4, "hex", "le");
      }
      r.intFromLE = p3;
    });
    var kr = Jt.getNAF;
    var O0 = Jt.getJSF;
    var qr = Jt.assert;
    function Be(e2, t) {
      this.type = e2, this.p = new K2(t.p, 16), this.red = t.prime ? K2.red(t.prime) : K2.mont(this.p), this.zero = new K2(0).toRed(this.red), this.one = new K2(1).toRed(this.red), this.two = new K2(2).toRed(this.red), this.n = t.n && new K2(t.n, 16), this.g = t.g && this.pointFromJSON(t.g, t.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
      var r = this.n && this.p.div(this.n);
      !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = true, this.redN = this.n.toRed(this.red));
    }
    var Xe = Be;
    Be.prototype.point = function() {
      throw new Error("Not implemented");
    }, Be.prototype.validate = function() {
      throw new Error("Not implemented");
    }, Be.prototype._fixedNafMul = function(t, r) {
      qr(t.precomputed);
      var i2 = t._getDoubles(), n3 = kr(r, 1, this._bitLength), o2 = (1 << i2.step + 1) - (i2.step % 2 === 0 ? 2 : 1);
      o2 /= 3;
      var h5 = [], p3, b4;
      for (p3 = 0; p3 < n3.length; p3 += i2.step) {
        b4 = 0;
        for (var g3 = p3 + i2.step - 1; g3 >= p3; g3--)
          b4 = (b4 << 1) + n3[g3];
        h5.push(b4);
      }
      for (var w4 = this.jpoint(null, null, null), y4 = this.jpoint(null, null, null), S4 = o2; S4 > 0; S4--) {
        for (p3 = 0; p3 < h5.length; p3++)
          b4 = h5[p3], b4 === S4 ? y4 = y4.mixedAdd(i2.points[p3]) : b4 === -S4 && (y4 = y4.mixedAdd(i2.points[p3].neg()));
        w4 = w4.add(y4);
      }
      return w4.toP();
    }, Be.prototype._wnafMul = function(t, r) {
      var i2 = 4, n3 = t._getNAFPoints(i2);
      i2 = n3.wnd;
      for (var o2 = n3.points, h5 = kr(r, i2, this._bitLength), p3 = this.jpoint(null, null, null), b4 = h5.length - 1; b4 >= 0; b4--) {
        for (var g3 = 0; b4 >= 0 && h5[b4] === 0; b4--)
          g3++;
        if (b4 >= 0 && g3++, p3 = p3.dblp(g3), b4 < 0)
          break;
        var w4 = h5[b4];
        qr(w4 !== 0), t.type === "affine" ? w4 > 0 ? p3 = p3.mixedAdd(o2[w4 - 1 >> 1]) : p3 = p3.mixedAdd(o2[-w4 - 1 >> 1].neg()) : w4 > 0 ? p3 = p3.add(o2[w4 - 1 >> 1]) : p3 = p3.add(o2[-w4 - 1 >> 1].neg());
      }
      return t.type === "affine" ? p3.toP() : p3;
    }, Be.prototype._wnafMulAdd = function(t, r, i2, n3, o2) {
      var h5 = this._wnafT1, p3 = this._wnafT2, b4 = this._wnafT3, g3 = 0, w4, y4, S4;
      for (w4 = 0; w4 < n3; w4++) {
        S4 = r[w4];
        var I2 = S4._getNAFPoints(t);
        h5[w4] = I2.wnd, p3[w4] = I2.points;
      }
      for (w4 = n3 - 1; w4 >= 1; w4 -= 2) {
        var N10 = w4 - 1, R2 = w4;
        if (h5[N10] !== 1 || h5[R2] !== 1) {
          b4[N10] = kr(i2[N10], h5[N10], this._bitLength), b4[R2] = kr(i2[R2], h5[R2], this._bitLength), g3 = Math.max(b4[N10].length, g3), g3 = Math.max(b4[R2].length, g3);
          continue;
        }
        var F = [r[N10], null, null, r[R2]];
        r[N10].y.cmp(r[R2].y) === 0 ? (F[1] = r[N10].add(r[R2]), F[2] = r[N10].toJ().mixedAdd(r[R2].neg())) : r[N10].y.cmp(r[R2].y.redNeg()) === 0 ? (F[1] = r[N10].toJ().mixedAdd(r[R2]), F[2] = r[N10].add(r[R2].neg())) : (F[1] = r[N10].toJ().mixedAdd(r[R2]), F[2] = r[N10].toJ().mixedAdd(r[R2].neg()));
        var U2 = [-3, -1, -5, -7, 0, 7, 5, 1, 3], Q = O0(i2[N10], i2[R2]);
        for (g3 = Math.max(Q[0].length, g3), b4[N10] = new Array(g3), b4[R2] = new Array(g3), y4 = 0; y4 < g3; y4++) {
          var Bt = Q[0][y4] | 0, J = Q[1][y4] | 0;
          b4[N10][y4] = U2[(Bt + 1) * 3 + (J + 1)], b4[R2][y4] = 0, p3[N10] = F;
        }
      }
      var H = this.jpoint(null, null, null), L2 = this._wnafT4;
      for (w4 = g3; w4 >= 0; w4--) {
        for (var Tt = 0; w4 >= 0; ) {
          var W = true;
          for (y4 = 0; y4 < n3; y4++)
            L2[y4] = b4[y4][w4] | 0, L2[y4] !== 0 && (W = false);
          if (!W)
            break;
          Tt++, w4--;
        }
        if (w4 >= 0 && Tt++, H = H.dblp(Tt), w4 < 0)
          break;
        for (y4 = 0; y4 < n3; y4++) {
          var Ot = L2[y4];
          Ot !== 0 && (Ot > 0 ? S4 = p3[y4][Ot - 1 >> 1] : Ot < 0 && (S4 = p3[y4][-Ot - 1 >> 1].neg()), S4.type === "affine" ? H = H.mixedAdd(S4) : H = H.add(S4));
        }
      }
      for (w4 = 0; w4 < n3; w4++)
        p3[w4] = null;
      return o2 ? H : H.toP();
    };
    function Zt(e2, t) {
      this.curve = e2, this.type = t, this.precomputed = null;
    }
    Be.BasePoint = Zt, Zt.prototype.eq = function() {
      throw new Error("Not implemented");
    }, Zt.prototype.validate = function() {
      return this.curve.validate(this);
    }, Be.prototype.decodePoint = function(t, r) {
      t = Jt.toArray(t, r);
      var i2 = this.p.byteLength();
      if ((t[0] === 4 || t[0] === 6 || t[0] === 7) && t.length - 1 === 2 * i2) {
        t[0] === 6 ? qr(t[t.length - 1] % 2 === 0) : t[0] === 7 && qr(t[t.length - 1] % 2 === 1);
        var n3 = this.point(t.slice(1, 1 + i2), t.slice(1 + i2, 1 + 2 * i2));
        return n3;
      } else if ((t[0] === 2 || t[0] === 3) && t.length - 1 === i2)
        return this.pointFromX(t.slice(1, 1 + i2), t[0] === 3);
      throw new Error("Unknown point format");
    }, Zt.prototype.encodeCompressed = function(t) {
      return this.encode(t, true);
    }, Zt.prototype._encode = function(t) {
      var r = this.curve.p.byteLength(), i2 = this.getX().toArray("be", r);
      return t ? [this.getY().isEven() ? 2 : 3].concat(i2) : [4].concat(i2, this.getY().toArray("be", r));
    }, Zt.prototype.encode = function(t, r) {
      return Jt.encode(this._encode(r), t);
    }, Zt.prototype.precompute = function(t) {
      if (this.precomputed)
        return this;
      var r = { doubles: null, naf: null, beta: null };
      return r.naf = this._getNAFPoints(8), r.doubles = this._getDoubles(4, t), r.beta = this._getBeta(), this.precomputed = r, this;
    }, Zt.prototype._hasDoubles = function(t) {
      if (!this.precomputed)
        return false;
      var r = this.precomputed.doubles;
      return r ? r.points.length >= Math.ceil((t.bitLength() + 1) / r.step) : false;
    }, Zt.prototype._getDoubles = function(t, r) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      for (var i2 = [this], n3 = this, o2 = 0; o2 < r; o2 += t) {
        for (var h5 = 0; h5 < t; h5++)
          n3 = n3.dbl();
        i2.push(n3);
      }
      return { step: t, points: i2 };
    }, Zt.prototype._getNAFPoints = function(t) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      for (var r = [this], i2 = (1 << t) - 1, n3 = i2 === 1 ? null : this.dbl(), o2 = 1; o2 < i2; o2++)
        r[o2] = r[o2 - 1].add(n3);
      return { wnd: t, points: r };
    }, Zt.prototype._getBeta = function() {
      return null;
    }, Zt.prototype.dblp = function(t) {
      for (var r = this, i2 = 0; i2 < t; i2++)
        r = r.dbl();
      return r;
    };
    var Fi = lr(function(e2) {
      typeof Object.create == "function" ? e2.exports = function(r, i2) {
        i2 && (r.super_ = i2, r.prototype = Object.create(i2.prototype, { constructor: { value: r, enumerable: false, writable: true, configurable: true } }));
      } : e2.exports = function(r, i2) {
        if (i2) {
          r.super_ = i2;
          var n3 = function() {
          };
          n3.prototype = i2.prototype, r.prototype = new n3(), r.prototype.constructor = r;
        }
      };
    });
    var P0 = Jt.assert;
    function $t(e2) {
      Xe.call(this, "short", e2), this.a = new K2(e2.a, 16).toRed(this.red), this.b = new K2(e2.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(e2), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
    }
    Fi($t, Xe);
    var T0 = $t;
    $t.prototype._getEndomorphism = function(t) {
      if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
        var r, i2;
        if (t.beta)
          r = new K2(t.beta, 16).toRed(this.red);
        else {
          var n3 = this._getEndoRoots(this.p);
          r = n3[0].cmp(n3[1]) < 0 ? n3[0] : n3[1], r = r.toRed(this.red);
        }
        if (t.lambda)
          i2 = new K2(t.lambda, 16);
        else {
          var o2 = this._getEndoRoots(this.n);
          this.g.mul(o2[0]).x.cmp(this.g.x.redMul(r)) === 0 ? i2 = o2[0] : (i2 = o2[1], P0(this.g.mul(i2).x.cmp(this.g.x.redMul(r)) === 0));
        }
        var h5;
        return t.basis ? h5 = t.basis.map(function(p3) {
          return { a: new K2(p3.a, 16), b: new K2(p3.b, 16) };
        }) : h5 = this._getEndoBasis(i2), { beta: r, lambda: i2, basis: h5 };
      }
    }, $t.prototype._getEndoRoots = function(t) {
      var r = t === this.p ? this.red : K2.mont(t), i2 = new K2(2).toRed(r).redInvm(), n3 = i2.redNeg(), o2 = new K2(3).toRed(r).redNeg().redSqrt().redMul(i2), h5 = n3.redAdd(o2).fromRed(), p3 = n3.redSub(o2).fromRed();
      return [h5, p3];
    }, $t.prototype._getEndoBasis = function(t) {
      for (var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), i2 = t, n3 = this.n.clone(), o2 = new K2(1), h5 = new K2(0), p3 = new K2(0), b4 = new K2(1), g3, w4, y4, S4, I2, N10, R2, F = 0, U2, Q; i2.cmpn(0) !== 0; ) {
        var Bt = n3.div(i2);
        U2 = n3.sub(Bt.mul(i2)), Q = p3.sub(Bt.mul(o2));
        var J = b4.sub(Bt.mul(h5));
        if (!y4 && U2.cmp(r) < 0)
          g3 = R2.neg(), w4 = o2, y4 = U2.neg(), S4 = Q;
        else if (y4 && ++F === 2)
          break;
        R2 = U2, n3 = i2, i2 = U2, p3 = o2, o2 = Q, b4 = h5, h5 = J;
      }
      I2 = U2.neg(), N10 = Q;
      var H = y4.sqr().add(S4.sqr()), L2 = I2.sqr().add(N10.sqr());
      return L2.cmp(H) >= 0 && (I2 = g3, N10 = w4), y4.negative && (y4 = y4.neg(), S4 = S4.neg()), I2.negative && (I2 = I2.neg(), N10 = N10.neg()), [{ a: y4, b: S4 }, { a: I2, b: N10 }];
    }, $t.prototype._endoSplit = function(t) {
      var r = this.endo.basis, i2 = r[0], n3 = r[1], o2 = n3.b.mul(t).divRound(this.n), h5 = i2.b.neg().mul(t).divRound(this.n), p3 = o2.mul(i2.a), b4 = h5.mul(n3.a), g3 = o2.mul(i2.b), w4 = h5.mul(n3.b), y4 = t.sub(p3).sub(b4), S4 = g3.add(w4).neg();
      return { k1: y4, k2: S4 };
    }, $t.prototype.pointFromX = function(t, r) {
      t = new K2(t, 16), t.red || (t = t.toRed(this.red));
      var i2 = t.redSqr().redMul(t).redIAdd(t.redMul(this.a)).redIAdd(this.b), n3 = i2.redSqrt();
      if (n3.redSqr().redSub(i2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var o2 = n3.fromRed().isOdd();
      return (r && !o2 || !r && o2) && (n3 = n3.redNeg()), this.point(t, n3);
    }, $t.prototype.validate = function(t) {
      if (t.inf)
        return true;
      var r = t.x, i2 = t.y, n3 = this.a.redMul(r), o2 = r.redSqr().redMul(r).redIAdd(n3).redIAdd(this.b);
      return i2.redSqr().redISub(o2).cmpn(0) === 0;
    }, $t.prototype._endoWnafMulAdd = function(t, r, i2) {
      for (var n3 = this._endoWnafT1, o2 = this._endoWnafT2, h5 = 0; h5 < t.length; h5++) {
        var p3 = this._endoSplit(r[h5]), b4 = t[h5], g3 = b4._getBeta();
        p3.k1.negative && (p3.k1.ineg(), b4 = b4.neg(true)), p3.k2.negative && (p3.k2.ineg(), g3 = g3.neg(true)), n3[h5 * 2] = b4, n3[h5 * 2 + 1] = g3, o2[h5 * 2] = p3.k1, o2[h5 * 2 + 1] = p3.k2;
      }
      for (var w4 = this._wnafMulAdd(1, n3, o2, h5 * 2, i2), y4 = 0; y4 < h5 * 2; y4++)
        n3[y4] = null, o2[y4] = null;
      return w4;
    };
    function Dt(e2, t, r, i2) {
      Xe.BasePoint.call(this, e2, "affine"), t === null && r === null ? (this.x = null, this.y = null, this.inf = true) : (this.x = new K2(t, 16), this.y = new K2(r, 16), i2 && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = false);
    }
    Fi(Dt, Xe.BasePoint), $t.prototype.point = function(t, r, i2) {
      return new Dt(this, t, r, i2);
    }, $t.prototype.pointFromJSON = function(t, r) {
      return Dt.fromJSON(this, t, r);
    }, Dt.prototype._getBeta = function() {
      if (this.curve.endo) {
        var t = this.precomputed;
        if (t && t.beta)
          return t.beta;
        var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (t) {
          var i2 = this.curve, n3 = function(o2) {
            return i2.point(o2.x.redMul(i2.endo.beta), o2.y);
          };
          t.beta = r, r.precomputed = { beta: null, naf: t.naf && { wnd: t.naf.wnd, points: t.naf.points.map(n3) }, doubles: t.doubles && { step: t.doubles.step, points: t.doubles.points.map(n3) } };
        }
        return r;
      }
    }, Dt.prototype.toJSON = function() {
      return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y];
    }, Dt.fromJSON = function(t, r, i2) {
      typeof r == "string" && (r = JSON.parse(r));
      var n3 = t.point(r[0], r[1], i2);
      if (!r[2])
        return n3;
      function o2(p3) {
        return t.point(p3[0], p3[1], i2);
      }
      var h5 = r[2];
      return n3.precomputed = { beta: null, doubles: h5.doubles && { step: h5.doubles.step, points: [n3].concat(h5.doubles.points.map(o2)) }, naf: h5.naf && { wnd: h5.naf.wnd, points: [n3].concat(h5.naf.points.map(o2)) } }, n3;
    }, Dt.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    }, Dt.prototype.isInfinity = function() {
      return this.inf;
    }, Dt.prototype.add = function(t) {
      if (this.inf)
        return t;
      if (t.inf)
        return this;
      if (this.eq(t))
        return this.dbl();
      if (this.neg().eq(t))
        return this.curve.point(null, null);
      if (this.x.cmp(t.x) === 0)
        return this.curve.point(null, null);
      var r = this.y.redSub(t.y);
      r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(t.x).redInvm()));
      var i2 = r.redSqr().redISub(this.x).redISub(t.x), n3 = r.redMul(this.x.redSub(i2)).redISub(this.y);
      return this.curve.point(i2, n3);
    }, Dt.prototype.dbl = function() {
      if (this.inf)
        return this;
      var t = this.y.redAdd(this.y);
      if (t.cmpn(0) === 0)
        return this.curve.point(null, null);
      var r = this.curve.a, i2 = this.x.redSqr(), n3 = t.redInvm(), o2 = i2.redAdd(i2).redIAdd(i2).redIAdd(r).redMul(n3), h5 = o2.redSqr().redISub(this.x.redAdd(this.x)), p3 = o2.redMul(this.x.redSub(h5)).redISub(this.y);
      return this.curve.point(h5, p3);
    }, Dt.prototype.getX = function() {
      return this.x.fromRed();
    }, Dt.prototype.getY = function() {
      return this.y.fromRed();
    }, Dt.prototype.mul = function(t) {
      return t = new K2(t, 16), this.isInfinity() ? this : this._hasDoubles(t) ? this.curve._fixedNafMul(this, t) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [t]) : this.curve._wnafMul(this, t);
    }, Dt.prototype.mulAdd = function(t, r, i2) {
      var n3 = [this, r], o2 = [t, i2];
      return this.curve.endo ? this.curve._endoWnafMulAdd(n3, o2) : this.curve._wnafMulAdd(1, n3, o2, 2);
    }, Dt.prototype.jmulAdd = function(t, r, i2) {
      var n3 = [this, r], o2 = [t, i2];
      return this.curve.endo ? this.curve._endoWnafMulAdd(n3, o2, true) : this.curve._wnafMulAdd(1, n3, o2, 2, true);
    }, Dt.prototype.eq = function(t) {
      return this === t || this.inf === t.inf && (this.inf || this.x.cmp(t.x) === 0 && this.y.cmp(t.y) === 0);
    }, Dt.prototype.neg = function(t) {
      if (this.inf)
        return this;
      var r = this.curve.point(this.x, this.y.redNeg());
      if (t && this.precomputed) {
        var i2 = this.precomputed, n3 = function(o2) {
          return o2.neg();
        };
        r.precomputed = { naf: i2.naf && { wnd: i2.naf.wnd, points: i2.naf.points.map(n3) }, doubles: i2.doubles && { step: i2.doubles.step, points: i2.doubles.points.map(n3) } };
      }
      return r;
    }, Dt.prototype.toJ = function() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var t = this.curve.jpoint(this.x, this.y, this.curve.one);
      return t;
    };
    function Ut(e2, t, r, i2) {
      Xe.BasePoint.call(this, e2, "jacobian"), t === null && r === null && i2 === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new K2(0)) : (this.x = new K2(t, 16), this.y = new K2(r, 16), this.z = new K2(i2, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
    }
    Fi(Ut, Xe.BasePoint), $t.prototype.jpoint = function(t, r, i2) {
      return new Ut(this, t, r, i2);
    }, Ut.prototype.toP = function() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var t = this.z.redInvm(), r = t.redSqr(), i2 = this.x.redMul(r), n3 = this.y.redMul(r).redMul(t);
      return this.curve.point(i2, n3);
    }, Ut.prototype.neg = function() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    }, Ut.prototype.add = function(t) {
      if (this.isInfinity())
        return t;
      if (t.isInfinity())
        return this;
      var r = t.z.redSqr(), i2 = this.z.redSqr(), n3 = this.x.redMul(r), o2 = t.x.redMul(i2), h5 = this.y.redMul(r.redMul(t.z)), p3 = t.y.redMul(i2.redMul(this.z)), b4 = n3.redSub(o2), g3 = h5.redSub(p3);
      if (b4.cmpn(0) === 0)
        return g3.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
      var w4 = b4.redSqr(), y4 = w4.redMul(b4), S4 = n3.redMul(w4), I2 = g3.redSqr().redIAdd(y4).redISub(S4).redISub(S4), N10 = g3.redMul(S4.redISub(I2)).redISub(h5.redMul(y4)), R2 = this.z.redMul(t.z).redMul(b4);
      return this.curve.jpoint(I2, N10, R2);
    }, Ut.prototype.mixedAdd = function(t) {
      if (this.isInfinity())
        return t.toJ();
      if (t.isInfinity())
        return this;
      var r = this.z.redSqr(), i2 = this.x, n3 = t.x.redMul(r), o2 = this.y, h5 = t.y.redMul(r).redMul(this.z), p3 = i2.redSub(n3), b4 = o2.redSub(h5);
      if (p3.cmpn(0) === 0)
        return b4.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
      var g3 = p3.redSqr(), w4 = g3.redMul(p3), y4 = i2.redMul(g3), S4 = b4.redSqr().redIAdd(w4).redISub(y4).redISub(y4), I2 = b4.redMul(y4.redISub(S4)).redISub(o2.redMul(w4)), N10 = this.z.redMul(p3);
      return this.curve.jpoint(S4, I2, N10);
    }, Ut.prototype.dblp = function(t) {
      if (t === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!t)
        return this.dbl();
      var r;
      if (this.curve.zeroA || this.curve.threeA) {
        var i2 = this;
        for (r = 0; r < t; r++)
          i2 = i2.dbl();
        return i2;
      }
      var n3 = this.curve.a, o2 = this.curve.tinv, h5 = this.x, p3 = this.y, b4 = this.z, g3 = b4.redSqr().redSqr(), w4 = p3.redAdd(p3);
      for (r = 0; r < t; r++) {
        var y4 = h5.redSqr(), S4 = w4.redSqr(), I2 = S4.redSqr(), N10 = y4.redAdd(y4).redIAdd(y4).redIAdd(n3.redMul(g3)), R2 = h5.redMul(S4), F = N10.redSqr().redISub(R2.redAdd(R2)), U2 = R2.redISub(F), Q = N10.redMul(U2);
        Q = Q.redIAdd(Q).redISub(I2);
        var Bt = w4.redMul(b4);
        r + 1 < t && (g3 = g3.redMul(I2)), h5 = F, b4 = Bt, w4 = Q;
      }
      return this.curve.jpoint(h5, w4.redMul(o2), b4);
    }, Ut.prototype.dbl = function() {
      return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
    }, Ut.prototype._zeroDbl = function() {
      var t, r, i2;
      if (this.zOne) {
        var n3 = this.x.redSqr(), o2 = this.y.redSqr(), h5 = o2.redSqr(), p3 = this.x.redAdd(o2).redSqr().redISub(n3).redISub(h5);
        p3 = p3.redIAdd(p3);
        var b4 = n3.redAdd(n3).redIAdd(n3), g3 = b4.redSqr().redISub(p3).redISub(p3), w4 = h5.redIAdd(h5);
        w4 = w4.redIAdd(w4), w4 = w4.redIAdd(w4), t = g3, r = b4.redMul(p3.redISub(g3)).redISub(w4), i2 = this.y.redAdd(this.y);
      } else {
        var y4 = this.x.redSqr(), S4 = this.y.redSqr(), I2 = S4.redSqr(), N10 = this.x.redAdd(S4).redSqr().redISub(y4).redISub(I2);
        N10 = N10.redIAdd(N10);
        var R2 = y4.redAdd(y4).redIAdd(y4), F = R2.redSqr(), U2 = I2.redIAdd(I2);
        U2 = U2.redIAdd(U2), U2 = U2.redIAdd(U2), t = F.redISub(N10).redISub(N10), r = R2.redMul(N10.redISub(t)).redISub(U2), i2 = this.y.redMul(this.z), i2 = i2.redIAdd(i2);
      }
      return this.curve.jpoint(t, r, i2);
    }, Ut.prototype._threeDbl = function() {
      var t, r, i2;
      if (this.zOne) {
        var n3 = this.x.redSqr(), o2 = this.y.redSqr(), h5 = o2.redSqr(), p3 = this.x.redAdd(o2).redSqr().redISub(n3).redISub(h5);
        p3 = p3.redIAdd(p3);
        var b4 = n3.redAdd(n3).redIAdd(n3).redIAdd(this.curve.a), g3 = b4.redSqr().redISub(p3).redISub(p3);
        t = g3;
        var w4 = h5.redIAdd(h5);
        w4 = w4.redIAdd(w4), w4 = w4.redIAdd(w4), r = b4.redMul(p3.redISub(g3)).redISub(w4), i2 = this.y.redAdd(this.y);
      } else {
        var y4 = this.z.redSqr(), S4 = this.y.redSqr(), I2 = this.x.redMul(S4), N10 = this.x.redSub(y4).redMul(this.x.redAdd(y4));
        N10 = N10.redAdd(N10).redIAdd(N10);
        var R2 = I2.redIAdd(I2);
        R2 = R2.redIAdd(R2);
        var F = R2.redAdd(R2);
        t = N10.redSqr().redISub(F), i2 = this.y.redAdd(this.z).redSqr().redISub(S4).redISub(y4);
        var U2 = S4.redSqr();
        U2 = U2.redIAdd(U2), U2 = U2.redIAdd(U2), U2 = U2.redIAdd(U2), r = N10.redMul(R2.redISub(t)).redISub(U2);
      }
      return this.curve.jpoint(t, r, i2);
    }, Ut.prototype._dbl = function() {
      var t = this.curve.a, r = this.x, i2 = this.y, n3 = this.z, o2 = n3.redSqr().redSqr(), h5 = r.redSqr(), p3 = i2.redSqr(), b4 = h5.redAdd(h5).redIAdd(h5).redIAdd(t.redMul(o2)), g3 = r.redAdd(r);
      g3 = g3.redIAdd(g3);
      var w4 = g3.redMul(p3), y4 = b4.redSqr().redISub(w4.redAdd(w4)), S4 = w4.redISub(y4), I2 = p3.redSqr();
      I2 = I2.redIAdd(I2), I2 = I2.redIAdd(I2), I2 = I2.redIAdd(I2);
      var N10 = b4.redMul(S4).redISub(I2), R2 = i2.redAdd(i2).redMul(n3);
      return this.curve.jpoint(y4, N10, R2);
    }, Ut.prototype.trpl = function() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var t = this.x.redSqr(), r = this.y.redSqr(), i2 = this.z.redSqr(), n3 = r.redSqr(), o2 = t.redAdd(t).redIAdd(t), h5 = o2.redSqr(), p3 = this.x.redAdd(r).redSqr().redISub(t).redISub(n3);
      p3 = p3.redIAdd(p3), p3 = p3.redAdd(p3).redIAdd(p3), p3 = p3.redISub(h5);
      var b4 = p3.redSqr(), g3 = n3.redIAdd(n3);
      g3 = g3.redIAdd(g3), g3 = g3.redIAdd(g3), g3 = g3.redIAdd(g3);
      var w4 = o2.redIAdd(p3).redSqr().redISub(h5).redISub(b4).redISub(g3), y4 = r.redMul(w4);
      y4 = y4.redIAdd(y4), y4 = y4.redIAdd(y4);
      var S4 = this.x.redMul(b4).redISub(y4);
      S4 = S4.redIAdd(S4), S4 = S4.redIAdd(S4);
      var I2 = this.y.redMul(w4.redMul(g3.redISub(w4)).redISub(p3.redMul(b4)));
      I2 = I2.redIAdd(I2), I2 = I2.redIAdd(I2), I2 = I2.redIAdd(I2);
      var N10 = this.z.redAdd(p3).redSqr().redISub(i2).redISub(b4);
      return this.curve.jpoint(S4, I2, N10);
    }, Ut.prototype.mul = function(t, r) {
      return t = new K2(t, r), this.curve._wnafMul(this, t);
    }, Ut.prototype.eq = function(t) {
      if (t.type === "affine")
        return this.eq(t.toJ());
      if (this === t)
        return true;
      var r = this.z.redSqr(), i2 = t.z.redSqr();
      if (this.x.redMul(i2).redISub(t.x.redMul(r)).cmpn(0) !== 0)
        return false;
      var n3 = r.redMul(this.z), o2 = i2.redMul(t.z);
      return this.y.redMul(o2).redISub(t.y.redMul(n3)).cmpn(0) === 0;
    }, Ut.prototype.eqXToP = function(t) {
      var r = this.z.redSqr(), i2 = t.toRed(this.curve.red).redMul(r);
      if (this.x.cmp(i2) === 0)
        return true;
      for (var n3 = t.clone(), o2 = this.curve.redN.redMul(r); ; ) {
        if (n3.iadd(this.curve.n), n3.cmp(this.curve.p) >= 0)
          return false;
        if (i2.redIAdd(o2), this.x.cmp(i2) === 0)
          return true;
      }
    }, Ut.prototype.inspect = function() {
      return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    }, Ut.prototype.isInfinity = function() {
      return this.z.cmpn(0) === 0;
    };
    var Kr = lr(function(e2, t) {
      var r = t;
      r.base = Xe, r.short = T0, r.mont = null, r.edwards = null;
    });
    var Hr = lr(function(e2, t) {
      var r = t, i2 = Jt.assert;
      function n3(p3) {
        p3.type === "short" ? this.curve = new Kr.short(p3) : p3.type === "edwards" ? this.curve = new Kr.edwards(p3) : this.curve = new Kr.mont(p3), this.g = this.curve.g, this.n = this.curve.n, this.hash = p3.hash, i2(this.g.validate(), "Invalid curve"), i2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
      }
      r.PresetCurve = n3;
      function o2(p3, b4) {
        Object.defineProperty(r, p3, { configurable: true, enumerable: true, get: function() {
          var g3 = new n3(b4);
          return Object.defineProperty(r, p3, { configurable: true, enumerable: true, value: g3 }), g3;
        } });
      }
      o2("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: oe.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] }), o2("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: oe.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] }), o2("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: oe.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] }), o2("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: oe.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] }), o2("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: oe.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] }), o2("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: oe.sha256, gRed: false, g: ["9"] }), o2("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: oe.sha256, gRed: false, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
      var h5;
      try {
        h5 = null.crash();
      } catch {
        h5 = void 0;
      }
      o2("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: oe.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: false, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", h5] });
    });
    function Re(e2) {
      if (!(this instanceof Re))
        return new Re(e2);
      this.hash = e2.hash, this.predResist = !!e2.predResist, this.outLen = this.hash.outSize, this.minEntropy = e2.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
      var t = ne.toArray(e2.entropy, e2.entropyEnc || "hex"), r = ne.toArray(e2.nonce, e2.nonceEnc || "hex"), i2 = ne.toArray(e2.pers, e2.persEnc || "hex");
      Ti(t.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(t, r, i2);
    }
    var If = Re;
    Re.prototype._init = function(t, r, i2) {
      var n3 = t.concat(r).concat(i2);
      this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
      for (var o2 = 0; o2 < this.V.length; o2++)
        this.K[o2] = 0, this.V[o2] = 1;
      this._update(n3), this._reseed = 1, this.reseedInterval = 281474976710656;
    }, Re.prototype._hmac = function() {
      return new oe.hmac(this.hash, this.K);
    }, Re.prototype._update = function(t) {
      var r = this._hmac().update(this.V).update([0]);
      t && (r = r.update(t)), this.K = r.digest(), this.V = this._hmac().update(this.V).digest(), t && (this.K = this._hmac().update(this.V).update([1]).update(t).digest(), this.V = this._hmac().update(this.V).digest());
    }, Re.prototype.reseed = function(t, r, i2, n3) {
      typeof r != "string" && (n3 = i2, i2 = r, r = null), t = ne.toArray(t, r), i2 = ne.toArray(i2, n3), Ti(t.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(t.concat(i2 || [])), this._reseed = 1;
    }, Re.prototype.generate = function(t, r, i2, n3) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      typeof r != "string" && (n3 = i2, i2 = r, r = null), i2 && (i2 = ne.toArray(i2, n3 || "hex"), this._update(i2));
      for (var o2 = []; o2.length < t; )
        this.V = this._hmac().update(this.V).digest(), o2 = o2.concat(this.V);
      var h5 = o2.slice(0, t);
      return this._update(i2), this._reseed++, ne.encode(h5, r);
    };
    var Di = Jt.assert;
    function qt(e2, t) {
      this.ec = e2, this.priv = null, this.pub = null, t.priv && this._importPrivate(t.priv, t.privEnc), t.pub && this._importPublic(t.pub, t.pubEnc);
    }
    var Ui = qt;
    qt.fromPublic = function(t, r, i2) {
      return r instanceof qt ? r : new qt(t, { pub: r, pubEnc: i2 });
    }, qt.fromPrivate = function(t, r, i2) {
      return r instanceof qt ? r : new qt(t, { priv: r, privEnc: i2 });
    }, qt.prototype.validate = function() {
      var t = this.getPublic();
      return t.isInfinity() ? { result: false, reason: "Invalid public key" } : t.validate() ? t.mul(this.ec.curve.n).isInfinity() ? { result: true, reason: null } : { result: false, reason: "Public key * N != O" } : { result: false, reason: "Public key is not a point" };
    }, qt.prototype.getPublic = function(t, r) {
      return typeof t == "string" && (r = t, t = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, t) : this.pub;
    }, qt.prototype.getPrivate = function(t) {
      return t === "hex" ? this.priv.toString(16, 2) : this.priv;
    }, qt.prototype._importPrivate = function(t, r) {
      this.priv = new K2(t, r || 16), this.priv = this.priv.umod(this.ec.curve.n);
    }, qt.prototype._importPublic = function(t, r) {
      if (t.x || t.y) {
        this.ec.curve.type === "mont" ? Di(t.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && Di(t.x && t.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(t.x, t.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(t, r);
    }, qt.prototype.derive = function(t) {
      return t.validate() || Di(t.validate(), "public point not validated"), t.mul(this.priv).getX();
    }, qt.prototype.sign = function(t, r, i2) {
      return this.ec.sign(t, this, r, i2);
    }, qt.prototype.verify = function(t, r) {
      return this.ec.verify(t, r, this);
    }, qt.prototype.inspect = function() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
    var F0 = Jt.assert;
    function Lr(e2, t) {
      if (e2 instanceof Lr)
        return e2;
      this._importDER(e2, t) || (F0(e2.r && e2.s, "Signature without r or s"), this.r = new K2(e2.r, 16), this.s = new K2(e2.s, 16), e2.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = e2.recoveryParam);
    }
    var zr = Lr;
    function D0() {
      this.place = 0;
    }
    function ki(e2, t) {
      var r = e2[t.place++];
      if (!(r & 128))
        return r;
      var i2 = r & 15;
      if (i2 === 0 || i2 > 4)
        return false;
      for (var n3 = 0, o2 = 0, h5 = t.place; o2 < i2; o2++, h5++)
        n3 <<= 8, n3 |= e2[h5], n3 >>>= 0;
      return n3 <= 127 ? false : (t.place = h5, n3);
    }
    function _f(e2) {
      for (var t = 0, r = e2.length - 1; !e2[t] && !(e2[t + 1] & 128) && t < r; )
        t++;
      return t === 0 ? e2 : e2.slice(t);
    }
    Lr.prototype._importDER = function(t, r) {
      t = Jt.toArray(t, r);
      var i2 = new D0();
      if (t[i2.place++] !== 48)
        return false;
      var n3 = ki(t, i2);
      if (n3 === false || n3 + i2.place !== t.length || t[i2.place++] !== 2)
        return false;
      var o2 = ki(t, i2);
      if (o2 === false)
        return false;
      var h5 = t.slice(i2.place, o2 + i2.place);
      if (i2.place += o2, t[i2.place++] !== 2)
        return false;
      var p3 = ki(t, i2);
      if (p3 === false || t.length !== p3 + i2.place)
        return false;
      var b4 = t.slice(i2.place, p3 + i2.place);
      if (h5[0] === 0)
        if (h5[1] & 128)
          h5 = h5.slice(1);
        else
          return false;
      if (b4[0] === 0)
        if (b4[1] & 128)
          b4 = b4.slice(1);
        else
          return false;
      return this.r = new K2(h5), this.s = new K2(b4), this.recoveryParam = null, true;
    };
    function qi(e2, t) {
      if (t < 128) {
        e2.push(t);
        return;
      }
      var r = 1 + (Math.log(t) / Math.LN2 >>> 3);
      for (e2.push(r | 128); --r; )
        e2.push(t >>> (r << 3) & 255);
      e2.push(t);
    }
    Lr.prototype.toDER = function(t) {
      var r = this.r.toArray(), i2 = this.s.toArray();
      for (r[0] & 128 && (r = [0].concat(r)), i2[0] & 128 && (i2 = [0].concat(i2)), r = _f(r), i2 = _f(i2); !i2[0] && !(i2[1] & 128); )
        i2 = i2.slice(1);
      var n3 = [2];
      qi(n3, r.length), n3 = n3.concat(r), n3.push(2), qi(n3, i2.length);
      var o2 = n3.concat(i2), h5 = [48];
      return qi(h5, o2.length), h5 = h5.concat(o2), Jt.encode(h5, t);
    };
    var U0 = function() {
      throw new Error("unsupported");
    };
    var Bf = Jt.assert;
    function te(e2) {
      if (!(this instanceof te))
        return new te(e2);
      typeof e2 == "string" && (Bf(Object.prototype.hasOwnProperty.call(Hr, e2), "Unknown curve " + e2), e2 = Hr[e2]), e2 instanceof Hr.PresetCurve && (e2 = { curve: e2 }), this.curve = e2.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = e2.curve.g, this.g.precompute(e2.curve.n.bitLength() + 1), this.hash = e2.hash || e2.curve.hash;
    }
    var k0 = te;
    te.prototype.keyPair = function(t) {
      return new Ui(this, t);
    }, te.prototype.keyFromPrivate = function(t, r) {
      return Ui.fromPrivate(this, t, r);
    }, te.prototype.keyFromPublic = function(t, r) {
      return Ui.fromPublic(this, t, r);
    }, te.prototype.genKeyPair = function(t) {
      t || (t = {});
      for (var r = new If({ hash: this.hash, pers: t.pers, persEnc: t.persEnc || "utf8", entropy: t.entropy || U0(this.hash.hmacStrength), entropyEnc: t.entropy && t.entropyEnc || "utf8", nonce: this.n.toArray() }), i2 = this.n.byteLength(), n3 = this.n.sub(new K2(2)); ; ) {
        var o2 = new K2(r.generate(i2));
        if (!(o2.cmp(n3) > 0))
          return o2.iaddn(1), this.keyFromPrivate(o2);
      }
    }, te.prototype._truncateToN = function(t, r) {
      var i2 = t.byteLength() * 8 - this.n.bitLength();
      return i2 > 0 && (t = t.ushrn(i2)), !r && t.cmp(this.n) >= 0 ? t.sub(this.n) : t;
    }, te.prototype.sign = function(t, r, i2, n3) {
      typeof i2 == "object" && (n3 = i2, i2 = null), n3 || (n3 = {}), r = this.keyFromPrivate(r, i2), t = this._truncateToN(new K2(t, 16));
      for (var o2 = this.n.byteLength(), h5 = r.getPrivate().toArray("be", o2), p3 = t.toArray("be", o2), b4 = new If({ hash: this.hash, entropy: h5, nonce: p3, pers: n3.pers, persEnc: n3.persEnc || "utf8" }), g3 = this.n.sub(new K2(1)), w4 = 0; ; w4++) {
        var y4 = n3.k ? n3.k(w4) : new K2(b4.generate(this.n.byteLength()));
        if (y4 = this._truncateToN(y4, true), !(y4.cmpn(1) <= 0 || y4.cmp(g3) >= 0)) {
          var S4 = this.g.mul(y4);
          if (!S4.isInfinity()) {
            var I2 = S4.getX(), N10 = I2.umod(this.n);
            if (N10.cmpn(0) !== 0) {
              var R2 = y4.invm(this.n).mul(N10.mul(r.getPrivate()).iadd(t));
              if (R2 = R2.umod(this.n), R2.cmpn(0) !== 0) {
                var F = (S4.getY().isOdd() ? 1 : 0) | (I2.cmp(N10) !== 0 ? 2 : 0);
                return n3.canonical && R2.cmp(this.nh) > 0 && (R2 = this.n.sub(R2), F ^= 1), new zr({ r: N10, s: R2, recoveryParam: F });
              }
            }
          }
        }
      }
    }, te.prototype.verify = function(t, r, i2, n3) {
      t = this._truncateToN(new K2(t, 16)), i2 = this.keyFromPublic(i2, n3), r = new zr(r, "hex");
      var o2 = r.r, h5 = r.s;
      if (o2.cmpn(1) < 0 || o2.cmp(this.n) >= 0 || h5.cmpn(1) < 0 || h5.cmp(this.n) >= 0)
        return false;
      var p3 = h5.invm(this.n), b4 = p3.mul(t).umod(this.n), g3 = p3.mul(o2).umod(this.n), w4;
      return this.curve._maxwellTrick ? (w4 = this.g.jmulAdd(b4, i2.getPublic(), g3), w4.isInfinity() ? false : w4.eqXToP(o2)) : (w4 = this.g.mulAdd(b4, i2.getPublic(), g3), w4.isInfinity() ? false : w4.getX().umod(this.n).cmp(o2) === 0);
    }, te.prototype.recoverPubKey = function(e2, t, r, i2) {
      Bf((3 & r) === r, "The recovery param is more than two bits"), t = new zr(t, i2);
      var n3 = this.n, o2 = new K2(e2), h5 = t.r, p3 = t.s, b4 = r & 1, g3 = r >> 1;
      if (h5.cmp(this.curve.p.umod(this.curve.n)) >= 0 && g3)
        throw new Error("Unable to find sencond key candinate");
      g3 ? h5 = this.curve.pointFromX(h5.add(this.curve.n), b4) : h5 = this.curve.pointFromX(h5, b4);
      var w4 = t.r.invm(n3), y4 = n3.sub(o2).mul(w4).umod(n3), S4 = p3.mul(w4).umod(n3);
      return this.g.mulAdd(y4, h5, S4);
    }, te.prototype.getKeyRecoveryParam = function(e2, t, r, i2) {
      if (t = new zr(t, i2), t.recoveryParam !== null)
        return t.recoveryParam;
      for (var n3 = 0; n3 < 4; n3++) {
        var o2;
        try {
          o2 = this.recoverPubKey(e2, t, n3);
        } catch {
          continue;
        }
        if (o2.eq(r))
          return n3;
      }
      throw new Error("Unable to find valid recovery factor");
    };
    var q0 = lr(function(e2, t) {
      var r = t;
      r.version = "6.5.4", r.utils = Jt, r.rand = function() {
        throw new Error("unsupported");
      }, r.curve = Kr, r.curves = Hr, r.ec = k0, r.eddsa = null;
    });
    var K0 = q0.ec;
    var H0 = "signing-key/5.7.0";
    var Ki = new z3(H0);
    var Hi = null;
    function pe() {
      return Hi || (Hi = new K0("secp256k1")), Hi;
    }
    var L0 = class {
      constructor(t) {
        yr(this, "curve", "secp256k1"), yr(this, "privateKey", Ht(t)), xs(this.privateKey) !== 32 && Ki.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
        const r = pe().keyFromPrivate(Pt(this.privateKey));
        yr(this, "publicKey", "0x" + r.getPublic(false, "hex")), yr(this, "compressedPublicKey", "0x" + r.getPublic(true, "hex")), yr(this, "_isSigningKey", true);
      }
      _addPoint(t) {
        const r = pe().keyFromPublic(Pt(this.publicKey)), i2 = pe().keyFromPublic(Pt(t));
        return "0x" + r.pub.add(i2.pub).encodeCompressed("hex");
      }
      signDigest(t) {
        const r = pe().keyFromPrivate(Pt(this.privateKey)), i2 = Pt(t);
        i2.length !== 32 && Ki.throwArgumentError("bad digest length", "digest", t);
        const n3 = r.sign(i2, { canonical: true });
        return kn({ recoveryParam: n3.recoveryParam, r: fe("0x" + n3.r.toString(16), 32), s: fe("0x" + n3.s.toString(16), 32) });
      }
      computeSharedSecret(t) {
        const r = pe().keyFromPrivate(Pt(this.privateKey)), i2 = pe().keyFromPublic(Pt(Rf(t)));
        return fe("0x" + r.derive(i2.getPublic()).toString(16), 32);
      }
      static isSigningKey(t) {
        return !!(t && t._isSigningKey);
      }
    };
    function z0(e2, t) {
      const r = kn(t), i2 = { r: Pt(r.r), s: Pt(r.s) };
      return "0x" + pe().recoverPubKey(Pt(e2), i2, r.recoveryParam).encode("hex", false);
    }
    function Rf(e2, t) {
      const r = Pt(e2);
      if (r.length === 32) {
        const i2 = new L0(r);
        return t ? "0x" + pe().keyFromPrivate(r).getPublic(true, "hex") : i2.publicKey;
      } else {
        if (r.length === 33)
          return t ? Ht(r) : "0x" + pe().keyFromPublic(r).getPublic(false, "hex");
        if (r.length === 65)
          return t ? "0x" + pe().keyFromPublic(r).getPublic(true, "hex") : Ht(r);
      }
      return Ki.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
    }
    var j0 = "transactions/5.7.0";
    new z3(j0);
    var Cf;
    (function(e2) {
      e2[e2.legacy = 0] = "legacy", e2[e2.eip2930 = 1] = "eip2930", e2[e2.eip1559 = 2] = "eip1559";
    })(Cf || (Cf = {}));
    function V0(e2) {
      const t = Rf(e2);
      return ta(Un(wi(Un(t, 1)), 12));
    }
    function Q0(e2, t) {
      return V0(z0(Pt(e2), t));
    }
    var J0 = "https://rpc.walletconnect.com/v1";
    async function Of(e2, t, r, i2, n3, o2) {
      switch (r.t) {
        case "eip191":
          return Pf(e2, t, r.s);
        case "eip1271":
          return await Tf(e2, t, r.s, i2, n3, o2);
        default:
          throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${r.t}`);
      }
    }
    function Pf(e2, t, r) {
      return Q0(tf(t), r).toLowerCase() === e2.toLowerCase();
    }
    async function Tf(e2, t, r, i2, n3, o2) {
      try {
        const h5 = "0x1626ba7e", p3 = "0000000000000000000000000000000000000000000000000000000000000040", b4 = "0000000000000000000000000000000000000000000000000000000000000041", g3 = r.substring(2), w4 = tf(t).substring(2), y4 = h5 + w4 + p3 + b4 + g3, S4 = await fetch(`${o2 || J0}/?chainId=${i2}&projectId=${n3}`, { method: "POST", body: JSON.stringify({ id: Y0(), jsonrpc: "2.0", method: "eth_call", params: [{ to: e2, data: y4 }, "latest"] }) }), { result: I2 } = await S4.json();
        return I2 ? I2.slice(0, h5.length).toLowerCase() === h5.toLowerCase() : false;
      } catch (h5) {
        return console.error("isValidEip1271Signature: ", h5), false;
      }
    }
    function Y0() {
      return Date.now() + Math.floor(Math.random() * 1e3);
    }
    var G0 = Object.defineProperty;
    var W0 = Object.defineProperties;
    var X0 = Object.getOwnPropertyDescriptors;
    var Ff = Object.getOwnPropertySymbols;
    var Z0 = Object.prototype.hasOwnProperty;
    var $0 = Object.prototype.propertyIsEnumerable;
    var Df = (e2, t, r) => t in e2 ? G0(e2, t, { enumerable: true, configurable: true, writable: true, value: r }) : e2[t] = r;
    var Li = (e2, t) => {
      for (var r in t || (t = {}))
        Z0.call(t, r) && Df(e2, r, t[r]);
      if (Ff)
        for (var r of Ff(t))
          $0.call(t, r) && Df(e2, r, t[r]);
      return e2;
    };
    var Uf = (e2, t) => W0(e2, X0(t));
    var tu = "did:pkh:";
    var jr = (e2) => e2?.split(":");
    var zi = (e2) => {
      const t = e2 && jr(e2);
      if (t)
        return e2.includes(tu) ? t[3] : t[1];
    };
    var eu = (e2) => {
      const t = e2 && jr(e2);
      if (t)
        return t[2] + ":" + t[3];
    };
    var ji = (e2) => {
      const t = e2 && jr(e2);
      if (t)
        return t.pop();
    };
    async function ru(e2) {
      const { cacao: t, projectId: r } = e2, { s: i2, p: n3 } = t, o2 = kf(n3, n3.iss), h5 = ji(n3.iss);
      return await Of(h5, o2, i2, zi(n3.iss), r);
    }
    var kf = (e2, t) => {
      const r = `${e2.domain} wants you to sign in with your Ethereum account:`, i2 = ji(t);
      if (!e2.aud && !e2.uri)
        throw new Error("Either `aud` or `uri` is required to construct the message");
      let n3 = e2.statement || void 0;
      const o2 = `URI: ${e2.aud || e2.uri}`, h5 = `Version: ${e2.version}`, p3 = `Chain ID: ${zi(t)}`, b4 = `Nonce: ${e2.nonce}`, g3 = `Issued At: ${e2.iat}`, w4 = e2.resources ? `Resources:${e2.resources.map((S4) => `
- ${S4}`).join("")}` : void 0, y4 = Qr(e2.resources);
      if (y4) {
        const S4 = Ce(y4);
        n3 = Ji(n3, S4);
      }
      return [r, i2, "", n3, "", o2, h5, p3, b4, g3, w4].filter((S4) => S4 != null).join(`
`);
    };
    function iu(e2, t, r) {
      return r.includes("did:pkh:") || (r = `did:pkh:${r}`), { h: { t: "caip122" }, p: { iss: r, domain: e2.domain, aud: e2.aud, version: e2.version, nonce: e2.nonce, iat: e2.iat, statement: e2.statement, requestId: e2.requestId, resources: e2.resources, nbf: e2.nbf, exp: e2.exp }, s: t };
    }
    function nu(e2) {
      var t;
      const { authPayload: r, chains: i2, methods: n3 } = e2, o2 = r.statement || "";
      if (!(i2 != null && i2.length))
        return r;
      const h5 = r.chains, p3 = mi(h5, i2);
      if (!(p3 != null && p3.length))
        throw new Error("No supported chains");
      const b4 = qf(r.resources);
      if (!b4)
        return r;
      ve(b4);
      const g3 = Kf(b4, "eip155");
      let w4 = r?.resources || [];
      if (g3 != null && g3.length) {
        const y4 = Hf(g3), S4 = mi(y4, n3);
        if (!(S4 != null && S4.length))
          throw new Error(`Supported methods don't satisfy the requested: ${JSON.stringify(y4)}, supported: ${JSON.stringify(n3)}`);
        const I2 = Vi("request", S4, { chains: p3 }), N10 = Vf(b4, "eip155", I2);
        w4 = ((t = r?.resources) == null ? void 0 : t.slice(0, -1)) || [], w4.push(Vr(N10));
      }
      return Uf(Li({}, r), { statement: Jf(o2, Qr(w4)), chains: p3, resources: r != null && r.resources || w4.length > 0 ? w4 : void 0 });
    }
    function qf(e2) {
      const t = Qr(e2);
      if (t && Qi(t))
        return Ce(t);
    }
    function fu(e2, t) {
      var r;
      return (r = e2?.att) == null ? void 0 : r.hasOwnProperty(t);
    }
    function Kf(e2, t) {
      var r, i2;
      return (r = e2?.att) != null && r[t] ? Object.keys((i2 = e2?.att) == null ? void 0 : i2[t]) : [];
    }
    function ou(e2) {
      return e2?.map((t) => Object.keys(t)) || [];
    }
    function Hf(e2) {
      return e2?.map((t) => {
        var r;
        return (r = t.split("/")) == null ? void 0 : r[1];
      }) || [];
    }
    function Lf(e2) {
      return import_buffer.Buffer.from(JSON.stringify(e2)).toString("base64");
    }
    function zf(e2) {
      return JSON.parse(import_buffer.Buffer.from(e2, "base64").toString("utf-8"));
    }
    function ve(e2) {
      if (!e2)
        throw new Error("No recap provided, value is undefined");
      if (!e2.att)
        throw new Error("No `att` property found");
      const t = Object.keys(e2.att);
      if (!(t != null && t.length))
        throw new Error("No resources found in `att` property");
      t.forEach((r) => {
        const i2 = e2.att[r];
        if (Array.isArray(i2))
          throw new Error(`Resource must be an object: ${r}`);
        if (typeof i2 != "object")
          throw new Error(`Resource must be an object: ${r}`);
        if (!Object.keys(i2).length)
          throw new Error(`Resource object is empty: ${r}`);
        Object.keys(i2).forEach((n3) => {
          const o2 = i2[n3];
          if (!Array.isArray(o2))
            throw new Error(`Ability limits ${n3} must be an array of objects, found: ${o2}`);
          if (!o2.length)
            throw new Error(`Value of ${n3} is empty array, must be an array with objects`);
          o2.forEach((h5) => {
            if (typeof h5 != "object")
              throw new Error(`Ability limits (${n3}) must be an array of objects, found: ${h5}`);
          });
        });
      });
    }
    function jf(e2, t, r, i2 = {}) {
      return r?.sort((n3, o2) => n3.localeCompare(o2)), { att: { [e2]: Vi(t, r, i2) } };
    }
    function Vf(e2, t, r) {
      var i2;
      return e2.att[t] = Li({}, r), ((i2 = Object.keys(e2.att)) == null ? void 0 : i2.sort((n3, o2) => n3.localeCompare(o2))).reduce((n3, o2) => (n3.att[o2] = e2.att[o2], n3), { att: {} });
    }
    function Vi(e2, t, r = {}) {
      t = t?.sort((n3, o2) => n3.localeCompare(o2));
      const i2 = t.map((n3) => ({ [`${e2}/${n3}`]: [r] }));
      return Object.assign({}, ...i2);
    }
    function Vr(e2) {
      return ve(e2), `urn:recap:${Lf(e2).replace(/=/g, "")}`;
    }
    function Ce(e2) {
      const t = zf(e2.replace("urn:recap:", ""));
      return ve(t), t;
    }
    function su(e2, t, r) {
      const i2 = jf(e2, t, r);
      return Vr(i2);
    }
    function Qi(e2) {
      return e2 && e2.includes("urn:recap:");
    }
    function au(e2, t) {
      const r = Ce(e2), i2 = Ce(t), n3 = Qf(r, i2);
      return Vr(n3);
    }
    function Qf(e2, t) {
      ve(e2), ve(t);
      const r = Object.keys(e2.att).concat(Object.keys(t.att)).sort((n3, o2) => n3.localeCompare(o2)), i2 = { att: {} };
      return r.forEach((n3) => {
        var o2, h5;
        Object.keys(((o2 = e2.att) == null ? void 0 : o2[n3]) || {}).concat(Object.keys(((h5 = t.att) == null ? void 0 : h5[n3]) || {})).sort((p3, b4) => p3.localeCompare(b4)).forEach((p3) => {
          var b4, g3;
          i2.att[n3] = Uf(Li({}, i2.att[n3]), { [p3]: ((b4 = e2.att[n3]) == null ? void 0 : b4[p3]) || ((g3 = t.att[n3]) == null ? void 0 : g3[p3]) });
        });
      }), i2;
    }
    function Ji(e2 = "", t) {
      ve(t);
      const r = "I further authorize the stated URI to perform the following actions on my behalf: ";
      if (e2.includes(r))
        return e2;
      const i2 = [];
      let n3 = 0;
      Object.keys(t.att).forEach((p3) => {
        const b4 = Object.keys(t.att[p3]).map((y4) => ({ ability: y4.split("/")[0], action: y4.split("/")[1] }));
        b4.sort((y4, S4) => y4.action.localeCompare(S4.action));
        const g3 = {};
        b4.forEach((y4) => {
          g3[y4.ability] || (g3[y4.ability] = []), g3[y4.ability].push(y4.action);
        });
        const w4 = Object.keys(g3).map((y4) => (n3++, `(${n3}) '${y4}': '${g3[y4].join("', '")}' for '${p3}'.`));
        i2.push(w4.join(", ").replace(".,", "."));
      });
      const o2 = i2.join(" "), h5 = `${r}${o2}`;
      return `${e2 ? e2 + " " : ""}${h5}`;
    }
    function uu(e2) {
      var t;
      const r = Ce(e2);
      ve(r);
      const i2 = (t = r.att) == null ? void 0 : t.eip155;
      return i2 ? Object.keys(i2).map((n3) => n3.split("/")[1]) : [];
    }
    function hu(e2) {
      const t = Ce(e2);
      ve(t);
      const r = [];
      return Object.values(t.att).forEach((i2) => {
        Object.values(i2).forEach((n3) => {
          var o2;
          (o2 = n3?.[0]) != null && o2.chains && r.push(n3[0].chains);
        });
      }), [...new Set(r.flat())];
    }
    function Jf(e2, t) {
      if (!t)
        return e2;
      const r = Ce(t);
      return ve(r), Ji(e2, r);
    }
    function Qr(e2) {
      if (!e2)
        return;
      const t = e2?.[e2.length - 1];
      return Qi(t) ? t : void 0;
    }
    var Yi = "base10";
    var zt = "base16";
    var Jr = "base64pad";
    var Yr = "utf8";
    var Gi = 0;
    var dr = 1;
    var cu = 0;
    var Yf = 1;
    var Wi = 12;
    var Xi = 32;
    function lu() {
      const e2 = an.generateKeyPair();
      return { privateKey: Rt.toString(e2.secretKey, zt), publicKey: Rt.toString(e2.publicKey, zt) };
    }
    function du() {
      const e2 = on.randomBytes(Xi);
      return Rt.toString(e2, zt);
    }
    function pu(e2, t) {
      const r = an.sharedKey(Rt.fromString(e2, zt), Rt.fromString(t, zt), true), i2 = new Po.HKDF(ci.SHA256, r).expand(Xi);
      return Rt.toString(i2, zt);
    }
    function vu(e2) {
      const t = ci.hash(Rt.fromString(e2, zt));
      return Rt.toString(t, zt);
    }
    function gu(e2) {
      const t = ci.hash(Rt.fromString(e2, Yr));
      return Rt.toString(t, zt);
    }
    function Gf(e2) {
      return Rt.fromString(`${e2}`, Yi);
    }
    function Er(e2) {
      return Number(Rt.toString(e2, Yi));
    }
    function mu(e2) {
      const t = Gf(typeof e2.type < "u" ? e2.type : Gi);
      if (Er(t) === dr && typeof e2.senderPublicKey > "u")
        throw new Error("Missing sender public key for type 1 envelope");
      const r = typeof e2.senderPublicKey < "u" ? Rt.fromString(e2.senderPublicKey, zt) : void 0, i2 = typeof e2.iv < "u" ? Rt.fromString(e2.iv, zt) : on.randomBytes(Wi), n3 = new fn.ChaCha20Poly1305(Rt.fromString(e2.symKey, zt)).seal(i2, Rt.fromString(e2.message, Yr));
      return Wf({ type: t, sealed: n3, iv: i2, senderPublicKey: r });
    }
    function Au(e2) {
      const t = new fn.ChaCha20Poly1305(Rt.fromString(e2.symKey, zt)), { sealed: r, iv: i2 } = Zi(e2.encoded), n3 = t.open(i2, r);
      if (n3 === null)
        throw new Error("Failed to decrypt");
      return Rt.toString(n3, Yr);
    }
    function Wf(e2) {
      if (Er(e2.type) === dr) {
        if (typeof e2.senderPublicKey > "u")
          throw new Error("Missing sender public key for type 1 envelope");
        return Rt.toString(Rt.concat([e2.type, e2.senderPublicKey, e2.iv, e2.sealed]), Jr);
      }
      return Rt.toString(Rt.concat([e2.type, e2.iv, e2.sealed]), Jr);
    }
    function Zi(e2) {
      const t = Rt.fromString(e2, Jr), r = t.slice(cu, Yf), i2 = Yf;
      if (Er(r) === dr) {
        const p3 = i2 + Xi, b4 = p3 + Wi, g3 = t.slice(i2, p3), w4 = t.slice(p3, b4), y4 = t.slice(b4);
        return { type: r, sealed: y4, iv: w4, senderPublicKey: g3 };
      }
      const n3 = i2 + Wi, o2 = t.slice(i2, n3), h5 = t.slice(n3);
      return { type: r, sealed: h5, iv: o2 };
    }
    function bu(e2, t) {
      const r = Zi(e2);
      return Xf({ type: Er(r.type), senderPublicKey: typeof r.senderPublicKey < "u" ? Rt.toString(r.senderPublicKey, zt) : void 0, receiverPublicKey: t?.receiverPublicKey });
    }
    function Xf(e2) {
      const t = e2?.type || Gi;
      if (t === dr) {
        if (typeof e2?.senderPublicKey > "u")
          throw new Error("missing sender public key");
        if (typeof e2?.receiverPublicKey > "u")
          throw new Error("missing receiver public key");
      }
      return { type: t, senderPublicKey: e2?.senderPublicKey, receiverPublicKey: e2?.receiverPublicKey };
    }
    function yu(e2) {
      return e2.type === dr && typeof e2.senderPublicKey == "string" && typeof e2.receiverPublicKey == "string";
    }
    var Zf = "irn";
    function wu(e2) {
      return e2?.relay || { protocol: Zf };
    }
    function xu(e2) {
      const t = Fo.RELAY_JSONRPC[e2];
      if (typeof t > "u")
        throw new Error(`Relay Protocol not supported: ${e2}`);
      return t;
    }
    var Mu = Object.defineProperty;
    var Eu = Object.defineProperties;
    var Su = Object.getOwnPropertyDescriptors;
    var $f = Object.getOwnPropertySymbols;
    var Nu = Object.prototype.hasOwnProperty;
    var Iu = Object.prototype.propertyIsEnumerable;
    var to = (e2, t, r) => t in e2 ? Mu(e2, t, { enumerable: true, configurable: true, writable: true, value: r }) : e2[t] = r;
    var eo = (e2, t) => {
      for (var r in t || (t = {}))
        Nu.call(t, r) && to(e2, r, t[r]);
      if ($f)
        for (var r of $f(t))
          Iu.call(t, r) && to(e2, r, t[r]);
      return e2;
    };
    var _u = (e2, t) => Eu(e2, Su(t));
    function ro(e2, t = "-") {
      const r = {}, i2 = "relay" + t;
      return Object.keys(e2).forEach((n3) => {
        if (n3.startsWith(i2)) {
          const o2 = n3.replace(i2, ""), h5 = e2[n3];
          r[o2] = h5;
        }
      }), r;
    }
    function Bu(e2) {
      e2 = e2.includes("wc://") ? e2.replace("wc://", "") : e2, e2 = e2.includes("wc:") ? e2.replace("wc:", "") : e2;
      const t = e2.indexOf(":"), r = e2.indexOf("?") !== -1 ? e2.indexOf("?") : void 0, i2 = e2.substring(0, t), n3 = e2.substring(t + 1, r).split("@"), o2 = typeof r < "u" ? e2.substring(r) : "", h5 = Ir.parse(o2), p3 = typeof h5.methods == "string" ? h5.methods.split(",") : void 0;
      return { protocol: i2, topic: io(n3[0]), version: parseInt(n3[1], 10), symKey: h5.symKey, relay: ro(h5), methods: p3, expiryTimestamp: h5.expiryTimestamp ? parseInt(h5.expiryTimestamp, 10) : void 0 };
    }
    function io(e2) {
      return e2.startsWith("//") ? e2.substring(2) : e2;
    }
    function no(e2, t = "-") {
      const r = "relay", i2 = {};
      return Object.keys(e2).forEach((n3) => {
        const o2 = r + t + n3;
        e2[n3] && (i2[o2] = e2[n3]);
      }), i2;
    }
    function Ru(e2) {
      return `${e2.protocol}:${e2.topic}@${e2.version}?` + Ir.stringify(eo(_u(eo({ symKey: e2.symKey }, no(e2.relay)), { expiryTimestamp: e2.expiryTimestamp }), e2.methods ? { methods: e2.methods.join(",") } : {}));
    }
    var Cu = Object.defineProperty;
    var Ou = Object.defineProperties;
    var Pu = Object.getOwnPropertyDescriptors;
    var fo = Object.getOwnPropertySymbols;
    var Tu = Object.prototype.hasOwnProperty;
    var Fu = Object.prototype.propertyIsEnumerable;
    var oo = (e2, t, r) => t in e2 ? Cu(e2, t, { enumerable: true, configurable: true, writable: true, value: r }) : e2[t] = r;
    var Du = (e2, t) => {
      for (var r in t || (t = {}))
        Tu.call(t, r) && oo(e2, r, t[r]);
      if (fo)
        for (var r of fo(t))
          Fu.call(t, r) && oo(e2, r, t[r]);
      return e2;
    };
    var Uu = (e2, t) => Ou(e2, Pu(t));
    function Ze(e2) {
      const t = [];
      return e2.forEach((r) => {
        const [i2, n3] = r.split(":");
        t.push(`${i2}:${n3}`);
      }), t;
    }
    function so(e2) {
      const t = [];
      return Object.values(e2).forEach((r) => {
        t.push(...Ze(r.accounts));
      }), t;
    }
    function ao(e2, t) {
      const r = [];
      return Object.values(e2).forEach((i2) => {
        Ze(i2.accounts).includes(t) && r.push(...i2.methods);
      }), r;
    }
    function uo(e2, t) {
      const r = [];
      return Object.values(e2).forEach((i2) => {
        Ze(i2.accounts).includes(t) && r.push(...i2.events);
      }), r;
    }
    function ku(e2, t) {
      const r = wo(e2, t);
      if (r)
        throw new Error(r.message);
      const i2 = {};
      for (const [n3, o2] of Object.entries(e2))
        i2[n3] = { methods: o2.methods, events: o2.events, chains: o2.accounts.map((h5) => `${h5.split(":")[0]}:${h5.split(":")[1]}`) };
      return i2;
    }
    function qu(e2) {
      const { proposal: { requiredNamespaces: t, optionalNamespaces: r = {} }, supportedNamespaces: i2 } = e2, n3 = tn(t), o2 = tn(r), h5 = {};
      Object.keys(i2).forEach((g3) => {
        const w4 = i2[g3].chains, y4 = i2[g3].methods, S4 = i2[g3].events, I2 = i2[g3].accounts;
        w4.forEach((N10) => {
          if (!I2.some((R2) => R2.includes(N10)))
            throw new Error(`No accounts provided for chain ${N10} in namespace ${g3}`);
        }), h5[g3] = { chains: w4, methods: y4, events: S4, accounts: I2 };
      });
      const p3 = Mo(t, h5, "approve()");
      if (p3)
        throw new Error(p3.message);
      const b4 = {};
      return !Object.keys(t).length && !Object.keys(r).length ? h5 : (Object.keys(n3).forEach((g3) => {
        const w4 = i2[g3].chains.filter((N10) => {
          var R2, F;
          return (F = (R2 = n3[g3]) == null ? void 0 : R2.chains) == null ? void 0 : F.includes(N10);
        }), y4 = i2[g3].methods.filter((N10) => {
          var R2, F;
          return (F = (R2 = n3[g3]) == null ? void 0 : R2.methods) == null ? void 0 : F.includes(N10);
        }), S4 = i2[g3].events.filter((N10) => {
          var R2, F;
          return (F = (R2 = n3[g3]) == null ? void 0 : R2.events) == null ? void 0 : F.includes(N10);
        }), I2 = w4.map((N10) => i2[g3].accounts.filter((R2) => R2.includes(`${N10}:`))).flat();
        b4[g3] = { chains: w4, methods: y4, events: S4, accounts: I2 };
      }), Object.keys(o2).forEach((g3) => {
        var w4, y4, S4, I2, N10, R2;
        if (!i2[g3])
          return;
        const F = (y4 = (w4 = o2[g3]) == null ? void 0 : w4.chains) == null ? void 0 : y4.filter((J) => i2[g3].chains.includes(J)), U2 = i2[g3].methods.filter((J) => {
          var H, L2;
          return (L2 = (H = o2[g3]) == null ? void 0 : H.methods) == null ? void 0 : L2.includes(J);
        }), Q = i2[g3].events.filter((J) => {
          var H, L2;
          return (L2 = (H = o2[g3]) == null ? void 0 : H.events) == null ? void 0 : L2.includes(J);
        }), Bt = F?.map((J) => i2[g3].accounts.filter((H) => H.includes(`${J}:`))).flat();
        b4[g3] = { chains: ge((S4 = b4[g3]) == null ? void 0 : S4.chains, F), methods: ge((I2 = b4[g3]) == null ? void 0 : I2.methods, U2), events: ge((N10 = b4[g3]) == null ? void 0 : N10.events, Q), accounts: ge((R2 = b4[g3]) == null ? void 0 : R2.accounts, Bt) };
      }), b4);
    }
    function $i(e2) {
      return e2.includes(":");
    }
    function ho(e2) {
      return $i(e2) ? e2.split(":")[0] : e2;
    }
    function tn(e2) {
      var t, r, i2;
      const n3 = {};
      if (!Gr(e2))
        return n3;
      for (const [o2, h5] of Object.entries(e2)) {
        const p3 = $i(o2) ? [o2] : h5.chains, b4 = h5.methods || [], g3 = h5.events || [], w4 = ho(o2);
        n3[w4] = Uu(Du({}, n3[w4]), { chains: ge(p3, (t = n3[w4]) == null ? void 0 : t.chains), methods: ge(b4, (r = n3[w4]) == null ? void 0 : r.methods), events: ge(g3, (i2 = n3[w4]) == null ? void 0 : i2.events) });
      }
      return n3;
    }
    function co(e2) {
      const t = {};
      return e2?.forEach((r) => {
        const [i2, n3] = r.split(":");
        t[i2] || (t[i2] = { accounts: [], chains: [], events: [] }), t[i2].accounts.push(r), t[i2].chains.push(`${i2}:${n3}`);
      }), t;
    }
    function Ku(e2, t) {
      t = t.map((i2) => i2.replace("did:pkh:", ""));
      const r = co(t);
      for (const [i2, n3] of Object.entries(r))
        n3.methods ? n3.methods = ge(n3.methods, e2) : n3.methods = e2, n3.events = ["chainChanged", "accountsChanged"];
      return r;
    }
    var lo = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
    var po = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
    function we(e2, t) {
      const { message: r, code: i2 } = po[e2];
      return { message: t ? `${r} ${t}` : r, code: i2 };
    }
    function $e(e2, t) {
      const { message: r, code: i2 } = lo[e2];
      return { message: t ? `${r} ${t}` : r, code: i2 };
    }
    function Sr(e2, t) {
      return Array.isArray(e2) ? typeof t < "u" && e2.length ? e2.every(t) : true : false;
    }
    function Gr(e2) {
      return Object.getPrototypeOf(e2) === Object.prototype && Object.keys(e2).length;
    }
    function Oe(e2) {
      return typeof e2 > "u";
    }
    function Yt(e2, t) {
      return t && Oe(e2) ? true : typeof e2 == "string" && !!e2.trim().length;
    }
    function Wr(e2, t) {
      return t && Oe(e2) ? true : typeof e2 == "number" && !isNaN(e2);
    }
    function Hu(e2, t) {
      const { requiredNamespaces: r } = t, i2 = Object.keys(e2.namespaces), n3 = Object.keys(r);
      let o2 = true;
      return Ie(n3, i2) ? (i2.forEach((h5) => {
        const { accounts: p3, methods: b4, events: g3 } = e2.namespaces[h5], w4 = Ze(p3), y4 = r[h5];
        (!Ie(Br(h5, y4), w4) || !Ie(y4.methods, b4) || !Ie(y4.events, g3)) && (o2 = false);
      }), o2) : false;
    }
    function Nr(e2) {
      return Yt(e2, false) && e2.includes(":") ? e2.split(":").length === 2 : false;
    }
    function vo(e2) {
      if (Yt(e2, false) && e2.includes(":")) {
        const t = e2.split(":");
        if (t.length === 3) {
          const r = t[0] + ":" + t[1];
          return !!t[2] && Nr(r);
        }
      }
      return false;
    }
    function Lu(e2) {
      if (Yt(e2, false))
        try {
          return typeof new URL(e2) < "u";
        } catch {
          return false;
        }
      return false;
    }
    function zu(e2) {
      var t;
      return (t = e2?.proposer) == null ? void 0 : t.publicKey;
    }
    function ju(e2) {
      return e2?.topic;
    }
    function Vu(e2, t) {
      let r = null;
      return Yt(e2?.publicKey, false) || (r = we("MISSING_OR_INVALID", `${t} controller public key should be a string`)), r;
    }
    function en(e2) {
      let t = true;
      return Sr(e2) ? e2.length && (t = e2.every((r) => Yt(r, false))) : t = false, t;
    }
    function go(e2, t, r) {
      let i2 = null;
      return Sr(t) && t.length ? t.forEach((n3) => {
        i2 || Nr(n3) || (i2 = $e("UNSUPPORTED_CHAINS", `${r}, chain ${n3} should be a string and conform to "namespace:chainId" format`));
      }) : Nr(e2) || (i2 = $e("UNSUPPORTED_CHAINS", `${r}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), i2;
    }
    function mo(e2, t, r) {
      let i2 = null;
      return Object.entries(e2).forEach(([n3, o2]) => {
        if (i2)
          return;
        const h5 = go(n3, Br(n3, o2), `${t} ${r}`);
        h5 && (i2 = h5);
      }), i2;
    }
    function Ao(e2, t) {
      let r = null;
      return Sr(e2) ? e2.forEach((i2) => {
        r || vo(i2) || (r = $e("UNSUPPORTED_ACCOUNTS", `${t}, account ${i2} should be a string and conform to "namespace:chainId:address" format`));
      }) : r = $e("UNSUPPORTED_ACCOUNTS", `${t}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), r;
    }
    function bo(e2, t) {
      let r = null;
      return Object.values(e2).forEach((i2) => {
        if (r)
          return;
        const n3 = Ao(i2?.accounts, `${t} namespace`);
        n3 && (r = n3);
      }), r;
    }
    function yo(e2, t) {
      let r = null;
      return en(e2?.methods) ? en(e2?.events) || (r = $e("UNSUPPORTED_EVENTS", `${t}, events should be an array of strings or empty array for no events`)) : r = $e("UNSUPPORTED_METHODS", `${t}, methods should be an array of strings or empty array for no methods`), r;
    }
    function rn(e2, t) {
      let r = null;
      return Object.values(e2).forEach((i2) => {
        if (r)
          return;
        const n3 = yo(i2, `${t}, namespace`);
        n3 && (r = n3);
      }), r;
    }
    function Qu(e2, t, r) {
      let i2 = null;
      if (e2 && Gr(e2)) {
        const n3 = rn(e2, t);
        n3 && (i2 = n3);
        const o2 = mo(e2, t, r);
        o2 && (i2 = o2);
      } else
        i2 = we("MISSING_OR_INVALID", `${t}, ${r} should be an object with data`);
      return i2;
    }
    function wo(e2, t) {
      let r = null;
      if (e2 && Gr(e2)) {
        const i2 = rn(e2, t);
        i2 && (r = i2);
        const n3 = bo(e2, t);
        n3 && (r = n3);
      } else
        r = we("MISSING_OR_INVALID", `${t}, namespaces should be an object with data`);
      return r;
    }
    function xo(e2) {
      return Yt(e2.protocol, true);
    }
    function Ju(e2, t) {
      let r = false;
      return t && !e2 ? r = true : e2 && Sr(e2) && e2.length && e2.forEach((i2) => {
        r = xo(i2);
      }), r;
    }
    function Yu(e2) {
      return typeof e2 == "number";
    }
    function Gu(e2) {
      return typeof e2 < "u" && typeof e2 !== null;
    }
    function Wu(e2) {
      return !(!e2 || typeof e2 != "object" || !e2.code || !Wr(e2.code, false) || !e2.message || !Yt(e2.message, false));
    }
    function Xu(e2) {
      return !(Oe(e2) || !Yt(e2.method, false));
    }
    function Zu(e2) {
      return !(Oe(e2) || Oe(e2.result) && Oe(e2.error) || !Wr(e2.id, false) || !Yt(e2.jsonrpc, false));
    }
    function $u(e2) {
      return !(Oe(e2) || !Yt(e2.name, false));
    }
    function th(e2, t) {
      return !(!Nr(t) || !so(e2).includes(t));
    }
    function eh(e2, t, r) {
      return Yt(r, false) ? ao(e2, t).includes(r) : false;
    }
    function rh(e2, t, r) {
      return Yt(r, false) ? uo(e2, t).includes(r) : false;
    }
    function Mo(e2, t, r) {
      let i2 = null;
      const n3 = ih(e2), o2 = nh(t), h5 = Object.keys(n3), p3 = Object.keys(o2), b4 = Eo(Object.keys(e2)), g3 = Eo(Object.keys(t)), w4 = b4.filter((y4) => !g3.includes(y4));
      return w4.length && (i2 = we("NON_CONFORMING_NAMESPACES", `${r} namespaces keys don't satisfy requiredNamespaces.
      Required: ${w4.toString()}
      Received: ${Object.keys(t).toString()}`)), Ie(h5, p3) || (i2 = we("NON_CONFORMING_NAMESPACES", `${r} namespaces chains don't satisfy required namespaces.
      Required: ${h5.toString()}
      Approved: ${p3.toString()}`)), Object.keys(t).forEach((y4) => {
        if (!y4.includes(":") || i2)
          return;
        const S4 = Ze(t[y4].accounts);
        S4.includes(y4) || (i2 = we("NON_CONFORMING_NAMESPACES", `${r} namespaces accounts don't satisfy namespace accounts for ${y4}
        Required: ${y4}
        Approved: ${S4.toString()}`));
      }), h5.forEach((y4) => {
        i2 || (Ie(n3[y4].methods, o2[y4].methods) ? Ie(n3[y4].events, o2[y4].events) || (i2 = we("NON_CONFORMING_NAMESPACES", `${r} namespaces events don't satisfy namespace events for ${y4}`)) : i2 = we("NON_CONFORMING_NAMESPACES", `${r} namespaces methods don't satisfy namespace methods for ${y4}`));
      }), i2;
    }
    function ih(e2) {
      const t = {};
      return Object.keys(e2).forEach((r) => {
        var i2;
        r.includes(":") ? t[r] = e2[r] : (i2 = e2[r].chains) == null || i2.forEach((n3) => {
          t[n3] = { methods: e2[r].methods, events: e2[r].events };
        });
      }), t;
    }
    function Eo(e2) {
      return [...new Set(e2.map((t) => t.includes(":") ? t.split(":")[0] : t))];
    }
    function nh(e2) {
      const t = {};
      return Object.keys(e2).forEach((r) => {
        if (r.includes(":"))
          t[r] = e2[r];
        else {
          const i2 = Ze(e2[r].accounts);
          i2?.forEach((n3) => {
            t[n3] = { accounts: e2[r].accounts.filter((o2) => o2.includes(`${n3}:`)), methods: e2[r].methods, events: e2[r].events };
          });
        }
      }), t;
    }
    function fh(e2, t) {
      return Wr(e2, false) && e2 <= t.max && e2 >= t.min;
    }
    function oh() {
      const e2 = Ge();
      return new Promise((t) => {
        switch (e2) {
          case Kt.browser:
            t(So());
            break;
          case Kt.reactNative:
            t(No());
            break;
          case Kt.node:
            t(Io());
            break;
          default:
            t(true);
        }
      });
    }
    function So() {
      return vr() && navigator?.onLine;
    }
    async function No() {
      if (rr() && typeof global < "u" && global != null && global.NetInfo) {
        const e2 = await (global == null ? void 0 : global.NetInfo.fetch());
        return e2?.isConnected;
      }
      return true;
    }
    function Io() {
      return true;
    }
    function sh(e2) {
      switch (Ge()) {
        case Kt.browser:
          _o(e2);
          break;
        case Kt.reactNative:
          Bo(e2);
          break;
        case Kt.node:
          break;
      }
    }
    function _o(e2) {
      !rr() && vr() && (window.addEventListener("online", () => e2(true)), window.addEventListener("offline", () => e2(false)));
    }
    function Bo(e2) {
      rr() && typeof global < "u" && global != null && global.NetInfo && global?.NetInfo.addEventListener((t) => e2(t?.isConnected));
    }
    var nn = {};
    var ah = class {
      static get(t) {
        return nn[t];
      }
      static set(t, r) {
        nn[t] = r;
      }
      static delete(t) {
        delete nn[t];
      }
    };
    exports2.BASE10 = Yi, exports2.BASE16 = zt, exports2.BASE64 = Jr, exports2.COLON = jo, exports2.DEFAULT_DEPTH = pi, exports2.EMPTY_SPACE = Rr, exports2.ENV_MAP = Kt, exports2.INTERNAL_ERRORS = po, exports2.MemoryStore = ah, exports2.ONE_THOUSAND = Vo, exports2.REACT_NATIVE_PRODUCT = An, exports2.RELAYER_DEFAULT_PROTOCOL = Zf, exports2.SDK_ERRORS = lo, exports2.SDK_TYPE = yn, exports2.SLASH = bn, exports2.TYPE_0 = Gi, exports2.TYPE_1 = dr, exports2.UTF8 = Yr, exports2.addResourceToRecap = Vf, exports2.appendToQueryString = wn, exports2.assertType = Xo, exports2.assignAbilityToActions = Vi, exports2.base64Decode = zf, exports2.base64Encode = Lf, exports2.buildApprovedNamespaces = qu, exports2.buildAuthObject = iu, exports2.buildNamespacesFromAuth = Ku, exports2.buildRecapStatement = Jf, exports2.calcExpiry = us, exports2.capitalize = is, exports2.capitalizeWord = In, exports2.createDelayedPromise = ns, exports2.createEncodedRecap = su, exports2.createExpiringPromise = fs, exports2.createRecap = jf, exports2.decodeRecap = Ce, exports2.decodeTypeByte = Er, exports2.decrypt = Au, exports2.deriveSymKey = pu, exports2.deserialize = Zi, exports2.encodeRecap = Vr, exports2.encodeTypeByte = Gf, exports2.encrypt = mu, exports2.engineEvent = cs, exports2.enumify = rs, exports2.formatAccountId = cn, exports2.formatAccountWithChain = Do, exports2.formatChainId = hn, exports2.formatExpirerTarget = gi, exports2.formatIdTarget = ss, exports2.formatMessage = kf, exports2.formatMessageContext = Zo, exports2.formatRelayParams = no, exports2.formatRelayRpcUrl = Go, exports2.formatStatementFromRecap = Ji, exports2.formatTopicTarget = os, exports2.formatUA = En, exports2.formatUri = Ru, exports2.generateKeyPair = lu, exports2.generateRandomBytes32 = du, exports2.getAccountsChains = Ze, exports2.getAccountsFromNamespaces = ko, exports2.getAddressFromAccount = ln, exports2.getAddressesFromAccounts = Uo, exports2.getAppMetadata = Jo, exports2.getBrowserOnlineStatus = So, exports2.getBundleId = Qo, exports2.getChainFromAccount = dn, exports2.getChainsFromAccounts = pn, exports2.getChainsFromNamespace = Br, exports2.getChainsFromNamespaces = qo, exports2.getChainsFromRecap = hu, exports2.getChainsFromRequiredNamespaces = Ko, exports2.getCommonValuesInArrays = mi, exports2.getDecodedRecapFromResources = qf, exports2.getDeepLink = ds, exports2.getDidAddress = ji, exports2.getDidAddressSegments = jr, exports2.getDidChainId = zi, exports2.getEnvironment = Ge, exports2.getHttpUrl = Wo, exports2.getInternalError = we, exports2.getJavascriptID = Mn, exports2.getJavascriptOS = xn, exports2.getLastItems = Nn, exports2.getMethodsFromRecap = uu, exports2.getNamespacedDidChainId = eu, exports2.getNamespacesChains = so, exports2.getNamespacesEventsForChainId = uo, exports2.getNamespacesFromAccounts = co, exports2.getNamespacesMethodsForChainId = ao, exports2.getNodeOnlineStatus = Io, exports2.getReCapActions = Hf, exports2.getReactNativeOnlineStatus = No, exports2.getRecapAbilitiesFromResource = ou, exports2.getRecapFromResources = Qr, exports2.getRecapResource = Kf, exports2.getRelayClientMetadata = Yo, exports2.getRelayProtocolApi = xu, exports2.getRelayProtocolName = wu, exports2.getRequiredNamespacesFromNamespaces = ku, exports2.getSdkError = $e, exports2.getUniqueValues = di, exports2.handleDeeplinkRedirect = ls2, exports2.hasOverlap = Ie, exports2.hashKey = vu, exports2.hashMessage = gu, exports2.isBrowser = vr, exports2.isCaipNamespace = $i, exports2.isConformingNamespaces = Mo, exports2.isExpired = hs, exports2.isNode = vi, exports2.isOnline = oh, exports2.isProposalStruct = zu, exports2.isReactNative = rr, exports2.isRecap = Qi, exports2.isSessionCompatible = Hu, exports2.isSessionStruct = ju, exports2.isTypeOneEnvelope = yu, exports2.isUndefined = Oe, exports2.isValidAccountId = vo, exports2.isValidAccounts = Ao, exports2.isValidActions = yo, exports2.isValidArray = Sr, exports2.isValidChainId = Nr, exports2.isValidChains = go, exports2.isValidController = Vu, exports2.isValidEip1271Signature = Tf, exports2.isValidEip191Signature = Pf, exports2.isValidErrorReason = Wu, exports2.isValidEvent = $u, exports2.isValidId = Yu, exports2.isValidNamespaceAccounts = bo, exports2.isValidNamespaceActions = rn, exports2.isValidNamespaceChains = mo, exports2.isValidNamespaceMethodsOrEvents = en, exports2.isValidNamespaces = wo, exports2.isValidNamespacesChainId = th, exports2.isValidNamespacesEvent = rh, exports2.isValidNamespacesRequest = eh, exports2.isValidNumber = Wr, exports2.isValidObject = Gr, exports2.isValidParams = Gu, exports2.isValidRecap = ve, exports2.isValidRelay = xo, exports2.isValidRelays = Ju, exports2.isValidRequest = Xu, exports2.isValidRequestExpiry = fh, exports2.isValidRequiredNamespaces = Qu, exports2.isValidResponse = Zu, exports2.isValidString = Yt, exports2.isValidUrl = Lu, exports2.mapEntries = es, exports2.mapToObj = $o, exports2.mergeArrays = ge, exports2.mergeEncodedRecaps = au, exports2.mergeRecaps = Qf, exports2.normalizeNamespaces = tn, exports2.objToMap = ts, exports2.parseAccountId = li, exports2.parseChainId = un, exports2.parseContextNames = Sn, exports2.parseExpirerTarget = as, exports2.parseNamespaceKey = ho, exports2.parseRelayParams = ro, exports2.parseTopic = io, exports2.parseUri = Bu, exports2.populateAuthPayload = nu, exports2.recapHasResource = fu, exports2.serialize = Wf, exports2.subscribeToBrowserNetworkChange = _o, exports2.subscribeToNetworkChange = sh, exports2.subscribeToReactNativeNetworkChange = Bo, exports2.validateDecoding = bu, exports2.validateEncoding = Xf, exports2.validateSignedCacao = ru, exports2.verifySignature = Of;
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/constants.js
var PARSE_ERROR, INVALID_REQUEST, METHOD_NOT_FOUND, INVALID_PARAMS, INTERNAL_ERROR, SERVER_ERROR, RESERVED_ERROR_CODES, SERVER_ERROR_CODE_RANGE, STANDARD_ERROR_MAP, DEFAULT_ERROR;
var init_constants2 = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/constants.js"() {
    init_shim();
    PARSE_ERROR = "PARSE_ERROR";
    INVALID_REQUEST = "INVALID_REQUEST";
    METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
    INVALID_PARAMS = "INVALID_PARAMS";
    INTERNAL_ERROR = "INTERNAL_ERROR";
    SERVER_ERROR = "SERVER_ERROR";
    RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
    SERVER_ERROR_CODE_RANGE = [-32e3, -32099];
    STANDARD_ERROR_MAP = {
      [PARSE_ERROR]: { code: -32700, message: "Parse error" },
      [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
      [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
      [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
      [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
      [SERVER_ERROR]: { code: -32e3, message: "Server error" }
    };
    DEFAULT_ERROR = SERVER_ERROR;
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js
function isServerErrorCode(code2) {
  return code2 <= SERVER_ERROR_CODE_RANGE[0] && code2 >= SERVER_ERROR_CODE_RANGE[1];
}
function isReservedErrorCode(code2) {
  return RESERVED_ERROR_CODES.includes(code2);
}
function isValidErrorCode(code2) {
  return typeof code2 === "number";
}
function getError(type) {
  if (!Object.keys(STANDARD_ERROR_MAP).includes(type)) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return STANDARD_ERROR_MAP[type];
}
function getErrorByCode(code2) {
  const match = Object.values(STANDARD_ERROR_MAP).find((e2) => e2.code === code2);
  if (!match) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return match;
}
function validateJsonRpcError(response) {
  if (typeof response.error.code === "undefined") {
    return { valid: false, error: "Missing code for JSON-RPC error" };
  }
  if (typeof response.error.message === "undefined") {
    return { valid: false, error: "Missing message for JSON-RPC error" };
  }
  if (!isValidErrorCode(response.error.code)) {
    return {
      valid: false,
      error: `Invalid error code type for JSON-RPC: ${response.error.code}`
    };
  }
  if (isReservedErrorCode(response.error.code)) {
    const error = getErrorByCode(response.error.code);
    if (error.message !== STANDARD_ERROR_MAP[DEFAULT_ERROR].message && response.error.message === error.message) {
      return {
        valid: false,
        error: `Invalid error code message for JSON-RPC: ${response.error.code}`
      };
    }
  }
  return { valid: true };
}
function parseConnectionError(e2, url, type) {
  return e2.message.includes("getaddrinfo ENOTFOUND") || e2.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${type} RPC url at ${url}`) : e2;
}
var init_error = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js"() {
    init_shim();
    init_constants2();
  }
});

// node_modules/@walletconnect/environment/dist/cjs/crypto.js
var require_crypto2 = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/crypto.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isBrowserCryptoAvailable = exports2.getSubtleCrypto = exports2.getBrowerCrypto = void 0;
    function getBrowerCrypto() {
      return (global === null || global === void 0 ? void 0 : global.crypto) || (global === null || global === void 0 ? void 0 : global.msCrypto) || {};
    }
    exports2.getBrowerCrypto = getBrowerCrypto;
    function getSubtleCrypto() {
      const browserCrypto = getBrowerCrypto();
      return browserCrypto.subtle || browserCrypto.webkitSubtle;
    }
    exports2.getSubtleCrypto = getSubtleCrypto;
    function isBrowserCryptoAvailable() {
      return !!getBrowerCrypto() && !!getSubtleCrypto();
    }
    exports2.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/env.js
var require_env = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/env.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isBrowser = exports2.isNode = exports2.isReactNative = void 0;
    function isReactNative() {
      return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
    }
    exports2.isReactNative = isReactNative;
    function isNode2() {
      return typeof import_process.default !== "undefined" && typeof import_process.default.versions !== "undefined" && typeof import_process.default.versions.node !== "undefined";
    }
    exports2.isNode = isNode2;
    function isBrowser() {
      return !isReactNative() && !isNode2();
    }
    exports2.isBrowser = isBrowser;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/index.js
var require_cjs5 = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/index.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_crypto2(), exports2);
    tslib_1.__exportStar(require_env(), exports2);
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/env.js
var env_exports = {};
__export(env_exports, {
  isNodeJs: () => isNodeJs
});
var import_environment, isNodeJs;
var init_env = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/env.js"() {
    init_shim();
    import_environment = __toESM(require_cjs5());
    __reExport(env_exports, __toESM(require_cjs5()));
    isNodeJs = import_environment.isNode;
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js
function payloadId(entropy = 3) {
  const date = Date.now() * Math.pow(10, entropy);
  const extra = Math.floor(Math.random() * Math.pow(10, entropy));
  return date + extra;
}
function getBigIntRpcId(entropy = 6) {
  return BigInt(payloadId(entropy));
}
function formatJsonRpcRequest(method, params, id) {
  return {
    id: id || payloadId(),
    jsonrpc: "2.0",
    method,
    params
  };
}
function formatJsonRpcResult(id, result) {
  return {
    id,
    jsonrpc: "2.0",
    result
  };
}
function formatJsonRpcError(id, error, data) {
  return {
    id,
    jsonrpc: "2.0",
    error: formatErrorMessage(error, data)
  };
}
function formatErrorMessage(error, data) {
  if (typeof error === "undefined") {
    return getError(INTERNAL_ERROR);
  }
  if (typeof error === "string") {
    error = Object.assign(Object.assign({}, getError(SERVER_ERROR)), { message: error });
  }
  if (typeof data !== "undefined") {
    error.data = data;
  }
  if (isReservedErrorCode(error.code)) {
    error = getErrorByCode(error.code);
  }
  return error;
}
var init_format = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js"() {
    init_shim();
    init_error();
    init_constants2();
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/routing.js
function isValidRoute(route) {
  if (route.includes("*")) {
    return isValidWildcardRoute(route);
  }
  if (/\W/g.test(route)) {
    return false;
  }
  return true;
}
function isValidDefaultRoute(route) {
  return route === "*";
}
function isValidWildcardRoute(route) {
  if (isValidDefaultRoute(route)) {
    return true;
  }
  if (!route.includes("*")) {
    return false;
  }
  if (route.split("*").length !== 2) {
    return false;
  }
  if (route.split("*").filter((x3) => x3.trim() === "").length !== 1) {
    return false;
  }
  return true;
}
function isValidLeadingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[0].trim();
}
function isValidTrailingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[1].trim();
}
var init_routing = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/routing.js"() {
    init_shim();
  }
});

// node_modules/@walletconnect/jsonrpc-types/dist/esm/jsonrpc.js
var init_jsonrpc = __esm({
  "node_modules/@walletconnect/jsonrpc-types/dist/esm/jsonrpc.js"() {
    init_shim();
  }
});

// node_modules/@walletconnect/jsonrpc-types/dist/esm/misc.js
var IEvents2;
var init_misc = __esm({
  "node_modules/@walletconnect/jsonrpc-types/dist/esm/misc.js"() {
    init_shim();
    IEvents2 = class {
    };
  }
});

// node_modules/@walletconnect/jsonrpc-types/dist/esm/provider.js
var IJsonRpcConnection, IBaseJsonRpcProvider, IJsonRpcProvider;
var init_provider = __esm({
  "node_modules/@walletconnect/jsonrpc-types/dist/esm/provider.js"() {
    init_shim();
    init_misc();
    IJsonRpcConnection = class extends IEvents2 {
      constructor(opts) {
        super();
      }
    };
    IBaseJsonRpcProvider = class extends IEvents2 {
      constructor() {
        super();
      }
    };
    IJsonRpcProvider = class extends IBaseJsonRpcProvider {
      constructor(connection) {
        super();
      }
    };
  }
});

// node_modules/@walletconnect/jsonrpc-types/dist/esm/validator.js
var init_validator = __esm({
  "node_modules/@walletconnect/jsonrpc-types/dist/esm/validator.js"() {
    init_shim();
  }
});

// node_modules/@walletconnect/jsonrpc-types/dist/esm/index.js
var init_esm4 = __esm({
  "node_modules/@walletconnect/jsonrpc-types/dist/esm/index.js"() {
    init_shim();
    init_jsonrpc();
    init_misc();
    init_provider();
    init_validator();
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/types.js
var init_types2 = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/types.js"() {
    init_shim();
    init_esm4();
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js
function getUrlProtocol(url) {
  const matches = url.match(new RegExp(/^\w+:/, "gi"));
  if (!matches || !matches.length)
    return;
  return matches[0];
}
function matchRegexProtocol(url, regex) {
  const protocol = getUrlProtocol(url);
  if (typeof protocol === "undefined")
    return false;
  return new RegExp(regex).test(protocol);
}
function isHttpUrl(url) {
  return matchRegexProtocol(url, HTTP_REGEX);
}
function isWsUrl(url) {
  return matchRegexProtocol(url, WS_REGEX);
}
function isLocalhostUrl(url) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(url);
}
var HTTP_REGEX, WS_REGEX;
var init_url = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js"() {
    init_shim();
    HTTP_REGEX = "^https?:";
    WS_REGEX = "^wss?:";
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/validators.js
function isJsonRpcPayload(payload) {
  return typeof payload === "object" && "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
}
function isJsonRpcRequest(payload) {
  return isJsonRpcPayload(payload) && "method" in payload;
}
function isJsonRpcResponse(payload) {
  return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
}
function isJsonRpcResult(payload) {
  return "result" in payload;
}
function isJsonRpcError(payload) {
  return "error" in payload;
}
function isJsonRpcValidationInvalid(validation) {
  return "error" in validation && validation.valid === false;
}
var init_validators = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/validators.js"() {
    init_shim();
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
var esm_exports4 = {};
__export(esm_exports4, {
  DEFAULT_ERROR: () => DEFAULT_ERROR,
  IBaseJsonRpcProvider: () => IBaseJsonRpcProvider,
  IEvents: () => IEvents2,
  IJsonRpcConnection: () => IJsonRpcConnection,
  IJsonRpcProvider: () => IJsonRpcProvider,
  INTERNAL_ERROR: () => INTERNAL_ERROR,
  INVALID_PARAMS: () => INVALID_PARAMS,
  INVALID_REQUEST: () => INVALID_REQUEST,
  METHOD_NOT_FOUND: () => METHOD_NOT_FOUND,
  PARSE_ERROR: () => PARSE_ERROR,
  RESERVED_ERROR_CODES: () => RESERVED_ERROR_CODES,
  SERVER_ERROR: () => SERVER_ERROR,
  SERVER_ERROR_CODE_RANGE: () => SERVER_ERROR_CODE_RANGE,
  STANDARD_ERROR_MAP: () => STANDARD_ERROR_MAP,
  formatErrorMessage: () => formatErrorMessage,
  formatJsonRpcError: () => formatJsonRpcError,
  formatJsonRpcRequest: () => formatJsonRpcRequest,
  formatJsonRpcResult: () => formatJsonRpcResult,
  getBigIntRpcId: () => getBigIntRpcId,
  getError: () => getError,
  getErrorByCode: () => getErrorByCode,
  isHttpUrl: () => isHttpUrl,
  isJsonRpcError: () => isJsonRpcError,
  isJsonRpcPayload: () => isJsonRpcPayload,
  isJsonRpcRequest: () => isJsonRpcRequest,
  isJsonRpcResponse: () => isJsonRpcResponse,
  isJsonRpcResult: () => isJsonRpcResult,
  isJsonRpcValidationInvalid: () => isJsonRpcValidationInvalid,
  isLocalhostUrl: () => isLocalhostUrl,
  isNodeJs: () => isNodeJs,
  isReservedErrorCode: () => isReservedErrorCode,
  isServerErrorCode: () => isServerErrorCode,
  isValidDefaultRoute: () => isValidDefaultRoute,
  isValidErrorCode: () => isValidErrorCode,
  isValidLeadingWildcardRoute: () => isValidLeadingWildcardRoute,
  isValidRoute: () => isValidRoute,
  isValidTrailingWildcardRoute: () => isValidTrailingWildcardRoute,
  isValidWildcardRoute: () => isValidWildcardRoute,
  isWsUrl: () => isWsUrl,
  parseConnectionError: () => parseConnectionError,
  payloadId: () => payloadId,
  validateJsonRpcError: () => validateJsonRpcError
});
var init_esm5 = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js"() {
    init_shim();
    init_constants2();
    init_error();
    init_env();
    __reExport(esm_exports4, env_exports);
    init_format();
    init_routing();
    init_types2();
    init_url();
    init_validators();
  }
});

// node_modules/@walletconnect/jsonrpc-provider/dist/esm/provider.js
var import_events, JsonRpcProvider, provider_default;
var init_provider2 = __esm({
  "node_modules/@walletconnect/jsonrpc-provider/dist/esm/provider.js"() {
    init_shim();
    import_events = __toESM(require_events());
    init_esm5();
    JsonRpcProvider = class extends IJsonRpcProvider {
      constructor(connection) {
        super(connection);
        this.events = new import_events.EventEmitter();
        this.hasRegisteredEventListeners = false;
        this.connection = this.setConnection(connection);
        if (this.connection.connected) {
          this.registerEventListeners();
        }
      }
      async connect(connection = this.connection) {
        await this.open(connection);
      }
      async disconnect() {
        await this.close();
      }
      on(event, listener) {
        this.events.on(event, listener);
      }
      once(event, listener) {
        this.events.once(event, listener);
      }
      off(event, listener) {
        this.events.off(event, listener);
      }
      removeListener(event, listener) {
        this.events.removeListener(event, listener);
      }
      async request(request, context) {
        return this.requestStrict(formatJsonRpcRequest(request.method, request.params || [], request.id || getBigIntRpcId().toString()), context);
      }
      async requestStrict(request, context) {
        return new Promise(async (resolve, reject) => {
          if (!this.connection.connected) {
            try {
              await this.open();
            } catch (e2) {
              reject(e2);
            }
          }
          this.events.on(`${request.id}`, (response) => {
            if (isJsonRpcError(response)) {
              reject(response.error);
            } else {
              resolve(response.result);
            }
          });
          try {
            await this.connection.send(request, context);
          } catch (e2) {
            reject(e2);
          }
        });
      }
      setConnection(connection = this.connection) {
        return connection;
      }
      onPayload(payload) {
        this.events.emit("payload", payload);
        if (isJsonRpcResponse(payload)) {
          this.events.emit(`${payload.id}`, payload);
        } else {
          this.events.emit("message", {
            type: payload.method,
            data: payload.params
          });
        }
      }
      onClose(event) {
        if (event && event.code === 3e3) {
          this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${event.code} ${event.reason ? `(${event.reason})` : ""}`));
        }
        this.events.emit("disconnect");
      }
      async open(connection = this.connection) {
        if (this.connection === connection && this.connection.connected)
          return;
        if (this.connection.connected)
          this.close();
        if (typeof connection === "string") {
          await this.connection.open(connection);
          connection = this.connection;
        }
        this.connection = this.setConnection(connection);
        await this.connection.open();
        this.registerEventListeners();
        this.events.emit("connect");
      }
      async close() {
        await this.connection.close();
      }
      registerEventListeners() {
        if (this.hasRegisteredEventListeners)
          return;
        this.connection.on("payload", (payload) => this.onPayload(payload));
        this.connection.on("close", (event) => this.onClose(event));
        this.connection.on("error", (error) => this.events.emit("error", error));
        this.connection.on("register_error", (error) => this.onClose());
        this.hasRegisteredEventListeners = true;
      }
    };
    provider_default = JsonRpcProvider;
  }
});

// node_modules/@walletconnect/jsonrpc-provider/dist/esm/index.js
var esm_exports5 = {};
__export(esm_exports5, {
  JsonRpcProvider: () => JsonRpcProvider,
  default: () => esm_default
});
var esm_default;
var init_esm6 = __esm({
  "node_modules/@walletconnect/jsonrpc-provider/dist/esm/index.js"() {
    init_shim();
    init_provider2();
    init_provider2();
    esm_default = provider_default;
  }
});

// node_modules/ws/browser.js
var require_browser5 = __commonJS({
  "node_modules/ws/browser.js"(exports2, module2) {
    "use strict";
    init_shim();
    module2.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/@walletconnect/jsonrpc-ws-connection/dist/index.es.js
var index_es_exports4 = {};
__export(index_es_exports4, {
  WsConnection: () => f3,
  default: () => f3
});
var import_events2, w3, b3, a2, h4, S3, f3;
var init_index_es4 = __esm({
  "node_modules/@walletconnect/jsonrpc-ws-connection/dist/index.es.js"() {
    init_shim();
    import_events2 = __toESM(require_events());
    init_esm();
    init_esm5();
    w3 = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require_browser5();
    b3 = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u";
    a2 = (c4) => c4.split("?")[0];
    h4 = 10;
    S3 = w3();
    f3 = class {
      constructor(e2) {
        if (this.url = e2, this.events = new import_events2.EventEmitter(), this.registering = false, !isWsUrl(e2))
          throw new Error(`Provided URL is not compatible with WebSocket connection: ${e2}`);
        this.url = e2;
      }
      get connected() {
        return typeof this.socket < "u";
      }
      get connecting() {
        return this.registering;
      }
      on(e2, t) {
        this.events.on(e2, t);
      }
      once(e2, t) {
        this.events.once(e2, t);
      }
      off(e2, t) {
        this.events.off(e2, t);
      }
      removeListener(e2, t) {
        this.events.removeListener(e2, t);
      }
      async open(e2 = this.url) {
        await this.register(e2);
      }
      async close() {
        return new Promise((e2, t) => {
          if (typeof this.socket > "u") {
            t(new Error("Connection already closed"));
            return;
          }
          this.socket.onclose = (n3) => {
            this.onClose(n3), e2();
          }, this.socket.close();
        });
      }
      async send(e2) {
        typeof this.socket > "u" && (this.socket = await this.register());
        try {
          this.socket.send(safeJsonStringify(e2));
        } catch (t) {
          this.onError(e2.id, t);
        }
      }
      register(e2 = this.url) {
        if (!isWsUrl(e2))
          throw new Error(`Provided URL is not compatible with WebSocket connection: ${e2}`);
        if (this.registering) {
          const t = this.events.getMaxListeners();
          return (this.events.listenerCount("register_error") >= t || this.events.listenerCount("open") >= t) && this.events.setMaxListeners(t + 1), new Promise((n3, o2) => {
            this.events.once("register_error", (s2) => {
              this.resetMaxListeners(), o2(s2);
            }), this.events.once("open", () => {
              if (this.resetMaxListeners(), typeof this.socket > "u")
                return o2(new Error("WebSocket connection is missing or invalid"));
              n3(this.socket);
            });
          });
        }
        return this.url = e2, this.registering = true, new Promise((t, n3) => {
          const o2 = new URLSearchParams(e2).get("origin"), s2 = (0, esm_exports4.isReactNative)() ? { headers: { origin: o2 } } : { rejectUnauthorized: !isLocalhostUrl(e2) }, i2 = new S3(e2, [], s2);
          b3() ? i2.onerror = (r) => {
            const l4 = r;
            n3(this.emitError(l4.error));
          } : i2.on("error", (r) => {
            n3(this.emitError(r));
          }), i2.onopen = () => {
            this.onOpen(i2), t(i2);
          };
        });
      }
      onOpen(e2) {
        e2.onmessage = (t) => this.onPayload(t), e2.onclose = (t) => this.onClose(t), this.socket = e2, this.registering = false, this.events.emit("open");
      }
      onClose(e2) {
        this.socket = void 0, this.registering = false, this.events.emit("close", e2);
      }
      onPayload(e2) {
        if (typeof e2.data > "u")
          return;
        const t = typeof e2.data == "string" ? safeJsonParse(e2.data) : e2.data;
        this.events.emit("payload", t);
      }
      onError(e2, t) {
        const n3 = this.parseError(t), o2 = n3.message || n3.toString(), s2 = formatJsonRpcError(e2, o2);
        this.events.emit("payload", s2);
      }
      parseError(e2, t = this.url) {
        return parseConnectionError(e2, a2(t), "WS");
      }
      resetMaxListeners() {
        this.events.getMaxListeners() > h4 && this.events.setMaxListeners(h4);
      }
      emitError(e2) {
        const t = this.parseError(new Error(e2?.message || `WebSocket connection failed for host: ${a2(this.url)}`));
        return this.events.emit("register_error", t), t;
      }
    };
  }
});

// node_modules/lodash.isequal/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.isequal/index.js"(exports2, module2) {
    init_shim();
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var MAX_SAFE_INTEGER2 = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayFilter(array, predicate) {
      var index = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length2) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length2 = values.length, offset = array.length;
      while (++index < length2) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arraySome(array, predicate) {
      var index = -1, length2 = array == null ? 0 : array.length;
      while (++index < length2) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseTimes(n3, iteratee) {
      var index = -1, result = Array(n3);
      while (++index < n3) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length2 = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length2) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length2)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length2 = array.length;
      while (length2--) {
        if (eq(array[length2][0], key)) {
          return length2;
        }
      }
      return -1;
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys2, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e2) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function isIndex(value, length2) {
      length2 = length2 == null ? MAX_SAFE_INTEGER2 : length2;
      return !!length2 && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function keys2(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module2.exports = isEqual;
  }
});

// node_modules/unfetch/dist/unfetch.js
var require_unfetch = __commonJS({
  "node_modules/unfetch/dist/unfetch.js"(exports2, module2) {
    init_shim();
    module2.exports = function(e2, n3) {
      return n3 = n3 || {}, new Promise(function(t, r) {
        var s2 = new XMLHttpRequest(), o2 = [], u3 = [], i2 = {}, a3 = function() {
          return { ok: 2 == (s2.status / 100 | 0), statusText: s2.statusText, status: s2.status, url: s2.responseURL, text: function() {
            return Promise.resolve(s2.responseText);
          }, json: function() {
            return Promise.resolve(s2.responseText).then(JSON.parse);
          }, blob: function() {
            return Promise.resolve(new Blob([s2.response]));
          }, clone: a3, headers: { keys: function() {
            return o2;
          }, entries: function() {
            return u3;
          }, get: function(e3) {
            return i2[e3.toLowerCase()];
          }, has: function(e3) {
            return e3.toLowerCase() in i2;
          } } };
        };
        for (var l4 in s2.open(n3.method || "get", e2, true), s2.onload = function() {
          s2.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function(e3, n4, t2) {
            o2.push(n4 = n4.toLowerCase()), u3.push([n4, t2]), i2[n4] = i2[n4] ? i2[n4] + "," + t2 : t2;
          }), t(a3());
        }, s2.onerror = r, s2.withCredentials = "include" == n3.credentials, n3.headers)
          s2.setRequestHeader(l4, n3.headers[l4]);
        s2.send(n3.body || null);
      });
    };
  }
});

// node_modules/isomorphic-unfetch/browser.js
var require_browser6 = __commonJS({
  "node_modules/isomorphic-unfetch/browser.js"(exports2, module2) {
    init_shim();
    module2.exports = self.fetch || (self.fetch = require_unfetch().default || require_unfetch());
  }
});

// node_modules/@walletconnect/core/dist/index.cjs.js
var require_index_cjs3 = __commonJS({
  "node_modules/@walletconnect/core/dist/index.cjs.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var z3 = require_events();
    var It = (init_index_es(), __toCommonJS(index_es_exports));
    var $ = require_cjs2();
    var g3 = (init_index_es2(), __toCommonJS(index_es_exports2));
    var x3 = require_index_cjs();
    var oe = (init_esm(), __toCommonJS(esm_exports));
    var Rt = (init_esm3(), __toCommonJS(esm_exports3));
    var a3 = require_index_cjs2();
    var _t = (init_src2(), __toCommonJS(src_exports));
    var l4 = require_cjs();
    var Ct = (init_esm6(), __toCommonJS(esm_exports5));
    var f4 = (init_esm5(), __toCommonJS(esm_exports4));
    var Tt = (init_index_es4(), __toCommonJS(index_es_exports4));
    var St = require_lodash();
    var Ot = require_browser6();
    function k4(n3) {
      return n3 && typeof n3 == "object" && "default" in n3 ? n3 : { default: n3 };
    }
    function Pt(n3) {
      if (n3 && n3.__esModule)
        return n3;
      var e2 = /* @__PURE__ */ Object.create(null);
      return n3 && Object.keys(n3).forEach(function(t) {
        if (t !== "default") {
          var i2 = Object.getOwnPropertyDescriptor(n3, t);
          Object.defineProperty(e2, t, i2.get ? i2 : { enumerable: true, get: function() {
            return n3[t];
          } });
        }
      }), e2.default = n3, Object.freeze(e2);
    }
    var At = k4(z3);
    var xt = k4(It);
    var j2 = Pt(Rt);
    var Nt = k4(Tt);
    var Lt = k4(St);
    var Ut = k4(Ot);
    function zt(n3, e2) {
      if (n3.length >= 255)
        throw new TypeError("Alphabet too long");
      for (var t = new Uint8Array(256), i2 = 0; i2 < t.length; i2++)
        t[i2] = 255;
      for (var s2 = 0; s2 < n3.length; s2++) {
        var r = n3.charAt(s2), o2 = r.charCodeAt(0);
        if (t[o2] !== 255)
          throw new TypeError(r + " is ambiguous");
        t[o2] = s2;
      }
      var h5 = n3.length, c4 = n3.charAt(0), u3 = Math.log(h5) / Math.log(256), p3 = Math.log(256) / Math.log(h5);
      function D2(d3) {
        if (d3 instanceof Uint8Array || (ArrayBuffer.isView(d3) ? d3 = new Uint8Array(d3.buffer, d3.byteOffset, d3.byteLength) : Array.isArray(d3) && (d3 = Uint8Array.from(d3))), !(d3 instanceof Uint8Array))
          throw new TypeError("Expected Uint8Array");
        if (d3.length === 0)
          return "";
        for (var y4 = 0, C3 = 0, E4 = 0, O3 = d3.length; E4 !== O3 && d3[E4] === 0; )
          E4++, y4++;
        for (var P2 = (O3 - E4) * p3 + 1 >>> 0, v2 = new Uint8Array(P2); E4 !== O3; ) {
          for (var A2 = d3[E4], U2 = 0, T2 = P2 - 1; (A2 !== 0 || U2 < C3) && T2 !== -1; T2--, U2++)
            A2 += 256 * v2[T2] >>> 0, v2[T2] = A2 % h5 >>> 0, A2 = A2 / h5 >>> 0;
          if (A2 !== 0)
            throw new Error("Non-zero carry");
          C3 = U2, E4++;
        }
        for (var N10 = P2 - C3; N10 !== P2 && v2[N10] === 0; )
          N10++;
        for (var Y = c4.repeat(y4); N10 < P2; ++N10)
          Y += n3.charAt(v2[N10]);
        return Y;
      }
      function b4(d3) {
        if (typeof d3 != "string")
          throw new TypeError("Expected String");
        if (d3.length === 0)
          return new Uint8Array();
        var y4 = 0;
        if (d3[y4] !== " ") {
          for (var C3 = 0, E4 = 0; d3[y4] === c4; )
            C3++, y4++;
          for (var O3 = (d3.length - y4) * u3 + 1 >>> 0, P2 = new Uint8Array(O3); d3[y4]; ) {
            var v2 = t[d3.charCodeAt(y4)];
            if (v2 === 255)
              return;
            for (var A2 = 0, U2 = O3 - 1; (v2 !== 0 || A2 < E4) && U2 !== -1; U2--, A2++)
              v2 += h5 * P2[U2] >>> 0, P2[U2] = v2 % 256 >>> 0, v2 = v2 / 256 >>> 0;
            if (v2 !== 0)
              throw new Error("Non-zero carry");
            E4 = A2, y4++;
          }
          if (d3[y4] !== " ") {
            for (var T2 = O3 - E4; T2 !== O3 && P2[T2] === 0; )
              T2++;
            for (var N10 = new Uint8Array(C3 + (O3 - T2)), Y = C3; T2 !== O3; )
              N10[Y++] = P2[T2++];
            return N10;
          }
        }
      }
      function F(d3) {
        var y4 = b4(d3);
        if (y4)
          return y4;
        throw new Error(`Non-${e2} character`);
      }
      return { encode: D2, decodeUnsafe: b4, decode: F };
    }
    var Ft = zt;
    var Mt = Ft;
    var ae = (n3) => {
      if (n3 instanceof Uint8Array && n3.constructor.name === "Uint8Array")
        return n3;
      if (n3 instanceof ArrayBuffer)
        return new Uint8Array(n3);
      if (ArrayBuffer.isView(n3))
        return new Uint8Array(n3.buffer, n3.byteOffset, n3.byteLength);
      throw new Error("Unknown type, must be binary type");
    };
    var Bt = (n3) => new TextEncoder().encode(n3);
    var $t = (n3) => new TextDecoder().decode(n3);
    var kt = class {
      constructor(e2, t, i2) {
        this.name = e2, this.prefix = t, this.baseEncode = i2;
      }
      encode(e2) {
        if (e2 instanceof Uint8Array)
          return `${this.prefix}${this.baseEncode(e2)}`;
        throw Error("Unknown type, must be binary type");
      }
    };
    var Vt = class {
      constructor(e2, t, i2) {
        if (this.name = e2, this.prefix = t, t.codePointAt(0) === void 0)
          throw new Error("Invalid prefix character");
        this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i2;
      }
      decode(e2) {
        if (typeof e2 == "string") {
          if (e2.codePointAt(0) !== this.prefixCodePoint)
            throw Error(`Unable to decode multibase string ${JSON.stringify(e2)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          return this.baseDecode(e2.slice(this.prefix.length));
        } else
          throw Error("Can only multibase decode strings");
      }
      or(e2) {
        return he(this, e2);
      }
    };
    var Kt = class {
      constructor(e2) {
        this.decoders = e2;
      }
      or(e2) {
        return he(this, e2);
      }
      decode(e2) {
        const t = e2[0], i2 = this.decoders[t];
        if (i2)
          return i2.decode(e2);
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(e2)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    };
    var he = (n3, e2) => new Kt({ ...n3.decoders || { [n3.prefix]: n3 }, ...e2.decoders || { [e2.prefix]: e2 } });
    var qt = class {
      constructor(e2, t, i2, s2) {
        this.name = e2, this.prefix = t, this.baseEncode = i2, this.baseDecode = s2, this.encoder = new kt(e2, t, i2), this.decoder = new Vt(e2, t, s2);
      }
      encode(e2) {
        return this.encoder.encode(e2);
      }
      decode(e2) {
        return this.decoder.decode(e2);
      }
    };
    var G = ({ name: n3, prefix: e2, encode: t, decode: i2 }) => new qt(n3, e2, t, i2);
    var V = ({ prefix: n3, name: e2, alphabet: t }) => {
      const { encode: i2, decode: s2 } = Mt(t, e2);
      return G({ prefix: n3, name: e2, encode: i2, decode: (r) => ae(s2(r)) });
    };
    var Yt = (n3, e2, t, i2) => {
      const s2 = {};
      for (let p3 = 0; p3 < e2.length; ++p3)
        s2[e2[p3]] = p3;
      let r = n3.length;
      for (; n3[r - 1] === "="; )
        --r;
      const o2 = new Uint8Array(r * t / 8 | 0);
      let h5 = 0, c4 = 0, u3 = 0;
      for (let p3 = 0; p3 < r; ++p3) {
        const D2 = s2[n3[p3]];
        if (D2 === void 0)
          throw new SyntaxError(`Non-${i2} character`);
        c4 = c4 << t | D2, h5 += t, h5 >= 8 && (h5 -= 8, o2[u3++] = 255 & c4 >> h5);
      }
      if (h5 >= t || 255 & c4 << 8 - h5)
        throw new SyntaxError("Unexpected end of data");
      return o2;
    };
    var jt = (n3, e2, t) => {
      const i2 = e2[e2.length - 1] === "=", s2 = (1 << t) - 1;
      let r = "", o2 = 0, h5 = 0;
      for (let c4 = 0; c4 < n3.length; ++c4)
        for (h5 = h5 << 8 | n3[c4], o2 += 8; o2 > t; )
          o2 -= t, r += e2[s2 & h5 >> o2];
      if (o2 && (r += e2[s2 & h5 << t - o2]), i2)
        for (; r.length * t & 7; )
          r += "=";
      return r;
    };
    var m3 = ({ name: n3, prefix: e2, bitsPerChar: t, alphabet: i2 }) => G({ prefix: e2, name: n3, encode(s2) {
      return jt(s2, i2, t);
    }, decode(s2) {
      return Yt(s2, i2, t, n3);
    } });
    var Gt = G({ prefix: "\0", name: "identity", encode: (n3) => $t(n3), decode: (n3) => Bt(n3) });
    var Ht = Object.freeze({ __proto__: null, identity: Gt });
    var Xt = m3({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
    var Jt = Object.freeze({ __proto__: null, base2: Xt });
    var Wt = m3({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
    var Qt = Object.freeze({ __proto__: null, base8: Wt });
    var Zt = V({ prefix: "9", name: "base10", alphabet: "0123456789" });
    var ei = Object.freeze({ __proto__: null, base10: Zt });
    var ti = m3({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
    var ii = m3({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
    var si = Object.freeze({ __proto__: null, base16: ti, base16upper: ii });
    var ri = m3({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
    var ni = m3({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
    var oi = m3({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
    var ai = m3({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
    var hi = m3({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
    var ci = m3({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
    var li = m3({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
    var ui = m3({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
    var gi = m3({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
    var di = Object.freeze({ __proto__: null, base32: ri, base32upper: ni, base32pad: oi, base32padupper: ai, base32hex: hi, base32hexupper: ci, base32hexpad: li, base32hexpadupper: ui, base32z: gi });
    var pi = V({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
    var Di = V({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
    var yi = Object.freeze({ __proto__: null, base36: pi, base36upper: Di });
    var Ei = V({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
    var mi = V({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
    var bi = Object.freeze({ __proto__: null, base58btc: Ei, base58flickr: mi });
    var fi = m3({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
    var wi = m3({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
    var vi = m3({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
    var Ii = m3({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
    var Ri = Object.freeze({ __proto__: null, base64: fi, base64pad: wi, base64url: vi, base64urlpad: Ii });
    var ce = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
    var _i = ce.reduce((n3, e2, t) => (n3[t] = e2, n3), []);
    var Ci = ce.reduce((n3, e2, t) => (n3[e2.codePointAt(0)] = t, n3), []);
    function Ti(n3) {
      return n3.reduce((e2, t) => (e2 += _i[t], e2), "");
    }
    function Si(n3) {
      const e2 = [];
      for (const t of n3) {
        const i2 = Ci[t.codePointAt(0)];
        if (i2 === void 0)
          throw new Error(`Non-base256emoji character: ${t}`);
        e2.push(i2);
      }
      return new Uint8Array(e2);
    }
    var Oi = G({ prefix: "\u{1F680}", name: "base256emoji", encode: Ti, decode: Si });
    var Pi = Object.freeze({ __proto__: null, base256emoji: Oi });
    var Ai = ue;
    var le = 128;
    var xi = 127;
    var Ni = ~xi;
    var Li = Math.pow(2, 31);
    function ue(n3, e2, t) {
      e2 = e2 || [], t = t || 0;
      for (var i2 = t; n3 >= Li; )
        e2[t++] = n3 & 255 | le, n3 /= 128;
      for (; n3 & Ni; )
        e2[t++] = n3 & 255 | le, n3 >>>= 7;
      return e2[t] = n3 | 0, ue.bytes = t - i2 + 1, e2;
    }
    var Ui = Q;
    var zi = 128;
    var ge = 127;
    function Q(n3, i2) {
      var t = 0, i2 = i2 || 0, s2 = 0, r = i2, o2, h5 = n3.length;
      do {
        if (r >= h5)
          throw Q.bytes = 0, new RangeError("Could not decode varint");
        o2 = n3[r++], t += s2 < 28 ? (o2 & ge) << s2 : (o2 & ge) * Math.pow(2, s2), s2 += 7;
      } while (o2 >= zi);
      return Q.bytes = r - i2, t;
    }
    var Fi = Math.pow(2, 7);
    var Mi = Math.pow(2, 14);
    var Bi = Math.pow(2, 21);
    var $i = Math.pow(2, 28);
    var ki = Math.pow(2, 35);
    var Vi = Math.pow(2, 42);
    var Ki = Math.pow(2, 49);
    var qi = Math.pow(2, 56);
    var Yi = Math.pow(2, 63);
    var ji = function(n3) {
      return n3 < Fi ? 1 : n3 < Mi ? 2 : n3 < Bi ? 3 : n3 < $i ? 4 : n3 < ki ? 5 : n3 < Vi ? 6 : n3 < Ki ? 7 : n3 < qi ? 8 : n3 < Yi ? 9 : 10;
    };
    var Gi = { encode: Ai, decode: Ui, encodingLength: ji };
    var de = Gi;
    var pe = (n3, e2, t = 0) => (de.encode(n3, e2, t), e2);
    var De = (n3) => de.encodingLength(n3);
    var Z = (n3, e2) => {
      const t = e2.byteLength, i2 = De(n3), s2 = i2 + De(t), r = new Uint8Array(s2 + t);
      return pe(n3, r, 0), pe(t, r, i2), r.set(e2, s2), new Hi(n3, t, e2, r);
    };
    var Hi = class {
      constructor(e2, t, i2, s2) {
        this.code = e2, this.size = t, this.digest = i2, this.bytes = s2;
      }
    };
    var ye = ({ name: n3, code: e2, encode: t }) => new Xi(n3, e2, t);
    var Xi = class {
      constructor(e2, t, i2) {
        this.name = e2, this.code = t, this.encode = i2;
      }
      digest(e2) {
        if (e2 instanceof Uint8Array) {
          const t = this.encode(e2);
          return t instanceof Uint8Array ? Z(this.code, t) : t.then((i2) => Z(this.code, i2));
        } else
          throw Error("Unknown type, must be binary type");
      }
    };
    var Ee = (n3) => async (e2) => new Uint8Array(await crypto.subtle.digest(n3, e2));
    var Ji = ye({ name: "sha2-256", code: 18, encode: Ee("SHA-256") });
    var Wi = ye({ name: "sha2-512", code: 19, encode: Ee("SHA-512") });
    var Qi = Object.freeze({ __proto__: null, sha256: Ji, sha512: Wi });
    var me = 0;
    var Zi = "identity";
    var be = ae;
    var es = (n3) => Z(me, be(n3));
    var ts = { code: me, name: Zi, encode: be, digest: es };
    var is = Object.freeze({ __proto__: null, identity: ts });
    new TextEncoder(), new TextDecoder();
    var fe = { ...Ht, ...Jt, ...Qt, ...ei, ...si, ...di, ...yi, ...bi, ...Ri, ...Pi };
    ({ ...Qi, ...is });
    function we(n3) {
      return globalThis.Buffer != null ? new Uint8Array(n3.buffer, n3.byteOffset, n3.byteLength) : n3;
    }
    function ss(n3 = 0) {
      return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? we(globalThis.Buffer.allocUnsafe(n3)) : new Uint8Array(n3);
    }
    function ve(n3, e2, t, i2) {
      return { name: n3, prefix: e2, encoder: { name: n3, prefix: e2, encode: t }, decoder: { decode: i2 } };
    }
    var Ie = ve("utf8", "u", (n3) => "u" + new TextDecoder("utf8").decode(n3), (n3) => new TextEncoder().encode(n3.substring(1)));
    var ee = ve("ascii", "a", (n3) => {
      let e2 = "a";
      for (let t = 0; t < n3.length; t++)
        e2 += String.fromCharCode(n3[t]);
      return e2;
    }, (n3) => {
      n3 = n3.substring(1);
      const e2 = ss(n3.length);
      for (let t = 0; t < n3.length; t++)
        e2[t] = n3.charCodeAt(t);
      return e2;
    });
    var rs = { utf8: Ie, "utf-8": Ie, hex: fe.base16, latin1: ee, ascii: ee, binary: ee, ...fe };
    function ns(n3, e2 = "utf8") {
      const t = rs[e2];
      if (!t)
        throw new Error(`Unsupported encoding "${e2}"`);
      return (e2 === "utf8" || e2 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? we(globalThis.Buffer.from(n3, "utf-8")) : t.decoder.decode(`${t.prefix}${n3}`);
    }
    var te = "wc";
    var Re = 2;
    var H = "core";
    var L2 = `${te}@2:${H}:`;
    var _e = { name: H, logger: "error" };
    var Ce = { database: ":memory:" };
    var Te = "crypto";
    var ie = "client_ed25519_seed";
    var Se = l4.ONE_DAY;
    var Oe = "keychain";
    var Pe = "0.3";
    var Ae = "messages";
    var xe = "0.3";
    var Ne = l4.SIX_HOURS;
    var Le = "publisher";
    var Ue = "irn";
    var ze = "error";
    var se = "wss://relay.walletconnect.com";
    var re = "wss://relay.walletconnect.org";
    var Fe = "relayer";
    var I2 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
    var Me = "_subscription";
    var w4 = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
    var Be = l4.ONE_SECOND;
    var os = { database: ":memory:" };
    var $e = "2.12.2";
    var ke = 1e4;
    var Ve = "0.3";
    var Ke = "WALLETCONNECT_CLIENT_ID";
    var S4 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
    var as = l4.THIRTY_DAYS;
    var qe = "subscription";
    var Ye = "0.3";
    var je = l4.FIVE_SECONDS * 1e3;
    var Ge = "pairing";
    var He = "0.3";
    var hs = l4.THIRTY_DAYS;
    var M = { wc_pairingDelete: { req: { ttl: l4.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: l4.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: l4.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: l4.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: l4.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: l4.ONE_DAY, prompt: false, tag: 0 } } };
    var K2 = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
    var R2 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
    var Xe = "history";
    var Je = "0.3";
    var We = "expirer";
    var _4 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
    var Qe = "0.3";
    var cs = l4.ONE_DAY;
    var X = "verify-api";
    var B2 = "https://verify.walletconnect.com";
    var J = "https://verify.walletconnect.org";
    var Ze = [B2, J];
    var et = "echo";
    var tt = "https://echo.walletconnect.com";
    var it = class {
      constructor(e2, t) {
        this.core = e2, this.logger = t, this.keychain = /* @__PURE__ */ new Map(), this.name = Oe, this.version = Pe, this.initialized = false, this.storagePrefix = L2, this.init = async () => {
          if (!this.initialized) {
            const i2 = await this.getKeyChain();
            typeof i2 < "u" && (this.keychain = i2), this.initialized = true;
          }
        }, this.has = (i2) => (this.isInitialized(), this.keychain.has(i2)), this.set = async (i2, s2) => {
          this.isInitialized(), this.keychain.set(i2, s2), await this.persist();
        }, this.get = (i2) => {
          this.isInitialized();
          const s2 = this.keychain.get(i2);
          if (typeof s2 > "u") {
            const { message: r } = a3.getInternalError("NO_MATCHING_KEY", `${this.name}: ${i2}`);
            throw new Error(r);
          }
          return s2;
        }, this.del = async (i2) => {
          this.isInitialized(), this.keychain.delete(i2), await this.persist();
        }, this.core = e2, this.logger = g3.generateChildLogger(t, this.name);
      }
      get context() {
        return g3.getLoggerContext(this.logger);
      }
      get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
      }
      async setKeyChain(e2) {
        await this.core.storage.setItem(this.storageKey, a3.mapToObj(e2));
      }
      async getKeyChain() {
        const e2 = await this.core.storage.getItem(this.storageKey);
        return typeof e2 < "u" ? a3.objToMap(e2) : void 0;
      }
      async persist() {
        await this.setKeyChain(this.keychain);
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e2 } = a3.getInternalError("NOT_INITIALIZED", this.name);
          throw new Error(e2);
        }
      }
    };
    var st = class {
      constructor(e2, t, i2) {
        this.core = e2, this.logger = t, this.name = Te, this.initialized = false, this.init = async () => {
          this.initialized || (await this.keychain.init(), this.initialized = true);
        }, this.hasKeys = (s2) => (this.isInitialized(), this.keychain.has(s2)), this.getClientId = async () => {
          this.isInitialized();
          const s2 = await this.getClientSeed(), r = j2.generateKeyPair(s2);
          return j2.encodeIss(r.publicKey);
        }, this.generateKeyPair = () => {
          this.isInitialized();
          const s2 = a3.generateKeyPair();
          return this.setPrivateKey(s2.publicKey, s2.privateKey);
        }, this.signJWT = async (s2) => {
          this.isInitialized();
          const r = await this.getClientSeed(), o2 = j2.generateKeyPair(r), h5 = a3.generateRandomBytes32(), c4 = Se;
          return await j2.signJWT(h5, s2, c4, o2);
        }, this.generateSharedKey = (s2, r, o2) => {
          this.isInitialized();
          const h5 = this.getPrivateKey(s2), c4 = a3.deriveSymKey(h5, r);
          return this.setSymKey(c4, o2);
        }, this.setSymKey = async (s2, r) => {
          this.isInitialized();
          const o2 = r || a3.hashKey(s2);
          return await this.keychain.set(o2, s2), o2;
        }, this.deleteKeyPair = async (s2) => {
          this.isInitialized(), await this.keychain.del(s2);
        }, this.deleteSymKey = async (s2) => {
          this.isInitialized(), await this.keychain.del(s2);
        }, this.encode = async (s2, r, o2) => {
          this.isInitialized();
          const h5 = a3.validateEncoding(o2), c4 = oe.safeJsonStringify(r);
          if (a3.isTypeOneEnvelope(h5)) {
            const b4 = h5.senderPublicKey, F = h5.receiverPublicKey;
            s2 = await this.generateSharedKey(b4, F);
          }
          const u3 = this.getSymKey(s2), { type: p3, senderPublicKey: D2 } = h5;
          return a3.encrypt({ type: p3, symKey: u3, message: c4, senderPublicKey: D2 });
        }, this.decode = async (s2, r, o2) => {
          this.isInitialized();
          const h5 = a3.validateDecoding(r, o2);
          if (a3.isTypeOneEnvelope(h5)) {
            const c4 = h5.receiverPublicKey, u3 = h5.senderPublicKey;
            s2 = await this.generateSharedKey(c4, u3);
          }
          try {
            const c4 = this.getSymKey(s2), u3 = a3.decrypt({ symKey: c4, encoded: r });
            return oe.safeJsonParse(u3);
          } catch (c4) {
            this.logger.error(`Failed to decode message from topic: '${s2}', clientId: '${await this.getClientId()}'`), this.logger.error(c4);
          }
        }, this.getPayloadType = (s2) => {
          const r = a3.deserialize(s2);
          return a3.decodeTypeByte(r.type);
        }, this.getPayloadSenderPublicKey = (s2) => {
          const r = a3.deserialize(s2);
          return r.senderPublicKey ? _t.toString(r.senderPublicKey, a3.BASE16) : void 0;
        }, this.core = e2, this.logger = g3.generateChildLogger(t, this.name), this.keychain = i2 || new it(this.core, this.logger);
      }
      get context() {
        return g3.getLoggerContext(this.logger);
      }
      async setPrivateKey(e2, t) {
        return await this.keychain.set(e2, t), e2;
      }
      getPrivateKey(e2) {
        return this.keychain.get(e2);
      }
      async getClientSeed() {
        let e2 = "";
        try {
          e2 = this.keychain.get(ie);
        } catch {
          e2 = a3.generateRandomBytes32(), await this.keychain.set(ie, e2);
        }
        return ns(e2, "base16");
      }
      getSymKey(e2) {
        return this.keychain.get(e2);
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e2 } = a3.getInternalError("NOT_INITIALIZED", this.name);
          throw new Error(e2);
        }
      }
    };
    var rt = class extends x3.IMessageTracker {
      constructor(e2, t) {
        super(e2, t), this.logger = e2, this.core = t, this.messages = /* @__PURE__ */ new Map(), this.name = Ae, this.version = xe, this.initialized = false, this.storagePrefix = L2, this.init = async () => {
          if (!this.initialized) {
            this.logger.trace("Initialized");
            try {
              const i2 = await this.getRelayerMessages();
              typeof i2 < "u" && (this.messages = i2), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
            } catch (i2) {
              this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i2);
            } finally {
              this.initialized = true;
            }
          }
        }, this.set = async (i2, s2) => {
          this.isInitialized();
          const r = a3.hashMessage(s2);
          let o2 = this.messages.get(i2);
          return typeof o2 > "u" && (o2 = {}), typeof o2[r] < "u" || (o2[r] = s2, this.messages.set(i2, o2), await this.persist()), r;
        }, this.get = (i2) => {
          this.isInitialized();
          let s2 = this.messages.get(i2);
          return typeof s2 > "u" && (s2 = {}), s2;
        }, this.has = (i2, s2) => {
          this.isInitialized();
          const r = this.get(i2), o2 = a3.hashMessage(s2);
          return typeof r[o2] < "u";
        }, this.del = async (i2) => {
          this.isInitialized(), this.messages.delete(i2), await this.persist();
        }, this.logger = g3.generateChildLogger(e2, this.name), this.core = t;
      }
      get context() {
        return g3.getLoggerContext(this.logger);
      }
      get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
      }
      async setRelayerMessages(e2) {
        await this.core.storage.setItem(this.storageKey, a3.mapToObj(e2));
      }
      async getRelayerMessages() {
        const e2 = await this.core.storage.getItem(this.storageKey);
        return typeof e2 < "u" ? a3.objToMap(e2) : void 0;
      }
      async persist() {
        await this.setRelayerMessages(this.messages);
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e2 } = a3.getInternalError("NOT_INITIALIZED", this.name);
          throw new Error(e2);
        }
      }
    };
    var ls2 = class extends x3.IPublisher {
      constructor(e2, t) {
        super(e2, t), this.relayer = e2, this.logger = t, this.events = new z3.EventEmitter(), this.name = Le, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = l4.toMiliseconds(l4.ONE_MINUTE), this.failedPublishTimeout = l4.toMiliseconds(l4.ONE_SECOND), this.needsTransportRestart = false, this.publish = async (i2, s2, r) => {
          var o2;
          this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i2, message: s2, opts: r } });
          const h5 = r?.ttl || Ne, c4 = a3.getRelayProtocolName(r), u3 = r?.prompt || false, p3 = r?.tag || 0, D2 = r?.id || f4.getBigIntRpcId().toString(), b4 = { topic: i2, message: s2, opts: { ttl: h5, relay: c4, prompt: u3, tag: p3, id: D2 } }, F = `Failed to publish payload, please try again. id:${D2} tag:${p3}`, d3 = Date.now();
          let y4, C3 = 1;
          try {
            for (; y4 === void 0; ) {
              if (Date.now() - d3 > this.publishTimeout)
                throw new Error(F);
              this.logger.trace({ id: D2, attempts: C3 }, `publisher.publish - attempt ${C3}`), y4 = await await a3.createExpiringPromise(this.rpcPublish(i2, s2, h5, c4, u3, p3, D2).catch((E4) => this.logger.warn(E4)), this.publishTimeout, F), C3++, y4 || await new Promise((E4) => setTimeout(E4, this.failedPublishTimeout));
            }
            this.relayer.events.emit(I2.publish, b4), this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { id: D2, topic: i2, message: s2, opts: r } });
          } catch (E4) {
            if (this.logger.debug("Failed to Publish Payload"), this.logger.error(E4), (o2 = r?.internal) != null && o2.throwOnFailedPublish)
              throw E4;
            this.queue.set(D2, b4);
          }
        }, this.on = (i2, s2) => {
          this.events.on(i2, s2);
        }, this.once = (i2, s2) => {
          this.events.once(i2, s2);
        }, this.off = (i2, s2) => {
          this.events.off(i2, s2);
        }, this.removeListener = (i2, s2) => {
          this.events.removeListener(i2, s2);
        }, this.relayer = e2, this.logger = g3.generateChildLogger(t, this.name), this.registerEventListeners();
      }
      get context() {
        return g3.getLoggerContext(this.logger);
      }
      rpcPublish(e2, t, i2, s2, r, o2, h5) {
        var c4, u3, p3, D2;
        const b4 = { method: a3.getRelayProtocolApi(s2.protocol).publish, params: { topic: e2, message: t, ttl: i2, prompt: r, tag: o2 }, id: h5 };
        return a3.isUndefined((c4 = b4.params) == null ? void 0 : c4.prompt) && ((u3 = b4.params) == null || delete u3.prompt), a3.isUndefined((p3 = b4.params) == null ? void 0 : p3.tag) && ((D2 = b4.params) == null || delete D2.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: b4 }), this.relayer.request(b4);
      }
      removeRequestFromQueue(e2) {
        this.queue.delete(e2);
      }
      checkQueue() {
        this.queue.forEach(async (e2) => {
          const { topic: t, message: i2, opts: s2 } = e2;
          await this.publish(t, i2, s2);
        });
      }
      registerEventListeners() {
        this.relayer.core.heartbeat.on($.HEARTBEAT_EVENTS.pulse, () => {
          if (this.needsTransportRestart) {
            this.needsTransportRestart = false, this.relayer.events.emit(I2.connection_stalled);
            return;
          }
          this.checkQueue();
        }), this.relayer.on(I2.message_ack, (e2) => {
          this.removeRequestFromQueue(e2.id.toString());
        });
      }
    };
    var us = class {
      constructor() {
        this.map = /* @__PURE__ */ new Map(), this.set = (e2, t) => {
          const i2 = this.get(e2);
          this.exists(e2, t) || this.map.set(e2, [...i2, t]);
        }, this.get = (e2) => this.map.get(e2) || [], this.exists = (e2, t) => this.get(e2).includes(t), this.delete = (e2, t) => {
          if (typeof t > "u") {
            this.map.delete(e2);
            return;
          }
          if (!this.map.has(e2))
            return;
          const i2 = this.get(e2);
          if (!this.exists(e2, t))
            return;
          const s2 = i2.filter((r) => r !== t);
          if (!s2.length) {
            this.map.delete(e2);
            return;
          }
          this.map.set(e2, s2);
        }, this.clear = () => {
          this.map.clear();
        };
      }
      get topics() {
        return Array.from(this.map.keys());
      }
    };
    var gs = Object.defineProperty;
    var ds = Object.defineProperties;
    var ps = Object.getOwnPropertyDescriptors;
    var nt = Object.getOwnPropertySymbols;
    var Ds = Object.prototype.hasOwnProperty;
    var ys = Object.prototype.propertyIsEnumerable;
    var ot = (n3, e2, t) => e2 in n3 ? gs(n3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : n3[e2] = t;
    var q2 = (n3, e2) => {
      for (var t in e2 || (e2 = {}))
        Ds.call(e2, t) && ot(n3, t, e2[t]);
      if (nt)
        for (var t of nt(e2))
          ys.call(e2, t) && ot(n3, t, e2[t]);
      return n3;
    };
    var ne = (n3, e2) => ds(n3, ps(e2));
    var at = class extends x3.ISubscriber {
      constructor(e2, t) {
        super(e2, t), this.relayer = e2, this.logger = t, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new us(), this.events = new z3.EventEmitter(), this.name = qe, this.version = Ye, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = false, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = L2, this.subscribeTimeout = l4.toMiliseconds(l4.ONE_MINUTE), this.restartInProgress = false, this.batchSubscribeTopicsLimit = 500, this.init = async () => {
          this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId());
        }, this.subscribe = async (i2, s2) => {
          await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i2, opts: s2 } });
          try {
            const r = a3.getRelayProtocolName(s2), o2 = { topic: i2, relay: r };
            this.pending.set(i2, o2);
            const h5 = await this.rpcSubscribe(i2, r);
            return typeof h5 == "string" && (this.onSubscribe(h5, o2), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i2, opts: s2 } })), h5;
          } catch (r) {
            throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(r), r;
          }
        }, this.unsubscribe = async (i2, s2) => {
          await this.restartToComplete(), this.isInitialized(), typeof s2?.id < "u" ? await this.unsubscribeById(i2, s2.id, s2) : await this.unsubscribeByTopic(i2, s2);
        }, this.isSubscribed = async (i2) => {
          if (this.topics.includes(i2))
            return true;
          const s2 = `${this.pendingSubscriptionWatchLabel}_${i2}`;
          return await new Promise((r, o2) => {
            const h5 = new l4.Watch();
            h5.start(s2);
            const c4 = setInterval(() => {
              !this.pending.has(i2) && this.topics.includes(i2) && (clearInterval(c4), h5.stop(s2), r(true)), h5.elapsed(s2) >= je && (clearInterval(c4), h5.stop(s2), o2(new Error("Subscription resolution timeout")));
            }, this.pollingInterval);
          }).catch(() => false);
        }, this.on = (i2, s2) => {
          this.events.on(i2, s2);
        }, this.once = (i2, s2) => {
          this.events.once(i2, s2);
        }, this.off = (i2, s2) => {
          this.events.off(i2, s2);
        }, this.removeListener = (i2, s2) => {
          this.events.removeListener(i2, s2);
        }, this.start = async () => {
          await this.onConnect();
        }, this.stop = async () => {
          await this.onDisconnect();
        }, this.restart = async () => {
          this.restartInProgress = true, await this.restore(), await this.reset(), this.restartInProgress = false;
        }, this.relayer = e2, this.logger = g3.generateChildLogger(t, this.name), this.clientId = "";
      }
      get context() {
        return g3.getLoggerContext(this.logger);
      }
      get storageKey() {
        return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
      }
      get length() {
        return this.subscriptions.size;
      }
      get ids() {
        return Array.from(this.subscriptions.keys());
      }
      get values() {
        return Array.from(this.subscriptions.values());
      }
      get topics() {
        return this.topicMap.topics;
      }
      hasSubscription(e2, t) {
        let i2 = false;
        try {
          i2 = this.getSubscription(e2).topic === t;
        } catch {
        }
        return i2;
      }
      onEnable() {
        this.cached = [], this.initialized = true;
      }
      onDisable() {
        this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
      }
      async unsubscribeByTopic(e2, t) {
        const i2 = this.topicMap.get(e2);
        await Promise.all(i2.map(async (s2) => await this.unsubscribeById(e2, s2, t)));
      }
      async unsubscribeById(e2, t, i2) {
        this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e2, id: t, opts: i2 } });
        try {
          const s2 = a3.getRelayProtocolName(i2);
          await this.rpcUnsubscribe(e2, t, s2);
          const r = a3.getSdkError("USER_DISCONNECTED", `${this.name}, ${e2}`);
          await this.onUnsubscribe(e2, t, r), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e2, id: t, opts: i2 } });
        } catch (s2) {
          throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s2), s2;
        }
      }
      async rpcSubscribe(e2, t) {
        const i2 = { method: a3.getRelayProtocolApi(t.protocol).subscribe, params: { topic: e2 } };
        this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i2 });
        try {
          return await await a3.createExpiringPromise(this.relayer.request(i2).catch((s2) => this.logger.warn(s2)), this.subscribeTimeout) ? a3.hashMessage(e2 + this.clientId) : null;
        } catch {
          this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(I2.connection_stalled);
        }
        return null;
      }
      async rpcBatchSubscribe(e2) {
        if (!e2.length)
          return;
        const t = e2[0].relay, i2 = { method: a3.getRelayProtocolApi(t.protocol).batchSubscribe, params: { topics: e2.map((s2) => s2.topic) } };
        this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i2 });
        try {
          return await await a3.createExpiringPromise(this.relayer.request(i2).catch((s2) => this.logger.warn(s2)), this.subscribeTimeout);
        } catch {
          this.relayer.events.emit(I2.connection_stalled);
        }
      }
      rpcUnsubscribe(e2, t, i2) {
        const s2 = { method: a3.getRelayProtocolApi(i2.protocol).unsubscribe, params: { topic: e2, id: t } };
        return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s2 }), this.relayer.request(s2);
      }
      onSubscribe(e2, t) {
        this.setSubscription(e2, ne(q2({}, t), { id: e2 })), this.pending.delete(t.topic);
      }
      onBatchSubscribe(e2) {
        e2.length && e2.forEach((t) => {
          this.setSubscription(t.id, q2({}, t)), this.pending.delete(t.topic);
        });
      }
      async onUnsubscribe(e2, t, i2) {
        this.events.removeAllListeners(t), this.hasSubscription(t, e2) && this.deleteSubscription(t, i2), await this.relayer.messages.del(e2);
      }
      async setRelayerSubscriptions(e2) {
        await this.relayer.core.storage.setItem(this.storageKey, e2);
      }
      async getRelayerSubscriptions() {
        return await this.relayer.core.storage.getItem(this.storageKey);
      }
      setSubscription(e2, t) {
        this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e2, subscription: t }), this.addSubscription(e2, t);
      }
      addSubscription(e2, t) {
        this.subscriptions.set(e2, q2({}, t)), this.topicMap.set(t.topic, e2), this.events.emit(S4.created, t);
      }
      getSubscription(e2) {
        this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e2 });
        const t = this.subscriptions.get(e2);
        if (!t) {
          const { message: i2 } = a3.getInternalError("NO_MATCHING_KEY", `${this.name}: ${e2}`);
          throw new Error(i2);
        }
        return t;
      }
      deleteSubscription(e2, t) {
        this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e2, reason: t });
        const i2 = this.getSubscription(e2);
        this.subscriptions.delete(e2), this.topicMap.delete(i2.topic, e2), this.events.emit(S4.deleted, ne(q2({}, i2), { reason: t }));
      }
      async persist() {
        await this.setRelayerSubscriptions(this.values), this.events.emit(S4.sync);
      }
      async reset() {
        if (this.cached.length) {
          const e2 = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
          for (let t = 0; t < e2; t++) {
            const i2 = this.cached.splice(0, this.batchSubscribeTopicsLimit);
            await this.batchSubscribe(i2);
          }
        }
        this.events.emit(S4.resubscribed);
      }
      async restore() {
        try {
          const e2 = await this.getRelayerSubscriptions();
          if (typeof e2 > "u" || !e2.length)
            return;
          if (this.subscriptions.size) {
            const { message: t } = a3.getInternalError("RESTORE_WILL_OVERRIDE", this.name);
            throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
          }
          this.cached = e2, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
        } catch (e2) {
          this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e2);
        }
      }
      async batchSubscribe(e2) {
        if (!e2.length)
          return;
        const t = await this.rpcBatchSubscribe(e2);
        a3.isValidArray(t) && this.onBatchSubscribe(t.map((i2, s2) => ne(q2({}, e2[s2]), { id: i2 })));
      }
      async onConnect() {
        await this.restart(), this.onEnable();
      }
      onDisconnect() {
        this.onDisable();
      }
      async checkPending() {
        if (!this.initialized || !this.relayer.connected)
          return;
        const e2 = [];
        this.pending.forEach((t) => {
          e2.push(t);
        }), await this.batchSubscribe(e2);
      }
      registerEventListeners() {
        this.relayer.core.heartbeat.on($.HEARTBEAT_EVENTS.pulse, async () => {
          await this.checkPending();
        }), this.events.on(S4.created, async (e2) => {
          const t = S4.created;
          this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e2 }), await this.persist();
        }), this.events.on(S4.deleted, async (e2) => {
          const t = S4.deleted;
          this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e2 }), await this.persist();
        });
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e2 } = a3.getInternalError("NOT_INITIALIZED", this.name);
          throw new Error(e2);
        }
      }
      async restartToComplete() {
        this.restartInProgress && await new Promise((e2) => {
          const t = setInterval(() => {
            this.restartInProgress || (clearInterval(t), e2());
          }, this.pollingInterval);
        });
      }
    };
    var Es = Object.defineProperty;
    var ht = Object.getOwnPropertySymbols;
    var ms = Object.prototype.hasOwnProperty;
    var bs = Object.prototype.propertyIsEnumerable;
    var ct = (n3, e2, t) => e2 in n3 ? Es(n3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : n3[e2] = t;
    var fs = (n3, e2) => {
      for (var t in e2 || (e2 = {}))
        ms.call(e2, t) && ct(n3, t, e2[t]);
      if (ht)
        for (var t of ht(e2))
          bs.call(e2, t) && ct(n3, t, e2[t]);
      return n3;
    };
    var lt = class extends x3.IRelayer {
      constructor(e2) {
        super(e2), this.protocol = "wc", this.version = 2, this.events = new z3.EventEmitter(), this.name = Fe, this.transportExplicitlyClosed = false, this.initialized = false, this.connectionAttemptInProgress = false, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "socket stalled", "interrupted"], this.hasExperiencedNetworkDisruption = false, this.requestsInFlight = /* @__PURE__ */ new Map(), this.heartBeatTimeout = l4.toMiliseconds(l4.THIRTY_SECONDS + l4.ONE_SECOND), this.request = async (t) => {
          var i2, s2;
          this.logger.debug("Publishing Request Payload");
          const r = t.id || f4.getBigIntRpcId().toString();
          await this.toEstablishConnection();
          try {
            const o2 = this.provider.request(t);
            this.requestsInFlight.set(r, { promise: o2, request: t }), this.logger.trace({ id: r, method: t.method, topic: (i2 = t.params) == null ? void 0 : i2.topic }, "relayer.request - attempt to publish...");
            const h5 = await new Promise(async (c4, u3) => {
              const p3 = () => {
                u3(new Error(`relayer.request - publish interrupted, id: ${r}`));
              };
              this.provider.on(w4.disconnect, p3);
              const D2 = await o2;
              this.provider.off(w4.disconnect, p3), c4(D2);
            });
            return this.logger.trace({ id: r, method: t.method, topic: (s2 = t.params) == null ? void 0 : s2.topic }, "relayer.request - published"), h5;
          } catch (o2) {
            throw this.logger.debug(`Failed to Publish Request: ${r}`), o2;
          } finally {
            this.requestsInFlight.delete(r);
          }
        }, this.resetPingTimeout = () => {
          if (a3.isNode())
            try {
              clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
                var t, i2, s2;
                (s2 = (i2 = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : i2.socket) == null || s2.terminate();
              }, this.heartBeatTimeout);
            } catch (t) {
              this.logger.warn(t);
            }
        }, this.onPayloadHandler = (t) => {
          this.onProviderPayload(t), this.resetPingTimeout();
        }, this.onConnectHandler = () => {
          this.startPingTimeout(), this.events.emit(I2.connect);
        }, this.onDisconnectHandler = () => {
          this.onProviderDisconnect();
        }, this.onProviderErrorHandler = (t) => {
          this.logger.error(t), this.events.emit(I2.error, t), this.logger.info("Fatal socket error received, closing transport"), this.transportClose();
        }, this.registerProviderListeners = () => {
          this.provider.on(w4.payload, this.onPayloadHandler), this.provider.on(w4.connect, this.onConnectHandler), this.provider.on(w4.disconnect, this.onDisconnectHandler), this.provider.on(w4.error, this.onProviderErrorHandler);
        }, this.core = e2.core, this.logger = typeof e2.logger < "u" && typeof e2.logger != "string" ? g3.generateChildLogger(e2.logger, this.name) : g3.pino(g3.getDefaultLoggerOptions({ level: e2.logger || ze })), this.messages = new rt(this.logger, e2.core), this.subscriber = new at(this, this.logger), this.publisher = new ls2(this, this.logger), this.relayUrl = e2?.relayUrl || se, this.projectId = e2.projectId, this.bundleId = a3.getBundleId(), this.provider = {};
      }
      async init() {
        this.logger.trace("Initialized"), this.registerEventListeners(), await this.createProvider(), await Promise.all([this.messages.init(), this.subscriber.init()]);
        try {
          await this.transportOpen();
        } catch {
          this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${re}...`), await this.restartTransport(re);
        }
        this.initialized = true, setTimeout(async () => {
          this.subscriber.topics.length === 0 && this.subscriber.pending.size === 0 && (this.logger.info("No topics subscribed to after init, closing transport"), await this.transportClose(), this.transportExplicitlyClosed = false);
        }, ke);
      }
      get context() {
        return g3.getLoggerContext(this.logger);
      }
      get connected() {
        var e2, t, i2;
        return ((i2 = (t = (e2 = this.provider) == null ? void 0 : e2.connection) == null ? void 0 : t.socket) == null ? void 0 : i2.readyState) === 1;
      }
      get connecting() {
        var e2, t, i2;
        return ((i2 = (t = (e2 = this.provider) == null ? void 0 : e2.connection) == null ? void 0 : t.socket) == null ? void 0 : i2.readyState) === 0;
      }
      async publish(e2, t, i2) {
        this.isInitialized(), await this.publisher.publish(e2, t, i2), await this.recordMessageEvent({ topic: e2, message: t, publishedAt: Date.now() });
      }
      async subscribe(e2, t) {
        var i2;
        this.isInitialized();
        let s2 = ((i2 = this.subscriber.topicMap.get(e2)) == null ? void 0 : i2[0]) || "", r;
        const o2 = (h5) => {
          h5.topic === e2 && (this.subscriber.off(S4.created, o2), r());
        };
        return await Promise.all([new Promise((h5) => {
          r = h5, this.subscriber.on(S4.created, o2);
        }), new Promise(async (h5) => {
          s2 = await this.subscriber.subscribe(e2, t) || s2, h5();
        })]), s2;
      }
      async unsubscribe(e2, t) {
        this.isInitialized(), await this.subscriber.unsubscribe(e2, t);
      }
      on(e2, t) {
        this.events.on(e2, t);
      }
      once(e2, t) {
        this.events.once(e2, t);
      }
      off(e2, t) {
        this.events.off(e2, t);
      }
      removeListener(e2, t) {
        this.events.removeListener(e2, t);
      }
      async transportDisconnect() {
        if (!this.hasExperiencedNetworkDisruption && this.connected && this.requestsInFlight.size > 0)
          try {
            await Promise.all(Array.from(this.requestsInFlight.values()).map((e2) => e2.promise));
          } catch (e2) {
            this.logger.warn(e2);
          }
        this.hasExperiencedNetworkDisruption || this.connected ? await a3.createExpiringPromise(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
      }
      async transportClose() {
        this.transportExplicitlyClosed = true, await this.transportDisconnect();
      }
      async transportOpen(e2) {
        await this.confirmOnlineStateOrThrow(), e2 && e2 !== this.relayUrl && (this.relayUrl = e2, await this.transportDisconnect(), await this.createProvider()), this.connectionAttemptInProgress = true, this.transportExplicitlyClosed = false;
        try {
          await new Promise(async (t, i2) => {
            const s2 = () => {
              this.provider.off(w4.disconnect, s2), i2(new Error("Connection interrupted while trying to subscribe"));
            };
            this.provider.on(w4.disconnect, s2), await a3.createExpiringPromise(this.provider.connect(), l4.toMiliseconds(l4.ONE_MINUTE), `Socket stalled when trying to connect to ${this.relayUrl}`).catch((r) => {
              i2(r);
            }), await this.subscriber.start(), this.hasExperiencedNetworkDisruption = false, t();
          });
        } catch (t) {
          this.logger.error(t);
          const i2 = t;
          if (!this.isConnectionStalled(i2.message))
            throw t;
        } finally {
          this.connectionAttemptInProgress = false;
        }
      }
      async restartTransport(e2) {
        this.connectionAttemptInProgress || (this.relayUrl = e2 || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.createProvider(), await this.transportOpen());
      }
      async confirmOnlineStateOrThrow() {
        if (!await a3.isOnline())
          throw new Error("No internet connection detected. Please restart your network and try again.");
      }
      startPingTimeout() {
        var e2, t, i2, s2, r;
        if (a3.isNode())
          try {
            (t = (e2 = this.provider) == null ? void 0 : e2.connection) != null && t.socket && ((r = (s2 = (i2 = this.provider) == null ? void 0 : i2.connection) == null ? void 0 : s2.socket) == null || r.once("ping", () => {
              this.resetPingTimeout();
            })), this.resetPingTimeout();
          } catch (o2) {
            this.logger.warn(o2);
          }
      }
      isConnectionStalled(e2) {
        return this.staleConnectionErrors.some((t) => e2.includes(t));
      }
      async createProvider() {
        this.provider.connection && this.unregisterProviderListeners();
        const e2 = await this.core.crypto.signJWT(this.relayUrl);
        this.provider = new Ct.JsonRpcProvider(new Nt.default(a3.formatRelayRpcUrl({ sdkVersion: $e, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e2, useOnCloseEvent: true, bundleId: this.bundleId }))), this.registerProviderListeners();
      }
      async recordMessageEvent(e2) {
        const { topic: t, message: i2 } = e2;
        await this.messages.set(t, i2);
      }
      async shouldIgnoreMessageEvent(e2) {
        const { topic: t, message: i2 } = e2;
        if (!i2 || i2.length === 0)
          return this.logger.debug(`Ignoring invalid/empty message: ${i2}`), true;
        if (!await this.subscriber.isSubscribed(t))
          return this.logger.debug(`Ignoring message for non-subscribed topic ${t}`), true;
        const s2 = this.messages.has(t, i2);
        return s2 && this.logger.debug(`Ignoring duplicate message: ${i2}`), s2;
      }
      async onProviderPayload(e2) {
        if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e2 }), f4.isJsonRpcRequest(e2)) {
          if (!e2.method.endsWith(Me))
            return;
          const t = e2.params, { topic: i2, message: s2, publishedAt: r } = t.data, o2 = { topic: i2, message: s2, publishedAt: r };
          this.logger.debug("Emitting Relayer Payload"), this.logger.trace(fs({ type: "event", event: t.id }, o2)), this.events.emit(t.id, o2), await this.acknowledgePayload(e2), await this.onMessageEvent(o2);
        } else
          f4.isJsonRpcResponse(e2) && this.events.emit(I2.message_ack, e2);
      }
      async onMessageEvent(e2) {
        await this.shouldIgnoreMessageEvent(e2) || (this.events.emit(I2.message, e2), await this.recordMessageEvent(e2));
      }
      async acknowledgePayload(e2) {
        const t = f4.formatJsonRpcResult(e2.id, true);
        await this.provider.connection.send(t);
      }
      unregisterProviderListeners() {
        this.provider.off(w4.payload, this.onPayloadHandler), this.provider.off(w4.connect, this.onConnectHandler), this.provider.off(w4.disconnect, this.onDisconnectHandler), this.provider.off(w4.error, this.onProviderErrorHandler);
      }
      async registerEventListeners() {
        let e2 = await a3.isOnline();
        a3.subscribeToNetworkChange(async (t) => {
          e2 !== t && (e2 = t, t ? await this.restartTransport().catch((i2) => this.logger.error(i2)) : (this.hasExperiencedNetworkDisruption = true, await this.transportDisconnect(), this.transportExplicitlyClosed = false));
        });
      }
      async onProviderDisconnect() {
        await this.subscriber.stop(), this.events.emit(I2.disconnect), this.connectionAttemptInProgress = false, !this.transportExplicitlyClosed && setTimeout(async () => {
          await this.transportOpen().catch((e2) => this.logger.error(e2));
        }, l4.toMiliseconds(Be));
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e2 } = a3.getInternalError("NOT_INITIALIZED", this.name);
          throw new Error(e2);
        }
      }
      async toEstablishConnection() {
        await this.confirmOnlineStateOrThrow(), !this.connected && (this.connectionAttemptInProgress && await new Promise((e2) => {
          const t = setInterval(() => {
            this.connected && (clearInterval(t), e2());
          }, this.connectionStatusPollingInterval);
        }), await this.transportOpen());
      }
    };
    var ws = Object.defineProperty;
    var ut = Object.getOwnPropertySymbols;
    var vs = Object.prototype.hasOwnProperty;
    var Is = Object.prototype.propertyIsEnumerable;
    var gt = (n3, e2, t) => e2 in n3 ? ws(n3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : n3[e2] = t;
    var dt = (n3, e2) => {
      for (var t in e2 || (e2 = {}))
        vs.call(e2, t) && gt(n3, t, e2[t]);
      if (ut)
        for (var t of ut(e2))
          Is.call(e2, t) && gt(n3, t, e2[t]);
      return n3;
    };
    var pt = class extends x3.IStore {
      constructor(e2, t, i2, s2 = L2, r = void 0) {
        super(e2, t, i2, s2), this.core = e2, this.logger = t, this.name = i2, this.map = /* @__PURE__ */ new Map(), this.version = Ve, this.cached = [], this.initialized = false, this.storagePrefix = L2, this.recentlyDeleted = [], this.recentlyDeletedLimit = 200, this.init = async () => {
          this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o2) => {
            this.getKey && o2 !== null && !a3.isUndefined(o2) ? this.map.set(this.getKey(o2), o2) : a3.isProposalStruct(o2) ? this.map.set(o2.id, o2) : a3.isSessionStruct(o2) && this.map.set(o2.topic, o2);
          }), this.cached = [], this.initialized = true);
        }, this.set = async (o2, h5) => {
          this.isInitialized(), this.map.has(o2) ? await this.update(o2, h5) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: o2, value: h5 }), this.map.set(o2, h5), await this.persist());
        }, this.get = (o2) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: o2 }), this.getData(o2)), this.getAll = (o2) => (this.isInitialized(), o2 ? this.values.filter((h5) => Object.keys(o2).every((c4) => Lt.default(h5[c4], o2[c4]))) : this.values), this.update = async (o2, h5) => {
          this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: o2, update: h5 });
          const c4 = dt(dt({}, this.getData(o2)), h5);
          this.map.set(o2, c4), await this.persist();
        }, this.delete = async (o2, h5) => {
          this.isInitialized(), this.map.has(o2) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: o2, reason: h5 }), this.map.delete(o2), this.addToRecentlyDeleted(o2), await this.persist());
        }, this.logger = g3.generateChildLogger(t, this.name), this.storagePrefix = s2, this.getKey = r;
      }
      get context() {
        return g3.getLoggerContext(this.logger);
      }
      get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
      }
      get length() {
        return this.map.size;
      }
      get keys() {
        return Array.from(this.map.keys());
      }
      get values() {
        return Array.from(this.map.values());
      }
      addToRecentlyDeleted(e2) {
        this.recentlyDeleted.push(e2), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
      }
      async setDataStore(e2) {
        await this.core.storage.setItem(this.storageKey, e2);
      }
      async getDataStore() {
        return await this.core.storage.getItem(this.storageKey);
      }
      getData(e2) {
        const t = this.map.get(e2);
        if (!t) {
          if (this.recentlyDeleted.includes(e2)) {
            const { message: s2 } = a3.getInternalError("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e2}`);
            throw this.logger.error(s2), new Error(s2);
          }
          const { message: i2 } = a3.getInternalError("NO_MATCHING_KEY", `${this.name}: ${e2}`);
          throw this.logger.error(i2), new Error(i2);
        }
        return t;
      }
      async persist() {
        await this.setDataStore(this.values);
      }
      async restore() {
        try {
          const e2 = await this.getDataStore();
          if (typeof e2 > "u" || !e2.length)
            return;
          if (this.map.size) {
            const { message: t } = a3.getInternalError("RESTORE_WILL_OVERRIDE", this.name);
            throw this.logger.error(t), new Error(t);
          }
          this.cached = e2, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
        } catch (e2) {
          this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e2);
        }
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e2 } = a3.getInternalError("NOT_INITIALIZED", this.name);
          throw new Error(e2);
        }
      }
    };
    var Dt = class {
      constructor(e2, t) {
        this.core = e2, this.logger = t, this.name = Ge, this.version = He, this.events = new At.default(), this.initialized = false, this.storagePrefix = L2, this.ignoredPayloadTypes = [a3.TYPE_1], this.registeredMethods = [], this.init = async () => {
          this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
        }, this.register = ({ methods: i2 }) => {
          this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...i2])];
        }, this.create = async (i2) => {
          this.isInitialized();
          const s2 = a3.generateRandomBytes32(), r = await this.core.crypto.setSymKey(s2), o2 = a3.calcExpiry(l4.FIVE_MINUTES), h5 = { protocol: Ue }, c4 = { topic: r, expiry: o2, relay: h5, active: false }, u3 = a3.formatUri({ protocol: this.core.protocol, version: this.core.version, topic: r, symKey: s2, relay: h5, expiryTimestamp: o2, methods: i2?.methods });
          return await this.pairings.set(r, c4), await this.core.relayer.subscribe(r), this.core.expirer.set(r, o2), { topic: r, uri: u3 };
        }, this.pair = async (i2) => {
          this.isInitialized(), this.isValidPair(i2);
          const { topic: s2, symKey: r, relay: o2, expiryTimestamp: h5, methods: c4 } = a3.parseUri(i2.uri);
          let u3;
          if (this.pairings.keys.includes(s2) && (u3 = this.pairings.get(s2), u3.active))
            throw new Error(`Pairing already exists: ${s2}. Please try again with a new connection URI.`);
          const p3 = h5 || a3.calcExpiry(l4.FIVE_MINUTES), D2 = { topic: s2, relay: o2, expiry: p3, active: false, methods: c4 };
          return await this.pairings.set(s2, D2), this.core.expirer.set(s2, p3), i2.activatePairing && await this.activate({ topic: s2 }), this.events.emit(K2.create, D2), this.core.crypto.keychain.has(s2) || await this.core.crypto.setSymKey(r, s2), await this.core.relayer.subscribe(s2, { relay: o2 }), D2;
        }, this.activate = async ({ topic: i2 }) => {
          this.isInitialized();
          const s2 = a3.calcExpiry(l4.THIRTY_DAYS);
          await this.pairings.update(i2, { active: true, expiry: s2 }), this.core.expirer.set(i2, s2);
        }, this.ping = async (i2) => {
          this.isInitialized(), await this.isValidPing(i2);
          const { topic: s2 } = i2;
          if (this.pairings.keys.includes(s2)) {
            const r = await this.sendRequest(s2, "wc_pairingPing", {}), { done: o2, resolve: h5, reject: c4 } = a3.createDelayedPromise();
            this.events.once(a3.engineEvent("pairing_ping", r), ({ error: u3 }) => {
              u3 ? c4(u3) : h5();
            }), await o2();
          }
        }, this.updateExpiry = async ({ topic: i2, expiry: s2 }) => {
          this.isInitialized(), await this.pairings.update(i2, { expiry: s2 });
        }, this.updateMetadata = async ({ topic: i2, metadata: s2 }) => {
          this.isInitialized(), await this.pairings.update(i2, { peerMetadata: s2 });
        }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (i2) => {
          this.isInitialized(), await this.isValidDisconnect(i2);
          const { topic: s2 } = i2;
          this.pairings.keys.includes(s2) && (await this.sendRequest(s2, "wc_pairingDelete", a3.getSdkError("USER_DISCONNECTED")), await this.deletePairing(s2));
        }, this.sendRequest = async (i2, s2, r) => {
          const o2 = f4.formatJsonRpcRequest(s2, r), h5 = await this.core.crypto.encode(i2, o2), c4 = M[s2].req;
          return this.core.history.set(i2, o2), this.core.relayer.publish(i2, h5, c4), o2.id;
        }, this.sendResult = async (i2, s2, r) => {
          const o2 = f4.formatJsonRpcResult(i2, r), h5 = await this.core.crypto.encode(s2, o2), c4 = await this.core.history.get(s2, i2), u3 = M[c4.request.method].res;
          await this.core.relayer.publish(s2, h5, u3), await this.core.history.resolve(o2);
        }, this.sendError = async (i2, s2, r) => {
          const o2 = f4.formatJsonRpcError(i2, r), h5 = await this.core.crypto.encode(s2, o2), c4 = await this.core.history.get(s2, i2), u3 = M[c4.request.method] ? M[c4.request.method].res : M.unregistered_method.res;
          await this.core.relayer.publish(s2, h5, u3), await this.core.history.resolve(o2);
        }, this.deletePairing = async (i2, s2) => {
          await this.core.relayer.unsubscribe(i2), await Promise.all([this.pairings.delete(i2, a3.getSdkError("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(i2), s2 ? Promise.resolve() : this.core.expirer.del(i2)]);
        }, this.cleanup = async () => {
          const i2 = this.pairings.getAll().filter((s2) => a3.isExpired(s2.expiry));
          await Promise.all(i2.map((s2) => this.deletePairing(s2.topic)));
        }, this.onRelayEventRequest = (i2) => {
          const { topic: s2, payload: r } = i2;
          switch (r.method) {
            case "wc_pairingPing":
              return this.onPairingPingRequest(s2, r);
            case "wc_pairingDelete":
              return this.onPairingDeleteRequest(s2, r);
            default:
              return this.onUnknownRpcMethodRequest(s2, r);
          }
        }, this.onRelayEventResponse = async (i2) => {
          const { topic: s2, payload: r } = i2, o2 = (await this.core.history.get(s2, r.id)).request.method;
          switch (o2) {
            case "wc_pairingPing":
              return this.onPairingPingResponse(s2, r);
            default:
              return this.onUnknownRpcMethodResponse(o2);
          }
        }, this.onPairingPingRequest = async (i2, s2) => {
          const { id: r } = s2;
          try {
            this.isValidPing({ topic: i2 }), await this.sendResult(r, i2, true), this.events.emit(K2.ping, { id: r, topic: i2 });
          } catch (o2) {
            await this.sendError(r, i2, o2), this.logger.error(o2);
          }
        }, this.onPairingPingResponse = (i2, s2) => {
          const { id: r } = s2;
          setTimeout(() => {
            f4.isJsonRpcResult(s2) ? this.events.emit(a3.engineEvent("pairing_ping", r), {}) : f4.isJsonRpcError(s2) && this.events.emit(a3.engineEvent("pairing_ping", r), { error: s2.error });
          }, 500);
        }, this.onPairingDeleteRequest = async (i2, s2) => {
          const { id: r } = s2;
          try {
            this.isValidDisconnect({ topic: i2 }), await this.deletePairing(i2), this.events.emit(K2.delete, { id: r, topic: i2 });
          } catch (o2) {
            await this.sendError(r, i2, o2), this.logger.error(o2);
          }
        }, this.onUnknownRpcMethodRequest = async (i2, s2) => {
          const { id: r, method: o2 } = s2;
          try {
            if (this.registeredMethods.includes(o2))
              return;
            const h5 = a3.getSdkError("WC_METHOD_UNSUPPORTED", o2);
            await this.sendError(r, i2, h5), this.logger.error(h5);
          } catch (h5) {
            await this.sendError(r, i2, h5), this.logger.error(h5);
          }
        }, this.onUnknownRpcMethodResponse = (i2) => {
          this.registeredMethods.includes(i2) || this.logger.error(a3.getSdkError("WC_METHOD_UNSUPPORTED", i2));
        }, this.isValidPair = (i2) => {
          var s2;
          if (!a3.isValidParams(i2)) {
            const { message: o2 } = a3.getInternalError("MISSING_OR_INVALID", `pair() params: ${i2}`);
            throw new Error(o2);
          }
          if (!a3.isValidUrl(i2.uri)) {
            const { message: o2 } = a3.getInternalError("MISSING_OR_INVALID", `pair() uri: ${i2.uri}`);
            throw new Error(o2);
          }
          const r = a3.parseUri(i2.uri);
          if (!((s2 = r?.relay) != null && s2.protocol)) {
            const { message: o2 } = a3.getInternalError("MISSING_OR_INVALID", "pair() uri#relay-protocol");
            throw new Error(o2);
          }
          if (!(r != null && r.symKey)) {
            const { message: o2 } = a3.getInternalError("MISSING_OR_INVALID", "pair() uri#symKey");
            throw new Error(o2);
          }
          if (r != null && r.expiryTimestamp && l4.toMiliseconds(r?.expiryTimestamp) < Date.now()) {
            const { message: o2 } = a3.getInternalError("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
            throw new Error(o2);
          }
        }, this.isValidPing = async (i2) => {
          if (!a3.isValidParams(i2)) {
            const { message: r } = a3.getInternalError("MISSING_OR_INVALID", `ping() params: ${i2}`);
            throw new Error(r);
          }
          const { topic: s2 } = i2;
          await this.isValidPairingTopic(s2);
        }, this.isValidDisconnect = async (i2) => {
          if (!a3.isValidParams(i2)) {
            const { message: r } = a3.getInternalError("MISSING_OR_INVALID", `disconnect() params: ${i2}`);
            throw new Error(r);
          }
          const { topic: s2 } = i2;
          await this.isValidPairingTopic(s2);
        }, this.isValidPairingTopic = async (i2) => {
          if (!a3.isValidString(i2, false)) {
            const { message: s2 } = a3.getInternalError("MISSING_OR_INVALID", `pairing topic should be a string: ${i2}`);
            throw new Error(s2);
          }
          if (!this.pairings.keys.includes(i2)) {
            const { message: s2 } = a3.getInternalError("NO_MATCHING_KEY", `pairing topic doesn't exist: ${i2}`);
            throw new Error(s2);
          }
          if (a3.isExpired(this.pairings.get(i2).expiry)) {
            await this.deletePairing(i2);
            const { message: s2 } = a3.getInternalError("EXPIRED", `pairing topic: ${i2}`);
            throw new Error(s2);
          }
        }, this.core = e2, this.logger = g3.generateChildLogger(t, this.name), this.pairings = new pt(this.core, this.logger, this.name, this.storagePrefix);
      }
      get context() {
        return g3.getLoggerContext(this.logger);
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e2 } = a3.getInternalError("NOT_INITIALIZED", this.name);
          throw new Error(e2);
        }
      }
      registerRelayerEvents() {
        this.core.relayer.on(I2.message, async (e2) => {
          const { topic: t, message: i2 } = e2;
          if (!this.pairings.keys.includes(t) || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i2)))
            return;
          const s2 = await this.core.crypto.decode(t, i2);
          try {
            f4.isJsonRpcRequest(s2) ? (this.core.history.set(t, s2), this.onRelayEventRequest({ topic: t, payload: s2 })) : f4.isJsonRpcResponse(s2) && (await this.core.history.resolve(s2), await this.onRelayEventResponse({ topic: t, payload: s2 }), this.core.history.delete(t, s2.id));
          } catch (r) {
            this.logger.error(r);
          }
        });
      }
      registerExpirerEvents() {
        this.core.expirer.on(_4.expired, async (e2) => {
          const { topic: t } = a3.parseExpirerTarget(e2.target);
          t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit(K2.expire, { topic: t }));
        });
      }
    };
    var yt = class extends x3.IJsonRpcHistory {
      constructor(e2, t) {
        super(e2, t), this.core = e2, this.logger = t, this.records = /* @__PURE__ */ new Map(), this.events = new z3.EventEmitter(), this.name = Xe, this.version = Je, this.cached = [], this.initialized = false, this.storagePrefix = L2, this.init = async () => {
          this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i2) => this.records.set(i2.id, i2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
        }, this.set = (i2, s2, r) => {
          if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: i2, request: s2, chainId: r }), this.records.has(s2.id))
            return;
          const o2 = { id: s2.id, topic: i2, request: { method: s2.method, params: s2.params || null }, chainId: r, expiry: a3.calcExpiry(l4.THIRTY_DAYS) };
          this.records.set(o2.id, o2), this.persist(), this.events.emit(R2.created, o2);
        }, this.resolve = async (i2) => {
          if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: i2 }), !this.records.has(i2.id))
            return;
          const s2 = await this.getRecord(i2.id);
          typeof s2.response > "u" && (s2.response = f4.isJsonRpcError(i2) ? { error: i2.error } : { result: i2.result }, this.records.set(s2.id, s2), this.persist(), this.events.emit(R2.updated, s2));
        }, this.get = async (i2, s2) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: i2, id: s2 }), await this.getRecord(s2)), this.delete = (i2, s2) => {
          this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s2 }), this.values.forEach((r) => {
            if (r.topic === i2) {
              if (typeof s2 < "u" && r.id !== s2)
                return;
              this.records.delete(r.id), this.events.emit(R2.deleted, r);
            }
          }), this.persist();
        }, this.exists = async (i2, s2) => (this.isInitialized(), this.records.has(s2) ? (await this.getRecord(s2)).topic === i2 : false), this.on = (i2, s2) => {
          this.events.on(i2, s2);
        }, this.once = (i2, s2) => {
          this.events.once(i2, s2);
        }, this.off = (i2, s2) => {
          this.events.off(i2, s2);
        }, this.removeListener = (i2, s2) => {
          this.events.removeListener(i2, s2);
        }, this.logger = g3.generateChildLogger(t, this.name);
      }
      get context() {
        return g3.getLoggerContext(this.logger);
      }
      get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
      }
      get size() {
        return this.records.size;
      }
      get keys() {
        return Array.from(this.records.keys());
      }
      get values() {
        return Array.from(this.records.values());
      }
      get pending() {
        const e2 = [];
        return this.values.forEach((t) => {
          if (typeof t.response < "u")
            return;
          const i2 = { topic: t.topic, request: f4.formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
          return e2.push(i2);
        }), e2;
      }
      async setJsonRpcRecords(e2) {
        await this.core.storage.setItem(this.storageKey, e2);
      }
      async getJsonRpcRecords() {
        return await this.core.storage.getItem(this.storageKey);
      }
      getRecord(e2) {
        this.isInitialized();
        const t = this.records.get(e2);
        if (!t) {
          const { message: i2 } = a3.getInternalError("NO_MATCHING_KEY", `${this.name}: ${e2}`);
          throw new Error(i2);
        }
        return t;
      }
      async persist() {
        await this.setJsonRpcRecords(this.values), this.events.emit(R2.sync);
      }
      async restore() {
        try {
          const e2 = await this.getJsonRpcRecords();
          if (typeof e2 > "u" || !e2.length)
            return;
          if (this.records.size) {
            const { message: t } = a3.getInternalError("RESTORE_WILL_OVERRIDE", this.name);
            throw this.logger.error(t), new Error(t);
          }
          this.cached = e2, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
        } catch (e2) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e2);
        }
      }
      registerEventListeners() {
        this.events.on(R2.created, (e2) => {
          const t = R2.created;
          this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e2 });
        }), this.events.on(R2.updated, (e2) => {
          const t = R2.updated;
          this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e2 });
        }), this.events.on(R2.deleted, (e2) => {
          const t = R2.deleted;
          this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e2 });
        }), this.core.heartbeat.on($.HEARTBEAT_EVENTS.pulse, () => {
          this.cleanup();
        });
      }
      cleanup() {
        try {
          this.isInitialized();
          let e2 = false;
          this.records.forEach((t) => {
            l4.toMiliseconds(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`), this.records.delete(t.id), this.events.emit(R2.deleted, t, false), e2 = true);
          }), e2 && this.persist();
        } catch (e2) {
          this.logger.warn(e2);
        }
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e2 } = a3.getInternalError("NOT_INITIALIZED", this.name);
          throw new Error(e2);
        }
      }
    };
    var Et = class extends x3.IExpirer {
      constructor(e2, t) {
        super(e2, t), this.core = e2, this.logger = t, this.expirations = /* @__PURE__ */ new Map(), this.events = new z3.EventEmitter(), this.name = We, this.version = Qe, this.cached = [], this.initialized = false, this.storagePrefix = L2, this.init = async () => {
          this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i2) => this.expirations.set(i2.target, i2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
        }, this.has = (i2) => {
          try {
            const s2 = this.formatTarget(i2);
            return typeof this.getExpiration(s2) < "u";
          } catch {
            return false;
          }
        }, this.set = (i2, s2) => {
          this.isInitialized();
          const r = this.formatTarget(i2), o2 = { target: r, expiry: s2 };
          this.expirations.set(r, o2), this.checkExpiry(r, o2), this.events.emit(_4.created, { target: r, expiration: o2 });
        }, this.get = (i2) => {
          this.isInitialized();
          const s2 = this.formatTarget(i2);
          return this.getExpiration(s2);
        }, this.del = (i2) => {
          if (this.isInitialized(), this.has(i2)) {
            const s2 = this.formatTarget(i2), r = this.getExpiration(s2);
            this.expirations.delete(s2), this.events.emit(_4.deleted, { target: s2, expiration: r });
          }
        }, this.on = (i2, s2) => {
          this.events.on(i2, s2);
        }, this.once = (i2, s2) => {
          this.events.once(i2, s2);
        }, this.off = (i2, s2) => {
          this.events.off(i2, s2);
        }, this.removeListener = (i2, s2) => {
          this.events.removeListener(i2, s2);
        }, this.logger = g3.generateChildLogger(t, this.name);
      }
      get context() {
        return g3.getLoggerContext(this.logger);
      }
      get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
      }
      get length() {
        return this.expirations.size;
      }
      get keys() {
        return Array.from(this.expirations.keys());
      }
      get values() {
        return Array.from(this.expirations.values());
      }
      formatTarget(e2) {
        if (typeof e2 == "string")
          return a3.formatTopicTarget(e2);
        if (typeof e2 == "number")
          return a3.formatIdTarget(e2);
        const { message: t } = a3.getInternalError("UNKNOWN_TYPE", `Target type: ${typeof e2}`);
        throw new Error(t);
      }
      async setExpirations(e2) {
        await this.core.storage.setItem(this.storageKey, e2);
      }
      async getExpirations() {
        return await this.core.storage.getItem(this.storageKey);
      }
      async persist() {
        await this.setExpirations(this.values), this.events.emit(_4.sync);
      }
      async restore() {
        try {
          const e2 = await this.getExpirations();
          if (typeof e2 > "u" || !e2.length)
            return;
          if (this.expirations.size) {
            const { message: t } = a3.getInternalError("RESTORE_WILL_OVERRIDE", this.name);
            throw this.logger.error(t), new Error(t);
          }
          this.cached = e2, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
        } catch (e2) {
          this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e2);
        }
      }
      getExpiration(e2) {
        const t = this.expirations.get(e2);
        if (!t) {
          const { message: i2 } = a3.getInternalError("NO_MATCHING_KEY", `${this.name}: ${e2}`);
          throw this.logger.warn(i2), new Error(i2);
        }
        return t;
      }
      checkExpiry(e2, t) {
        const { expiry: i2 } = t;
        l4.toMiliseconds(i2) - Date.now() <= 0 && this.expire(e2, t);
      }
      expire(e2, t) {
        this.expirations.delete(e2), this.events.emit(_4.expired, { target: e2, expiration: t });
      }
      checkExpirations() {
        this.core.relayer.connected && this.expirations.forEach((e2, t) => this.checkExpiry(t, e2));
      }
      registerEventListeners() {
        this.core.heartbeat.on($.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(_4.created, (e2) => {
          const t = _4.created;
          this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e2 }), this.persist();
        }), this.events.on(_4.expired, (e2) => {
          const t = _4.expired;
          this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e2 }), this.persist();
        }), this.events.on(_4.deleted, (e2) => {
          const t = _4.deleted;
          this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e2 }), this.persist();
        });
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e2 } = a3.getInternalError("NOT_INITIALIZED", this.name);
          throw new Error(e2);
        }
      }
    };
    var mt = class extends x3.IVerify {
      constructor(e2, t) {
        super(e2, t), this.projectId = e2, this.logger = t, this.name = X, this.initialized = false, this.queue = [], this.verifyDisabled = false, this.init = async (i2) => {
          if (this.verifyDisabled || a3.isReactNative() || !a3.isBrowser())
            return;
          const s2 = this.getVerifyUrl(i2?.verifyUrl);
          this.verifyUrl !== s2 && this.removeIframe(), this.verifyUrl = s2;
          try {
            await this.createIframe();
          } catch (r) {
            this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(r);
          }
          if (!this.initialized) {
            this.removeIframe(), this.verifyUrl = J;
            try {
              await this.createIframe();
            } catch (r) {
              this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(r), this.verifyDisabled = true;
            }
          }
        }, this.register = async (i2) => {
          this.initialized ? this.sendPost(i2.attestationId) : (this.addToQueue(i2.attestationId), await this.init());
        }, this.resolve = async (i2) => {
          if (this.isDevEnv)
            return "";
          const s2 = this.getVerifyUrl(i2?.verifyUrl);
          let r;
          try {
            r = await this.fetchAttestation(i2.attestationId, s2);
          } catch (o2) {
            this.logger.info(`failed to resolve attestation: ${i2.attestationId} from url: ${s2}`), this.logger.info(o2), r = await this.fetchAttestation(i2.attestationId, J);
          }
          return r;
        }, this.fetchAttestation = async (i2, s2) => {
          this.logger.info(`resolving attestation: ${i2} from url: ${s2}`);
          const r = this.startAbortTimer(l4.ONE_SECOND * 2), o2 = await fetch(`${s2}/attestation/${i2}`, { signal: this.abortController.signal });
          return clearTimeout(r), o2.status === 200 ? await o2.json() : void 0;
        }, this.addToQueue = (i2) => {
          this.queue.push(i2);
        }, this.processQueue = () => {
          this.queue.length !== 0 && (this.queue.forEach((i2) => this.sendPost(i2)), this.queue = []);
        }, this.sendPost = (i2) => {
          var s2;
          try {
            if (!this.iframe)
              return;
            (s2 = this.iframe.contentWindow) == null || s2.postMessage(i2, "*"), this.logger.info(`postMessage sent: ${i2} ${this.verifyUrl}`);
          } catch {
          }
        }, this.createIframe = async () => {
          let i2;
          const s2 = (r) => {
            r.data === "verify_ready" && (this.onInit(), window.removeEventListener("message", s2), i2());
          };
          await Promise.race([new Promise((r) => {
            const o2 = document.getElementById(X);
            if (o2)
              return this.iframe = o2, this.onInit(), r();
            window.addEventListener("message", s2);
            const h5 = document.createElement("iframe");
            h5.id = X, h5.src = `${this.verifyUrl}/${this.projectId}`, h5.style.display = "none", document.body.append(h5), this.iframe = h5, i2 = r;
          }), new Promise((r, o2) => setTimeout(() => {
            window.removeEventListener("message", s2), o2("verify iframe load timeout");
          }, l4.toMiliseconds(l4.FIVE_SECONDS)))]);
        }, this.onInit = () => {
          this.initialized = true, this.processQueue();
        }, this.removeIframe = () => {
          this.iframe && (this.iframe.remove(), this.iframe = void 0, this.initialized = false);
        }, this.getVerifyUrl = (i2) => {
          let s2 = i2 || B2;
          return Ze.includes(s2) || (this.logger.info(`verify url: ${s2}, not included in trusted list, assigning default: ${B2}`), s2 = B2), s2;
        }, this.logger = g3.generateChildLogger(t, this.name), this.verifyUrl = B2, this.abortController = new AbortController(), this.isDevEnv = a3.isNode() && import_process.default.env.IS_VITEST;
      }
      get context() {
        return g3.getLoggerContext(this.logger);
      }
      startAbortTimer(e2) {
        return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), l4.toMiliseconds(e2));
      }
    };
    var bt = class extends x3.IEchoClient {
      constructor(e2, t) {
        super(e2, t), this.projectId = e2, this.logger = t, this.context = et, this.registerDeviceToken = async (i2) => {
          const { clientId: s2, token: r, notificationType: o2, enableEncrypted: h5 = false } = i2, c4 = `${tt}/${this.projectId}/clients`;
          await Ut.default(c4, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: s2, type: o2, token: r, always_raw: h5 }) });
        }, this.logger = g3.generateChildLogger(t, this.context);
      }
    };
    var Rs = Object.defineProperty;
    var ft = Object.getOwnPropertySymbols;
    var _s = Object.prototype.hasOwnProperty;
    var Cs = Object.prototype.propertyIsEnumerable;
    var wt = (n3, e2, t) => e2 in n3 ? Rs(n3, e2, { enumerable: true, configurable: true, writable: true, value: t }) : n3[e2] = t;
    var vt = (n3, e2) => {
      for (var t in e2 || (e2 = {}))
        _s.call(e2, t) && wt(n3, t, e2[t]);
      if (ft)
        for (var t of ft(e2))
          Cs.call(e2, t) && wt(n3, t, e2[t]);
      return n3;
    };
    var W = class _W extends x3.ICore {
      constructor(e2) {
        var t;
        super(e2), this.protocol = te, this.version = Re, this.name = H, this.events = new z3.EventEmitter(), this.initialized = false, this.on = (o2, h5) => this.events.on(o2, h5), this.once = (o2, h5) => this.events.once(o2, h5), this.off = (o2, h5) => this.events.off(o2, h5), this.removeListener = (o2, h5) => this.events.removeListener(o2, h5), this.projectId = e2?.projectId, this.relayUrl = e2?.relayUrl || se, this.customStoragePrefix = e2 != null && e2.customStoragePrefix ? `:${e2.customStoragePrefix}` : "";
        const i2 = g3.getDefaultLoggerOptions({ level: typeof e2?.logger == "string" && e2.logger ? e2.logger : _e.logger }), { logger: s2, chunkLoggerController: r } = g3.generatePlatformLogger({ opts: i2, maxSizeInBytes: e2?.maxLogBlobSizeInBytes, loggerOverride: e2?.logger });
        this.logChunkController = r, (t = this.logChunkController) != null && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
          var o2, h5;
          (o2 = this.logChunkController) != null && o2.downloadLogsBlobInBrowser && ((h5 = this.logChunkController) == null || h5.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
        }), this.logger = g3.generateChildLogger(s2, this.name), this.heartbeat = new $.HeartBeat(), this.crypto = new st(this, this.logger, e2?.keychain), this.history = new yt(this, this.logger), this.expirer = new Et(this, this.logger), this.storage = e2 != null && e2.storage ? e2.storage : new xt.default(vt(vt({}, Ce), e2?.storageOptions)), this.relayer = new lt({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new Dt(this, this.logger), this.verify = new mt(this.projectId || "", this.logger), this.echoClient = new bt(this.projectId || "", this.logger);
      }
      static async init(e2) {
        const t = new _W(e2);
        await t.initialize();
        const i2 = await t.crypto.getClientId();
        return await t.storage.setItem(Ke, i2), t;
      }
      get context() {
        return g3.getLoggerContext(this.logger);
      }
      async start() {
        this.initialized || await this.initialize();
      }
      async getLogsBlob() {
        var e2;
        return (e2 = this.logChunkController) == null ? void 0 : e2.logsToBlob({ clientId: await this.crypto.getClientId() });
      }
      async initialize() {
        this.logger.trace("Initialized");
        try {
          await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = true, this.logger.info("Core Initialization Success");
        } catch (e2) {
          throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e2), this.logger.error(e2.message), e2;
        }
      }
    };
    var Ts = W;
    exports2.CORE_CONTEXT = H, exports2.CORE_DEFAULT = _e, exports2.CORE_PROTOCOL = te, exports2.CORE_STORAGE_OPTIONS = Ce, exports2.CORE_STORAGE_PREFIX = L2, exports2.CORE_VERSION = Re, exports2.CRYPTO_CLIENT_SEED = ie, exports2.CRYPTO_CONTEXT = Te, exports2.CRYPTO_JWT_TTL = Se, exports2.Core = Ts, exports2.Crypto = st, exports2.ECHO_CONTEXT = et, exports2.ECHO_URL = tt, exports2.EXPIRER_CONTEXT = We, exports2.EXPIRER_DEFAULT_TTL = cs, exports2.EXPIRER_EVENTS = _4, exports2.EXPIRER_STORAGE_VERSION = Qe, exports2.EchoClient = bt, exports2.Expirer = Et, exports2.HISTORY_CONTEXT = Xe, exports2.HISTORY_EVENTS = R2, exports2.HISTORY_STORAGE_VERSION = Je, exports2.JsonRpcHistory = yt, exports2.KEYCHAIN_CONTEXT = Oe, exports2.KEYCHAIN_STORAGE_VERSION = Pe, exports2.KeyChain = it, exports2.MESSAGES_CONTEXT = Ae, exports2.MESSAGES_STORAGE_VERSION = xe, exports2.MessageTracker = rt, exports2.PAIRING_CONTEXT = Ge, exports2.PAIRING_DEFAULT_TTL = hs, exports2.PAIRING_EVENTS = K2, exports2.PAIRING_RPC_OPTS = M, exports2.PAIRING_STORAGE_VERSION = He, exports2.PENDING_SUB_RESOLUTION_TIMEOUT = je, exports2.PUBLISHER_CONTEXT = Le, exports2.PUBLISHER_DEFAULT_TTL = Ne, exports2.Pairing = Dt, exports2.RELAYER_CONTEXT = Fe, exports2.RELAYER_DEFAULT_LOGGER = ze, exports2.RELAYER_DEFAULT_PROTOCOL = Ue, exports2.RELAYER_DEFAULT_RELAY_URL = se, exports2.RELAYER_EVENTS = I2, exports2.RELAYER_FAILOVER_RELAY_URL = re, exports2.RELAYER_PROVIDER_EVENTS = w4, exports2.RELAYER_RECONNECT_TIMEOUT = Be, exports2.RELAYER_SDK_VERSION = $e, exports2.RELAYER_STORAGE_OPTIONS = os, exports2.RELAYER_SUBSCRIBER_SUFFIX = Me, exports2.RELAYER_TRANSPORT_CUTOFF = ke, exports2.Relayer = lt, exports2.STORE_STORAGE_VERSION = Ve, exports2.SUBSCRIBER_CONTEXT = qe, exports2.SUBSCRIBER_DEFAULT_TTL = as, exports2.SUBSCRIBER_EVENTS = S4, exports2.SUBSCRIBER_STORAGE_VERSION = Ye, exports2.Store = pt, exports2.Subscriber = at, exports2.TRUSTED_VERIFY_URLS = Ze, exports2.VERIFY_CONTEXT = X, exports2.VERIFY_FALLBACK_SERVER = J, exports2.VERIFY_SERVER = B2, exports2.Verify = mt, exports2.WALLETCONNECT_CLIENT_ID = Ke, exports2.default = W;
  }
});

// node_modules/@walletconnect/sign-client/dist/index.cjs.js
var require_index_cjs4 = __commonJS({
  "node_modules/@walletconnect/sign-client/dist/index.cjs.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var N10 = require_index_cjs3();
    var k4 = (init_index_es2(), __toCommonJS(index_es_exports2));
    var oe = require_index_cjs();
    var s2 = require_index_cjs2();
    var ae = require_events();
    var w4 = require_cjs();
    var u3 = (init_esm5(), __toCommonJS(esm_exports4));
    function fe(y4) {
      return y4 && typeof y4 == "object" && "default" in y4 ? y4 : { default: y4 };
    }
    var qe = fe(ae);
    var ee = "wc";
    var te = 2;
    var ie = "client";
    var F = `${ee}@${te}:${ie}:`;
    var Y = { name: ie, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.com" };
    var Pe = { session_proposal: "session_proposal", session_update: "session_update", session_extend: "session_extend", session_ping: "session_ping", session_delete: "session_delete", session_expire: "session_expire", session_request: "session_request", session_request_sent: "session_request_sent", session_event: "session_event", proposal_expire: "proposal_expire", session_authenticate: "session_authenticate", session_request_expire: "session_request_expire" };
    var Te = { database: ":memory:" };
    var se = "WALLETCONNECT_DEEPLINK_CHOICE";
    var ve = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
    var Oe = "history";
    var Ae = "0.3";
    var ce = "proposal";
    var Ve = w4.THIRTY_DAYS;
    var le = "Proposal expired";
    var he = "session";
    var V = w4.SEVEN_DAYS;
    var pe = "engine";
    var q2 = { wc_sessionPropose: { req: { ttl: w4.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: w4.FIVE_MINUTES, prompt: false, tag: 1101 } }, wc_sessionSettle: { req: { ttl: w4.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: w4.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: w4.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: w4.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: w4.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: w4.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: w4.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: w4.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: w4.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: w4.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: w4.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: w4.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: w4.ONE_DAY, prompt: false, tag: 1114 }, res: { ttl: w4.ONE_DAY, prompt: false, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: w4.ONE_HOUR, prompt: true, tag: 1116 }, res: { ttl: w4.ONE_HOUR, prompt: false, tag: 1117 } } };
    var H = { min: w4.FIVE_MINUTES, max: w4.SEVEN_DAYS };
    var A2 = { idle: "IDLE", active: "ACTIVE" };
    var de = "request";
    var ue = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest"];
    var ge = "wc";
    var De = 1.5;
    var Ee = "auth";
    var we = "authKeys";
    var ye = "pairingTopics";
    var me = "requests";
    var L2 = `${ge}@${1.5}:${Ee}:`;
    var U2 = `${L2}:PUB_KEY`;
    var Ce = Object.defineProperty;
    var xe = Object.defineProperties;
    var be = Object.getOwnPropertyDescriptors;
    var Se = Object.getOwnPropertySymbols;
    var Me = Object.prototype.hasOwnProperty;
    var Le = Object.prototype.propertyIsEnumerable;
    var Ie = (y4, o2, t) => o2 in y4 ? Ce(y4, o2, { enumerable: true, configurable: true, writable: true, value: t }) : y4[o2] = t;
    var S4 = (y4, o2) => {
      for (var t in o2 || (o2 = {}))
        Me.call(o2, t) && Ie(y4, t, o2[t]);
      if (Se)
        for (var t of Se(o2))
          Le.call(o2, t) && Ie(y4, t, o2[t]);
      return y4;
    };
    var C3 = (y4, o2) => xe(y4, be(o2));
    var Ue = class extends oe.IEngine {
      constructor(o2) {
        super(o2), this.name = pe, this.events = new qe.default(), this.initialized = false, this.requestQueue = { state: A2.idle, queue: [] }, this.sessionRequestQueue = { state: A2.idle, queue: [] }, this.requestQueueDelay = w4.ONE_SECOND, this.expectedPairingMethodMap = /* @__PURE__ */ new Map(), this.recentlyDeletedMap = /* @__PURE__ */ new Map(), this.recentlyDeletedLimit = 200, this.init = async () => {
          this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({ methods: Object.keys(q2) }), this.initialized = true, setTimeout(() => {
            this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
          }, w4.toMiliseconds(this.requestQueueDelay)));
        }, this.connect = async (t) => {
          await this.isInitialized();
          const e2 = C3(S4({}, t), { requiredNamespaces: t.requiredNamespaces || {}, optionalNamespaces: t.optionalNamespaces || {} });
          await this.isValidConnect(e2);
          const { pairingTopic: i2, requiredNamespaces: r, optionalNamespaces: n3, sessionProperties: a3, relays: c4 } = e2;
          let l4 = i2, d3, p3 = false;
          try {
            l4 && (p3 = this.client.core.pairing.pairings.get(l4).active);
          } catch (f4) {
            throw this.client.logger.error(`connect() -> pairing.get(${l4}) failed`), f4;
          }
          if (!l4 || !p3) {
            const { topic: f4, uri: T2 } = await this.client.core.pairing.create();
            l4 = f4, d3 = T2;
          }
          if (!l4) {
            const { message: f4 } = s2.getInternalError("NO_MATCHING_KEY", `connect() pairing topic: ${l4}`);
            throw new Error(f4);
          }
          const g3 = await this.client.core.crypto.generateKeyPair(), h5 = q2.wc_sessionPropose.req.ttl || w4.FIVE_MINUTES, m3 = s2.calcExpiry(h5), E4 = S4({ requiredNamespaces: r, optionalNamespaces: n3, relays: c4 ?? [{ protocol: N10.RELAYER_DEFAULT_PROTOCOL }], proposer: { publicKey: g3, metadata: this.client.metadata }, expiryTimestamp: m3 }, a3 && { sessionProperties: a3 }), { reject: R2, resolve: O3, done: I2 } = s2.createDelayedPromise(h5, le);
          this.events.once(s2.engineEvent("session_connect"), async ({ error: f4, session: T2 }) => {
            if (f4)
              R2(f4);
            else if (T2) {
              T2.self.publicKey = g3;
              const x3 = C3(S4({}, T2), { requiredNamespaces: E4.requiredNamespaces, optionalNamespaces: E4.optionalNamespaces });
              await this.client.session.set(T2.topic, x3), await this.setExpiry(T2.topic, T2.expiry), l4 && await this.client.core.pairing.updateMetadata({ topic: l4, metadata: T2.peer.metadata }), O3(x3);
            }
          });
          const P2 = await this.sendRequest({ topic: l4, method: "wc_sessionPropose", params: E4, throwOnFailedPublish: true });
          return await this.setProposal(P2, S4({ id: P2 }, E4)), { uri: d3, approval: I2 };
        }, this.pair = async (t) => {
          await this.isInitialized();
          try {
            return await this.client.core.pairing.pair(t);
          } catch (e2) {
            throw this.client.logger.error("pair() failed"), e2;
          }
        }, this.approve = async (t) => {
          await this.isInitialized();
          try {
            await this.isValidApprove(t);
          } catch (I2) {
            throw this.client.logger.error("approve() -> isValidApprove() failed"), I2;
          }
          const { id: e2, relayProtocol: i2, namespaces: r, sessionProperties: n3, sessionConfig: a3 } = t;
          let c4;
          try {
            c4 = this.client.proposal.get(e2);
          } catch (I2) {
            throw this.client.logger.error(`approve() -> proposal.get(${e2}) failed`), I2;
          }
          let { pairingTopic: l4, proposer: d3, requiredNamespaces: p3, optionalNamespaces: g3 } = c4;
          l4 = l4 || "";
          const h5 = await this.client.core.crypto.generateKeyPair(), m3 = d3.publicKey, E4 = await this.client.core.crypto.generateSharedKey(h5, m3), R2 = S4(S4({ relay: { protocol: i2 ?? "irn" }, namespaces: r, pairingTopic: l4, controller: { publicKey: h5, metadata: this.client.metadata }, expiry: s2.calcExpiry(V) }, n3 && { sessionProperties: n3 }), a3 && { sessionConfig: a3 });
          await this.client.core.relayer.subscribe(E4);
          const O3 = C3(S4({}, R2), { topic: E4, requiredNamespaces: p3, optionalNamespaces: g3, pairingTopic: l4, acknowledged: false, self: R2.controller, peer: { publicKey: d3.publicKey, metadata: d3.metadata }, controller: h5 });
          await this.client.session.set(E4, O3);
          try {
            await this.sendResult({ id: e2, topic: l4, result: { relay: { protocol: i2 ?? "irn" }, responderPublicKey: h5 }, throwOnFailedPublish: true }), await this.sendRequest({ topic: E4, method: "wc_sessionSettle", params: R2, throwOnFailedPublish: true });
          } catch (I2) {
            throw this.client.logger.error(I2), this.client.session.delete(E4, s2.getSdkError("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(E4), I2;
          }
          return await this.client.core.pairing.updateMetadata({ topic: l4, metadata: d3.metadata }), await this.client.proposal.delete(e2, s2.getSdkError("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: l4 }), await this.setExpiry(E4, s2.calcExpiry(V)), { topic: E4, acknowledged: () => new Promise((I2) => setTimeout(() => I2(this.client.session.get(E4)), 500)) };
        }, this.reject = async (t) => {
          await this.isInitialized();
          try {
            await this.isValidReject(t);
          } catch (n3) {
            throw this.client.logger.error("reject() -> isValidReject() failed"), n3;
          }
          const { id: e2, reason: i2 } = t;
          let r;
          try {
            r = this.client.proposal.get(e2).pairingTopic;
          } catch (n3) {
            throw this.client.logger.error(`reject() -> proposal.get(${e2}) failed`), n3;
          }
          r && (await this.sendError({ id: e2, topic: r, error: i2 }), await this.client.proposal.delete(e2, s2.getSdkError("USER_DISCONNECTED")));
        }, this.update = async (t) => {
          await this.isInitialized();
          try {
            await this.isValidUpdate(t);
          } catch (p3) {
            throw this.client.logger.error("update() -> isValidUpdate() failed"), p3;
          }
          const { topic: e2, namespaces: i2 } = t, { done: r, resolve: n3, reject: a3 } = s2.createDelayedPromise(), c4 = u3.payloadId(), l4 = u3.getBigIntRpcId().toString(), d3 = this.client.session.get(e2).namespaces;
          return this.events.once(s2.engineEvent("session_update", c4), ({ error: p3 }) => {
            p3 ? a3(p3) : n3();
          }), await this.client.session.update(e2, { namespaces: i2 }), this.sendRequest({ topic: e2, method: "wc_sessionUpdate", params: { namespaces: i2 }, throwOnFailedPublish: true, clientRpcId: c4, relayRpcId: l4 }).catch((p3) => {
            this.client.logger.error(p3), this.client.session.update(e2, { namespaces: d3 }), a3(p3);
          }), { acknowledged: r };
        }, this.extend = async (t) => {
          await this.isInitialized();
          try {
            await this.isValidExtend(t);
          } catch (c4) {
            throw this.client.logger.error("extend() -> isValidExtend() failed"), c4;
          }
          const { topic: e2 } = t, i2 = u3.payloadId(), { done: r, resolve: n3, reject: a3 } = s2.createDelayedPromise();
          return this.events.once(s2.engineEvent("session_extend", i2), ({ error: c4 }) => {
            c4 ? a3(c4) : n3();
          }), await this.setExpiry(e2, s2.calcExpiry(V)), this.sendRequest({ topic: e2, method: "wc_sessionExtend", params: {}, clientRpcId: i2, throwOnFailedPublish: true }).catch((c4) => {
            a3(c4);
          }), { acknowledged: r };
        }, this.request = async (t) => {
          await this.isInitialized();
          try {
            await this.isValidRequest(t);
          } catch (h5) {
            throw this.client.logger.error("request() -> isValidRequest() failed"), h5;
          }
          const { chainId: e2, request: i2, topic: r, expiry: n3 = q2.wc_sessionRequest.req.ttl } = t, a3 = this.client.session.get(r), c4 = u3.payloadId(), l4 = u3.getBigIntRpcId().toString(), { done: d3, resolve: p3, reject: g3 } = s2.createDelayedPromise(n3, "Request expired. Please try again.");
          return this.events.once(s2.engineEvent("session_request", c4), ({ error: h5, result: m3 }) => {
            h5 ? g3(h5) : p3(m3);
          }), await Promise.all([new Promise(async (h5) => {
            await this.sendRequest({ clientRpcId: c4, relayRpcId: l4, topic: r, method: "wc_sessionRequest", params: { request: C3(S4({}, i2), { expiryTimestamp: s2.calcExpiry(n3) }), chainId: e2 }, expiry: n3, throwOnFailedPublish: true }).catch((m3) => g3(m3)), this.client.events.emit("session_request_sent", { topic: r, request: i2, chainId: e2, id: c4 }), h5();
          }), new Promise(async (h5) => {
            var m3;
            if (!((m3 = a3.sessionConfig) != null && m3.disableDeepLink)) {
              const E4 = await s2.getDeepLink(this.client.core.storage, se);
              s2.handleDeeplinkRedirect({ id: c4, topic: r, wcDeepLink: E4 });
            }
            h5();
          }), d3()]).then((h5) => h5[2]);
        }, this.respond = async (t) => {
          await this.isInitialized(), await this.isValidRespond(t);
          const { topic: e2, response: i2 } = t, { id: r } = i2;
          u3.isJsonRpcResult(i2) ? await this.sendResult({ id: r, topic: e2, result: i2.result, throwOnFailedPublish: true }) : u3.isJsonRpcError(i2) && await this.sendError({ id: r, topic: e2, error: i2.error }), this.cleanupAfterResponse(t);
        }, this.ping = async (t) => {
          await this.isInitialized();
          try {
            await this.isValidPing(t);
          } catch (i2) {
            throw this.client.logger.error("ping() -> isValidPing() failed"), i2;
          }
          const { topic: e2 } = t;
          if (this.client.session.keys.includes(e2)) {
            const i2 = u3.payloadId(), r = u3.getBigIntRpcId().toString(), { done: n3, resolve: a3, reject: c4 } = s2.createDelayedPromise();
            this.events.once(s2.engineEvent("session_ping", i2), ({ error: l4 }) => {
              l4 ? c4(l4) : a3();
            }), await Promise.all([this.sendRequest({ topic: e2, method: "wc_sessionPing", params: {}, throwOnFailedPublish: true, clientRpcId: i2, relayRpcId: r }), n3()]);
          } else
            this.client.core.pairing.pairings.keys.includes(e2) && await this.client.core.pairing.ping({ topic: e2 });
        }, this.emit = async (t) => {
          await this.isInitialized(), await this.isValidEmit(t);
          const { topic: e2, event: i2, chainId: r } = t, n3 = u3.getBigIntRpcId().toString();
          await this.sendRequest({ topic: e2, method: "wc_sessionEvent", params: { event: i2, chainId: r }, throwOnFailedPublish: true, relayRpcId: n3 });
        }, this.disconnect = async (t) => {
          await this.isInitialized(), await this.isValidDisconnect(t);
          const { topic: e2 } = t;
          if (this.client.session.keys.includes(e2))
            await this.sendRequest({ topic: e2, method: "wc_sessionDelete", params: s2.getSdkError("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession({ topic: e2, emitEvent: false });
          else if (this.client.core.pairing.pairings.keys.includes(e2))
            await this.client.core.pairing.disconnect({ topic: e2 });
          else {
            const { message: i2 } = s2.getInternalError("MISMATCHED_TOPIC", `Session or pairing topic not found: ${e2}`);
            throw new Error(i2);
          }
        }, this.find = (t) => (this.isInitialized(), this.client.session.getAll().filter((e2) => s2.isSessionCompatible(e2, t))), this.getPendingSessionRequests = () => this.client.pendingRequest.getAll(), this.authenticate = async (t) => {
          this.isInitialized(), this.isValidAuthenticate(t);
          const { chains: e2, statement: i2 = "", uri: r, domain: n3, nonce: a3, type: c4, exp: l4, nbf: d3, methods: p3 = [] } = t, g3 = [...t.resources || []], { topic: h5, uri: m3 } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"] });
          this.client.logger.info({ message: "Generated new pairing", pairing: { topic: h5, uri: m3 } });
          const E4 = await this.client.core.crypto.generateKeyPair(), R2 = s2.hashKey(E4);
          if (await Promise.all([this.client.auth.authKeys.set(U2, { responseTopic: R2, publicKey: E4 }), this.client.auth.pairingTopics.set(R2, { topic: R2, pairingTopic: h5 })]), await this.client.core.relayer.subscribe(R2), this.client.logger.info(`sending request to new pairing topic: ${h5}`), p3.length > 0) {
            const { namespace: v2 } = s2.parseChainId(e2[0]);
            let _4 = s2.createEncodedRecap(v2, "request", p3);
            s2.getRecapFromResources(g3) && (_4 = s2.mergeEncodedRecaps(_4, g3.pop())), g3.push(_4);
          }
          const O3 = s2.calcExpiry(q2.wc_sessionPropose.req.ttl), I2 = { authPayload: { type: c4 ?? "caip122", chains: e2, statement: i2, aud: r, domain: n3, version: "1", nonce: a3, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: l4, nbf: d3, resources: g3 }, requester: { publicKey: E4, metadata: this.client.metadata }, expiryTimestamp: O3 }, P2 = { eip155: { chains: e2, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...p3])], events: ["chainChanged", "accountsChanged"] } }, f4 = { requiredNamespaces: {}, optionalNamespaces: P2, relays: [{ protocol: "irn" }], proposer: { publicKey: E4, metadata: this.client.metadata }, expiryTimestamp: O3 }, { done: T2, resolve: x3, reject: Q } = s2.createDelayedPromise(q2.wc_sessionAuthenticate.req.ttl, "Request expired"), $ = async ({ error: v2, session: _4 }) => {
            if (this.events.off(s2.engineEvent("session_request", D2), X), v2)
              Q(v2);
            else if (_4) {
              _4.self.publicKey = E4, await this.client.session.set(_4.topic, _4), await this.setExpiry(_4.topic, _4.expiry), h5 && await this.client.core.pairing.updateMetadata({ topic: h5, metadata: _4.peer.metadata });
              const b4 = this.client.session.get(_4.topic);
              x3({ session: b4 });
            }
          }, X = async (v2) => {
            if (v2.error) {
              const M = s2.getSdkError("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
              return v2.error.code === M.code ? void 0 : (this.events.off(s2.engineEvent("session_connect"), $), Q(v2.error.message));
            }
            this.events.off(s2.engineEvent("session_connect"), $);
            const { cacaos: _4, responder: b4 } = v2.result, z3 = [], re = [];
            for (const M of _4) {
              await s2.validateSignedCacao({ cacao: M, projectId: this.client.core.projectId }) || (this.client.logger.error(M, "Signature verification failed"), Q(s2.getSdkError("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
              const { p: B2 } = M, W = s2.getRecapFromResources(B2.resources), ne = [s2.getNamespacedDidChainId(B2.iss)], Re = s2.getDidAddress(B2.iss);
              if (W) {
                const Z = s2.getMethodsFromRecap(W), Ne = s2.getChainsFromRecap(W);
                z3.push(...Z), ne.push(...Ne);
              }
              for (const Z of ne)
                re.push(`${Z}:${Re}`);
            }
            const G = await this.client.core.crypto.generateSharedKey(E4, b4.publicKey);
            let K2;
            z3.length > 0 && (K2 = { topic: G, acknowledged: true, self: { publicKey: E4, metadata: this.client.metadata }, peer: b4, controller: b4.publicKey, expiry: s2.calcExpiry(V), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: h5, namespaces: s2.buildNamespacesFromAuth([...new Set(z3)], [...new Set(re)]) }, await this.client.core.relayer.subscribe(G), await this.client.session.set(G, K2), K2 = this.client.session.get(G)), x3({ auths: _4, session: K2 });
          }, D2 = u3.payloadId(), J = u3.payloadId();
          this.events.once(s2.engineEvent("session_connect"), $), this.events.once(s2.engineEvent("session_request", D2), X);
          try {
            await Promise.all([this.sendRequest({ topic: h5, method: "wc_sessionAuthenticate", params: I2, expiry: t.expiry, throwOnFailedPublish: true, clientRpcId: D2 }), this.sendRequest({ topic: h5, method: "wc_sessionPropose", params: f4, expiry: q2.wc_sessionPropose.req.ttl, throwOnFailedPublish: true, clientRpcId: J })]);
          } catch (v2) {
            throw this.events.off(s2.engineEvent("session_connect"), $), this.events.off(s2.engineEvent("session_request", D2), X), v2;
          }
          return await this.setProposal(J, S4({ id: J }, f4)), await this.client.auth.requests.set(D2, { authPayload: I2.authPayload, requester: I2.requester, expiryTimestamp: O3, id: D2, pairingTopic: h5, verifyContext: {} }), { uri: m3, response: T2 };
        }, this.approveSessionAuthenticate = async (t) => {
          this.isInitialized();
          const { id: e2, auths: i2 } = t, r = this.getPendingAuthRequest(e2);
          if (!r)
            throw new Error(`Could not find pending auth request with id ${e2}`);
          const n3 = r.requester.publicKey, a3 = await this.client.core.crypto.generateKeyPair(), c4 = s2.hashKey(n3), l4 = { type: s2.TYPE_1, receiverPublicKey: n3, senderPublicKey: a3 }, d3 = [], p3 = [];
          for (const m3 of i2) {
            if (!await s2.validateSignedCacao({ cacao: m3, projectId: this.client.core.projectId })) {
              const P2 = s2.getSdkError("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
              throw await this.sendError({ id: e2, topic: c4, error: P2, encodeOpts: l4 }), new Error(P2.message);
            }
            const { p: E4 } = m3, R2 = s2.getRecapFromResources(E4.resources), O3 = [s2.getNamespacedDidChainId(E4.iss)], I2 = s2.getDidAddress(E4.iss);
            if (R2) {
              const P2 = s2.getMethodsFromRecap(R2), f4 = s2.getChainsFromRecap(R2);
              d3.push(...P2), O3.push(...f4);
            }
            for (const P2 of O3)
              p3.push(`${P2}:${I2}`);
          }
          const g3 = await this.client.core.crypto.generateSharedKey(a3, n3);
          let h5;
          return d3?.length > 0 && (h5 = { topic: g3, acknowledged: true, self: { publicKey: a3, metadata: this.client.metadata }, peer: { publicKey: n3, metadata: r.requester.metadata }, controller: n3, expiry: s2.calcExpiry(V), authentication: i2, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: "", namespaces: s2.buildNamespacesFromAuth([...new Set(d3)], [...new Set(p3)]) }, await this.client.core.relayer.subscribe(g3), await this.client.session.set(g3, h5)), await this.sendResult({ topic: c4, id: e2, result: { cacaos: i2, responder: { publicKey: a3, metadata: this.client.metadata } }, encodeOpts: l4, throwOnFailedPublish: true }), await this.client.auth.requests.delete(e2, { message: "fullfilled", code: 0 }), await this.client.core.pairing.activate({ topic: r.pairingTopic }), { session: h5 };
        }, this.rejectSessionAuthenticate = async (t) => {
          await this.isInitialized();
          const { id: e2, reason: i2 } = t, r = this.getPendingAuthRequest(e2);
          if (!r)
            throw new Error(`Could not find pending auth request with id ${e2}`);
          const n3 = r.requester.publicKey, a3 = await this.client.core.crypto.generateKeyPair(), c4 = s2.hashKey(n3), l4 = { type: s2.TYPE_1, receiverPublicKey: n3, senderPublicKey: a3 };
          await this.sendError({ id: e2, topic: c4, error: i2, encodeOpts: l4 }), await this.client.auth.requests.delete(e2, { message: "rejected", code: 0 }), await this.client.proposal.delete(e2, s2.getSdkError("USER_DISCONNECTED"));
        }, this.formatAuthMessage = (t) => {
          this.isInitialized();
          const { request: e2, iss: i2 } = t;
          return s2.formatMessage(e2, i2);
        }, this.cleanupDuplicatePairings = async (t) => {
          if (t.pairingTopic)
            try {
              const e2 = this.client.core.pairing.pairings.get(t.pairingTopic), i2 = this.client.core.pairing.pairings.getAll().filter((r) => {
                var n3, a3;
                return ((n3 = r.peerMetadata) == null ? void 0 : n3.url) && ((a3 = r.peerMetadata) == null ? void 0 : a3.url) === t.peer.metadata.url && r.topic && r.topic !== e2.topic;
              });
              if (i2.length === 0)
                return;
              this.client.logger.info(`Cleaning up ${i2.length} duplicate pairing(s)`), await Promise.all(i2.map((r) => this.client.core.pairing.disconnect({ topic: r.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
            } catch (e2) {
              this.client.logger.error(e2);
            }
        }, this.deleteSession = async (t) => {
          const { topic: e2, expirerHasDeleted: i2 = false, emitEvent: r = true, id: n3 = 0 } = t, { self: a3 } = this.client.session.get(e2);
          await this.client.core.relayer.unsubscribe(e2), await this.client.session.delete(e2, s2.getSdkError("USER_DISCONNECTED")), this.addToRecentlyDeleted(e2, "session"), this.client.core.crypto.keychain.has(a3.publicKey) && await this.client.core.crypto.deleteKeyPair(a3.publicKey), this.client.core.crypto.keychain.has(e2) && await this.client.core.crypto.deleteSymKey(e2), i2 || this.client.core.expirer.del(e2), this.client.core.storage.removeItem(se).catch((c4) => this.client.logger.warn(c4)), this.getPendingSessionRequests().forEach((c4) => {
            c4.topic === e2 && this.deletePendingSessionRequest(c4.id, s2.getSdkError("USER_DISCONNECTED"));
          }), r && this.client.events.emit("session_delete", { id: n3, topic: e2 });
        }, this.deleteProposal = async (t, e2) => {
          await Promise.all([this.client.proposal.delete(t, s2.getSdkError("USER_DISCONNECTED")), e2 ? Promise.resolve() : this.client.core.expirer.del(t)]), this.addToRecentlyDeleted(t, "proposal");
        }, this.deletePendingSessionRequest = async (t, e2, i2 = false) => {
          await Promise.all([this.client.pendingRequest.delete(t, e2), i2 ? Promise.resolve() : this.client.core.expirer.del(t)]), this.addToRecentlyDeleted(t, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((r) => r.id !== t), i2 && (this.sessionRequestQueue.state = A2.idle, this.client.events.emit("session_request_expire", { id: t }));
        }, this.setExpiry = async (t, e2) => {
          this.client.session.keys.includes(t) && await this.client.session.update(t, { expiry: e2 }), this.client.core.expirer.set(t, e2);
        }, this.setProposal = async (t, e2) => {
          await this.client.proposal.set(t, e2), this.client.core.expirer.set(t, s2.calcExpiry(q2.wc_sessionPropose.req.ttl));
        }, this.setPendingSessionRequest = async (t) => {
          const { id: e2, topic: i2, params: r, verifyContext: n3 } = t, a3 = r.request.expiryTimestamp || s2.calcExpiry(q2.wc_sessionRequest.req.ttl);
          await this.client.pendingRequest.set(e2, { id: e2, topic: i2, params: r, verifyContext: n3 }), a3 && this.client.core.expirer.set(e2, a3);
        }, this.sendRequest = async (t) => {
          const { topic: e2, method: i2, params: r, expiry: n3, relayRpcId: a3, clientRpcId: c4, throwOnFailedPublish: l4 } = t, d3 = u3.formatJsonRpcRequest(i2, r, c4);
          if (s2.isBrowser() && ue.includes(i2)) {
            const h5 = s2.hashMessage(JSON.stringify(d3));
            this.client.core.verify.register({ attestationId: h5 });
          }
          let p3;
          try {
            p3 = await this.client.core.crypto.encode(e2, d3);
          } catch (h5) {
            throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${e2} failed`), h5;
          }
          const g3 = q2[i2].req;
          return n3 && (g3.ttl = n3), a3 && (g3.id = a3), this.client.core.history.set(e2, d3), l4 ? (g3.internal = C3(S4({}, g3.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(e2, p3, g3)) : this.client.core.relayer.publish(e2, p3, g3).catch((h5) => this.client.logger.error(h5)), d3.id;
        }, this.sendResult = async (t) => {
          const { id: e2, topic: i2, result: r, throwOnFailedPublish: n3, encodeOpts: a3 } = t, c4 = u3.formatJsonRpcResult(e2, r);
          let l4;
          try {
            l4 = await this.client.core.crypto.encode(i2, c4, a3);
          } catch (g3) {
            throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${i2} failed`), g3;
          }
          let d3;
          try {
            d3 = await this.client.core.history.get(i2, e2);
          } catch (g3) {
            throw this.client.logger.error(`sendResult() -> history.get(${i2}, ${e2}) failed`), g3;
          }
          const p3 = q2[d3.request.method].res;
          n3 ? (p3.internal = C3(S4({}, p3.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(i2, l4, p3)) : this.client.core.relayer.publish(i2, l4, p3).catch((g3) => this.client.logger.error(g3)), await this.client.core.history.resolve(c4);
        }, this.sendError = async (t) => {
          const { id: e2, topic: i2, error: r, encodeOpts: n3 } = t, a3 = u3.formatJsonRpcError(e2, r);
          let c4;
          try {
            c4 = await this.client.core.crypto.encode(i2, a3, n3);
          } catch (p3) {
            throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${i2} failed`), p3;
          }
          let l4;
          try {
            l4 = await this.client.core.history.get(i2, e2);
          } catch (p3) {
            throw this.client.logger.error(`sendError() -> history.get(${i2}, ${e2}) failed`), p3;
          }
          const d3 = q2[l4.request.method].res;
          this.client.core.relayer.publish(i2, c4, d3), await this.client.core.history.resolve(a3);
        }, this.cleanup = async () => {
          const t = [], e2 = [];
          this.client.session.getAll().forEach((i2) => {
            let r = false;
            s2.isExpired(i2.expiry) && (r = true), this.client.core.crypto.keychain.has(i2.topic) || (r = true), r && t.push(i2.topic);
          }), this.client.proposal.getAll().forEach((i2) => {
            s2.isExpired(i2.expiryTimestamp) && e2.push(i2.id);
          }), await Promise.all([...t.map((i2) => this.deleteSession({ topic: i2 })), ...e2.map((i2) => this.deleteProposal(i2))]);
        }, this.onRelayEventRequest = async (t) => {
          this.requestQueue.queue.push(t), await this.processRequestsQueue();
        }, this.processRequestsQueue = async () => {
          if (this.requestQueue.state === A2.active) {
            this.client.logger.info("Request queue already active, skipping...");
            return;
          }
          for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
            this.requestQueue.state = A2.active;
            const t = this.requestQueue.queue.shift();
            if (t)
              try {
                this.processRequest(t), await new Promise((e2) => setTimeout(e2, 300));
              } catch (e2) {
                this.client.logger.warn(e2);
              }
          }
          this.requestQueue.state = A2.idle;
        }, this.processRequest = (t) => {
          const { topic: e2, payload: i2 } = t, r = i2.method;
          if (!this.shouldIgnorePairingRequest({ topic: e2, requestMethod: r }))
            switch (r) {
              case "wc_sessionPropose":
                return this.onSessionProposeRequest(e2, i2);
              case "wc_sessionSettle":
                return this.onSessionSettleRequest(e2, i2);
              case "wc_sessionUpdate":
                return this.onSessionUpdateRequest(e2, i2);
              case "wc_sessionExtend":
                return this.onSessionExtendRequest(e2, i2);
              case "wc_sessionPing":
                return this.onSessionPingRequest(e2, i2);
              case "wc_sessionDelete":
                return this.onSessionDeleteRequest(e2, i2);
              case "wc_sessionRequest":
                return this.onSessionRequest(e2, i2);
              case "wc_sessionEvent":
                return this.onSessionEventRequest(e2, i2);
              case "wc_sessionAuthenticate":
                return this.onSessionAuthenticateRequest(e2, i2);
              default:
                return this.client.logger.info(`Unsupported request method ${r}`);
            }
        }, this.onRelayEventResponse = async (t) => {
          const { topic: e2, payload: i2 } = t, r = (await this.client.core.history.get(e2, i2.id)).request.method;
          switch (r) {
            case "wc_sessionPropose":
              return this.onSessionProposeResponse(e2, i2);
            case "wc_sessionSettle":
              return this.onSessionSettleResponse(e2, i2);
            case "wc_sessionUpdate":
              return this.onSessionUpdateResponse(e2, i2);
            case "wc_sessionExtend":
              return this.onSessionExtendResponse(e2, i2);
            case "wc_sessionPing":
              return this.onSessionPingResponse(e2, i2);
            case "wc_sessionRequest":
              return this.onSessionRequestResponse(e2, i2);
            case "wc_sessionAuthenticate":
              return this.onSessionAuthenticateResponse(e2, i2);
            default:
              return this.client.logger.info(`Unsupported response method ${r}`);
          }
        }, this.onRelayEventUnknownPayload = (t) => {
          const { topic: e2 } = t, { message: i2 } = s2.getInternalError("MISSING_OR_INVALID", `Decoded payload on topic ${e2} is not identifiable as a JSON-RPC request or a response.`);
          throw new Error(i2);
        }, this.shouldIgnorePairingRequest = (t) => {
          const { topic: e2, requestMethod: i2 } = t, r = this.expectedPairingMethodMap.get(e2);
          return !r || r.includes(i2) ? false : !!(r.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
        }, this.onSessionProposeRequest = async (t, e2) => {
          const { params: i2, id: r } = e2;
          try {
            this.isValidConnect(S4({}, e2.params));
            const n3 = i2.expiryTimestamp || s2.calcExpiry(q2.wc_sessionPropose.req.ttl), a3 = S4({ id: r, pairingTopic: t, expiryTimestamp: n3 }, i2);
            await this.setProposal(r, a3);
            const c4 = s2.hashMessage(JSON.stringify(e2)), l4 = await this.getVerifyContext(c4, a3.proposer.metadata);
            this.client.events.emit("session_proposal", { id: r, params: a3, verifyContext: l4 });
          } catch (n3) {
            await this.sendError({ id: r, topic: t, error: n3 }), this.client.logger.error(n3);
          }
        }, this.onSessionProposeResponse = async (t, e2) => {
          const { id: i2 } = e2;
          if (u3.isJsonRpcResult(e2)) {
            const { result: r } = e2;
            this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: r });
            const n3 = this.client.proposal.get(i2);
            this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: n3 });
            const a3 = n3.proposer.publicKey;
            this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: a3 });
            const c4 = r.responderPublicKey;
            this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: c4 });
            const l4 = await this.client.core.crypto.generateSharedKey(a3, c4);
            this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: l4 });
            const d3 = await this.client.core.relayer.subscribe(l4);
            this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: d3 }), await this.client.core.pairing.activate({ topic: t });
          } else if (u3.isJsonRpcError(e2)) {
            await this.client.proposal.delete(i2, s2.getSdkError("USER_DISCONNECTED"));
            const r = s2.engineEvent("session_connect");
            if (this.events.listenerCount(r) === 0)
              throw new Error(`emitting ${r} without any listeners, 954`);
            this.events.emit(s2.engineEvent("session_connect"), { error: e2.error });
          }
        }, this.onSessionSettleRequest = async (t, e2) => {
          const { id: i2, params: r } = e2;
          try {
            this.isValidSessionSettleRequest(r);
            const { relay: n3, controller: a3, expiry: c4, namespaces: l4, sessionProperties: d3, pairingTopic: p3, sessionConfig: g3 } = e2.params, h5 = S4(S4({ topic: t, relay: n3, expiry: c4, namespaces: l4, acknowledged: true, pairingTopic: p3, requiredNamespaces: {}, optionalNamespaces: {}, controller: a3.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: a3.publicKey, metadata: a3.metadata } }, d3 && { sessionProperties: d3 }), g3 && { sessionConfig: g3 });
            await this.sendResult({ id: e2.id, topic: t, result: true, throwOnFailedPublish: true });
            const m3 = s2.engineEvent("session_connect");
            if (this.events.listenerCount(m3) === 0)
              throw new Error(`emitting ${m3} without any listeners 997`);
            this.events.emit(s2.engineEvent("session_connect"), { session: h5 }), this.cleanupDuplicatePairings(h5);
          } catch (n3) {
            await this.sendError({ id: i2, topic: t, error: n3 }), this.client.logger.error(n3);
          }
        }, this.onSessionSettleResponse = async (t, e2) => {
          const { id: i2 } = e2;
          u3.isJsonRpcResult(e2) ? (await this.client.session.update(t, { acknowledged: true }), this.events.emit(s2.engineEvent("session_approve", i2), {})) : u3.isJsonRpcError(e2) && (await this.client.session.delete(t, s2.getSdkError("USER_DISCONNECTED")), this.events.emit(s2.engineEvent("session_approve", i2), { error: e2.error }));
        }, this.onSessionUpdateRequest = async (t, e2) => {
          const { params: i2, id: r } = e2;
          try {
            const n3 = `${t}_session_update`, a3 = s2.MemoryStore.get(n3);
            if (a3 && this.isRequestOutOfSync(a3, r)) {
              this.client.logger.info(`Discarding out of sync request - ${r}`), this.sendError({ id: r, topic: t, error: s2.getSdkError("INVALID_UPDATE_REQUEST") });
              return;
            }
            this.isValidUpdate(S4({ topic: t }, i2));
            try {
              s2.MemoryStore.set(n3, r), await this.client.session.update(t, { namespaces: i2.namespaces }), await this.sendResult({ id: r, topic: t, result: true, throwOnFailedPublish: true });
            } catch (c4) {
              throw s2.MemoryStore.delete(n3), c4;
            }
            this.client.events.emit("session_update", { id: r, topic: t, params: i2 });
          } catch (n3) {
            await this.sendError({ id: r, topic: t, error: n3 }), this.client.logger.error(n3);
          }
        }, this.isRequestOutOfSync = (t, e2) => parseInt(e2.toString().slice(0, -3)) <= parseInt(t.toString().slice(0, -3)), this.onSessionUpdateResponse = (t, e2) => {
          const { id: i2 } = e2, r = s2.engineEvent("session_update", i2);
          if (this.events.listenerCount(r) === 0)
            throw new Error(`emitting ${r} without any listeners`);
          u3.isJsonRpcResult(e2) ? this.events.emit(s2.engineEvent("session_update", i2), {}) : u3.isJsonRpcError(e2) && this.events.emit(s2.engineEvent("session_update", i2), { error: e2.error });
        }, this.onSessionExtendRequest = async (t, e2) => {
          const { id: i2 } = e2;
          try {
            this.isValidExtend({ topic: t }), await this.setExpiry(t, s2.calcExpiry(V)), await this.sendResult({ id: i2, topic: t, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_extend", { id: i2, topic: t });
          } catch (r) {
            await this.sendError({ id: i2, topic: t, error: r }), this.client.logger.error(r);
          }
        }, this.onSessionExtendResponse = (t, e2) => {
          const { id: i2 } = e2, r = s2.engineEvent("session_extend", i2);
          if (this.events.listenerCount(r) === 0)
            throw new Error(`emitting ${r} without any listeners`);
          u3.isJsonRpcResult(e2) ? this.events.emit(s2.engineEvent("session_extend", i2), {}) : u3.isJsonRpcError(e2) && this.events.emit(s2.engineEvent("session_extend", i2), { error: e2.error });
        }, this.onSessionPingRequest = async (t, e2) => {
          const { id: i2 } = e2;
          try {
            this.isValidPing({ topic: t }), await this.sendResult({ id: i2, topic: t, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_ping", { id: i2, topic: t });
          } catch (r) {
            await this.sendError({ id: i2, topic: t, error: r }), this.client.logger.error(r);
          }
        }, this.onSessionPingResponse = (t, e2) => {
          const { id: i2 } = e2, r = s2.engineEvent("session_ping", i2);
          if (this.events.listenerCount(r) === 0)
            throw new Error(`emitting ${r} without any listeners`);
          setTimeout(() => {
            u3.isJsonRpcResult(e2) ? this.events.emit(s2.engineEvent("session_ping", i2), {}) : u3.isJsonRpcError(e2) && this.events.emit(s2.engineEvent("session_ping", i2), { error: e2.error });
          }, 500);
        }, this.onSessionDeleteRequest = async (t, e2) => {
          const { id: i2 } = e2;
          try {
            this.isValidDisconnect({ topic: t, reason: e2.params }), await Promise.all([new Promise((r) => {
              this.client.core.relayer.once(N10.RELAYER_EVENTS.publish, async () => {
                r(await this.deleteSession({ topic: t, id: i2 }));
              });
            }), this.sendResult({ id: i2, topic: t, result: true, throwOnFailedPublish: true }), this.cleanupPendingSentRequestsForTopic({ topic: t, error: s2.getSdkError("USER_DISCONNECTED") })]);
          } catch (r) {
            this.client.logger.error(r);
          }
        }, this.onSessionRequest = async (t, e2) => {
          const { id: i2, params: r } = e2;
          try {
            await this.isValidRequest(S4({ topic: t }, r));
            const n3 = s2.hashMessage(JSON.stringify(u3.formatJsonRpcRequest("wc_sessionRequest", r, i2))), a3 = this.client.session.get(t), c4 = await this.getVerifyContext(n3, a3.peer.metadata), l4 = { id: i2, topic: t, params: r, verifyContext: c4 };
            await this.setPendingSessionRequest(l4), this.addSessionRequestToSessionRequestQueue(l4), this.processSessionRequestQueue();
          } catch (n3) {
            await this.sendError({ id: i2, topic: t, error: n3 }), this.client.logger.error(n3);
          }
        }, this.onSessionRequestResponse = (t, e2) => {
          const { id: i2 } = e2, r = s2.engineEvent("session_request", i2);
          if (this.events.listenerCount(r) === 0)
            throw new Error(`emitting ${r} without any listeners`);
          u3.isJsonRpcResult(e2) ? this.events.emit(s2.engineEvent("session_request", i2), { result: e2.result }) : u3.isJsonRpcError(e2) && this.events.emit(s2.engineEvent("session_request", i2), { error: e2.error });
        }, this.onSessionEventRequest = async (t, e2) => {
          const { id: i2, params: r } = e2;
          try {
            const n3 = `${t}_session_event_${r.event.name}`, a3 = s2.MemoryStore.get(n3);
            if (a3 && this.isRequestOutOfSync(a3, i2)) {
              this.client.logger.info(`Discarding out of sync request - ${i2}`);
              return;
            }
            this.isValidEmit(S4({ topic: t }, r)), this.client.events.emit("session_event", { id: i2, topic: t, params: r }), s2.MemoryStore.set(n3, i2);
          } catch (n3) {
            await this.sendError({ id: i2, topic: t, error: n3 }), this.client.logger.error(n3);
          }
        }, this.onSessionAuthenticateResponse = (t, e2) => {
          const { id: i2 } = e2;
          this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: t, payload: e2 }), u3.isJsonRpcResult(e2) ? this.events.emit(s2.engineEvent("session_request", i2), { result: e2.result }) : u3.isJsonRpcError(e2) && this.events.emit(s2.engineEvent("session_request", i2), { error: e2.error });
        }, this.onSessionAuthenticateRequest = async (t, e2) => {
          const { requester: i2, authPayload: r, expiryTimestamp: n3 } = e2.params, a3 = s2.hashMessage(JSON.stringify(e2)), c4 = await this.getVerifyContext(a3, this.client.metadata), l4 = { requester: i2, pairingTopic: t, id: e2.id, authPayload: r, verifyContext: c4, expiryTimestamp: n3 };
          await this.client.auth.requests.set(e2.id, l4), this.client.events.emit("session_authenticate", { topic: t, params: e2.params, id: e2.id });
        }, this.addSessionRequestToSessionRequestQueue = (t) => {
          this.sessionRequestQueue.queue.push(t);
        }, this.cleanupAfterResponse = (t) => {
          this.deletePendingSessionRequest(t.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
            this.sessionRequestQueue.state = A2.idle, this.processSessionRequestQueue();
          }, w4.toMiliseconds(this.requestQueueDelay));
        }, this.cleanupPendingSentRequestsForTopic = ({ topic: t, error: e2 }) => {
          const i2 = this.client.core.history.pending;
          i2.length > 0 && i2.filter((r) => r.topic === t && r.request.method === "wc_sessionRequest").forEach((r) => {
            const n3 = r.request.id, a3 = s2.engineEvent("session_request", n3);
            if (this.events.listenerCount(a3) === 0)
              throw new Error(`emitting ${a3} without any listeners`);
            this.events.emit(s2.engineEvent("session_request", r.request.id), { error: e2 });
          });
        }, this.processSessionRequestQueue = () => {
          if (this.sessionRequestQueue.state === A2.active) {
            this.client.logger.info("session request queue is already active.");
            return;
          }
          const t = this.sessionRequestQueue.queue[0];
          if (!t) {
            this.client.logger.info("session request queue is empty.");
            return;
          }
          try {
            this.sessionRequestQueue.state = A2.active, this.client.events.emit("session_request", t);
          } catch (e2) {
            this.client.logger.error(e2);
          }
        }, this.onPairingCreated = (t) => {
          if (t.methods && this.expectedPairingMethodMap.set(t.topic, t.methods), t.active)
            return;
          const e2 = this.client.proposal.getAll().find((i2) => i2.pairingTopic === t.topic);
          e2 && this.onSessionProposeRequest(t.topic, u3.formatJsonRpcRequest("wc_sessionPropose", { requiredNamespaces: e2.requiredNamespaces, optionalNamespaces: e2.optionalNamespaces, relays: e2.relays, proposer: e2.proposer, sessionProperties: e2.sessionProperties }, e2.id));
        }, this.isValidConnect = async (t) => {
          if (!s2.isValidParams(t)) {
            const { message: c4 } = s2.getInternalError("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(t)}`);
            throw new Error(c4);
          }
          const { pairingTopic: e2, requiredNamespaces: i2, optionalNamespaces: r, sessionProperties: n3, relays: a3 } = t;
          if (s2.isUndefined(e2) || await this.isValidPairingTopic(e2), !s2.isValidRelays(a3, true)) {
            const { message: c4 } = s2.getInternalError("MISSING_OR_INVALID", `connect() relays: ${a3}`);
            throw new Error(c4);
          }
          !s2.isUndefined(i2) && s2.isValidObject(i2) !== 0 && this.validateNamespaces(i2, "requiredNamespaces"), !s2.isUndefined(r) && s2.isValidObject(r) !== 0 && this.validateNamespaces(r, "optionalNamespaces"), s2.isUndefined(n3) || this.validateSessionProps(n3, "sessionProperties");
        }, this.validateNamespaces = (t, e2) => {
          const i2 = s2.isValidRequiredNamespaces(t, "connect()", e2);
          if (i2)
            throw new Error(i2.message);
        }, this.isValidApprove = async (t) => {
          if (!s2.isValidParams(t))
            throw new Error(s2.getInternalError("MISSING_OR_INVALID", `approve() params: ${t}`).message);
          const { id: e2, namespaces: i2, relayProtocol: r, sessionProperties: n3 } = t;
          this.checkRecentlyDeleted(e2), await this.isValidProposalId(e2);
          const a3 = this.client.proposal.get(e2), c4 = s2.isValidNamespaces(i2, "approve()");
          if (c4)
            throw new Error(c4.message);
          const l4 = s2.isConformingNamespaces(a3.requiredNamespaces, i2, "approve()");
          if (l4)
            throw new Error(l4.message);
          if (!s2.isValidString(r, true)) {
            const { message: d3 } = s2.getInternalError("MISSING_OR_INVALID", `approve() relayProtocol: ${r}`);
            throw new Error(d3);
          }
          s2.isUndefined(n3) || this.validateSessionProps(n3, "sessionProperties");
        }, this.isValidReject = async (t) => {
          if (!s2.isValidParams(t)) {
            const { message: r } = s2.getInternalError("MISSING_OR_INVALID", `reject() params: ${t}`);
            throw new Error(r);
          }
          const { id: e2, reason: i2 } = t;
          if (this.checkRecentlyDeleted(e2), await this.isValidProposalId(e2), !s2.isValidErrorReason(i2)) {
            const { message: r } = s2.getInternalError("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(i2)}`);
            throw new Error(r);
          }
        }, this.isValidSessionSettleRequest = (t) => {
          if (!s2.isValidParams(t)) {
            const { message: l4 } = s2.getInternalError("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${t}`);
            throw new Error(l4);
          }
          const { relay: e2, controller: i2, namespaces: r, expiry: n3 } = t;
          if (!s2.isValidRelay(e2)) {
            const { message: l4 } = s2.getInternalError("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
            throw new Error(l4);
          }
          const a3 = s2.isValidController(i2, "onSessionSettleRequest()");
          if (a3)
            throw new Error(a3.message);
          const c4 = s2.isValidNamespaces(r, "onSessionSettleRequest()");
          if (c4)
            throw new Error(c4.message);
          if (s2.isExpired(n3)) {
            const { message: l4 } = s2.getInternalError("EXPIRED", "onSessionSettleRequest()");
            throw new Error(l4);
          }
        }, this.isValidUpdate = async (t) => {
          if (!s2.isValidParams(t)) {
            const { message: c4 } = s2.getInternalError("MISSING_OR_INVALID", `update() params: ${t}`);
            throw new Error(c4);
          }
          const { topic: e2, namespaces: i2 } = t;
          this.checkRecentlyDeleted(e2), await this.isValidSessionTopic(e2);
          const r = this.client.session.get(e2), n3 = s2.isValidNamespaces(i2, "update()");
          if (n3)
            throw new Error(n3.message);
          const a3 = s2.isConformingNamespaces(r.requiredNamespaces, i2, "update()");
          if (a3)
            throw new Error(a3.message);
        }, this.isValidExtend = async (t) => {
          if (!s2.isValidParams(t)) {
            const { message: i2 } = s2.getInternalError("MISSING_OR_INVALID", `extend() params: ${t}`);
            throw new Error(i2);
          }
          const { topic: e2 } = t;
          this.checkRecentlyDeleted(e2), await this.isValidSessionTopic(e2);
        }, this.isValidRequest = async (t) => {
          if (!s2.isValidParams(t)) {
            const { message: c4 } = s2.getInternalError("MISSING_OR_INVALID", `request() params: ${t}`);
            throw new Error(c4);
          }
          const { topic: e2, request: i2, chainId: r, expiry: n3 } = t;
          this.checkRecentlyDeleted(e2), await this.isValidSessionTopic(e2);
          const { namespaces: a3 } = this.client.session.get(e2);
          if (!s2.isValidNamespacesChainId(a3, r)) {
            const { message: c4 } = s2.getInternalError("MISSING_OR_INVALID", `request() chainId: ${r}`);
            throw new Error(c4);
          }
          if (!s2.isValidRequest(i2)) {
            const { message: c4 } = s2.getInternalError("MISSING_OR_INVALID", `request() ${JSON.stringify(i2)}`);
            throw new Error(c4);
          }
          if (!s2.isValidNamespacesRequest(a3, r, i2.method)) {
            const { message: c4 } = s2.getInternalError("MISSING_OR_INVALID", `request() method: ${i2.method}`);
            throw new Error(c4);
          }
          if (n3 && !s2.isValidRequestExpiry(n3, H)) {
            const { message: c4 } = s2.getInternalError("MISSING_OR_INVALID", `request() expiry: ${n3}. Expiry must be a number (in seconds) between ${H.min} and ${H.max}`);
            throw new Error(c4);
          }
        }, this.isValidRespond = async (t) => {
          var e2;
          if (!s2.isValidParams(t)) {
            const { message: n3 } = s2.getInternalError("MISSING_OR_INVALID", `respond() params: ${t}`);
            throw new Error(n3);
          }
          const { topic: i2, response: r } = t;
          try {
            await this.isValidSessionTopic(i2);
          } catch (n3) {
            throw (e2 = t?.response) != null && e2.id && this.cleanupAfterResponse(t), n3;
          }
          if (!s2.isValidResponse(r)) {
            const { message: n3 } = s2.getInternalError("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(r)}`);
            throw new Error(n3);
          }
        }, this.isValidPing = async (t) => {
          if (!s2.isValidParams(t)) {
            const { message: i2 } = s2.getInternalError("MISSING_OR_INVALID", `ping() params: ${t}`);
            throw new Error(i2);
          }
          const { topic: e2 } = t;
          await this.isValidSessionOrPairingTopic(e2);
        }, this.isValidEmit = async (t) => {
          if (!s2.isValidParams(t)) {
            const { message: a3 } = s2.getInternalError("MISSING_OR_INVALID", `emit() params: ${t}`);
            throw new Error(a3);
          }
          const { topic: e2, event: i2, chainId: r } = t;
          await this.isValidSessionTopic(e2);
          const { namespaces: n3 } = this.client.session.get(e2);
          if (!s2.isValidNamespacesChainId(n3, r)) {
            const { message: a3 } = s2.getInternalError("MISSING_OR_INVALID", `emit() chainId: ${r}`);
            throw new Error(a3);
          }
          if (!s2.isValidEvent(i2)) {
            const { message: a3 } = s2.getInternalError("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(i2)}`);
            throw new Error(a3);
          }
          if (!s2.isValidNamespacesEvent(n3, r, i2.name)) {
            const { message: a3 } = s2.getInternalError("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(i2)}`);
            throw new Error(a3);
          }
        }, this.isValidDisconnect = async (t) => {
          if (!s2.isValidParams(t)) {
            const { message: i2 } = s2.getInternalError("MISSING_OR_INVALID", `disconnect() params: ${t}`);
            throw new Error(i2);
          }
          const { topic: e2 } = t;
          await this.isValidSessionOrPairingTopic(e2);
        }, this.isValidAuthenticate = (t) => {
          const { chains: e2, uri: i2, domain: r, nonce: n3 } = t;
          if (!Array.isArray(e2) || e2.length === 0)
            throw new Error("chains is required and must be a non-empty array");
          if (!s2.isValidString(i2, false))
            throw new Error("uri is required parameter");
          if (!s2.isValidString(r, false))
            throw new Error("domain is required parameter");
          if (!s2.isValidString(n3, false))
            throw new Error("nonce is required parameter");
          if ([...new Set(e2.map((c4) => s2.parseChainId(c4).namespace))].length > 1)
            throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
          const { namespace: a3 } = s2.parseChainId(e2[0]);
          if (a3 !== "eip155")
            throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
        }, this.getVerifyContext = async (t, e2) => {
          const i2 = { verified: { verifyUrl: e2.verifyUrl || N10.VERIFY_SERVER, validation: "UNKNOWN", origin: e2.url || "" } };
          try {
            const r = await this.client.core.verify.resolve({ attestationId: t, verifyUrl: e2.verifyUrl });
            r && (i2.verified.origin = r.origin, i2.verified.isScam = r.isScam, i2.verified.validation = r.origin === new URL(e2.url).origin ? "VALID" : "INVALID");
          } catch (r) {
            this.client.logger.info(r);
          }
          return this.client.logger.info(`Verify context: ${JSON.stringify(i2)}`), i2;
        }, this.validateSessionProps = (t, e2) => {
          Object.values(t).forEach((i2) => {
            if (!s2.isValidString(i2, false)) {
              const { message: r } = s2.getInternalError("MISSING_OR_INVALID", `${e2} must be in Record<string, string> format. Received: ${JSON.stringify(i2)}`);
              throw new Error(r);
            }
          });
        }, this.getPendingAuthRequest = (t) => {
          const e2 = this.client.auth.requests.get(t);
          return typeof e2 == "object" ? e2 : void 0;
        }, this.addToRecentlyDeleted = (t, e2) => {
          if (this.recentlyDeletedMap.set(t, e2), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
            let i2 = 0;
            const r = this.recentlyDeletedLimit / 2;
            for (const n3 of this.recentlyDeletedMap.keys()) {
              if (i2++ >= r)
                break;
              this.recentlyDeletedMap.delete(n3);
            }
          }
        }, this.checkRecentlyDeleted = (t) => {
          const e2 = this.recentlyDeletedMap.get(t);
          if (e2) {
            const { message: i2 } = s2.getInternalError("MISSING_OR_INVALID", `Record was recently deleted - ${e2}: ${t}`);
            throw new Error(i2);
          }
        };
      }
      async isInitialized() {
        if (!this.initialized) {
          const { message: o2 } = s2.getInternalError("NOT_INITIALIZED", this.name);
          throw new Error(o2);
        }
        await this.client.core.relayer.confirmOnlineStateOrThrow();
      }
      registerRelayerEvents() {
        this.client.core.relayer.on(N10.RELAYER_EVENTS.message, async (o2) => {
          const { topic: t, message: e2 } = o2, { publicKey: i2 } = this.client.auth.authKeys.keys.includes(U2) ? this.client.auth.authKeys.get(U2) : { responseTopic: void 0, publicKey: void 0 }, r = await this.client.core.crypto.decode(t, e2, { receiverPublicKey: i2 });
          try {
            u3.isJsonRpcRequest(r) ? (this.client.core.history.set(t, r), this.onRelayEventRequest({ topic: t, payload: r })) : u3.isJsonRpcResponse(r) ? (await this.client.core.history.resolve(r), await this.onRelayEventResponse({ topic: t, payload: r }), this.client.core.history.delete(t, r.id)) : this.onRelayEventUnknownPayload({ topic: t, payload: r });
          } catch (n3) {
            this.client.logger.error(n3);
          }
        });
      }
      registerExpirerEvents() {
        this.client.core.expirer.on(N10.EXPIRER_EVENTS.expired, async (o2) => {
          const { topic: t, id: e2 } = s2.parseExpirerTarget(o2.target);
          if (e2 && this.client.pendingRequest.keys.includes(e2))
            return await this.deletePendingSessionRequest(e2, s2.getInternalError("EXPIRED"), true);
          t ? this.client.session.keys.includes(t) && (await this.deleteSession({ topic: t, expirerHasDeleted: true }), this.client.events.emit("session_expire", { topic: t })) : e2 && (await this.deleteProposal(e2, true), this.client.events.emit("proposal_expire", { id: e2 }));
        });
      }
      registerPairingEvents() {
        this.client.core.pairing.events.on(N10.PAIRING_EVENTS.create, (o2) => this.onPairingCreated(o2)), this.client.core.pairing.events.on(N10.PAIRING_EVENTS.delete, (o2) => {
          this.addToRecentlyDeleted(o2.topic, "pairing");
        });
      }
      isValidPairingTopic(o2) {
        if (!s2.isValidString(o2, false)) {
          const { message: t } = s2.getInternalError("MISSING_OR_INVALID", `pairing topic should be a string: ${o2}`);
          throw new Error(t);
        }
        if (!this.client.core.pairing.pairings.keys.includes(o2)) {
          const { message: t } = s2.getInternalError("NO_MATCHING_KEY", `pairing topic doesn't exist: ${o2}`);
          throw new Error(t);
        }
        if (s2.isExpired(this.client.core.pairing.pairings.get(o2).expiry)) {
          const { message: t } = s2.getInternalError("EXPIRED", `pairing topic: ${o2}`);
          throw new Error(t);
        }
      }
      async isValidSessionTopic(o2) {
        if (!s2.isValidString(o2, false)) {
          const { message: t } = s2.getInternalError("MISSING_OR_INVALID", `session topic should be a string: ${o2}`);
          throw new Error(t);
        }
        if (this.checkRecentlyDeleted(o2), !this.client.session.keys.includes(o2)) {
          const { message: t } = s2.getInternalError("NO_MATCHING_KEY", `session topic doesn't exist: ${o2}`);
          throw new Error(t);
        }
        if (s2.isExpired(this.client.session.get(o2).expiry)) {
          await this.deleteSession({ topic: o2 });
          const { message: t } = s2.getInternalError("EXPIRED", `session topic: ${o2}`);
          throw new Error(t);
        }
        if (!this.client.core.crypto.keychain.has(o2)) {
          const { message: t } = s2.getInternalError("MISSING_OR_INVALID", `session topic does not exist in keychain: ${o2}`);
          throw await this.deleteSession({ topic: o2 }), new Error(t);
        }
      }
      async isValidSessionOrPairingTopic(o2) {
        if (this.checkRecentlyDeleted(o2), this.client.session.keys.includes(o2))
          await this.isValidSessionTopic(o2);
        else if (this.client.core.pairing.pairings.keys.includes(o2))
          this.isValidPairingTopic(o2);
        else if (s2.isValidString(o2, false)) {
          const { message: t } = s2.getInternalError("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${o2}`);
          throw new Error(t);
        } else {
          const { message: t } = s2.getInternalError("MISSING_OR_INVALID", `session or pairing topic should be a string: ${o2}`);
          throw new Error(t);
        }
      }
      async isValidProposalId(o2) {
        if (!s2.isValidId(o2)) {
          const { message: t } = s2.getInternalError("MISSING_OR_INVALID", `proposal id should be a number: ${o2}`);
          throw new Error(t);
        }
        if (!this.client.proposal.keys.includes(o2)) {
          const { message: t } = s2.getInternalError("NO_MATCHING_KEY", `proposal id doesn't exist: ${o2}`);
          throw new Error(t);
        }
        if (s2.isExpired(this.client.proposal.get(o2).expiryTimestamp)) {
          await this.deleteProposal(o2);
          const { message: t } = s2.getInternalError("EXPIRED", `proposal id: ${o2}`);
          throw new Error(t);
        }
      }
    };
    var $e = class extends N10.Store {
      constructor(o2, t) {
        super(o2, t, ce, F), this.core = o2, this.logger = t;
      }
    };
    var _e = class extends N10.Store {
      constructor(o2, t) {
        super(o2, t, he, F), this.core = o2, this.logger = t;
      }
    };
    var Ge = class extends N10.Store {
      constructor(o2, t) {
        super(o2, t, de, F, (e2) => e2.id), this.core = o2, this.logger = t;
      }
    };
    var Ke = class extends N10.Store {
      constructor(o2, t) {
        super(o2, t, we, L2, () => U2), this.core = o2, this.logger = t;
      }
    };
    var ke = class extends N10.Store {
      constructor(o2, t) {
        super(o2, t, ye, L2), this.core = o2, this.logger = t;
      }
    };
    var Fe = class extends N10.Store {
      constructor(o2, t) {
        super(o2, t, me, L2, (e2) => e2.id), this.core = o2, this.logger = t;
      }
    };
    var Ye = class {
      constructor(o2, t) {
        this.core = o2, this.logger = t, this.authKeys = new Ke(this.core, this.logger), this.pairingTopics = new ke(this.core, this.logger), this.requests = new Fe(this.core, this.logger);
      }
      async init() {
        await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
      }
    };
    var j2 = class _j extends oe.ISignClient {
      constructor(o2) {
        super(o2), this.protocol = ee, this.version = te, this.name = Y.name, this.events = new ae.EventEmitter(), this.on = (e2, i2) => this.events.on(e2, i2), this.once = (e2, i2) => this.events.once(e2, i2), this.off = (e2, i2) => this.events.off(e2, i2), this.removeListener = (e2, i2) => this.events.removeListener(e2, i2), this.removeAllListeners = (e2) => this.events.removeAllListeners(e2), this.connect = async (e2) => {
          try {
            return await this.engine.connect(e2);
          } catch (i2) {
            throw this.logger.error(i2.message), i2;
          }
        }, this.pair = async (e2) => {
          try {
            return await this.engine.pair(e2);
          } catch (i2) {
            throw this.logger.error(i2.message), i2;
          }
        }, this.approve = async (e2) => {
          try {
            return await this.engine.approve(e2);
          } catch (i2) {
            throw this.logger.error(i2.message), i2;
          }
        }, this.reject = async (e2) => {
          try {
            return await this.engine.reject(e2);
          } catch (i2) {
            throw this.logger.error(i2.message), i2;
          }
        }, this.update = async (e2) => {
          try {
            return await this.engine.update(e2);
          } catch (i2) {
            throw this.logger.error(i2.message), i2;
          }
        }, this.extend = async (e2) => {
          try {
            return await this.engine.extend(e2);
          } catch (i2) {
            throw this.logger.error(i2.message), i2;
          }
        }, this.request = async (e2) => {
          try {
            return await this.engine.request(e2);
          } catch (i2) {
            throw this.logger.error(i2.message), i2;
          }
        }, this.respond = async (e2) => {
          try {
            return await this.engine.respond(e2);
          } catch (i2) {
            throw this.logger.error(i2.message), i2;
          }
        }, this.ping = async (e2) => {
          try {
            return await this.engine.ping(e2);
          } catch (i2) {
            throw this.logger.error(i2.message), i2;
          }
        }, this.emit = async (e2) => {
          try {
            return await this.engine.emit(e2);
          } catch (i2) {
            throw this.logger.error(i2.message), i2;
          }
        }, this.disconnect = async (e2) => {
          try {
            return await this.engine.disconnect(e2);
          } catch (i2) {
            throw this.logger.error(i2.message), i2;
          }
        }, this.find = (e2) => {
          try {
            return this.engine.find(e2);
          } catch (i2) {
            throw this.logger.error(i2.message), i2;
          }
        }, this.getPendingSessionRequests = () => {
          try {
            return this.engine.getPendingSessionRequests();
          } catch (e2) {
            throw this.logger.error(e2.message), e2;
          }
        }, this.authenticate = async (e2) => {
          try {
            return await this.engine.authenticate(e2);
          } catch (i2) {
            throw this.logger.error(i2.message), i2;
          }
        }, this.formatAuthMessage = (e2) => {
          try {
            return this.engine.formatAuthMessage(e2);
          } catch (i2) {
            throw this.logger.error(i2.message), i2;
          }
        }, this.approveSessionAuthenticate = async (e2) => {
          try {
            return await this.engine.approveSessionAuthenticate(e2);
          } catch (i2) {
            throw this.logger.error(i2.message), i2;
          }
        }, this.rejectSessionAuthenticate = async (e2) => {
          try {
            return await this.engine.rejectSessionAuthenticate(e2);
          } catch (i2) {
            throw this.logger.error(i2.message), i2;
          }
        }, this.name = o2?.name || Y.name, this.metadata = o2?.metadata || s2.getAppMetadata();
        const t = typeof o2?.logger < "u" && typeof o2?.logger != "string" ? o2.logger : k4.pino(k4.getDefaultLoggerOptions({ level: o2?.logger || Y.logger }));
        this.core = o2?.core || new N10.Core(o2), this.logger = k4.generateChildLogger(t, this.name), this.session = new _e(this.core, this.logger), this.proposal = new $e(this.core, this.logger), this.pendingRequest = new Ge(this.core, this.logger), this.engine = new Ue(this), this.auth = new Ye(this.core, this.logger);
      }
      static async init(o2) {
        const t = new _j(o2);
        return await t.initialize(), t;
      }
      get context() {
        return k4.getLoggerContext(this.logger);
      }
      get pairing() {
        return this.core.pairing.pairings;
      }
      async initialize() {
        this.logger.trace("Initialized");
        try {
          await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), await this.auth.init(), this.core.verify.init({ verifyUrl: this.metadata.verifyUrl }), this.logger.info("SignClient Initialization Success");
        } catch (o2) {
          throw this.logger.info("SignClient Initialization Failure"), this.logger.error(o2.message), o2;
        }
      }
    };
    var He = _e;
    var je = j2;
    exports2.AUTH_CONTEXT = Ee, exports2.AUTH_KEYS_CONTEXT = we, exports2.AUTH_PAIRING_TOPIC_CONTEXT = ye, exports2.AUTH_PROTOCOL = ge, exports2.AUTH_PUBLIC_KEY_NAME = U2, exports2.AUTH_REQUEST_CONTEXT = me, exports2.AUTH_STORAGE_PREFIX = L2, exports2.AUTH_VERSION = De, exports2.ENGINE_CONTEXT = pe, exports2.ENGINE_QUEUE_STATES = A2, exports2.ENGINE_RPC_OPTS = q2, exports2.HISTORY_CONTEXT = Oe, exports2.HISTORY_EVENTS = ve, exports2.HISTORY_STORAGE_VERSION = Ae, exports2.METHODS_TO_VERIFY = ue, exports2.PROPOSAL_CONTEXT = ce, exports2.PROPOSAL_EXPIRY = Ve, exports2.PROPOSAL_EXPIRY_MESSAGE = le, exports2.REQUEST_CONTEXT = de, exports2.SESSION_CONTEXT = he, exports2.SESSION_EXPIRY = V, exports2.SESSION_REQUEST_EXPIRY_BOUNDARIES = H, exports2.SIGN_CLIENT_CONTEXT = ie, exports2.SIGN_CLIENT_DEFAULT = Y, exports2.SIGN_CLIENT_EVENTS = Pe, exports2.SIGN_CLIENT_PROTOCOL = ee, exports2.SIGN_CLIENT_STORAGE_OPTIONS = Te, exports2.SIGN_CLIENT_STORAGE_PREFIX = F, exports2.SIGN_CLIENT_VERSION = te, exports2.SessionStore = He, exports2.SignClient = je, exports2.WALLETCONNECT_DEEPLINK_CHOICE = se, exports2.default = j2;
  }
});

// node_modules/@multiversx/sdk-wallet-connect-provider/out/operation.js
var require_operation2 = __commonJS({
  "node_modules/@multiversx/sdk-wallet-connect-provider/out/operation.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OptionalOperation = exports2.Operation = void 0;
    var Operation;
    (function(Operation2) {
      Operation2["SIGN_TRANSACTION"] = "mvx_signTransaction";
      Operation2["SIGN_TRANSACTIONS"] = "mvx_signTransactions";
      Operation2["SIGN_MESSAGE"] = "mvx_signMessage";
    })(Operation = exports2.Operation || (exports2.Operation = {}));
    var OptionalOperation;
    (function(OptionalOperation2) {
      OptionalOperation2["SIGN_LOGIN_TOKEN"] = "mvx_signLoginToken";
      OptionalOperation2["SIGN_NATIVE_AUTH_TOKEN"] = "mvx_signNativeAuthToken";
      OptionalOperation2["CANCEL_ACTION"] = "mvx_cancelAction";
    })(OptionalOperation = exports2.OptionalOperation || (exports2.OptionalOperation = {}));
  }
});

// node_modules/@multiversx/sdk-wallet-connect-provider/out/constants.js
var require_constants6 = __commonJS({
  "node_modules/@multiversx/sdk-wallet-connect-provider/out/constants.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WALLETCONNECT_SIGN_LOGIN_DELAY = exports2.WALLETCONNECT_MULTIVERSX_OPTIONAL_METHODS = exports2.WALLETCONNECT_MULTIVERSX_METHODS = exports2.WALLETCONNECT_MULTIVERSX_NAMESPACE = void 0;
    var operation_1 = require_operation2();
    exports2.WALLETCONNECT_MULTIVERSX_NAMESPACE = "mvx";
    exports2.WALLETCONNECT_MULTIVERSX_METHODS = Object.values(operation_1.Operation);
    exports2.WALLETCONNECT_MULTIVERSX_OPTIONAL_METHODS = Object.values(operation_1.OptionalOperation);
    exports2.WALLETCONNECT_SIGN_LOGIN_DELAY = 500;
  }
});

// node_modules/@multiversx/sdk-wallet-connect-provider/out/errors.js
var require_errors3 = __commonJS({
  "node_modules/@multiversx/sdk-wallet-connect-provider/out/errors.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WalletConnectV2ProviderErrorMessagesEnum = exports2.ErrBadAddress = exports2.ErrNotImplemented = exports2.Err = void 0;
    var Err = class extends Error {
      constructor(message, inner) {
        super(message);
        this.inner = void 0;
        this.inner = inner;
      }
    };
    exports2.Err = Err;
    var ErrNotImplemented = class extends Err {
      constructor() {
        super("Method not yet implemented");
      }
    };
    exports2.ErrNotImplemented = ErrNotImplemented;
    var ErrBadAddress = class extends Err {
      constructor(value, inner) {
        super(`Bad address: ${value}`, inner);
      }
    };
    exports2.ErrBadAddress = ErrBadAddress;
    var WalletConnectV2ProviderErrorMessagesEnum;
    (function(WalletConnectV2ProviderErrorMessagesEnum2) {
      WalletConnectV2ProviderErrorMessagesEnum2["unableToInit"] = "WalletConnect is unable to init";
      WalletConnectV2ProviderErrorMessagesEnum2["notInitialized"] = "WalletConnect is not initialized";
      WalletConnectV2ProviderErrorMessagesEnum2["unableToConnect"] = "WalletConnect is unable to connect";
      WalletConnectV2ProviderErrorMessagesEnum2["unableToConnectExisting"] = "WalletConnect is unable to connect to existing pairing";
      WalletConnectV2ProviderErrorMessagesEnum2["unableToSignLoginToken"] = "WalletConnect could not sign login token";
      WalletConnectV2ProviderErrorMessagesEnum2["unableToSign"] = "WalletConnect could not sign the message";
      WalletConnectV2ProviderErrorMessagesEnum2["unableToLogin"] = "WalletConnect is unable to login";
      WalletConnectV2ProviderErrorMessagesEnum2["unableToHandleTopic"] = "WalletConnect: Unable to handle topic update";
      WalletConnectV2ProviderErrorMessagesEnum2["unableToHandleEvent"] = "WalletConnect: Unable to handle events";
      WalletConnectV2ProviderErrorMessagesEnum2["unableToHandleCleanup"] = "WalletConnect: Unable to handle cleanup";
      WalletConnectV2ProviderErrorMessagesEnum2["sessionNotConnected"] = "WalletConnect Session is not connected";
      WalletConnectV2ProviderErrorMessagesEnum2["sessionDeleted"] = "WalletConnect Session Deleted";
      WalletConnectV2ProviderErrorMessagesEnum2["sessionExpired"] = "WalletConnect Session Expired";
      WalletConnectV2ProviderErrorMessagesEnum2["alreadyLoggedOut"] = "WalletConnect: Already logged out";
      WalletConnectV2ProviderErrorMessagesEnum2["pingFailed"] = "WalletConnect Ping Failed";
      WalletConnectV2ProviderErrorMessagesEnum2["invalidAddress"] = "WalletConnect: Invalid address";
      WalletConnectV2ProviderErrorMessagesEnum2["requestDifferentChain"] = "WalletConnect: Request Chain Id different than Connection Chain Id";
      WalletConnectV2ProviderErrorMessagesEnum2["invalidMessageResponse"] = "WalletConnect could not sign the message";
      WalletConnectV2ProviderErrorMessagesEnum2["invalidMessageSignature"] = "WalletConnect: Invalid message signature";
      WalletConnectV2ProviderErrorMessagesEnum2["invalidTransactionResponse"] = "WalletConnect could not sign the transactions. Invalid signatures";
      WalletConnectV2ProviderErrorMessagesEnum2["invalidCustomRequestResponse"] = "WalletConnect could not send the custom request";
      WalletConnectV2ProviderErrorMessagesEnum2["transactionError"] = "Transaction canceled";
      WalletConnectV2ProviderErrorMessagesEnum2["connectionError"] = "WalletConnect could not establish a connection";
      WalletConnectV2ProviderErrorMessagesEnum2["invalidGuardian"] = "WalletConnect: Invalid Guardian";
    })(WalletConnectV2ProviderErrorMessagesEnum = exports2.WalletConnectV2ProviderErrorMessagesEnum || (exports2.WalletConnectV2ProviderErrorMessagesEnum = {}));
  }
});

// node_modules/@multiversx/sdk-wallet-connect-provider/out/logger.js
var require_logger2 = __commonJS({
  "node_modules/@multiversx/sdk-wallet-connect-provider/out/logger.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Logger = void 0;
    var Logger = class {
      static error(message) {
        console.error(message);
      }
      static trace(message) {
        console.trace(message);
      }
    };
    exports2.Logger = Logger;
  }
});

// node_modules/@multiversx/sdk-core/out/globals.js
var require_globals = __commonJS({
  "node_modules/@multiversx/sdk-core/out/globals.js"() {
    "use strict";
    init_shim();
    if (!global.Buffer) {
      global.Buffer = require_buffer2().Buffer;
    }
  }
});

// node_modules/@multiversx/sdk-core/out/smartContractQuery.js
var require_smartContractQuery = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartContractQuery.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SmartContractQueryResponse = exports2.SmartContractQuery = void 0;
    var SmartContractQuery = class {
      constructor(options) {
        this.contract = options.contract;
        this.caller = options.caller;
        this.value = options.value;
        this.function = options.function;
        this.arguments = options.arguments;
      }
    };
    exports2.SmartContractQuery = SmartContractQuery;
    var SmartContractQueryResponse = class {
      constructor(obj) {
        this.function = obj.function;
        this.returnCode = obj.returnCode;
        this.returnMessage = obj.returnMessage;
        this.returnDataParts = obj.returnDataParts;
      }
    };
    exports2.SmartContractQueryResponse = SmartContractQueryResponse;
  }
});

// node_modules/@multiversx/sdk-core/out/adapters/queryRunnerAdapter.js
var require_queryRunnerAdapter = __commonJS({
  "node_modules/@multiversx/sdk-core/out/adapters/queryRunnerAdapter.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryRunnerAdapter = void 0;
    var address_1 = require_address();
    var smartContractQuery_1 = require_smartContractQuery();
    var QueryRunnerAdapter = class {
      constructor(options) {
        this.networkProvider = options.networkProvider;
      }
      async runQuery(query) {
        const adaptedQuery = {
          address: address_1.Address.fromBech32(query.contract),
          caller: query.caller ? address_1.Address.fromBech32(query.caller) : void 0,
          func: query.function,
          value: query.value,
          getEncodedArguments: () => query.arguments.map((arg) => import_buffer.Buffer.from(arg).toString("hex"))
        };
        const adaptedQueryResponse = await this.networkProvider.queryContract(adaptedQuery);
        return new smartContractQuery_1.SmartContractQueryResponse({
          function: query.function,
          returnCode: adaptedQueryResponse.returnCode.toString(),
          returnMessage: adaptedQueryResponse.returnMessage,
          returnDataParts: adaptedQueryResponse.getReturnDataParts()
        });
      }
    };
    exports2.QueryRunnerAdapter = QueryRunnerAdapter;
  }
});

// node_modules/@multiversx/sdk-core/out/adapters/index.js
var require_adapters = __commonJS({
  "node_modules/@multiversx/sdk-core/out/adapters/index.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m3, exports3) {
      for (var p3 in m3)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3))
          __createBinding2(exports3, m3, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_queryRunnerAdapter(), exports2);
  }
});

// node_modules/@multiversx/sdk-core/out/converters/index.js
var require_converters = __commonJS({
  "node_modules/@multiversx/sdk-core/out/converters/index.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m3, exports3) {
      for (var p3 in m3)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3))
          __createBinding2(exports3, m3, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_transactionsConverter(), exports2);
  }
});

// node_modules/@multiversx/sdk-core/out/gasEstimator.js
var require_gasEstimator = __commonJS({
  "node_modules/@multiversx/sdk-core/out/gasEstimator.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GasEstimator = exports2.DefaultGasConfiguration = void 0;
    exports2.DefaultGasConfiguration = {
      minGasLimit: 5e4,
      gasPerDataByte: 1500,
      gasCostESDTTransfer: 2e5,
      gasCostESDTNFTTransfer: 2e5,
      gasCostESDTNFTMultiTransfer: 2e5
    };
    var ADDITIONAL_GAS_FOR_ESDT_TRANSFER = 1e5;
    var ADDITIONAL_GAS_FOR_ESDT_NFT_TRANSFER = 8e5;
    var GasEstimator = class {
      constructor(gasConfiguration) {
        this.gasConfiguration = gasConfiguration || exports2.DefaultGasConfiguration;
      }
      forEGLDTransfer(dataLength) {
        const gasLimit = this.gasConfiguration.minGasLimit + this.gasConfiguration.gasPerDataByte * dataLength;
        return gasLimit;
      }
      forESDTTransfer(dataLength) {
        const gasLimit = this.gasConfiguration.minGasLimit + this.gasConfiguration.gasCostESDTTransfer + this.gasConfiguration.gasPerDataByte * dataLength + ADDITIONAL_GAS_FOR_ESDT_TRANSFER;
        return gasLimit;
      }
      forESDTNFTTransfer(dataLength) {
        const gasLimit = this.gasConfiguration.minGasLimit + this.gasConfiguration.gasCostESDTNFTTransfer + this.gasConfiguration.gasPerDataByte * dataLength + ADDITIONAL_GAS_FOR_ESDT_NFT_TRANSFER;
        return gasLimit;
      }
      forMultiESDTNFTTransfer(dataLength, numTransfers) {
        const gasLimit = this.gasConfiguration.minGasLimit + (this.gasConfiguration.gasCostESDTNFTMultiTransfer + ADDITIONAL_GAS_FOR_ESDT_NFT_TRANSFER) * numTransfers + this.gasConfiguration.gasPerDataByte * dataLength;
        return gasLimit;
      }
    };
    exports2.GasEstimator = GasEstimator;
  }
});

// node_modules/@multiversx/sdk-core/out/interface.js
var require_interface2 = __commonJS({
  "node_modules/@multiversx/sdk-core/out/interface.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@multiversx/sdk-core/out/interfaceOfNetwork.js
var require_interfaceOfNetwork = __commonJS({
  "node_modules/@multiversx/sdk-core/out/interfaceOfNetwork.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@multiversx/sdk-core/out/relayedTransactionV1Builder.js
var require_relayedTransactionV1Builder = __commonJS({
  "node_modules/@multiversx/sdk-core/out/relayedTransactionV1Builder.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RelayedTransactionV1Builder = void 0;
    var address_1 = require_address();
    var errors_1 = require_errors();
    var transaction_1 = require_transaction();
    var transactionPayload_1 = require_transactionPayload();
    var JSONbig = require_json_bigint();
    var RelayedTransactionV1Builder = class {
      /**
       * Sets the inner transaction to be used. It has to be already signed.
       *
       * @param {Transaction} transaction The inner transaction to be used
       */
      setInnerTransaction(transaction) {
        this.innerTransaction = transaction;
        return this;
      }
      /**
       * Sets the network config to be used for building the relayed v1 transaction
       *
       * @param {INetworkConfig} netConfig The network configuration to be used
       */
      setNetworkConfig(netConfig) {
        this.netConfig = netConfig;
        return this;
      }
      /**
       * Sets the address of the relayer (the one that will actually pay the fee)
       *
       * @param relayerAddress
       */
      setRelayerAddress(relayerAddress) {
        this.relayerAddress = relayerAddress;
        return this;
      }
      /**
       * (optional) Sets the nonce of the relayer
       *
       * @param relayerNonce
       */
      setRelayerNonce(relayerNonce) {
        this.relayerNonce = relayerNonce;
        return this;
      }
      /**
       * (optional) Sets the version of the relayed transaction
       *
       * @param relayedTxVersion
       */
      setRelayedTransactionVersion(relayedTxVersion) {
        this.relayedTransactionVersion = relayedTxVersion;
        return this;
      }
      /**
       * (optional) Sets the options of the relayed transaction
       *
       * @param relayedTxOptions
       */
      setRelayedTransactionOptions(relayedTxOptions) {
        this.relayedTransactionOptions = relayedTxOptions;
        return this;
      }
      /**
       * (optional) Sets the guardian of the relayed transaction
       *
       * @param relayedTxGuardian
       */
      setRelayedTransactionGuardian(relayedTxGuardian) {
        this.relayedTransactionGuardian = relayedTxGuardian;
        return this;
      }
      /**
       * Tries to build the relayed v1 transaction based on the previously set fields
       *
       * @throws ErrInvalidRelayedV1BuilderArguments
       * @return Transaction
       */
      build() {
        if (!this.innerTransaction || !this.netConfig || !this.relayerAddress || !this.innerTransaction.getSignature()) {
          throw new errors_1.ErrInvalidRelayedV1BuilderArguments();
        }
        const serializedTransaction = this.prepareInnerTransaction();
        const data = `relayedTx@${import_buffer.Buffer.from(serializedTransaction).toString("hex")}`;
        const payload = new transactionPayload_1.TransactionPayload(data);
        const gasLimit = this.netConfig.MinGasLimit + this.netConfig.GasPerDataByte * payload.length() + this.innerTransaction.getGasLimit().valueOf();
        let relayedTransaction = new transaction_1.Transaction({
          nonce: this.relayerNonce,
          sender: this.relayerAddress,
          receiver: this.innerTransaction.getSender(),
          value: 0,
          gasLimit,
          data: payload,
          chainID: this.netConfig.ChainID,
          version: this.relayedTransactionVersion,
          options: this.relayedTransactionOptions,
          guardian: this.relayedTransactionGuardian
        });
        if (this.relayerNonce) {
          relayedTransaction.setNonce(this.relayerNonce);
        }
        return relayedTransaction;
      }
      prepareInnerTransaction() {
        if (!this.innerTransaction) {
          return "";
        }
        const txObject = {
          nonce: this.innerTransaction.getNonce().valueOf(),
          sender: new address_1.Address(this.innerTransaction.getSender().bech32()).pubkey().toString("base64"),
          receiver: new address_1.Address(this.innerTransaction.getReceiver().bech32()).pubkey().toString("base64"),
          value: BigInt(this.innerTransaction.getValue().toString()),
          gasPrice: this.innerTransaction.getGasPrice().valueOf(),
          gasLimit: this.innerTransaction.getGasLimit().valueOf(),
          data: this.innerTransaction.getData().valueOf().toString("base64"),
          signature: this.innerTransaction.getSignature().toString("base64"),
          chainID: import_buffer.Buffer.from(this.innerTransaction.getChainID().valueOf()).toString("base64"),
          version: this.innerTransaction.getVersion().valueOf(),
          options: this.innerTransaction.getOptions().valueOf() == 0 ? void 0 : this.innerTransaction.getOptions().valueOf(),
          guardian: this.innerTransaction.getGuardian().bech32() ? new address_1.Address(this.innerTransaction.getGuardian().bech32()).pubkey().toString("base64") : void 0,
          guardianSignature: this.innerTransaction.getGuardianSignature().toString("hex") ? this.innerTransaction.getGuardianSignature().toString("base64") : void 0,
          sndUserName: this.innerTransaction.getSenderUsername() ? import_buffer.Buffer.from(this.innerTransaction.getSenderUsername()).toString("base64") : void 0,
          rcvUserName: this.innerTransaction.getReceiverUsername() ? import_buffer.Buffer.from(this.innerTransaction.getReceiverUsername()).toString("base64") : void 0
        };
        return JSONbig.stringify(txObject);
      }
    };
    exports2.RelayedTransactionV1Builder = RelayedTransactionV1Builder;
  }
});

// node_modules/@multiversx/sdk-core/out/relayedTransactionV2Builder.js
var require_relayedTransactionV2Builder = __commonJS({
  "node_modules/@multiversx/sdk-core/out/relayedTransactionV2Builder.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RelayedTransactionV2Builder = void 0;
    var errors_1 = require_errors();
    var smartcontracts_1 = require_smartcontracts();
    var transaction_1 = require_transaction();
    var transactionPayload_1 = require_transactionPayload();
    var RelayedTransactionV2Builder = class {
      /**
       * Sets the inner transaction to be used. It has to be already signed and with gasLimit set to 0. These checks
       * are performed on the build() method
       *
       * @param {Transaction} transaction The inner transaction to be used
       */
      setInnerTransaction(transaction) {
        this.innerTransaction = transaction;
        return this;
      }
      /**
       * Sets the gas limit to be used for the SC Call inside the inner transaction
       *
       * @param {IGasLimit} gasLimit The gas limit to be used. The inner transaction needs to have the gas limit set to 0,
       * so this field will specify the gas to be used for the SC call of the inner transaction
       */
      setInnerTransactionGasLimit(gasLimit) {
        this.innerTransactionGasLimit = gasLimit;
        return this;
      }
      /**
       * Sets the network config to be used for building the relayed v2 transaction
       *
       * @param {INetworkConfig} netConfig The network configuration to be used
       */
      setNetworkConfig(netConfig) {
        this.netConfig = netConfig;
        return this;
      }
      /**
       * Sets the address of the relayer (the one that will actually pay the fee)
       *
       * @param relayerAddress
       */
      setRelayerAddress(relayerAddress) {
        this.relayerAddress = relayerAddress;
        return this;
      }
      /**
       * (optional) Sets the nonce of the relayer
       *
       * @param relayerNonce
       */
      setRelayerNonce(relayerNonce) {
        this.relayerNonce = relayerNonce;
        return this;
      }
      /**
       * Tries to build the relayed v2 transaction based on the previously set fields.
       * It returns a transaction that isn't signed
       *
       * @throws ErrInvalidRelayedV2BuilderArguments
       * @throws ErrGasLimitShouldBe0ForInnerTransaction
       * @return Transaction
       */
      build() {
        if (!this.innerTransaction || !this.innerTransactionGasLimit || !this.relayerAddress || !this.netConfig || !this.innerTransaction.getSignature()) {
          throw new errors_1.ErrInvalidRelayedV2BuilderArguments();
        }
        if (this.innerTransaction.getGasLimit() != 0) {
          throw new errors_1.ErrGasLimitShouldBe0ForInnerTransaction();
        }
        const { argumentsString } = new smartcontracts_1.ArgSerializer().valuesToString([
          new smartcontracts_1.AddressValue(this.innerTransaction.getReceiver()),
          new smartcontracts_1.U64Value(this.innerTransaction.getNonce().valueOf()),
          new smartcontracts_1.BytesValue(this.innerTransaction.getData().valueOf()),
          new smartcontracts_1.BytesValue(this.innerTransaction.getSignature())
        ]);
        const data = `relayedTxV2@${argumentsString}`;
        const payload = new transactionPayload_1.TransactionPayload(data);
        let relayedTransaction = new transaction_1.Transaction({
          sender: this.relayerAddress,
          receiver: this.innerTransaction.getSender(),
          value: 0,
          gasLimit: this.innerTransactionGasLimit.valueOf() + this.netConfig.MinGasLimit + this.netConfig.GasPerDataByte * payload.length(),
          data: payload,
          chainID: this.netConfig.ChainID,
          version: this.innerTransaction.getVersion(),
          options: this.innerTransaction.getOptions()
        });
        if (this.relayerNonce) {
          relayedTransaction.setNonce(this.relayerNonce);
        }
        return relayedTransaction;
      }
    };
    exports2.RelayedTransactionV2Builder = RelayedTransactionV2Builder;
  }
});

// node_modules/@multiversx/sdk-core/out/smartContractQueriesController.js
var require_smartContractQueriesController = __commonJS({
  "node_modules/@multiversx/sdk-core/out/smartContractQueriesController.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SmartContractQueriesController = void 0;
    var errors_1 = require_errors();
    var smartContractQuery_1 = require_smartContractQuery();
    var smartcontracts_1 = require_smartcontracts();
    var SmartContractQueriesController = class {
      constructor(options) {
        this.abi = options.abi;
        this.queryRunner = options.queryRunner;
        this.legacyResultsParser = new smartcontracts_1.ResultsParser();
      }
      createQuery(options) {
        const preparedArguments = this.encodeArguments(options.function, options.arguments);
        return new smartContractQuery_1.SmartContractQuery({
          contract: options.contract,
          caller: options.caller,
          function: options.function,
          arguments: preparedArguments,
          value: options.value
        });
      }
      encodeArguments(functionName, args) {
        const endpoint = this.abi?.getEndpoint(functionName);
        if (endpoint) {
          const typedArgs = smartcontracts_1.NativeSerializer.nativeToTypedValues(args, endpoint);
          return new smartcontracts_1.ArgSerializer().valuesToBuffers(typedArgs);
        }
        if (this.areArgsOfTypedValue(args)) {
          return new smartcontracts_1.ArgSerializer().valuesToBuffers(args);
        }
        if (this.areArgsBuffers(args)) {
          return args.map((arg) => import_buffer.Buffer.from(arg));
        }
        throw new errors_1.Err("cannot encode arguments: when ABI is not available, they must be either typed values or buffers");
      }
      areArgsOfTypedValue(args) {
        for (const arg of args) {
          if (!arg.belongsToTypesystem) {
            return false;
          }
        }
        return true;
      }
      areArgsBuffers(args) {
        for (const arg of args) {
          if (!ArrayBuffer.isView(arg)) {
            return false;
          }
        }
        return true;
      }
      async runQuery(query) {
        const queryResponse = await this.queryRunner.runQuery(query);
        return queryResponse;
      }
      parseQueryResponse(response) {
        if (!this.abi) {
          return response.returnDataParts;
        }
        const legacyQueryResponse = {
          returnCode: response.returnCode,
          returnMessage: response.returnMessage,
          getReturnDataParts: () => response.returnDataParts.map((part) => import_buffer.Buffer.from(part))
        };
        const functionName = response.function;
        const endpoint = this.abi.getEndpoint(functionName);
        const legacyBundle = this.legacyResultsParser.parseQueryResponse(legacyQueryResponse, endpoint);
        const nativeValues = legacyBundle.values.map((value) => value.valueOf());
        return nativeValues;
      }
    };
    exports2.SmartContractQueriesController = SmartContractQueriesController;
  }
});

// node_modules/@multiversx/sdk-core/out/index.js
var require_out = __commonJS({
  "node_modules/@multiversx/sdk-core/out/index.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m3, exports3) {
      for (var p3 in m3)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3))
          __createBinding2(exports3, m3, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    require_globals();
    __exportStar2(require_account(), exports2);
    __exportStar2(require_adapters(), exports2);
    __exportStar2(require_address(), exports2);
    __exportStar2(require_asyncTimer(), exports2);
    __exportStar2(require_converters(), exports2);
    __exportStar2(require_errors(), exports2);
    __exportStar2(require_gasEstimator(), exports2);
    __exportStar2(require_interface2(), exports2);
    __exportStar2(require_interfaceOfNetwork(), exports2);
    __exportStar2(require_logger(), exports2);
    __exportStar2(require_message(), exports2);
    __exportStar2(require_networkParams(), exports2);
    __exportStar2(require_relayedTransactionV1Builder(), exports2);
    __exportStar2(require_relayedTransactionV2Builder(), exports2);
    __exportStar2(require_signableMessage(), exports2);
    __exportStar2(require_smartContractQueriesController(), exports2);
    __exportStar2(require_smartcontracts(), exports2);
    __exportStar2(require_tokenOperations(), exports2);
    __exportStar2(require_tokens(), exports2);
    __exportStar2(require_transaction(), exports2);
    __exportStar2(require_transactionComputer(), exports2);
    __exportStar2(require_transactionPayload(), exports2);
    __exportStar2(require_transactionWatcher(), exports2);
    __exportStar2(require_transactionsFactories(), exports2);
    __exportStar2(require_transactionsOutcomeParsers(), exports2);
    __exportStar2(require_utils2(), exports2);
  }
});

// node_modules/@multiversx/sdk-wallet-connect-provider/out/utils.js
var require_utils4 = __commonJS({
  "node_modules/@multiversx/sdk-wallet-connect-provider/out/utils.js"(exports2) {
    "use strict";
    init_shim();
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sleep = exports2.getMetadata = exports2.applyTransactionSignature = exports2.getAddressFromSession = exports2.addressIsValid = exports2.getConnectionParams = exports2.getCurrentTopic = exports2.getCurrentSession = void 0;
    var sdk_core_1 = require_out();
    var signature_1 = require_signature();
    var utils_1 = require_index_cjs2();
    var constants_1 = require_constants6();
    var errors_1 = require_errors3();
    var logger_1 = require_logger2();
    var operation_1 = require_operation2();
    function getCurrentSession(chainId, client) {
      if (!client) {
        throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
      }
      const acknowledgedSessions = client.find(getConnectionParams(chainId)).filter((s2) => s2.acknowledged);
      if (acknowledgedSessions.length > 0) {
        const lastKeyIndex = acknowledgedSessions.length - 1;
        const session = acknowledgedSessions[lastKeyIndex];
        return session;
      }
      if (client.session.length > 0) {
        const lastKeyIndex = client.session.keys.length - 1;
        const session = client.session.get(client.session.keys[lastKeyIndex]);
        return session;
      }
      logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
      throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
    }
    exports2.getCurrentSession = getCurrentSession;
    function getCurrentTopic(chainId, client) {
      if (!client) {
        throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
      }
      const session = getCurrentSession(chainId, client);
      if (!(session === null || session === void 0 ? void 0 : session.topic)) {
        throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
      }
      return session.topic;
    }
    exports2.getCurrentTopic = getCurrentTopic;
    function getConnectionParams(chainId, options) {
      var _a, _b, _c;
      const methods = [
        ...constants_1.WALLETCONNECT_MULTIVERSX_METHODS,
        ...(_a = options === null || options === void 0 ? void 0 : options.methods) !== null && _a !== void 0 ? _a : []
      ];
      if (!((_b = options === null || options === void 0 ? void 0 : options.methods) === null || _b === void 0 ? void 0 : _b.includes(operation_1.OptionalOperation.SIGN_LOGIN_TOKEN))) {
        methods.push(operation_1.OptionalOperation.SIGN_LOGIN_TOKEN);
      }
      const chains = [`${constants_1.WALLETCONNECT_MULTIVERSX_NAMESPACE}:${chainId}`];
      const events = (_c = options === null || options === void 0 ? void 0 : options.events) !== null && _c !== void 0 ? _c : [];
      return {
        requiredNamespaces: {
          [constants_1.WALLETCONNECT_MULTIVERSX_NAMESPACE]: {
            methods,
            chains,
            events
          }
        }
      };
    }
    exports2.getConnectionParams = getConnectionParams;
    function addressIsValid(destinationAddress) {
      try {
        const address = sdk_core_1.Address.fromBech32(destinationAddress);
        return !address.isEmpty();
      } catch (_a) {
        return false;
      }
    }
    exports2.addressIsValid = addressIsValid;
    function getAddressFromSession(session) {
      const selectedNamespace = session.namespaces[constants_1.WALLETCONNECT_MULTIVERSX_NAMESPACE];
      if (selectedNamespace && selectedNamespace.accounts) {
        const currentSession = selectedNamespace.accounts[0];
        const [namespace, reference, address] = currentSession.split(":");
        return address;
      }
      return "";
    }
    exports2.getAddressFromSession = getAddressFromSession;
    function applyTransactionSignature({ transaction, response }) {
      if (!response) {
        logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidTransactionResponse);
        throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidTransactionResponse);
      }
      const { signature, guardianSignature, version: version2, options, guardian } = response;
      const transactionGuardian = transaction.getGuardian().bech32();
      if (transactionGuardian && transactionGuardian !== guardian) {
        logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidGuardian);
        throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidGuardian);
      }
      if (guardian) {
        transaction.setGuardian(sdk_core_1.Address.fromBech32(guardian));
      }
      if (version2) {
        transaction.setVersion(version2);
      }
      if (options != null) {
        transaction.setOptions(options);
      }
      transaction.applySignature(new signature_1.Signature(signature));
      if (guardianSignature) {
        transaction.applyGuardianSignature(new signature_1.Signature(guardianSignature));
      }
      return transaction;
    }
    exports2.applyTransactionSignature = applyTransactionSignature;
    function getMetadata(metadata) {
      if (metadata) {
        return Object.assign(Object.assign({}, metadata), { url: utils_1.getAppMetadata().url });
      }
      return;
    }
    exports2.getMetadata = getMetadata;
    function sleep(timeout) {
      return __awaiter2(this, void 0, void 0, function* () {
        return yield new Promise((resolve) => setTimeout(() => {
          resolve();
        }, timeout));
      });
    }
    exports2.sleep = sleep;
  }
});

// node_modules/@multiversx/sdk-wallet-connect-provider/out/walletConnectV2Provider.js
var require_walletConnectV2Provider = __commonJS({
  "node_modules/@multiversx/sdk-wallet-connect-provider/out/walletConnectV2Provider.js"(exports2) {
    "use strict";
    init_shim();
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WalletConnectV2Provider = exports2.OptionalOperation = exports2.Operation = exports2.WalletConnectV2ProviderErrorMessagesEnum = void 0;
    var signature_1 = require_signature();
    var sign_client_1 = __importDefault2(require_index_cjs4());
    var utils_1 = require_index_cjs2();
    var constants_1 = require_constants6();
    var errors_1 = require_errors3();
    Object.defineProperty(exports2, "WalletConnectV2ProviderErrorMessagesEnum", { enumerable: true, get: function() {
      return errors_1.WalletConnectV2ProviderErrorMessagesEnum;
    } });
    var logger_1 = require_logger2();
    var operation_1 = require_operation2();
    Object.defineProperty(exports2, "Operation", { enumerable: true, get: function() {
      return operation_1.Operation;
    } });
    Object.defineProperty(exports2, "OptionalOperation", { enumerable: true, get: function() {
      return operation_1.OptionalOperation;
    } });
    var utils_2 = require_utils4();
    var WalletConnectV2Provider5 = class {
      constructor(onClientConnect, chainId, walletConnectV2Relay, walletConnectV2ProjectId, options) {
        this.chainId = "";
        this.address = "";
        this.signature = "";
        this.isInitializing = false;
        this.processingTopic = "";
        this.options = {};
        this.onClientConnect = onClientConnect;
        this.chainId = chainId;
        this.walletConnectV2Relay = walletConnectV2Relay;
        this.walletConnectV2ProjectId = walletConnectV2ProjectId;
        this.options = options;
      }
      reset() {
        this.address = "";
        this.signature = "";
        this.walletConnector = void 0;
        this.session = void 0;
        this.pairings = void 0;
      }
      /**
       * Initiates WalletConnect client.
       */
      init() {
        var _a, _b;
        return __awaiter2(this, void 0, void 0, function* () {
          if (this.isInitialized()) {
            return this.isInitialized();
          } else {
            try {
              if (!this.isInitializing) {
                this.isInitializing = true;
                this.reset();
                const metadata = ((_a = this.options) === null || _a === void 0 ? void 0 : _a.metadata) ? {
                  metadata: utils_2.getMetadata((_b = this.options) === null || _b === void 0 ? void 0 : _b.metadata)
                } : {};
                const client = yield sign_client_1.default.init(Object.assign(Object.assign(Object.assign({}, this.options), { relayUrl: this.walletConnectV2Relay, projectId: this.walletConnectV2ProjectId }), metadata));
                this.walletConnector = client;
                this.isInitializing = false;
                yield this.subscribeToEvents(client);
                yield this.checkPersistedState(client);
              }
            } catch (error) {
              throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToInit);
            } finally {
              this.isInitializing = false;
              return this.isInitialized();
            }
          }
        });
      }
      /**
       * Returns true if init() was previously called successfully
       */
      isInitialized() {
        return !!this.walletConnector && !this.isInitializing;
      }
      /**
       * Returns true if provider is initialized and a valid session is set
       */
      isConnected() {
        return new Promise((resolve, _4) => resolve(Boolean(this.isInitialized() && typeof this.session !== "undefined")));
      }
      connect(options) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (typeof this.walletConnector === "undefined") {
            throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
          }
          const connectParams = utils_2.getConnectionParams(this.chainId, options);
          try {
            const response = yield this.walletConnector.connect(Object.assign({ pairingTopic: options === null || options === void 0 ? void 0 : options.topic }, connectParams));
            return response;
          } catch (error) {
            this.reset();
            logger_1.Logger.error((options === null || options === void 0 ? void 0 : options.topic) ? errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToConnectExisting : errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToConnect);
            throw new Error((options === null || options === void 0 ? void 0 : options.topic) ? errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToConnectExisting : errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToConnect);
          }
        });
      }
      login(options) {
        var _a;
        return __awaiter2(this, void 0, void 0, function* () {
          this.isInitializing = true;
          if (typeof this.walletConnector === "undefined") {
            yield this.connect();
          }
          if (typeof this.walletConnector === "undefined") {
            throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
          }
          if (typeof this.session !== "undefined") {
            yield this.logout({ topic: (_a = this.session) === null || _a === void 0 ? void 0 : _a.topic });
          }
          try {
            if (options && options.approval) {
              const session = yield options.approval();
              if (options.token) {
                yield utils_2.sleep(constants_1.WALLETCONNECT_SIGN_LOGIN_DELAY);
                const address = utils_2.getAddressFromSession(session);
                const selectedNamespace = session.namespaces[constants_1.WALLETCONNECT_MULTIVERSX_NAMESPACE];
                const method = selectedNamespace.methods.includes(operation_1.OptionalOperation.SIGN_NATIVE_AUTH_TOKEN) ? operation_1.OptionalOperation.SIGN_NATIVE_AUTH_TOKEN : operation_1.OptionalOperation.SIGN_LOGIN_TOKEN;
                const { signature } = yield this.walletConnector.request({
                  chainId: `${constants_1.WALLETCONNECT_MULTIVERSX_NAMESPACE}:${this.chainId}`,
                  topic: session.topic,
                  request: {
                    method,
                    params: {
                      token: options.token,
                      address
                    }
                  }
                });
                if (!signature) {
                  logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToSignLoginToken);
                  throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToSignLoginToken);
                }
                return yield this.onSessionConnected({
                  session,
                  signature
                });
              }
              return yield this.onSessionConnected({
                session,
                signature: ""
              });
            }
          } catch (error) {
            this.reset();
            logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToLogin);
            throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToLogin);
          } finally {
            this.isInitializing = false;
          }
          return "";
        });
      }
      /**
       * Mocks a logout request by returning true
       */
      logout(options) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (typeof this.walletConnector === "undefined") {
            logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
          }
          try {
            if (this.processingTopic === ((options === null || options === void 0 ? void 0 : options.topic) || utils_2.getCurrentTopic(this.chainId, this.walletConnector))) {
              return true;
            }
            if (options === null || options === void 0 ? void 0 : options.topic) {
              this.processingTopic = options.topic;
              yield this.walletConnector.disconnect({
                topic: options.topic,
                reason: utils_1.getSdkError("USER_DISCONNECTED")
              });
            } else {
              const currentSessionTopic = utils_2.getCurrentTopic(this.chainId, this.walletConnector);
              this.processingTopic = currentSessionTopic;
              yield this.walletConnector.disconnect({
                topic: currentSessionTopic,
                reason: utils_1.getSdkError("USER_DISCONNECTED")
              });
              this.reset();
              yield this.cleanupPendingPairings({ deletePairings: true });
            }
          } catch (_a) {
            logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.alreadyLoggedOut);
          } finally {
            this.processingTopic = "";
          }
          return true;
        });
      }
      /**
       * Fetches the WalletConnect address
       */
      getAddress() {
        return __awaiter2(this, void 0, void 0, function* () {
          if (typeof this.walletConnector === "undefined") {
            logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
          }
          return this.address;
        });
      }
      /**
       * Fetches the WalletConnect signature
       */
      getSignature() {
        return __awaiter2(this, void 0, void 0, function* () {
          if (typeof this.walletConnector === "undefined") {
            logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
          }
          return this.signature;
        });
      }
      /**
       * Fetches the WalletConnect pairings
       */
      getPairings() {
        var _a, _b, _c, _d, _e;
        return __awaiter2(this, void 0, void 0, function* () {
          if (typeof this.walletConnector === "undefined") {
            logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
          }
          return (_e = (_d = (_c = (_b = (_a = this.walletConnector) === null || _a === void 0 ? void 0 : _a.core) === null || _b === void 0 ? void 0 : _b.pairing) === null || _c === void 0 ? void 0 : _c.pairings) === null || _d === void 0 ? void 0 : _d.getAll({ active: true })) !== null && _e !== void 0 ? _e : [];
        });
      }
      /**
       * Signs a message and returns it signed
       * @param message
       */
      signMessage(message) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (typeof this.walletConnector === "undefined") {
            logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
          }
          if (typeof this.session === "undefined") {
            logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
            this.onClientConnect.onClientLogout();
            throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
          }
          try {
            const address = yield this.getAddress();
            const { signature } = yield this.walletConnector.request({
              chainId: `${constants_1.WALLETCONNECT_MULTIVERSX_NAMESPACE}:${this.chainId}`,
              topic: utils_2.getCurrentTopic(this.chainId, this.walletConnector),
              request: {
                method: operation_1.Operation.SIGN_MESSAGE,
                params: {
                  address,
                  message: message.message.toString()
                }
              }
            });
            if (!signature) {
              logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidMessageResponse);
              throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidMessageResponse);
            }
            try {
              message.applySignature(new signature_1.Signature(signature));
            } catch (error) {
              logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidMessageSignature);
              throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidMessageSignature);
            }
          } catch (error) {
            throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToSign);
          }
          return message;
        });
      }
      /**
       * Signs a transaction and returns it signed
       * @param transaction
       */
      signTransaction(transaction) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (typeof this.walletConnector === "undefined") {
            logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
          }
          if (typeof this.session === "undefined") {
            logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
            this.onClientConnect.onClientLogout();
            throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
          }
          const plainTransaction = transaction.toPlainObject();
          if (this.chainId !== transaction.getChainID().valueOf()) {
            logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.requestDifferentChain);
            throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.requestDifferentChain);
          }
          try {
            const response = yield this.walletConnector.request({
              chainId: `${constants_1.WALLETCONNECT_MULTIVERSX_NAMESPACE}:${this.chainId}`,
              topic: utils_2.getCurrentTopic(this.chainId, this.walletConnector),
              request: {
                method: operation_1.Operation.SIGN_TRANSACTION,
                params: {
                  transaction: plainTransaction
                }
              }
            });
            return utils_2.applyTransactionSignature({ transaction, response });
          } catch (error) {
            throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.transactionError);
          }
        });
      }
      /**
       * Signs an array of transactions and returns it signed
       * @param transactions
       */
      signTransactions(transactions) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (typeof this.walletConnector === "undefined") {
            logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
          }
          if (typeof this.session === "undefined") {
            logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
            this.onClientConnect.onClientLogout();
            throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
          }
          const plainTransactions = transactions.map((transaction) => {
            if (this.chainId !== transaction.getChainID().valueOf()) {
              logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.requestDifferentChain);
              throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.requestDifferentChain);
            }
            return transaction.toPlainObject();
          });
          try {
            const { signatures } = yield this.walletConnector.request({
              chainId: `${constants_1.WALLETCONNECT_MULTIVERSX_NAMESPACE}:${this.chainId}`,
              topic: utils_2.getCurrentTopic(this.chainId, this.walletConnector),
              request: {
                method: operation_1.Operation.SIGN_TRANSACTIONS,
                params: {
                  transactions: plainTransactions
                }
              }
            });
            if (!signatures) {
              logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidTransactionResponse);
              throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidTransactionResponse);
            }
            if (!Array.isArray(signatures) || transactions.length !== signatures.length) {
              throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidTransactionResponse);
            }
            for (const [index, transaction] of transactions.entries()) {
              const response = signatures[index];
              utils_2.applyTransactionSignature({ transaction, response });
            }
            return transactions;
          } catch (error) {
            throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.transactionError);
          }
        });
      }
      /**
       * Sends a custom request
       * @param request
       */
      sendCustomRequest(options) {
        var _a;
        return __awaiter2(this, void 0, void 0, function* () {
          if (typeof this.walletConnector === "undefined") {
            logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
          }
          if (typeof this.session === "undefined") {
            logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
            this.onClientConnect.onClientLogout();
            throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
          }
          if ((_a = options === null || options === void 0 ? void 0 : options.request) === null || _a === void 0 ? void 0 : _a.method) {
            try {
              const request = Object.assign({}, options.request);
              let { method } = request;
              const { response } = yield this.walletConnector.request({
                chainId: `${constants_1.WALLETCONNECT_MULTIVERSX_NAMESPACE}:${this.chainId}`,
                topic: utils_2.getCurrentTopic(this.chainId, this.walletConnector),
                request: Object.assign(Object.assign({}, request), { method })
              });
              if (!response) {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidCustomRequestResponse);
              }
            } catch (error) {
              logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidCustomRequestResponse);
            }
            return;
          }
        });
      }
      /**
       * Ping helper
       */
      ping() {
        return __awaiter2(this, void 0, void 0, function* () {
          if (typeof this.walletConnector === "undefined") {
            logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
          }
          if (typeof this.session === "undefined") {
            logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
          }
          try {
            const topic = utils_2.getCurrentTopic(this.chainId, this.walletConnector);
            yield this.walletConnector.ping({
              topic
            });
            return true;
          } catch (error) {
            logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.pingFailed);
            return false;
          }
        });
      }
      loginAccount(options) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (!options) {
            return "";
          }
          if (utils_2.addressIsValid(options.address)) {
            this.address = options.address;
            if (options.signature) {
              this.signature = options.signature;
            }
            this.onClientConnect.onClientLogin();
            return this.address;
          }
          logger_1.Logger.error(`${errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidAddress} ${options.address}`);
          if (this.walletConnector) {
            yield this.logout();
          }
          return "";
        });
      }
      onSessionConnected(options) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (!options) {
            return "";
          }
          this.session = options.session;
          const address = utils_2.getAddressFromSession(options.session);
          if (address) {
            yield this.loginAccount({ address, signature: options.signature });
            return address;
          }
          return "";
        });
      }
      handleTopicUpdateEvent({ topic }) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (typeof this.walletConnector === "undefined") {
            logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            return;
          }
          try {
            const existingPairings = yield this.getPairings();
            if (this.address && !this.isInitializing && existingPairings) {
              if ((existingPairings === null || existingPairings === void 0 ? void 0 : existingPairings.length) === 0) {
                this.onClientConnect.onClientLogout();
              } else {
                const lastActivePairing = existingPairings[existingPairings.length - 1];
                if ((lastActivePairing === null || lastActivePairing === void 0 ? void 0 : lastActivePairing.topic) === topic) {
                  this.onClientConnect.onClientLogout();
                }
              }
            }
          } catch (error) {
            logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToHandleTopic);
          } finally {
            this.pairings = yield this.getPairings();
          }
        });
      }
      handleSessionEvents({ topic, params }) {
        var _a;
        return __awaiter2(this, void 0, void 0, function* () {
          if (typeof this.walletConnector === "undefined") {
            throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
          }
          if (this.session && ((_a = this.session) === null || _a === void 0 ? void 0 : _a.topic) !== topic) {
            return;
          }
          const { event } = params;
          if ((event === null || event === void 0 ? void 0 : event.name) && utils_2.getCurrentTopic(this.chainId, this.walletConnector) === topic) {
            const eventData = event.data;
            this.onClientConnect.onClientEvent(eventData);
          }
        });
      }
      subscribeToEvents(client) {
        var _a, _b, _c, _d;
        return __awaiter2(this, void 0, void 0, function* () {
          if (typeof client === "undefined") {
            throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
          }
          try {
            client.on("session_update", ({ topic, params }) => {
              var _a2;
              if (!this.session || ((_a2 = this.session) === null || _a2 === void 0 ? void 0 : _a2.topic) !== topic) {
                return;
              }
              const { namespaces } = params;
              const _session = client.session.get(topic);
              const updatedSession = Object.assign(Object.assign({}, _session), { namespaces });
              this.onSessionConnected({ session: updatedSession });
            });
            client.on("session_event", this.handleSessionEvents.bind(this));
            client.on("session_delete", ({ topic }) => __awaiter2(this, void 0, void 0, function* () {
              var _e;
              if (this.isInitializing) {
                this.onClientConnect.onClientLogout();
                this.reset();
              }
              if (!this.session || ((_e = this.session) === null || _e === void 0 ? void 0 : _e.topic) !== topic) {
                return;
              }
              logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionDeleted);
              this.onClientConnect.onClientLogout();
              this.reset();
              yield this.cleanupPendingPairings({ deletePairings: true });
            }));
            client.on("session_expire", ({ topic }) => __awaiter2(this, void 0, void 0, function* () {
              var _f;
              if (!this.session || ((_f = this.session) === null || _f === void 0 ? void 0 : _f.topic) !== topic) {
                return;
              }
              logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionExpired);
              this.onClientConnect.onClientLogout();
              this.reset();
              yield this.cleanupPendingPairings({ deletePairings: true });
            }));
            (_b = (_a = client.core) === null || _a === void 0 ? void 0 : _a.pairing) === null || _b === void 0 ? void 0 : _b.events.on("pairing_delete", this.handleTopicUpdateEvent.bind(this));
            (_d = (_c = client.core) === null || _c === void 0 ? void 0 : _c.pairing) === null || _d === void 0 ? void 0 : _d.events.on("pairing_expire", this.handleTopicUpdateEvent.bind(this));
          } catch (error) {
            logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToHandleEvent);
          }
        });
      }
      checkPersistedState(client) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (typeof client === "undefined") {
            throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
          }
          this.pairings = yield this.getPairings();
          if (typeof this.session !== "undefined") {
            return;
          }
          if (client.session.length && !this.address && !this.isInitializing) {
            const session = utils_2.getCurrentSession(this.chainId, client);
            if (session) {
              yield this.onSessionConnected({ session });
              return session;
            }
          }
          return;
        });
      }
      cleanupPendingPairings(options = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        return __awaiter2(this, void 0, void 0, function* () {
          if (typeof this.walletConnector === "undefined") {
            return;
          }
          try {
            const inactivePairings = (_c = (_b = (_a = this.walletConnector.core) === null || _a === void 0 ? void 0 : _a.pairing) === null || _b === void 0 ? void 0 : _b.pairings) === null || _c === void 0 ? void 0 : _c.getAll({ active: false });
            if (!utils_1.isValidArray(inactivePairings)) {
              return;
            }
            for (const pairing of inactivePairings) {
              if (options.deletePairings) {
                (_e = (_d = this.walletConnector.core) === null || _d === void 0 ? void 0 : _d.expirer) === null || _e === void 0 ? void 0 : _e.set(pairing.topic, 0);
              } else {
                try {
                  yield (_h = (_g = (_f = this.walletConnector.core) === null || _f === void 0 ? void 0 : _f.relayer) === null || _g === void 0 ? void 0 : _g.subscriber) === null || _h === void 0 ? void 0 : _h.unsubscribe(pairing.topic);
                } catch (error) {
                  logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToHandleCleanup);
                }
              }
            }
          } catch (error) {
            logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToHandleCleanup);
          }
        });
      }
    };
    exports2.WalletConnectV2Provider = WalletConnectV2Provider5;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    init_shim();
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/has-proto/index.js
var require_has_proto = __commonJS({
  "node_modules/has-proto/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    var test = {
      foo: {}
    };
    var $Object = Object;
    module2.exports = function hasProto() {
      return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    init_shim();
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a3, b4) {
      var arr = [];
      for (var i2 = 0; i2 < a3.length; i2 += 1) {
        arr[i2] = a3[i2];
      }
      for (var j2 = 0; j2 < b4.length; j2 += 1) {
        arr[j2 + a3.length] = b4[j2];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i2 = offset || 0, j2 = 0; i2 < arrLike.length; i2 += 1, j2 += 1) {
        arr[j2] = arrLike[i2];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i2 = 0; i2 < arr.length; i2 += 1) {
        str += arr[i2];
        if (i2 + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i2 = 0; i2 < boundLength; i2++) {
        boundArgs[i2] = "$" + i2;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module2.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e2) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e2) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var hasProto = require_has_proto()();
    var getProto = Object.getPrototypeOf || (hasProto ? function(x3) {
      return x3.__proto__;
    } : null);
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    if (getProto) {
      try {
        null.error;
      } catch (e2) {
        errorProto = getProto(getProto(e2));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name2) {
      var value;
      if (name2 === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name2 === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name2 === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name2 === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name2 === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name2] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string2) {
      var first = $strSlice(string2, 0, 1);
      var last = $strSlice(string2, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string2, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
      var intrinsicName = name2;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name2, allowMissing) {
      if (typeof name2 !== "string" || name2.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name2) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name2);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
        var part = parts[i2];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name2 + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i2 + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/has-property-descriptors/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
          return true;
        } catch (e2) {
          return false;
        }
      }
      return false;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!hasPropertyDescriptors()) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e2) {
        return true;
      }
    };
    module2.exports = hasPropertyDescriptors;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e2) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});

// node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "node_modules/define-data-property/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    var hasPropertyDescriptors = require_has_property_descriptors()();
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = hasPropertyDescriptors && GetIntrinsic("%Object.defineProperty%", true);
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e2) {
        $defineProperty = false;
      }
    }
    var $SyntaxError = GetIntrinsic("%SyntaxError%");
    var $TypeError = GetIntrinsic("%TypeError%");
    var gopd = require_gopd();
    module2.exports = function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "node_modules/set-function-length/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    var GetIntrinsic = require_get_intrinsic();
    var define2 = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $floor = GetIntrinsic("%Math.floor%");
    module2.exports = function setFunctionLength(fn, length2) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length2 !== "number" || length2 < 0 || length2 > 4294967295 || $floor(length2) !== length2) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn && gOPD) {
        var desc = gOPD(fn, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length2,
            true,
            true
          );
        } else {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length2
          );
        }
      }
      return fn;
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var setFunctionLength = require_set_function_length();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e2) {
        $defineProperty = null;
      }
    }
    module2.exports = function callBind(originalFunction) {
      if (typeof originalFunction !== "function") {
        throw new $TypeError("a function is required");
      }
      var func = $reflectApply(bind, $call, arguments);
      return setFunctionLength(
        func,
        1 + $max(0, originalFunction.length - (arguments.length - 1)),
        true
      );
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  }
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/call-bind/callBound.js"(exports2, module2) {
    "use strict";
    init_shim();
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module2.exports = function callBoundIntrinsic(name2, allowMissing) {
      var intrinsic = GetIntrinsic(name2, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// (disabled):node_modules/object-inspect/util.inspect
var require_util2 = __commonJS({
  "(disabled):node_modules/object-inspect/util.inspect"() {
    init_shim();
  }
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "node_modules/object-inspect/index.js"(exports2, module2) {
    init_shim();
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O3) {
      return O3.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util2();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    module2.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from3, noIndent) {
        if (from3) {
          seen = $arrSlice.call(seen);
          seen.push(from3);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name2 = nameOf(obj);
        var keys2 = arrObjKeys(obj, inspect);
        return "[Function" + (name2 ? ": " + name2 : " (anonymous)") + "]" + (keys2.length > 0 ? " { " + $join.call(keys2, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s2 = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i2 = 0; i2 < attrs.length; i2++) {
          s2 += " " + attrs[i2].name + "=" + wrapQuotes(quote(attrs[i2].value), "double", opts);
        }
        s2 += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s2 += "...";
        }
        s2 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s2;
      }
      if (isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString2(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (typeof window !== "undefined" && obj === window) {
        return "{ [object Window] }";
      }
      if (obj === global) {
        return "{ [object globalThis] }";
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s2, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s2 + quoteChar;
    }
    function quote(s2) {
      return $replace.call(String(s2), /"/g, "&quot;");
    }
    function isArray(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString2(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e2) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e2) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f4) {
      if (f4.name) {
        return f4.name;
      }
      var m3 = $match.call(functionToString.call(f4), /^function\s*([\w$]+)/);
      if (m3) {
        return m3[1];
      }
      return null;
    }
    function indexOf(xs, x3) {
      if (xs.indexOf) {
        return xs.indexOf(x3);
      }
      for (var i2 = 0, l4 = xs.length; i2 < l4; i2++) {
        if (xs[i2] === x3) {
          return i2;
        }
      }
      return -1;
    }
    function isMap(x3) {
      if (!mapSize || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        mapSize.call(x3);
        try {
          setSize.call(x3);
        } catch (s2) {
          return true;
        }
        return x3 instanceof Map;
      } catch (e2) {
      }
      return false;
    }
    function isWeakMap(x3) {
      if (!weakMapHas || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x3, weakMapHas);
        try {
          weakSetHas.call(x3, weakSetHas);
        } catch (s2) {
          return true;
        }
        return x3 instanceof WeakMap;
      } catch (e2) {
      }
      return false;
    }
    function isWeakRef(x3) {
      if (!weakRefDeref || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x3);
        return true;
      } catch (e2) {
      }
      return false;
    }
    function isSet(x3) {
      if (!setSize || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        setSize.call(x3);
        try {
          mapSize.call(x3);
        } catch (m3) {
          return true;
        }
        return x3 instanceof Set;
      } catch (e2) {
      }
      return false;
    }
    function isWeakSet(x3) {
      if (!weakSetHas || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x3, weakSetHas);
        try {
          weakMapHas.call(x3, weakMapHas);
        } catch (s2) {
          return true;
        }
        return x3 instanceof WeakSet;
      } catch (e2) {
      }
      return false;
    }
    function isElement(x3) {
      if (!x3 || typeof x3 !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x3 instanceof HTMLElement) {
        return true;
      }
      return typeof x3.nodeName === "string" && typeof x3.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s2 = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s2, "single", opts);
    }
    function lowbyte(c4) {
      var n3 = c4.charCodeAt(0);
      var x3 = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n3];
      if (x3) {
        return "\\" + x3;
      }
      return "\\x" + (n3 < 16 ? "0" : "") + $toUpperCase.call(n3.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i2 = 0; i2 < xs.length; i2++) {
        if (indexOf(xs[i2], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr = isArray(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i2 = 0; i2 < obj.length; i2++) {
          xs[i2] = has(obj, i2) ? inspect(obj[i2], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k4 = 0; k4 < syms.length; k4++) {
          symMap["$" + syms[k4]] = syms[k4];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j2 = 0; j2 < syms.length; j2++) {
          if (isEnumerable.call(obj, syms[j2])) {
            xs.push("[" + inspect(syms[j2]) + "]: " + inspect(obj[syms[j2]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "node_modules/side-channel/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect = require_object_inspect();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list, key) {
      for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          curr.next = list.next;
          list.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      var node = listGetNode(objects, key);
      return node && node.value;
    };
    var listSet = function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = {
          // eslint-disable-line no-param-reassign
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      return !!listGetNode(objects, key);
    };
    module2.exports = function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key);
            }
          } else {
            if ($o) {
              return listGet($o, key);
            }
          }
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key);
            }
          } else {
            if ($o) {
              return listHas($o, key);
            }
          }
          return false;
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key, value);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key, value);
          }
        }
      };
      return channel;
    };
  }
});

// node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "node_modules/qs/lib/formats.js"(exports2, module2) {
    "use strict";
    init_shim();
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module2.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// node_modules/qs/lib/utils.js
var require_utils5 = __commonJS({
  "node_modules/qs/lib/utils.js"(exports2, module2) {
    "use strict";
    init_shim();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i2 = 0; i2 < 256; ++i2) {
        array.push("%" + ((i2 < 16 ? "0" : "") + i2.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
          var compacted = [];
          for (var j2 = 0; j2 < obj.length; ++j2) {
            if (typeof obj[j2] !== "undefined") {
              compacted.push(obj[j2]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      for (var i2 = 0; i2 < source.length; ++i2) {
        if (typeof source[i2] !== "undefined") {
          obj[i2] = source[i2];
        }
      }
      return obj;
    };
    var merge = function merge2(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (isArray(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i2) {
          if (has.call(target, i2)) {
            var targetItem = target[i2];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i2] = merge2(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i2] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge2(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode6 = function(str, decoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e2) {
        return strWithoutPlus;
      }
    };
    var encode5 = function encode6(str, defaultEncoder, charset, kind, format) {
      if (str.length === 0) {
        return str;
      }
      var string2 = str;
      if (typeof str === "symbol") {
        string2 = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string2 = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string2).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var i2 = 0; i2 < string2.length; ++i2) {
        var c4 = string2.charCodeAt(i2);
        if (c4 === 45 || c4 === 46 || c4 === 95 || c4 === 126 || c4 >= 48 && c4 <= 57 || c4 >= 65 && c4 <= 90 || c4 >= 97 && c4 <= 122 || format === formats.RFC1738 && (c4 === 40 || c4 === 41)) {
          out += string2.charAt(i2);
          continue;
        }
        if (c4 < 128) {
          out = out + hexTable[c4];
          continue;
        }
        if (c4 < 2048) {
          out = out + (hexTable[192 | c4 >> 6] + hexTable[128 | c4 & 63]);
          continue;
        }
        if (c4 < 55296 || c4 >= 57344) {
          out = out + (hexTable[224 | c4 >> 12] + hexTable[128 | c4 >> 6 & 63] + hexTable[128 | c4 & 63]);
          continue;
        }
        i2 += 1;
        c4 = 65536 + ((c4 & 1023) << 10 | string2.charCodeAt(i2) & 1023);
        out += hexTable[240 | c4 >> 18] + hexTable[128 | c4 >> 12 & 63] + hexTable[128 | c4 >> 6 & 63] + hexTable[128 | c4 & 63];
      }
      return out;
    };
    var compact = function compact2(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i2 = 0; i2 < queue.length; ++i2) {
        var item = queue[i2];
        var obj = item.obj[item.prop];
        var keys2 = Object.keys(obj);
        for (var j2 = 0; j2 < keys2.length; ++j2) {
          var key = keys2[j2];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue);
      return value;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer = function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a3, b4) {
      return [].concat(a3, b4);
    };
    var maybeMap = function maybeMap2(val, fn) {
      if (isArray(val)) {
        var mapped = [];
        for (var i2 = 0; i2 < val.length; i2 += 1) {
          mapped.push(fn(val[i2]));
        }
        return mapped;
      }
      return fn(val);
    };
    module2.exports = {
      arrayToObject,
      assign,
      combine,
      compact,
      decode: decode6,
      encode: encode5,
      isBuffer,
      isRegExp,
      maybeMap,
      merge
    };
  }
});

// node_modules/qs/lib/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/qs/lib/stringify.js"(exports2, module2) {
    "use strict";
    init_shim();
    var getSideChannel = require_side_channel();
    var utils = require_utils5();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat(prefix) {
        return prefix;
      }
    };
    var isArray = Array.isArray;
    var split = String.prototype.split;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encoder: utils.encode,
      encodeValuesOnly: false,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v2) {
      return typeof v2 === "string" || typeof v2 === "number" || typeof v2 === "boolean" || typeof v2 === "symbol" || typeof v2 === "bigint";
    };
    var sentinel = {};
    var stringify2 = function stringify3(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter === "function") {
        obj = filter(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
          if (generateArrayPrefix === "comma" && encodeValuesOnly) {
            var valuesArray = split.call(String(obj), ",");
            var valuesJoined = "";
            for (var i2 = 0; i2 < valuesArray.length; ++i2) {
              valuesJoined += (i2 === 0 ? "" : ",") + formatter(encoder(valuesArray[i2], defaults.encoder, charset, "value", format));
            }
            return [formatter(keyValue) + "=" + valuesJoined];
          }
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray(obj)) {
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray(filter)) {
        objKeys = filter;
      } else {
        var keys2 = Object.keys(obj);
        objKeys = sort ? keys2.sort(sort) : keys2;
      }
      for (var j2 = 0; j2 < objKeys.length; ++j2) {
        var key = objKeys[j2];
        var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(prefix, key) : prefix : prefix + (allowDots ? "." + key : "[" + key + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify3(
          value,
          keyPrefix,
          generateArrayPrefix,
          strictNullHandling,
          skipNulls,
          encoder,
          filter,
          sort,
          allowDots,
          serializeDate,
          format,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter = defaults.filter;
      if (typeof opts.filter === "function" || isArray(opts.filter)) {
        filter = opts.filter;
      }
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter,
        format,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module2.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter;
      if (typeof options.filter === "function") {
        filter = options.filter;
        obj = filter("", obj);
      } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
      }
      var keys2 = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var arrayFormat;
      if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if (opts && "indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = "indices";
      }
      var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i2 = 0; i2 < objKeys.length; ++i2) {
        var key = objKeys[i2];
        if (options.skipNulls && obj[key] === null) {
          continue;
        }
        pushToArray(keys2, stringify2(
          obj[key],
          key,
          generateArrayPrefix,
          options.strictNullHandling,
          options.skipNulls,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      var joined = keys2.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// node_modules/qs/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/qs/lib/parse.js"(exports2, module2) {
    "use strict";
    init_shim();
    var utils = require_utils5();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var defaults = {
      allowDots: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictNullHandling: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = {};
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1;
      var i2;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i2 = 0; i2 < parts.length; ++i2) {
          if (parts[i2].indexOf("utf8=") === 0) {
            if (parts[i2] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i2] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i2;
            i2 = parts.length;
          }
        }
      }
      for (i2 = 0; i2 < parts.length; ++i2) {
        if (i2 === skipIndex) {
          continue;
        }
        var part = parts[i2];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key, val;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val = utils.maybeMap(
            parseArrayValue(part.slice(pos + 1), options),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults.decoder, charset, "value");
            }
          );
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(val);
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray(val) ? [val] : val;
        }
        if (has.call(obj, key)) {
          obj[key] = utils.combine(obj[key], val);
        } else {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options, valuesParsed) {
      var leaf = valuesParsed ? val : parseArrayValue(val, options);
      for (var i2 = chain.length - 1; i2 >= 0; --i2) {
        var obj;
        var root = chain[i2];
        if (root === "[]" && options.parseArrays) {
          obj = [].concat(leaf);
        } else {
          obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var index = parseInt(cleanRoot, 10);
          if (!options.parseArrays && cleanRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
            obj = [];
            obj[index] = leaf;
          } else if (cleanRoot !== "__proto__") {
            obj[cleanRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys2 = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys2.push(parent);
      }
      var i2 = 0;
      while (options.depth > 0 && (segment = child.exec(key)) !== null && i2 < options.depth) {
        i2 += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys2.push(segment[1]);
      }
      if (segment) {
        keys2.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys2, val, options, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      return {
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module2.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var keys2 = Object.keys(tempObj);
      for (var i2 = 0; i2 < keys2.length; ++i2) {
        var key = keys2[i2];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// node_modules/qs/lib/index.js
var require_lib = __commonJS({
  "node_modules/qs/lib/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    var stringify2 = require_stringify2();
    var parse = require_parse2();
    var formats = require_formats();
    module2.exports = {
      formats,
      parse,
      stringify: stringify2
    };
  }
});

// node_modules/@multiversx/sdk-web-wallet-provider/out/constants.js
var require_constants7 = __commonJS({
  "node_modules/@multiversx/sdk-web-wallet-provider/out/constants.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WALLET_PROVIDER_CALLBACK_PARAM_TX_SIGNED = exports2.WALLET_PROVIDER_CALLBACK_PARAM = exports2.WALLET_PROVIDER_SIGN_MESSAGE_URL = exports2.WALLET_PROVIDER_GUARD_TRANSACTION_URL = exports2.WALLET_PROVIDER_SIGN_TRANSACTION_URL = exports2.WALLET_PROVIDER_SEND_TRANSACTION_URL = exports2.WALLET_PROVIDER_DISCONNECT_URL = exports2.WALLET_PROVIDER_CONNECT_URL = exports2.XALIAS_PROVIDER_TESTNET = exports2.XALIAS_PROVIDER_DEVNET = exports2.XALIAS_PROVIDER_MAINNET = exports2.WALLET_PROVIDER_TESTNET = exports2.WALLET_PROVIDER_DEVNET = exports2.WALLET_PROVIDER_MAINNET = void 0;
    exports2.WALLET_PROVIDER_MAINNET = "https://wallet.multiversx.com/dapp/init";
    exports2.WALLET_PROVIDER_DEVNET = "https://devnet-wallet.multiversx.com/dapp/init";
    exports2.WALLET_PROVIDER_TESTNET = "https://testnet-wallet.multiversx.com/dapp/init";
    exports2.XALIAS_PROVIDER_MAINNET = "https://xalias.com";
    exports2.XALIAS_PROVIDER_DEVNET = "https://devnet.xalias.com";
    exports2.XALIAS_PROVIDER_TESTNET = "https://testnet.xalias.com";
    exports2.WALLET_PROVIDER_CONNECT_URL = "hook/login";
    exports2.WALLET_PROVIDER_DISCONNECT_URL = "hook/logout";
    exports2.WALLET_PROVIDER_SEND_TRANSACTION_URL = "hook/transaction";
    exports2.WALLET_PROVIDER_SIGN_TRANSACTION_URL = "hook/sign";
    exports2.WALLET_PROVIDER_GUARD_TRANSACTION_URL = "hook/2fa";
    exports2.WALLET_PROVIDER_SIGN_MESSAGE_URL = "hook/sign-message";
    exports2.WALLET_PROVIDER_CALLBACK_PARAM = "walletProviderStatus";
    exports2.WALLET_PROVIDER_CALLBACK_PARAM_TX_SIGNED = "transactionsSigned";
  }
});

// node_modules/@multiversx/sdk-web-wallet-provider/out/errors.js
var require_errors4 = __commonJS({
  "node_modules/@multiversx/sdk-web-wallet-provider/out/errors.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ErrCannotSignedMessage = exports2.ErrCannotGetSignedTransactions = void 0;
    var ErrCannotGetSignedTransactions = class extends Error {
      constructor() {
        super("Cannot get signed transaction(s)");
      }
    };
    exports2.ErrCannotGetSignedTransactions = ErrCannotGetSignedTransactions;
    var ErrCannotSignedMessage = class extends Error {
      constructor() {
        super("Cannot get signed message");
      }
    };
    exports2.ErrCannotSignedMessage = ErrCannotSignedMessage;
  }
});

// node_modules/@multiversx/sdk-web-wallet-provider/out/plainSignedTransaction.js
var require_plainSignedTransaction = __commonJS({
  "node_modules/@multiversx/sdk-web-wallet-provider/out/plainSignedTransaction.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PlainSignedTransaction = void 0;
    var PlainSignedTransaction = class {
      constructor(init) {
        this.nonce = 0;
        this.value = "";
        this.receiver = "";
        this.sender = "";
        this.gasPrice = 0;
        this.gasLimit = 0;
        this.data = "";
        this.chainID = "";
        this.version = 0;
        this.signature = "";
        Object.assign(this, init);
      }
    };
    exports2.PlainSignedTransaction = PlainSignedTransaction;
  }
});

// node_modules/@multiversx/sdk-web-wallet-provider/out/walletProvider.js
var require_walletProvider = __commonJS({
  "node_modules/@multiversx/sdk-web-wallet-provider/out/walletProvider.js"(exports2) {
    "use strict";
    init_shim();
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WalletProvider = void 0;
    var qs_1 = __importDefault2(require_lib());
    var constants_1 = require_constants7();
    var errors_1 = require_errors4();
    var plainSignedTransaction_1 = require_plainSignedTransaction();
    var WalletProvider6 = class _WalletProvider {
      /**
       * Creates a new WalletProvider
       * @param walletURL
       */
      constructor(walletURL) {
        this.walletUrl = walletURL;
      }
      /**
       * Fetches the login hook url and redirects the client to the wallet login.
       */
      login(options) {
        return __awaiter2(this, void 0, void 0, function* () {
          const redirectUrl = this.buildWalletUrl({
            endpoint: constants_1.WALLET_PROVIDER_CONNECT_URL,
            callbackUrl: options === null || options === void 0 ? void 0 : options.callbackUrl,
            params: {
              token: options === null || options === void 0 ? void 0 : options.token
            }
          });
          yield this.redirect(redirectUrl, options === null || options === void 0 ? void 0 : options.redirectDelayMilliseconds);
          return redirectUrl;
        });
      }
      redirect(url, delayMilliseconds) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (delayMilliseconds) {
            yield this.redirectLater(url, delayMilliseconds);
          } else {
            this.redirectImmediately(url);
          }
        });
      }
      redirectImmediately(url) {
        window.location.href = url;
      }
      redirectLater(url, delayMilliseconds) {
        return __awaiter2(this, void 0, void 0, function* () {
          yield new Promise((resolve) => {
            setTimeout(() => {
              window.location.href = url;
              resolve(true);
            }, delayMilliseconds);
          });
        });
      }
      /**
      * Fetches the logout hook url and redirects the client to the wallet logout.
      */
      logout(options) {
        return __awaiter2(this, void 0, void 0, function* () {
          const redirectUrl = this.buildWalletUrl({
            endpoint: constants_1.WALLET_PROVIDER_DISCONNECT_URL,
            callbackUrl: options === null || options === void 0 ? void 0 : options.callbackUrl
          });
          yield this.redirect(redirectUrl, options === null || options === void 0 ? void 0 : options.redirectDelayMilliseconds);
          return true;
        });
      }
      /**
       * Packs a {@link SignMessage} and fetches correct redirect URL from the wallet API. Then redirects
       * the client to the sign message hook
       * @param message
       * @param options
       */
      signMessage(message, options) {
        return __awaiter2(this, void 0, void 0, function* () {
          const redirectUrl = this.buildWalletUrl({
            endpoint: constants_1.WALLET_PROVIDER_SIGN_MESSAGE_URL,
            callbackUrl: options === null || options === void 0 ? void 0 : options.callbackUrl,
            params: {
              message: message.message.toString()
            }
          });
          yield this.redirect(redirectUrl);
          return redirectUrl;
        });
      }
      getMessageSignatureFromWalletUrl() {
        var _a, _b;
        const url = window.location.search.slice(1);
        console.info("getMessageSignatureFromWalletUrl(), url:", url);
        const urlParams = qs_1.default.parse(url);
        const status = ((_a = urlParams.status) === null || _a === void 0 ? void 0 : _a.toString()) || "";
        const expectedStatus = "signed";
        if (status !== expectedStatus) {
          throw new errors_1.ErrCannotSignedMessage();
        }
        const signature = ((_b = urlParams.signature) === null || _b === void 0 ? void 0 : _b.toString()) || "";
        return signature;
      }
      /**
      * Packs an array of {$link Transaction} and redirects to the 2fa hook
      *
      * @param transactions
      * @param options
      */
      guardTransactions(transactions, options) {
        return __awaiter2(this, void 0, void 0, function* () {
          this.redirectTransactionsToEndpoint(constants_1.WALLET_PROVIDER_GUARD_TRANSACTION_URL, transactions, options);
        });
      }
      /**
      * Packs an array of {$link Transaction} and redirects to the correct transaction sigining hook
      *
      * @param transactions
      * @param options
      */
      signTransactions(transactions, options) {
        return __awaiter2(this, void 0, void 0, function* () {
          this.redirectTransactionsToEndpoint(constants_1.WALLET_PROVIDER_SIGN_TRANSACTION_URL, transactions, options);
        });
      }
      /**
       * Packs a {@link Transaction} and fetches correct redirect URL from the wallet API. Then redirects
       *   the client to the sign transaction hook
       * @param transaction
       * @param options
       */
      signTransaction(transaction, options) {
        return __awaiter2(this, void 0, void 0, function* () {
          yield this.signTransactions([transaction], options);
        });
      }
      getTransactionsFromWalletUrl(search = window.location.search) {
        const urlParams = qs_1.default.parse(search.slice(1));
        if (!_WalletProvider.isTxSignReturnSuccess(urlParams)) {
          return [];
        }
        return this.getTxSignReturnValue(urlParams);
      }
      static isTxSignReturnSuccess(urlParams) {
        return urlParams.hasOwnProperty(constants_1.WALLET_PROVIDER_CALLBACK_PARAM) && urlParams[constants_1.WALLET_PROVIDER_CALLBACK_PARAM] === constants_1.WALLET_PROVIDER_CALLBACK_PARAM_TX_SIGNED;
      }
      getTxSignReturnValue(urlParams) {
        console.info("getTxSignReturnValue(), urlParams:", urlParams);
        const expectedProps = [
          "nonce",
          "value",
          "receiver",
          "sender",
          "gasPrice",
          "gasLimit",
          "chainID",
          "version",
          "signature"
        ];
        for (let txProp of expectedProps) {
          if (!urlParams[txProp] || !Array.isArray(urlParams[txProp])) {
            throw new errors_1.ErrCannotGetSignedTransactions();
          }
        }
        const expectedLength = urlParams["nonce"].length;
        for (let txProp of expectedProps) {
          if (urlParams[txProp].length !== expectedLength) {
            throw new errors_1.ErrCannotGetSignedTransactions();
          }
        }
        const transactions = [];
        for (let i2 = 0; i2 < expectedLength; i2++) {
          let plainSignedTransaction = new plainSignedTransaction_1.PlainSignedTransaction(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
            nonce: parseInt(urlParams["nonce"][i2]),
            value: urlParams["value"][i2],
            receiver: urlParams["receiver"][i2],
            sender: urlParams["sender"][i2],
            gasPrice: parseInt(urlParams["gasPrice"][i2]),
            gasLimit: parseInt(urlParams["gasLimit"][i2]),
            // Handle the optional "data" property.
            data: urlParams["data"] && urlParams["data"][i2] ? urlParams["data"][i2] : "",
            chainID: urlParams["chainID"][i2],
            version: parseInt(urlParams["version"][i2])
          }, urlParams["guardian"] && urlParams["guardian"][i2] ? { guardian: urlParams["guardian"][i2] } : {}), urlParams["guardianSignature"] && urlParams["guardianSignature"][i2] ? { guardianSignature: urlParams["guardianSignature"][i2] } : {}), urlParams["options"] && urlParams["options"][i2] ? {
            options: parseInt(urlParams["options"][i2])
          } : {}), urlParams["senderUsername"] && urlParams["senderUsername"][i2] ? { senderUsername: urlParams["senderUsername"][i2] } : {}), urlParams["receiverUsername"] && urlParams["receiverUsername"][i2] ? { receiverUsername: urlParams["receiverUsername"][i2] } : {}), { signature: urlParams["signature"][i2] }));
          transactions.push(plainSignedTransaction);
        }
        return transactions;
      }
      static prepareWalletTransaction(transaction) {
        let plainTransaction = transaction.toPlainObject();
        if (plainTransaction.data) {
          plainTransaction.data = import_buffer.Buffer.from(plainTransaction.data, "base64").toString();
        } else {
          plainTransaction.data = "";
        }
        return plainTransaction;
      }
      buildWalletUrl(options) {
        const callbackUrl = (options === null || options === void 0 ? void 0 : options.callbackUrl) || window.location.href;
        const partialQueryString = qs_1.default.stringify(options.params || {});
        const fullQueryString = partialQueryString ? `${partialQueryString}&callbackUrl=${callbackUrl}` : `callbackUrl=${callbackUrl}`;
        const url = `${this.baseWalletUrl()}/${options.endpoint}?${fullQueryString}`;
        console.info(`Redirecting to Wallet URL: ${decodeURI(url)}`);
        return url;
      }
      baseWalletUrl() {
        const pathArray = this.walletUrl.split("/");
        const protocol = pathArray[0];
        const host = pathArray[2];
        return protocol + "//" + host;
      }
      /**
       * Packs an array of {$link Transaction} and redirects to the specified wallet hook
       *
       * @param transactions
       * @param options
       */
      redirectTransactionsToEndpoint(endpoint, transactions, options) {
        const jsonToSend = {};
        transactions.map((tx) => {
          let plainTx = _WalletProvider.prepareWalletTransaction(tx);
          for (let txProp in plainTx) {
            if (plainTx.hasOwnProperty(txProp) && !jsonToSend.hasOwnProperty(txProp)) {
              jsonToSend[txProp] = [];
            }
            jsonToSend[txProp].push(plainTx[txProp]);
          }
        });
        const redirectUrl = this.buildWalletUrl({
          endpoint,
          callbackUrl: options === null || options === void 0 ? void 0 : options.callbackUrl,
          params: jsonToSend
        });
        window.location.href = redirectUrl;
      }
    };
    exports2.WalletProvider = WalletProvider6;
  }
});

// node_modules/axios/dist/browser/axios.cjs
var require_axios = __commonJS({
  "node_modules/axios/dist/browser/axios.cjs"(exports2, module2) {
    "use strict";
    init_shim();
    function bind(fn, thisArg) {
      return function wrap() {
        return fn.apply(thisArg, arguments);
      };
    }
    var { toString: toString3 } = Object.prototype;
    var { getPrototypeOf } = Object;
    var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
      const str = toString3.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    var kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    var typeOfTest = (type) => (thing) => typeof thing === type;
    var { isArray } = Array;
    var isUndefined = typeOfTest("undefined");
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      let result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    var isString2 = typeOfTest("string");
    var isFunction = typeOfTest("function");
    var isNumber = typeOfTest("number");
    var isObject = (thing) => thing !== null && typeof thing === "object";
    var isBoolean = (thing) => thing === true || thing === false;
    var isPlainObject = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
    };
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    var isStream = (val) => isObject(val) && isFunction(val.pipe);
    var isFormData = (thing) => {
      let kind;
      return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
      kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
    };
    var isURLSearchParams = kindOfTest("URLSearchParams");
    var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach(obj, fn, { allOwnKeys = false } = {}) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      let i2;
      let l4;
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (i2 = 0, l4 = obj.length; i2 < l4; i2++) {
          fn.call(null, obj[i2], i2, obj);
        }
      } else {
        const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys2.length;
        let key;
        for (i2 = 0; i2 < len; i2++) {
          key = keys2[i2];
          fn.call(null, obj[key], key, obj);
        }
      }
    }
    function findKey(obj, key) {
      key = key.toLowerCase();
      const keys2 = Object.keys(obj);
      let i2 = keys2.length;
      let _key;
      while (i2-- > 0) {
        _key = keys2[i2];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    var _global = (() => {
      if (typeof globalThis !== "undefined")
        return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    var isContextDefined = (context) => !isUndefined(context) && context !== _global;
    function merge() {
      const { caseless } = isContextDefined(this) && this || {};
      const result = {};
      const assignValue = (val, key) => {
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
          result[targetKey] = merge(result[targetKey], val);
        } else if (isPlainObject(val)) {
          result[targetKey] = merge({}, val);
        } else if (isArray(val)) {
          result[targetKey] = val.slice();
        } else {
          result[targetKey] = val;
        }
      };
      for (let i2 = 0, l4 = arguments.length; i2 < l4; i2++) {
        arguments[i2] && forEach(arguments[i2], assignValue);
      }
      return result;
    }
    var extend = (a3, b4, thisArg, { allOwnKeys } = {}) => {
      forEach(b4, (val, key) => {
        if (thisArg && isFunction(val)) {
          a3[key] = bind(val, thisArg);
        } else {
          a3[key] = val;
        }
      }, { allOwnKeys });
      return a3;
    };
    var stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    var inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    var toFlatObject = (sourceObj, destObj, filter, propFilter) => {
      let props;
      let i2;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null)
        return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i2 = props.length;
        while (i2-- > 0) {
          prop = props[i2];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    var endsWith = (str, searchString, position) => {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      const lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
    var toArray = (thing) => {
      if (!thing)
        return null;
      if (isArray(thing))
        return thing;
      let i2 = thing.length;
      if (!isNumber(i2))
        return null;
      const arr = new Array(i2);
      while (i2-- > 0) {
        arr[i2] = thing[i2];
      }
      return arr;
    };
    var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    var forEachEntry = (obj, fn) => {
      const generator = obj && obj[Symbol.iterator];
      const iterator = generator.call(obj);
      let result;
      while ((result = iterator.next()) && !result.done) {
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    };
    var matchAll = (regExp, str) => {
      let matches;
      const arr = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }
      return arr;
    };
    var isHTMLForm = kindOfTest("HTMLFormElement");
    var toCamelCase = (str) => {
      return str.toLowerCase().replace(
        /[-_\s]([a-z\d])(\w*)/g,
        function replacer(m3, p1, p22) {
          return p1.toUpperCase() + p22;
        }
      );
    };
    var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
    var isRegExp = kindOfTest("RegExp");
    var reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach(descriptors2, (descriptor, name2) => {
        let ret;
        if ((ret = reducer(descriptor, name2, obj)) !== false) {
          reducedDescriptors[name2] = ret || descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    var freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name2) => {
        if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name2) !== -1) {
          return false;
        }
        const value = obj[name2];
        if (!isFunction(value))
          return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name2 + "'");
          };
        }
      });
    };
    var toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};
      const define2 = (arr) => {
        arr.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
      return obj;
    };
    var noop = () => {
    };
    var toFiniteNumber = (value, defaultValue) => {
      value = +value;
      return Number.isFinite(value) ? value : defaultValue;
    };
    var ALPHA = "abcdefghijklmnopqrstuvwxyz";
    var DIGIT = "0123456789";
    var ALPHABET = {
      DIGIT,
      ALPHA,
      ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
    };
    var generateString = (size = 16, alphabet2 = ALPHABET.ALPHA_DIGIT) => {
      let str = "";
      const { length: length2 } = alphabet2;
      while (size--) {
        str += alphabet2[Math.random() * length2 | 0];
      }
      return str;
    };
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
    }
    var toJSONObject = (obj) => {
      const stack = new Array(10);
      const visit = (source, i2) => {
        if (isObject(source)) {
          if (stack.indexOf(source) >= 0) {
            return;
          }
          if (!("toJSON" in source)) {
            stack[i2] = source;
            const target = isArray(source) ? [] : {};
            forEach(source, (value, key) => {
              const reducedValue = visit(value, i2 + 1);
              !isUndefined(reducedValue) && (target[key] = reducedValue);
            });
            stack[i2] = void 0;
            return target;
          }
        }
        return source;
      };
      return visit(obj, 0);
    };
    var isAsyncFn = kindOfTest("AsyncFunction");
    var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
    var utils$1 = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString: isString2,
      isNumber,
      isBoolean,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isRegExp,
      isFunction,
      isStream,
      isURLSearchParams,
      isTypedArray,
      isFileList,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty,
      hasOwnProp: hasOwnProperty,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      ALPHABET,
      generateString,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable
    };
    function AxiosError(message, code2, config, request, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message;
      this.name = "AxiosError";
      code2 && (this.code = code2);
      config && (this.config = config);
      request && (this.request = request);
      response && (this.response = response);
    }
    utils$1.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils$1.toJSONObject(this.config),
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    var prototype$1 = AxiosError.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
      // eslint-disable-next-line func-names
    ].forEach((code2) => {
      descriptors[code2] = { value: code2 };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype$1, "isAxiosError", { value: true });
    AxiosError.from = (error, code2, config, request, response, customProps) => {
      const axiosError = Object.create(prototype$1);
      utils$1.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      }, (prop) => {
        return prop !== "isAxiosError";
      });
      AxiosError.call(axiosError, error.message, code2, config, request, response);
      axiosError.cause = error;
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    var httpAdapter = null;
    function isVisitable(thing) {
      return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
    }
    function removeBrackets(key) {
      return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path, key, dots) {
      if (!path)
        return key;
      return path.concat(key).map(function each(token, i2) {
        token = removeBrackets(token);
        return !dots && i2 ? "[" + token + "]" : token;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils$1.isArray(arr) && !arr.some(isVisitable);
    }
    var predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function toFormData(obj, formData, options) {
      if (!utils$1.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new FormData();
      options = utils$1.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils$1.isUndefined(source[option]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
      if (!utils$1.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null)
          return "";
        if (utils$1.isDate(value)) {
          return value.toISOString();
        }
        if (!useBlob && utils$1.isBlob(value)) {
          throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        }
        if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : import_buffer.Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === "object") {
          if (utils$1.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
            key = removeBrackets(key);
            arr.forEach(function each(el, index) {
              !(utils$1.isUndefined(el) || el === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
                convertValue(el)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
      }
      const stack = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value, path) {
        if (utils$1.isUndefined(value))
          return;
        if (stack.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path.join("."));
        }
        stack.push(value);
        utils$1.forEach(value, function each(el, key) {
          const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
            formData,
            el,
            utils$1.isString(key) ? key.trim() : key,
            path,
            exposedHelpers
          );
          if (result === true) {
            build(el, path ? path.concat(key) : [key]);
          }
        });
        stack.pop();
      }
      if (!utils$1.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build(obj);
      return formData;
    }
    function encode$1(str) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    var prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append(name2, value) {
      this._pairs.push([name2, value]);
    };
    prototype.toString = function toString4(encoder) {
      const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode$1);
      } : encode$1;
      return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    function encode5(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    function buildURL(url, params, options) {
      if (!params) {
        return url;
      }
      const _encode = options && options.encode || encode5;
      const serializeFn = options && options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        const hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    }
    var InterceptorManager = class {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
       */
      eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn) {
        utils$1.forEach(this.handlers, function forEachHandler(h5) {
          if (h5 !== null) {
            fn(h5);
          }
        });
      }
    };
    var InterceptorManager$1 = InterceptorManager;
    var transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    var URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
    var FormData$1 = typeof FormData !== "undefined" ? FormData : null;
    var Blob$1 = typeof Blob !== "undefined" ? Blob : null;
    var platform$1 = {
      isBrowser: true,
      classes: {
        URLSearchParams: URLSearchParams$1,
        FormData: FormData$1,
        Blob: Blob$1
      },
      protocols: ["http", "https", "file", "blob", "url", "data"]
    };
    var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
    var hasStandardBrowserEnv = ((product) => {
      return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
    })(typeof navigator !== "undefined" && navigator.product);
    var hasStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    var utils = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      hasBrowserEnv,
      hasStandardBrowserWebWorkerEnv,
      hasStandardBrowserEnv
    });
    var platform = {
      ...utils,
      ...platform$1
    };
    function toURLEncodedForm(data, options) {
      return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
        visitor: function(value, key, path, helpers) {
          if (platform.isNode && utils$1.isBuffer(value)) {
            this.append(key, value.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        }
      }, options));
    }
    function parsePropPath(name2) {
      return utils$1.matchAll(/\w+|\[(\w*)]/g, name2).map((match) => {
        return match[0] === "[]" ? "" : match[1] || match[0];
      });
    }
    function arrayToObject(arr) {
      const obj = {};
      const keys2 = Object.keys(arr);
      let i2;
      const len = keys2.length;
      let key;
      for (i2 = 0; i2 < len; i2++) {
        key = keys2[i2];
        obj[key] = arr[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path, value, target, index) {
        let name2 = path[index++];
        if (name2 === "__proto__")
          return true;
        const isNumericKey = Number.isFinite(+name2);
        const isLast = index >= path.length;
        name2 = !name2 && utils$1.isArray(target) ? target.length : name2;
        if (isLast) {
          if (utils$1.hasOwnProp(target, name2)) {
            target[name2] = [target[name2], value];
          } else {
            target[name2] = value;
          }
          return !isNumericKey;
        }
        if (!target[name2] || !utils$1.isObject(target[name2])) {
          target[name2] = [];
        }
        const result = buildPath(path, value, target[name2], index);
        if (result && utils$1.isArray(target[name2])) {
          target[name2] = arrayToObject(target[name2]);
        }
        return !isNumericKey;
      }
      if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
        const obj = {};
        utils$1.forEachEntry(formData, (name2, value) => {
          buildPath(parsePropPath(name2), value, obj, 0);
        });
        return obj;
      }
      return null;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils$1.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils$1.trim(rawValue);
        } catch (e2) {
          if (e2.name !== "SyntaxError") {
            throw e2;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: ["xhr", "http"],
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils$1.isObject(data);
        if (isObjectPayload && utils$1.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils$1.isFormData(data);
        if (isFormData2) {
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data)) {
          return data;
        }
        if (utils$1.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$1.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data);
          } catch (e2) {
            if (strictJSONParsing) {
              if (e2.name === "SyntaxError") {
                throw AxiosError.from(e2, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e2;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*",
          "Content-Type": void 0
        }
      }
    };
    utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
      defaults.headers[method] = {};
    });
    var defaults$1 = defaults;
    var ignoreDuplicateOf = utils$1.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    var parseHeaders = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i2;
      rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i2 = line.indexOf(":");
        key = line.substring(0, i2).trim().toLowerCase();
        val = line.substring(i2 + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
    var $internals = Symbol("internals");
    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }
    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }
      return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
    }
    function parseTokens(str) {
      const tokens = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match;
      while (match = tokensRE.exec(str)) {
        tokens[match[1]] = match[2];
      }
      return tokens;
    }
    var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
    function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
      if (utils$1.isFunction(filter)) {
        return filter.call(this, value, header);
      }
      if (isHeaderNameFilter) {
        value = header;
      }
      if (!utils$1.isString(value))
        return;
      if (utils$1.isString(filter)) {
        return value.indexOf(filter) !== -1;
      }
      if (utils$1.isRegExp(filter)) {
        return filter.test(value);
      }
    }
    function formatHeader(header) {
      return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w4, char, str) => {
        return char.toUpperCase() + str;
      });
    }
    function buildAccessors(obj, header) {
      const accessorName = utils$1.toCamelCase(" " + header);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    var AxiosHeaders = class {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils$1.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          if (key) {
            const value = this[key];
            if (!parser) {
              return value;
            }
            if (parser === true) {
              return parseTokens(value);
            }
            if (utils$1.isFunction(parser)) {
              return parser.call(this, value, key);
            }
            if (utils$1.isRegExp(parser)) {
              return parser.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
      }
      delete(header, matcher) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = utils$1.findKey(self2, _header);
            if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils$1.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear(matcher) {
        const keys2 = Object.keys(this);
        let i2 = keys2.length;
        let deleted = false;
        while (i2--) {
          const key = keys2[i2];
          if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format) {
        const self2 = this;
        const headers = {};
        utils$1.forEach(this, (value, header) => {
          const key = utils$1.findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value);
            delete self2[header];
            return;
          }
          const normalized = format ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils$1.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target) => computed.set(target));
        return computed;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    };
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
      let mapped = key[0].toUpperCase() + key.slice(1);
      return {
        get: () => value,
        set(headerValue) {
          this[mapped] = headerValue;
        }
      };
    });
    utils$1.freezeMethods(AxiosHeaders);
    var AxiosHeaders$1 = AxiosHeaders;
    function transformData(fns, response) {
      const config = this || defaults$1;
      const context = response || config;
      const headers = AxiosHeaders$1.from(context.headers);
      let data = context.data;
      utils$1.forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data;
    }
    function isCancel(value) {
      return !!(value && value.__CANCEL__);
    }
    function CanceledError(message, config, request) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
      this.name = "CanceledError";
    }
    utils$1.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    function settle(resolve, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    var cookies = platform.hasStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      {
        write(name2, value, expires, path, domain, secure) {
          const cookie = [name2 + "=" + encodeURIComponent(value)];
          utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
          utils$1.isString(path) && cookie.push("path=" + path);
          utils$1.isString(domain) && cookie.push("domain=" + domain);
          secure === true && cookie.push("secure");
          document.cookie = cookie.join("; ");
        },
        read(name2) {
          const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove(name2) {
          this.write(name2, "", Date.now() - 864e5);
        }
      }
    ) : (
      // Non-standard browser env (web workers, react-native) lack needed support.
      {
        write() {
        },
        read() {
          return null;
        },
        remove() {
        }
      }
    );
    function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    }
    function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }
    var isURLSameOrigin = platform.hasStandardBrowserEnv ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        const msie = /(msie|trident)/i.test(navigator.userAgent);
        const urlParsingNode = document.createElement("a");
        let originURL;
        function resolveURL(url) {
          let href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin2(requestURL) {
          const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      /* @__PURE__ */ function nonStandardBrowserEnv() {
        return function isURLSameOrigin2() {
          return true;
        };
      }()
    );
    function parseProtocol(url) {
      const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match && match[1] || "";
    }
    function speedometer(samplesCount, min) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;
      min = min !== void 0 ? min : 1e3;
      return function push(chunkLength) {
        const now = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now;
        let i2 = tail;
        let bytesCount = 0;
        while (i2 !== head) {
          bytesCount += bytes[i2++];
          i2 = i2 % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now - firstSampleTS < min) {
          return;
        }
        const passed = startedAt && now - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    function progressEventReducer(listener, isDownloadStream) {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return (e2) => {
        const loaded = e2.loaded;
        const total = e2.lengthComputable ? e2.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e2
        };
        data[isDownloadStream ? "download" : "upload"] = true;
        listener(data);
      };
    }
    var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    var xhrAdapter = isXHRAdapterSupported && function(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        let requestData = config.data;
        const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
        let { responseType, withXSRFToken } = config;
        let onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        let contentType;
        if (utils$1.isFormData(requestData)) {
          if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
            requestHeaders.setContentType(false);
          } else if ((contentType = requestHeaders.getContentType()) !== false) {
            const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
            requestHeaders.setContentType([type || "multipart/form-data", ...tokens].join("; "));
          }
        }
        let request = new XMLHttpRequest();
        if (config.auth) {
          const username = config.auth.username || "";
          const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
        }
        const fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = config.transitional || transitionalDefaults;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config,
            request
          ));
          request = null;
        };
        if (platform.hasStandardBrowserEnv) {
          withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
          if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(fullPath)) {
            const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
            if (xsrfValue) {
              requestHeaders.set(config.xsrfHeaderName, xsrfValue);
            }
          }
        }
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }
        if (!utils$1.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
        }
        if (config.cancelToken || config.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(fullPath);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
          return;
        }
        request.send(requestData || null);
      });
    };
    var knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter
    };
    utils$1.forEach(knownAdapters, (fn, value) => {
      if (fn) {
        try {
          Object.defineProperty(fn, "name", { value });
        } catch (e2) {
        }
        Object.defineProperty(fn, "adapterName", { value });
      }
    });
    var renderReason = (reason) => `- ${reason}`;
    var isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
    var adapters = {
      getAdapter: (adapters2) => {
        adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
        const { length: length2 } = adapters2;
        let nameOrAdapter;
        let adapter;
        const rejectedReasons = {};
        for (let i2 = 0; i2 < length2; i2++) {
          nameOrAdapter = adapters2[i2];
          let id;
          adapter = nameOrAdapter;
          if (!isResolvedHandle(nameOrAdapter)) {
            adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
            if (adapter === void 0) {
              throw new AxiosError(`Unknown adapter '${id}'`);
            }
          }
          if (adapter) {
            break;
          }
          rejectedReasons[id || "#" + i2] = adapter;
        }
        if (!adapter) {
          const reasons = Object.entries(rejectedReasons).map(
            ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
          );
          let s2 = length2 ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
          throw new AxiosError(
            `There is no suitable adapter to dispatch the request ` + s2,
            "ERR_NOT_SUPPORT"
          );
        }
        return adapter;
      },
      adapters: knownAdapters
    };
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError(null, config);
      }
    }
    function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = AxiosHeaders$1.from(config.headers);
      config.data = transformData.call(
        config,
        config.transformRequest
      );
      if (["post", "put", "patch"].indexOf(config.method) !== -1) {
        config.headers.setContentType("application/x-www-form-urlencoded", false);
      }
      const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          config.transformResponse,
          response
        );
        response.headers = AxiosHeaders$1.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              config.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    var headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
    function mergeConfig(config1, config2) {
      config2 = config2 || {};
      const config = {};
      function getMergedValue(target, source, caseless) {
        if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
          return utils$1.merge.call({ caseless }, target, source);
        } else if (utils$1.isPlainObject(source)) {
          return utils$1.merge({}, source);
        } else if (utils$1.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(a3, b4, caseless) {
        if (!utils$1.isUndefined(b4)) {
          return getMergedValue(a3, b4, caseless);
        } else if (!utils$1.isUndefined(a3)) {
          return getMergedValue(void 0, a3, caseless);
        }
      }
      function valueFromConfig2(a3, b4) {
        if (!utils$1.isUndefined(b4)) {
          return getMergedValue(void 0, b4);
        }
      }
      function defaultToConfig2(a3, b4) {
        if (!utils$1.isUndefined(b4)) {
          return getMergedValue(void 0, b4);
        } else if (!utils$1.isUndefined(a3)) {
          return getMergedValue(void 0, a3);
        }
      }
      function mergeDirectKeys(a3, b4, prop) {
        if (prop in config2) {
          return getMergedValue(a3, b4);
        } else if (prop in config1) {
          return getMergedValue(void 0, a3);
        }
      }
      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a3, b4) => mergeDeepProperties(headersToObject(a3), headersToObject(b4), true)
      };
      utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
        const merge2 = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge2(config1[prop], config2[prop], prop);
        utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    }
    var VERSION = "1.6.8";
    var validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i2) => {
      validators$1[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators$1.transitional = function transitional(validator2, version2, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return (value, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version2 && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version2 + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      const keys2 = Object.keys(options);
      let i2 = keys2.length;
      while (i2-- > 0) {
        const opt = keys2[i2];
        const validator2 = schema[opt];
        if (validator2) {
          const value = options[opt];
          const result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    var validator = {
      assertOptions,
      validators: validators$1
    };
    var validators = validator.validators;
    var Axios = class {
      constructor(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager$1(),
          response: new InterceptorManager$1()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      async request(configOrUrl, config) {
        try {
          return await this._request(configOrUrl, config);
        } catch (err) {
          if (err instanceof Error) {
            let dummy;
            Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
            const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
            if (!err.stack) {
              err.stack = stack;
            } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
              err.stack += "\n" + stack;
            }
          }
          throw err;
        }
      }
      _request(configOrUrl, config) {
        if (typeof configOrUrl === "string") {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }
        config = mergeConfig(this.defaults, config);
        const { transitional, paramsSerializer, headers } = config;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer != null) {
          if (utils$1.isFunction(paramsSerializer)) {
            config.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator.assertOptions(paramsSerializer, {
              encode: validators.function,
              serialize: validators.function
            }, true);
          }
        }
        config.method = (config.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders = headers && utils$1.merge(
          headers.common,
          headers[config.method]
        );
        headers && utils$1.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          }
        );
        config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i2 = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift.apply(chain, requestInterceptorChain);
          chain.push.apply(chain, responseInterceptorChain);
          len = chain.length;
          promise = Promise.resolve(config);
          while (i2 < len) {
            promise = promise.then(chain[i2++], chain[i2++]);
          }
          return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        i2 = 0;
        while (i2 < len) {
          const onFulfilled = requestInterceptorChain[i2++];
          const onRejected = requestInterceptorChain[i2++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i2 = 0;
        len = responseInterceptorChain.length;
        while (i2 < len) {
          promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
        }
        return promise;
      }
      getUri(config) {
        config = mergeConfig(this.defaults, config);
        const fullPath = buildFullPath(config.baseURL, config.url);
        return buildURL(fullPath, config.params, config.paramsSerializer);
      }
    };
    utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    var Axios$1 = Axios;
    var CancelToken = class _CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        const token = this;
        this.promise.then((cancel) => {
          if (!token._listeners)
            return;
          let i2 = token._listeners.length;
          while (i2-- > 0) {
            token._listeners[i2](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise = new Promise((resolve) => {
            token.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message, config, request) {
          if (token.reason) {
            return;
          }
          token.reason = new CanceledError(message, config, request);
          resolvePromise(token.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token = new _CancelToken(function executor(c4) {
          cancel = c4;
        });
        return {
          token,
          cancel
        };
      }
    };
    var CancelToken$1 = CancelToken;
    function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    }
    function isAxiosError(payload) {
      return utils$1.isObject(payload) && payload.isAxiosError === true;
    }
    var HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511
    };
    Object.entries(HttpStatusCode).forEach(([key, value]) => {
      HttpStatusCode[value] = key;
    });
    var HttpStatusCode$1 = HttpStatusCode;
    function createInstance(defaultConfig) {
      const context = new Axios$1(defaultConfig);
      const instance = bind(Axios$1.prototype.request, context);
      utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
      utils$1.extend(instance, context, null, { allOwnKeys: true });
      instance.create = function create2(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults$1);
    axios.Axios = Axios$1;
    axios.CanceledError = CanceledError;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION;
    axios.toFormData = toFormData;
    axios.AxiosError = AxiosError;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;
    axios.isAxiosError = isAxiosError;
    axios.mergeConfig = mergeConfig;
    axios.AxiosHeaders = AxiosHeaders$1;
    axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.getAdapter = adapters.getAdapter;
    axios.HttpStatusCode = HttpStatusCode$1;
    axios.default = axios;
    module2.exports = axios;
  }
});

// node_modules/@multiversx/sdk-native-auth-client/lib/src/entities/native.auth.client.config.js
var require_native_auth_client_config = __commonJS({
  "node_modules/@multiversx/sdk-native-auth-client/lib/src/entities/native.auth.client.config.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NativeAuthClientConfig = void 0;
    var NativeAuthClientConfig = class {
      constructor() {
        this.origin = typeof window !== "undefined" && typeof window.location !== "undefined" ? window.location.hostname : "";
        this.apiUrl = "https://api.multiversx.com";
        this.expirySeconds = 60 * 60 * 24;
      }
    };
    exports2.NativeAuthClientConfig = NativeAuthClientConfig;
  }
});

// node_modules/@multiversx/sdk-native-auth-client/lib/src/native.auth.client.js
var require_native_auth_client = __commonJS({
  "node_modules/@multiversx/sdk-native-auth-client/lib/src/native.auth.client.js"(exports2) {
    "use strict";
    init_shim();
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NativeAuthClient = void 0;
    var axios_1 = require_axios();
    var native_auth_client_config_1 = require_native_auth_client_config();
    var NativeAuthClient3 = class {
      constructor(config) {
        this.config = Object.assign(new native_auth_client_config_1.NativeAuthClientConfig(), config);
      }
      getToken(address, token, signature) {
        const encodedAddress = this.encodeValue(address);
        const encodedToken = this.encodeValue(token);
        const accessToken = `${encodedAddress}.${encodedToken}.${signature}`;
        return accessToken;
      }
      initialize(extraInfo = {}) {
        return __awaiter2(this, void 0, void 0, function* () {
          const blockHash = yield this.getCurrentBlockHash();
          const encodedExtraInfo = this.encodeValue(JSON.stringify(extraInfo));
          const origin = this.encodeValue(this.config.origin);
          return `${origin}.${blockHash}.${this.config.expirySeconds}.${encodedExtraInfo}`;
        });
      }
      getCurrentBlockHash() {
        return __awaiter2(this, void 0, void 0, function* () {
          if (this.config.gatewayUrl) {
            return yield this.getCurrentBlockHashWithGateway();
          }
          return yield this.getCurrentBlockHashWithApi();
        });
      }
      getCurrentBlockHashWithGateway() {
        return __awaiter2(this, void 0, void 0, function* () {
          const round = yield this.getCurrentRound();
          const url = `${this.config.gatewayUrl}/blocks/by-round/${round}`;
          const response = yield this.get(url);
          const blocks = response.data.data.blocks;
          const block = blocks.filter((block2) => block2.shard === this.config.blockHashShard)[0];
          return block.hash;
        });
      }
      getCurrentRound() {
        return __awaiter2(this, void 0, void 0, function* () {
          if (!this.config.gatewayUrl) {
            throw new Error("Gateway URL not set");
          }
          if (!this.config.blockHashShard) {
            throw new Error("Blockhash shard not set");
          }
          const url = `${this.config.gatewayUrl}/network/status/${this.config.blockHashShard}`;
          const response = yield this.get(url);
          const status = response.data.data.status;
          return status.erd_current_round;
        });
      }
      getCurrentBlockHashWithApi() {
        return __awaiter2(this, void 0, void 0, function* () {
          try {
            const url = `${this.config.apiUrl}/blocks/latest?ttl=${this.config.expirySeconds}&fields=hash`;
            const response = yield this.get(url);
            if (response.data[0].hash !== void 0) {
              return response.data[0].hash;
            }
          } catch (error) {
          }
          return this.getCurrentBlockHashWithApiFallback();
        });
      }
      getCurrentBlockHashWithApiFallback() {
        return __awaiter2(this, void 0, void 0, function* () {
          let url = `${this.config.apiUrl}/blocks?size=1&fields=hash`;
          if (this.config.blockHashShard !== void 0) {
            url += `&shard=${this.config.blockHashShard}`;
          }
          const response = yield this.get(url);
          return response.data[0].hash;
        });
      }
      encodeValue(str) {
        return this.escape(import_buffer.Buffer.from(str, "utf8").toString("base64"));
      }
      escape(str) {
        return str.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
      }
      get(url) {
        return __awaiter2(this, void 0, void 0, function* () {
          return yield axios_1.default.get(url, { headers: this.config.extraRequestHeaders });
        });
      }
    };
    exports2.NativeAuthClient = NativeAuthClient3;
  }
});

// node_modules/@multiversx/sdk-network-providers/out/transactionStatus.js
var require_transactionStatus = __commonJS({
  "node_modules/@multiversx/sdk-network-providers/out/transactionStatus.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransactionStatus = void 0;
    var TransactionStatus2 = class _TransactionStatus {
      /**
       * Creates a new TransactionStatus object.
       */
      constructor(status) {
        this.status = (status || "").toLowerCase();
      }
      /**
       * Creates an unknown status.
       */
      static createUnknown() {
        return new _TransactionStatus("unknown");
      }
      /**
       * Returns whether the transaction is pending (e.g. in mempool).
       */
      isPending() {
        return this.status == "received" || this.status == "pending";
      }
      /**
       * Returns whether the transaction has been executed (not necessarily with success).
       */
      isExecuted() {
        return this.isSuccessful() || this.isFailed() || this.isInvalid();
      }
      /**
       * Returns whether the transaction has been executed successfully.
       */
      isSuccessful() {
        return this.status == "executed" || this.status == "success" || this.status == "successful";
      }
      /**
       * Returns whether the transaction has been executed, but with a failure.
       */
      isFailed() {
        return this.status == "fail" || this.status == "failed" || this.status == "unsuccessful" || this.isInvalid();
      }
      /**
       * Returns whether the transaction has been executed, but marked as invalid (e.g. due to "insufficient funds").
       */
      isInvalid() {
        return this.status == "invalid";
      }
      toString() {
        return this.status;
      }
      valueOf() {
        return this.status;
      }
      equals(other) {
        if (!other) {
          return false;
        }
        return this.status == other.status;
      }
    };
    exports2.TransactionStatus = TransactionStatus2;
  }
});

// node_modules/@multiversx/sdk-network-providers/out/transactionReceipt.js
var require_transactionReceipt = __commonJS({
  "node_modules/@multiversx/sdk-network-providers/out/transactionReceipt.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransactionReceipt = void 0;
    var primitives_1 = require_primitives();
    var TransactionReceipt2 = class _TransactionReceipt {
      constructor() {
        this.value = "";
        this.sender = new primitives_1.Address("");
        this.data = "";
        this.hash = "";
      }
      static fromHttpResponse(response) {
        let receipt = new _TransactionReceipt();
        receipt.value = (response.value || 0).toString();
        receipt.sender = new primitives_1.Address(response.sender);
        receipt.data = response.data;
        receipt.hash = response.txHash;
        return receipt;
      }
    };
    exports2.TransactionReceipt = TransactionReceipt2;
  }
});

// node_modules/@multiversx/sdk-network-providers/out/errors.js
var require_errors5 = __commonJS({
  "node_modules/@multiversx/sdk-network-providers/out/errors.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ErrContractQuery = exports2.ErrNetworkProvider = exports2.ErrUnexpectedCondition = exports2.Err = void 0;
    var Err = class extends Error {
      constructor(message, inner) {
        super(message);
        this.inner = void 0;
        this.inner = inner;
      }
    };
    exports2.Err = Err;
    var ErrUnexpectedCondition = class extends Err {
      constructor(message) {
        super(`Unexpected condition: [${message}]`);
      }
    };
    exports2.ErrUnexpectedCondition = ErrUnexpectedCondition;
    var ErrNetworkProvider = class extends Err {
      constructor(url, error, inner) {
        let message = `Request error on url [${url}]: [${error}]`;
        super(message, inner);
      }
    };
    exports2.ErrNetworkProvider = ErrNetworkProvider;
    var ErrContractQuery = class extends Err {
      constructor(originalError) {
        super(originalError.message.replace("executeQuery:", ""));
      }
    };
    exports2.ErrContractQuery = ErrContractQuery;
  }
});

// node_modules/@multiversx/sdk-network-providers/out/transactionEvents.js
var require_transactionEvents = __commonJS({
  "node_modules/@multiversx/sdk-network-providers/out/transactionEvents.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransactionEventTopic = exports2.TransactionEventData = exports2.TransactionEvent = void 0;
    var primitives_1 = require_primitives();
    var TransactionEvent = class _TransactionEvent {
      constructor(init) {
        this.address = new primitives_1.Address("");
        this.identifier = "";
        this.topics = [];
        this.data = "";
        this.dataPayload = new TransactionEventData(import_buffer.Buffer.from("", "utf8"));
        this.additionalData = [];
        Object.assign(this, init);
      }
      static fromHttpResponse(responsePart) {
        let result = new _TransactionEvent();
        result.address = new primitives_1.Address(responsePart.address);
        result.identifier = responsePart.identifier || "";
        result.topics = (responsePart.topics || []).map((topic) => new TransactionEventTopic(topic));
        result.dataPayload = TransactionEventData.fromBase64(responsePart.data);
        result.additionalData = (responsePart.additionalData || []).map(TransactionEventData.fromBase64);
        result.data = result.dataPayload.toString();
        return result;
      }
      findFirstOrNoneTopic(predicate) {
        return this.topics.filter((topic) => predicate(topic))[0];
      }
      getLastTopic() {
        return this.topics[this.topics.length - 1];
      }
    };
    exports2.TransactionEvent = TransactionEvent;
    var TransactionEventData = class _TransactionEventData {
      constructor(data) {
        this.raw = data;
      }
      static fromBase64(str) {
        return new _TransactionEventData(import_buffer.Buffer.from(str || "", "base64"));
      }
      toString() {
        return this.raw.toString("utf8");
      }
      hex() {
        return this.raw.toString("hex");
      }
      valueOf() {
        return this.raw;
      }
    };
    exports2.TransactionEventData = TransactionEventData;
    var TransactionEventTopic = class {
      constructor(topic) {
        this.raw = import_buffer.Buffer.from(topic || "", "base64");
      }
      toString() {
        return this.raw.toString("utf8");
      }
      hex() {
        return this.raw.toString("hex");
      }
      valueOf() {
        return this.raw;
      }
    };
    exports2.TransactionEventTopic = TransactionEventTopic;
  }
});

// node_modules/@multiversx/sdk-network-providers/out/transactionLogs.js
var require_transactionLogs = __commonJS({
  "node_modules/@multiversx/sdk-network-providers/out/transactionLogs.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransactionLogs = void 0;
    var errors_1 = require_errors5();
    var primitives_1 = require_primitives();
    var transactionEvents_1 = require_transactionEvents();
    var TransactionLogs2 = class _TransactionLogs {
      constructor(init) {
        this.address = new primitives_1.Address("");
        this.events = [];
        Object.assign(this, init);
      }
      static fromHttpResponse(logs) {
        let result = new _TransactionLogs();
        result.address = new primitives_1.Address(logs.address);
        result.events = (logs.events || []).map((event) => transactionEvents_1.TransactionEvent.fromHttpResponse(event));
        return result;
      }
      findSingleOrNoneEvent(identifier, predicate) {
        let events = this.findEvents(identifier, predicate);
        if (events.length > 1) {
          throw new errors_1.ErrUnexpectedCondition(`more than one event of type ${identifier}`);
        }
        return events[0];
      }
      findFirstOrNoneEvent(identifier, predicate) {
        return this.findEvents(identifier, predicate)[0];
      }
      findEvents(identifier, predicate) {
        let events = this.events.filter((event) => event.identifier == identifier);
        if (predicate) {
          events = events.filter((event) => predicate(event));
        }
        return events;
      }
    };
    exports2.TransactionLogs = TransactionLogs2;
  }
});

// node_modules/@multiversx/sdk-network-providers/out/contractResults.js
var require_contractResults = __commonJS({
  "node_modules/@multiversx/sdk-network-providers/out/contractResults.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ContractResultItem = exports2.ContractResults = void 0;
    var transactionLogs_1 = require_transactionLogs();
    var primitives_1 = require_primitives();
    var ContractResults2 = class _ContractResults {
      constructor(items) {
        this.items = items;
        this.items.sort(function(a3, b4) {
          return a3.nonce.valueOf() - b4.nonce.valueOf();
        });
      }
      static fromProxyHttpResponse(results) {
        let items = results.map((item) => ContractResultItem.fromProxyHttpResponse(item));
        return new _ContractResults(items);
      }
      static fromApiHttpResponse(results) {
        let items = results.map((item) => ContractResultItem.fromApiHttpResponse(item));
        return new _ContractResults(items);
      }
    };
    exports2.ContractResults = ContractResults2;
    var ContractResultItem = class _ContractResultItem {
      constructor(init) {
        this.hash = "";
        this.nonce = 0;
        this.value = "";
        this.receiver = new primitives_1.Address("");
        this.sender = new primitives_1.Address("");
        this.data = "";
        this.previousHash = "";
        this.originalHash = "";
        this.gasLimit = 0;
        this.gasPrice = 0;
        this.callType = 0;
        this.returnMessage = "";
        this.logs = new transactionLogs_1.TransactionLogs();
        Object.assign(this, init);
      }
      static fromProxyHttpResponse(response) {
        let item = _ContractResultItem.fromHttpResponse(response);
        return item;
      }
      static fromApiHttpResponse(response) {
        let item = _ContractResultItem.fromHttpResponse(response);
        item.data = import_buffer.Buffer.from(item.data, "base64").toString();
        item.callType = Number(item.callType);
        return item;
      }
      static fromHttpResponse(response) {
        let item = new _ContractResultItem();
        item.hash = response.hash;
        item.nonce = Number(response.nonce || 0);
        item.value = (response.value || 0).toString();
        item.receiver = new primitives_1.Address(response.receiver);
        item.sender = new primitives_1.Address(response.sender);
        item.previousHash = response.prevTxHash;
        item.originalHash = response.originalTxHash;
        item.gasLimit = Number(response.gasLimit || 0);
        item.gasPrice = Number(response.gasPrice || 0);
        item.data = response.data || "";
        item.callType = response.callType;
        item.returnMessage = response.returnMessage;
        item.logs = transactionLogs_1.TransactionLogs.fromHttpResponse(response.logs || {});
        return item;
      }
    };
    exports2.ContractResultItem = ContractResultItem;
  }
});

// node_modules/@multiversx/sdk-network-providers/out/contractQueryRequest.js
var require_contractQueryRequest = __commonJS({
  "node_modules/@multiversx/sdk-network-providers/out/contractQueryRequest.js"(exports2) {
    "use strict";
    init_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ContractQueryRequest = void 0;
    var ContractQueryRequest2 = class {
      constructor(query) {
        this.query = query;
      }
      toHttpRequest() {
        var _a;
        let request = {};
        let query = this.query;
        request.scAddress = query.address.bech32();
        request.caller = ((_a = query.caller) === null || _a === void 0 ? void 0 : _a.bech32()) ? query.caller.bech32() : void 0;
        request.funcName = query.func.toString();
        request.value = query.value ? query.value.toString() : void 0;
        request.args = query.getEncodedArguments();
        return request;
      }
    };
    exports2.ContractQueryRequest = ContractQueryRequest2;
  }
});

// node_modules/qrcode/lib/can-promise.js
var require_can_promise = __commonJS({
  "node_modules/qrcode/lib/can-promise.js"(exports2, module2) {
    init_shim();
    module2.exports = function() {
      return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
    };
  }
});

// node_modules/qrcode/lib/core/utils.js
var require_utils6 = __commonJS({
  "node_modules/qrcode/lib/core/utils.js"(exports2) {
    init_shim();
    var toSJISFunction;
    var CODEWORDS_COUNT = [
      0,
      // Not used
      26,
      44,
      70,
      100,
      134,
      172,
      196,
      242,
      292,
      346,
      404,
      466,
      532,
      581,
      655,
      733,
      815,
      901,
      991,
      1085,
      1156,
      1258,
      1364,
      1474,
      1588,
      1706,
      1828,
      1921,
      2051,
      2185,
      2323,
      2465,
      2611,
      2761,
      2876,
      3034,
      3196,
      3362,
      3532,
      3706
    ];
    exports2.getSymbolSize = function getSymbolSize(version2) {
      if (!version2)
        throw new Error('"version" cannot be null or undefined');
      if (version2 < 1 || version2 > 40)
        throw new Error('"version" should be in range from 1 to 40');
      return version2 * 4 + 17;
    };
    exports2.getSymbolTotalCodewords = function getSymbolTotalCodewords(version2) {
      return CODEWORDS_COUNT[version2];
    };
    exports2.getBCHDigit = function(data) {
      let digit = 0;
      while (data !== 0) {
        digit++;
        data >>>= 1;
      }
      return digit;
    };
    exports2.setToSJISFunction = function setToSJISFunction(f4) {
      if (typeof f4 !== "function") {
        throw new Error('"toSJISFunc" is not a valid function.');
      }
      toSJISFunction = f4;
    };
    exports2.isKanjiModeEnabled = function() {
      return typeof toSJISFunction !== "undefined";
    };
    exports2.toSJIS = function toSJIS(kanji) {
      return toSJISFunction(kanji);
    };
  }
});

// node_modules/qrcode/lib/core/error-correction-level.js
var require_error_correction_level = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-level.js"(exports2) {
    init_shim();
    exports2.L = { bit: 1 };
    exports2.M = { bit: 0 };
    exports2.Q = { bit: 3 };
    exports2.H = { bit: 2 };
    function fromString3(string2) {
      if (typeof string2 !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string2.toLowerCase();
      switch (lcStr) {
        case "l":
        case "low":
          return exports2.L;
        case "m":
        case "medium":
          return exports2.M;
        case "q":
        case "quartile":
          return exports2.Q;
        case "h":
        case "high":
          return exports2.H;
        default:
          throw new Error("Unknown EC Level: " + string2);
      }
    }
    exports2.isValid = function isValid(level) {
      return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
    };
    exports2.from = function from3(value, defaultValue) {
      if (exports2.isValid(value)) {
        return value;
      }
      try {
        return fromString3(value);
      } catch (e2) {
        return defaultValue;
      }
    };
  }
});

// node_modules/qrcode/lib/core/bit-buffer.js
var require_bit_buffer = __commonJS({
  "node_modules/qrcode/lib/core/bit-buffer.js"(exports2, module2) {
    init_shim();
    function BitBuffer() {
      this.buffer = [];
      this.length = 0;
    }
    BitBuffer.prototype = {
      get: function(index) {
        const bufIndex = Math.floor(index / 8);
        return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;
      },
      put: function(num, length2) {
        for (let i2 = 0; i2 < length2; i2++) {
          this.putBit((num >>> length2 - i2 - 1 & 1) === 1);
        }
      },
      getLengthInBits: function() {
        return this.length;
      },
      putBit: function(bit) {
        const bufIndex = Math.floor(this.length / 8);
        if (this.buffer.length <= bufIndex) {
          this.buffer.push(0);
        }
        if (bit) {
          this.buffer[bufIndex] |= 128 >>> this.length % 8;
        }
        this.length++;
      }
    };
    module2.exports = BitBuffer;
  }
});

// node_modules/qrcode/lib/core/bit-matrix.js
var require_bit_matrix = __commonJS({
  "node_modules/qrcode/lib/core/bit-matrix.js"(exports2, module2) {
    init_shim();
    function BitMatrix(size) {
      if (!size || size < 1) {
        throw new Error("BitMatrix size must be defined and greater than 0");
      }
      this.size = size;
      this.data = new Uint8Array(size * size);
      this.reservedBit = new Uint8Array(size * size);
    }
    BitMatrix.prototype.set = function(row, col, value, reserved) {
      const index = row * this.size + col;
      this.data[index] = value;
      if (reserved)
        this.reservedBit[index] = true;
    };
    BitMatrix.prototype.get = function(row, col) {
      return this.data[row * this.size + col];
    };
    BitMatrix.prototype.xor = function(row, col, value) {
      this.data[row * this.size + col] ^= value;
    };
    BitMatrix.prototype.isReserved = function(row, col) {
      return this.reservedBit[row * this.size + col];
    };
    module2.exports = BitMatrix;
  }
});

// node_modules/qrcode/lib/core/alignment-pattern.js
var require_alignment_pattern = __commonJS({
  "node_modules/qrcode/lib/core/alignment-pattern.js"(exports2) {
    init_shim();
    var getSymbolSize = require_utils6().getSymbolSize;
    exports2.getRowColCoords = function getRowColCoords(version2) {
      if (version2 === 1)
        return [];
      const posCount = Math.floor(version2 / 7) + 2;
      const size = getSymbolSize(version2);
      const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
      const positions = [size - 7];
      for (let i2 = 1; i2 < posCount - 1; i2++) {
        positions[i2] = positions[i2 - 1] - intervals;
      }
      positions.push(6);
      return positions.reverse();
    };
    exports2.getPositions = function getPositions(version2) {
      const coords = [];
      const pos = exports2.getRowColCoords(version2);
      const posLength = pos.length;
      for (let i2 = 0; i2 < posLength; i2++) {
        for (let j2 = 0; j2 < posLength; j2++) {
          if (i2 === 0 && j2 === 0 || // top-left
          i2 === 0 && j2 === posLength - 1 || // bottom-left
          i2 === posLength - 1 && j2 === 0) {
            continue;
          }
          coords.push([pos[i2], pos[j2]]);
        }
      }
      return coords;
    };
  }
});

// node_modules/qrcode/lib/core/finder-pattern.js
var require_finder_pattern = __commonJS({
  "node_modules/qrcode/lib/core/finder-pattern.js"(exports2) {
    init_shim();
    var getSymbolSize = require_utils6().getSymbolSize;
    var FINDER_PATTERN_SIZE = 7;
    exports2.getPositions = function getPositions(version2) {
      const size = getSymbolSize(version2);
      return [
        // top-left
        [0, 0],
        // top-right
        [size - FINDER_PATTERN_SIZE, 0],
        // bottom-left
        [0, size - FINDER_PATTERN_SIZE]
      ];
    };
  }
});

// node_modules/qrcode/lib/core/mask-pattern.js
var require_mask_pattern = __commonJS({
  "node_modules/qrcode/lib/core/mask-pattern.js"(exports2) {
    init_shim();
    exports2.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };
    var PenaltyScores = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10
    };
    exports2.isValid = function isValid(mask) {
      return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
    };
    exports2.from = function from3(value) {
      return exports2.isValid(value) ? parseInt(value, 10) : void 0;
    };
    exports2.getPenaltyN1 = function getPenaltyN1(data) {
      const size = data.size;
      let points = 0;
      let sameCountCol = 0;
      let sameCountRow = 0;
      let lastCol = null;
      let lastRow = null;
      for (let row = 0; row < size; row++) {
        sameCountCol = sameCountRow = 0;
        lastCol = lastRow = null;
        for (let col = 0; col < size; col++) {
          let module3 = data.get(row, col);
          if (module3 === lastCol) {
            sameCountCol++;
          } else {
            if (sameCountCol >= 5)
              points += PenaltyScores.N1 + (sameCountCol - 5);
            lastCol = module3;
            sameCountCol = 1;
          }
          module3 = data.get(col, row);
          if (module3 === lastRow) {
            sameCountRow++;
          } else {
            if (sameCountRow >= 5)
              points += PenaltyScores.N1 + (sameCountRow - 5);
            lastRow = module3;
            sameCountRow = 1;
          }
        }
        if (sameCountCol >= 5)
          points += PenaltyScores.N1 + (sameCountCol - 5);
        if (sameCountRow >= 5)
          points += PenaltyScores.N1 + (sameCountRow - 5);
      }
      return points;
    };
    exports2.getPenaltyN2 = function getPenaltyN2(data) {
      const size = data.size;
      let points = 0;
      for (let row = 0; row < size - 1; row++) {
        for (let col = 0; col < size - 1; col++) {
          const last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
          if (last === 4 || last === 0)
            points++;
        }
      }
      return points * PenaltyScores.N2;
    };
    exports2.getPenaltyN3 = function getPenaltyN3(data) {
      const size = data.size;
      let points = 0;
      let bitsCol = 0;
      let bitsRow = 0;
      for (let row = 0; row < size; row++) {
        bitsCol = bitsRow = 0;
        for (let col = 0; col < size; col++) {
          bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
          if (col >= 10 && (bitsCol === 1488 || bitsCol === 93))
            points++;
          bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
          if (col >= 10 && (bitsRow === 1488 || bitsRow === 93))
            points++;
        }
      }
      return points * PenaltyScores.N3;
    };
    exports2.getPenaltyN4 = function getPenaltyN4(data) {
      let darkCount = 0;
      const modulesCount = data.data.length;
      for (let i2 = 0; i2 < modulesCount; i2++)
        darkCount += data.data[i2];
      const k4 = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
      return k4 * PenaltyScores.N4;
    };
    function getMaskAt(maskPattern, i2, j2) {
      switch (maskPattern) {
        case exports2.Patterns.PATTERN000:
          return (i2 + j2) % 2 === 0;
        case exports2.Patterns.PATTERN001:
          return i2 % 2 === 0;
        case exports2.Patterns.PATTERN010:
          return j2 % 3 === 0;
        case exports2.Patterns.PATTERN011:
          return (i2 + j2) % 3 === 0;
        case exports2.Patterns.PATTERN100:
          return (Math.floor(i2 / 2) + Math.floor(j2 / 3)) % 2 === 0;
        case exports2.Patterns.PATTERN101:
          return i2 * j2 % 2 + i2 * j2 % 3 === 0;
        case exports2.Patterns.PATTERN110:
          return (i2 * j2 % 2 + i2 * j2 % 3) % 2 === 0;
        case exports2.Patterns.PATTERN111:
          return (i2 * j2 % 3 + (i2 + j2) % 2) % 2 === 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    }
    exports2.applyMask = function applyMask(pattern, data) {
      const size = data.size;
      for (let col = 0; col < size; col++) {
        for (let row = 0; row < size; row++) {
          if (data.isReserved(row, col))
            continue;
          data.xor(row, col, getMaskAt(pattern, row, col));
        }
      }
    };
    exports2.getBestMask = function getBestMask(data, setupFormatFunc) {
      const numPatterns = Object.keys(exports2.Patterns).length;
      let bestPattern = 0;
      let lowerPenalty = Infinity;
      for (let p3 = 0; p3 < numPatterns; p3++) {
        setupFormatFunc(p3);
        exports2.applyMask(p3, data);
        const penalty = exports2.getPenaltyN1(data) + exports2.getPenaltyN2(data) + exports2.getPenaltyN3(data) + exports2.getPenaltyN4(data);
        exports2.applyMask(p3, data);
        if (penalty < lowerPenalty) {
          lowerPenalty = penalty;
          bestPattern = p3;
        }
      }
      return bestPattern;
    };
  }
});

// node_modules/qrcode/lib/core/error-correction-code.js
var require_error_correction_code = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-code.js"(exports2) {
    init_shim();
    var ECLevel = require_error_correction_level();
    var EC_BLOCKS_TABLE = [
      // L  M  Q  H
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      1,
      2,
      2,
      4,
      1,
      2,
      4,
      4,
      2,
      4,
      4,
      4,
      2,
      4,
      6,
      5,
      2,
      4,
      6,
      6,
      2,
      5,
      8,
      8,
      4,
      5,
      8,
      8,
      4,
      5,
      8,
      11,
      4,
      8,
      10,
      11,
      4,
      9,
      12,
      16,
      4,
      9,
      16,
      16,
      6,
      10,
      12,
      18,
      6,
      10,
      17,
      16,
      6,
      11,
      16,
      19,
      6,
      13,
      18,
      21,
      7,
      14,
      21,
      25,
      8,
      16,
      20,
      25,
      8,
      17,
      23,
      25,
      9,
      17,
      23,
      34,
      9,
      18,
      25,
      30,
      10,
      20,
      27,
      32,
      12,
      21,
      29,
      35,
      12,
      23,
      34,
      37,
      12,
      25,
      34,
      40,
      13,
      26,
      35,
      42,
      14,
      28,
      38,
      45,
      15,
      29,
      40,
      48,
      16,
      31,
      43,
      51,
      17,
      33,
      45,
      54,
      18,
      35,
      48,
      57,
      19,
      37,
      51,
      60,
      19,
      38,
      53,
      63,
      20,
      40,
      56,
      66,
      21,
      43,
      59,
      70,
      22,
      45,
      62,
      74,
      24,
      47,
      65,
      77,
      25,
      49,
      68,
      81
    ];
    var EC_CODEWORDS_TABLE = [
      // L  M  Q  H
      7,
      10,
      13,
      17,
      10,
      16,
      22,
      28,
      15,
      26,
      36,
      44,
      20,
      36,
      52,
      64,
      26,
      48,
      72,
      88,
      36,
      64,
      96,
      112,
      40,
      72,
      108,
      130,
      48,
      88,
      132,
      156,
      60,
      110,
      160,
      192,
      72,
      130,
      192,
      224,
      80,
      150,
      224,
      264,
      96,
      176,
      260,
      308,
      104,
      198,
      288,
      352,
      120,
      216,
      320,
      384,
      132,
      240,
      360,
      432,
      144,
      280,
      408,
      480,
      168,
      308,
      448,
      532,
      180,
      338,
      504,
      588,
      196,
      364,
      546,
      650,
      224,
      416,
      600,
      700,
      224,
      442,
      644,
      750,
      252,
      476,
      690,
      816,
      270,
      504,
      750,
      900,
      300,
      560,
      810,
      960,
      312,
      588,
      870,
      1050,
      336,
      644,
      952,
      1110,
      360,
      700,
      1020,
      1200,
      390,
      728,
      1050,
      1260,
      420,
      784,
      1140,
      1350,
      450,
      812,
      1200,
      1440,
      480,
      868,
      1290,
      1530,
      510,
      924,
      1350,
      1620,
      540,
      980,
      1440,
      1710,
      570,
      1036,
      1530,
      1800,
      570,
      1064,
      1590,
      1890,
      600,
      1120,
      1680,
      1980,
      630,
      1204,
      1770,
      2100,
      660,
      1260,
      1860,
      2220,
      720,
      1316,
      1950,
      2310,
      750,
      1372,
      2040,
      2430
    ];
    exports2.getBlocksCount = function getBlocksCount(version2, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 0];
        case ECLevel.M:
          return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 2];
        case ECLevel.H:
          return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
    exports2.getTotalCodewordsCount = function getTotalCodewordsCount(version2, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 0];
        case ECLevel.M:
          return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 2];
        case ECLevel.H:
          return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
  }
});

// node_modules/qrcode/lib/core/galois-field.js
var require_galois_field = __commonJS({
  "node_modules/qrcode/lib/core/galois-field.js"(exports2) {
    init_shim();
    var EXP_TABLE = new Uint8Array(512);
    var LOG_TABLE = new Uint8Array(256);
    (function initTables() {
      let x3 = 1;
      for (let i2 = 0; i2 < 255; i2++) {
        EXP_TABLE[i2] = x3;
        LOG_TABLE[x3] = i2;
        x3 <<= 1;
        if (x3 & 256) {
          x3 ^= 285;
        }
      }
      for (let i2 = 255; i2 < 512; i2++) {
        EXP_TABLE[i2] = EXP_TABLE[i2 - 255];
      }
    })();
    exports2.log = function log(n3) {
      if (n3 < 1)
        throw new Error("log(" + n3 + ")");
      return LOG_TABLE[n3];
    };
    exports2.exp = function exp(n3) {
      return EXP_TABLE[n3];
    };
    exports2.mul = function mul(x3, y4) {
      if (x3 === 0 || y4 === 0)
        return 0;
      return EXP_TABLE[LOG_TABLE[x3] + LOG_TABLE[y4]];
    };
  }
});

// node_modules/qrcode/lib/core/polynomial.js
var require_polynomial = __commonJS({
  "node_modules/qrcode/lib/core/polynomial.js"(exports2) {
    init_shim();
    var GF = require_galois_field();
    exports2.mul = function mul(p1, p22) {
      const coeff = new Uint8Array(p1.length + p22.length - 1);
      for (let i2 = 0; i2 < p1.length; i2++) {
        for (let j2 = 0; j2 < p22.length; j2++) {
          coeff[i2 + j2] ^= GF.mul(p1[i2], p22[j2]);
        }
      }
      return coeff;
    };
    exports2.mod = function mod2(divident, divisor) {
      let result = new Uint8Array(divident);
      while (result.length - divisor.length >= 0) {
        const coeff = result[0];
        for (let i2 = 0; i2 < divisor.length; i2++) {
          result[i2] ^= GF.mul(divisor[i2], coeff);
        }
        let offset = 0;
        while (offset < result.length && result[offset] === 0)
          offset++;
        result = result.slice(offset);
      }
      return result;
    };
    exports2.generateECPolynomial = function generateECPolynomial(degree) {
      let poly = new Uint8Array([1]);
      for (let i2 = 0; i2 < degree; i2++) {
        poly = exports2.mul(poly, new Uint8Array([1, GF.exp(i2)]));
      }
      return poly;
    };
  }
});

// node_modules/qrcode/lib/core/reed-solomon-encoder.js
var require_reed_solomon_encoder = __commonJS({
  "node_modules/qrcode/lib/core/reed-solomon-encoder.js"(exports2, module2) {
    init_shim();
    var Polynomial = require_polynomial();
    function ReedSolomonEncoder(degree) {
      this.genPoly = void 0;
      this.degree = degree;
      if (this.degree)
        this.initialize(this.degree);
    }
    ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
      this.degree = degree;
      this.genPoly = Polynomial.generateECPolynomial(this.degree);
    };
    ReedSolomonEncoder.prototype.encode = function encode5(data) {
      if (!this.genPoly) {
        throw new Error("Encoder not initialized");
      }
      const paddedData = new Uint8Array(data.length + this.degree);
      paddedData.set(data);
      const remainder = Polynomial.mod(paddedData, this.genPoly);
      const start = this.degree - remainder.length;
      if (start > 0) {
        const buff = new Uint8Array(this.degree);
        buff.set(remainder, start);
        return buff;
      }
      return remainder;
    };
    module2.exports = ReedSolomonEncoder;
  }
});

// node_modules/qrcode/lib/core/version-check.js
var require_version_check = __commonJS({
  "node_modules/qrcode/lib/core/version-check.js"(exports2) {
    init_shim();
    exports2.isValid = function isValid(version2) {
      return !isNaN(version2) && version2 >= 1 && version2 <= 40;
    };
  }
});

// node_modules/qrcode/lib/core/regex.js
var require_regex = __commonJS({
  "node_modules/qrcode/lib/core/regex.js"(exports2) {
    init_shim();
    var numeric = "[0-9]+";
    var alphanumeric = "[A-Z $%*+\\-./:]+";
    var kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
    kanji = kanji.replace(/u/g, "\\u");
    var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
    exports2.KANJI = new RegExp(kanji, "g");
    exports2.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
    exports2.BYTE = new RegExp(byte, "g");
    exports2.NUMERIC = new RegExp(numeric, "g");
    exports2.ALPHANUMERIC = new RegExp(alphanumeric, "g");
    var TEST_KANJI = new RegExp("^" + kanji + "$");
    var TEST_NUMERIC = new RegExp("^" + numeric + "$");
    var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
    exports2.testKanji = function testKanji(str) {
      return TEST_KANJI.test(str);
    };
    exports2.testNumeric = function testNumeric(str) {
      return TEST_NUMERIC.test(str);
    };
    exports2.testAlphanumeric = function testAlphanumeric(str) {
      return TEST_ALPHANUMERIC.test(str);
    };
  }
});

// node_modules/qrcode/lib/core/mode.js
var require_mode = __commonJS({
  "node_modules/qrcode/lib/core/mode.js"(exports2) {
    init_shim();
    var VersionCheck = require_version_check();
    var Regex = require_regex();
    exports2.NUMERIC = {
      id: "Numeric",
      bit: 1 << 0,
      ccBits: [10, 12, 14]
    };
    exports2.ALPHANUMERIC = {
      id: "Alphanumeric",
      bit: 1 << 1,
      ccBits: [9, 11, 13]
    };
    exports2.BYTE = {
      id: "Byte",
      bit: 1 << 2,
      ccBits: [8, 16, 16]
    };
    exports2.KANJI = {
      id: "Kanji",
      bit: 1 << 3,
      ccBits: [8, 10, 12]
    };
    exports2.MIXED = {
      bit: -1
    };
    exports2.getCharCountIndicator = function getCharCountIndicator(mode, version2) {
      if (!mode.ccBits)
        throw new Error("Invalid mode: " + mode);
      if (!VersionCheck.isValid(version2)) {
        throw new Error("Invalid version: " + version2);
      }
      if (version2 >= 1 && version2 < 10)
        return mode.ccBits[0];
      else if (version2 < 27)
        return mode.ccBits[1];
      return mode.ccBits[2];
    };
    exports2.getBestModeForData = function getBestModeForData(dataStr) {
      if (Regex.testNumeric(dataStr))
        return exports2.NUMERIC;
      else if (Regex.testAlphanumeric(dataStr))
        return exports2.ALPHANUMERIC;
      else if (Regex.testKanji(dataStr))
        return exports2.KANJI;
      else
        return exports2.BYTE;
    };
    exports2.toString = function toString3(mode) {
      if (mode && mode.id)
        return mode.id;
      throw new Error("Invalid mode");
    };
    exports2.isValid = function isValid(mode) {
      return mode && mode.bit && mode.ccBits;
    };
    function fromString3(string2) {
      if (typeof string2 !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string2.toLowerCase();
      switch (lcStr) {
        case "numeric":
          return exports2.NUMERIC;
        case "alphanumeric":
          return exports2.ALPHANUMERIC;
        case "kanji":
          return exports2.KANJI;
        case "byte":
          return exports2.BYTE;
        default:
          throw new Error("Unknown mode: " + string2);
      }
    }
    exports2.from = function from3(value, defaultValue) {
      if (exports2.isValid(value)) {
        return value;
      }
      try {
        return fromString3(value);
      } catch (e2) {
        return defaultValue;
      }
    };
  }
});

// node_modules/qrcode/lib/core/version.js
var require_version = __commonJS({
  "node_modules/qrcode/lib/core/version.js"(exports2) {
    init_shim();
    var Utils = require_utils6();
    var ECCode = require_error_correction_code();
    var ECLevel = require_error_correction_level();
    var Mode = require_mode();
    var VersionCheck = require_version_check();
    var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
    var G18_BCH = Utils.getBCHDigit(G18);
    function getBestVersionForDataLength(mode, length2, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        if (length2 <= exports2.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    function getReservedBitsCount(mode, version2) {
      return Mode.getCharCountIndicator(mode, version2) + 4;
    }
    function getTotalBitsFromDataArray(segments, version2) {
      let totalBits = 0;
      segments.forEach(function(data) {
        const reservedBits = getReservedBitsCount(data.mode, version2);
        totalBits += reservedBits + data.getBitsLength();
      });
      return totalBits;
    }
    function getBestVersionForMixedData(segments, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        const length2 = getTotalBitsFromDataArray(segments, currentVersion);
        if (length2 <= exports2.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    exports2.from = function from3(value, defaultValue) {
      if (VersionCheck.isValid(value)) {
        return parseInt(value, 10);
      }
      return defaultValue;
    };
    exports2.getCapacity = function getCapacity(version2, errorCorrectionLevel, mode) {
      if (!VersionCheck.isValid(version2)) {
        throw new Error("Invalid QR Code version");
      }
      if (typeof mode === "undefined")
        mode = Mode.BYTE;
      const totalCodewords = Utils.getSymbolTotalCodewords(version2);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (mode === Mode.MIXED)
        return dataTotalCodewordsBits;
      const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version2);
      switch (mode) {
        case Mode.NUMERIC:
          return Math.floor(usableBits / 10 * 3);
        case Mode.ALPHANUMERIC:
          return Math.floor(usableBits / 11 * 2);
        case Mode.KANJI:
          return Math.floor(usableBits / 13);
        case Mode.BYTE:
        default:
          return Math.floor(usableBits / 8);
      }
    };
    exports2.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel) {
      let seg;
      const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);
      if (Array.isArray(data)) {
        if (data.length > 1) {
          return getBestVersionForMixedData(data, ecl);
        }
        if (data.length === 0) {
          return 1;
        }
        seg = data[0];
      } else {
        seg = data;
      }
      return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
    };
    exports2.getEncodedBits = function getEncodedBits(version2) {
      if (!VersionCheck.isValid(version2) || version2 < 7) {
        throw new Error("Invalid QR Code version");
      }
      let d3 = version2 << 12;
      while (Utils.getBCHDigit(d3) - G18_BCH >= 0) {
        d3 ^= G18 << Utils.getBCHDigit(d3) - G18_BCH;
      }
      return version2 << 12 | d3;
    };
  }
});

// node_modules/qrcode/lib/core/format-info.js
var require_format_info = __commonJS({
  "node_modules/qrcode/lib/core/format-info.js"(exports2) {
    init_shim();
    var Utils = require_utils6();
    var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
    var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
    var G15_BCH = Utils.getBCHDigit(G15);
    exports2.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {
      const data = errorCorrectionLevel.bit << 3 | mask;
      let d3 = data << 10;
      while (Utils.getBCHDigit(d3) - G15_BCH >= 0) {
        d3 ^= G15 << Utils.getBCHDigit(d3) - G15_BCH;
      }
      return (data << 10 | d3) ^ G15_MASK;
    };
  }
});

// node_modules/qrcode/lib/core/numeric-data.js
var require_numeric_data = __commonJS({
  "node_modules/qrcode/lib/core/numeric-data.js"(exports2, module2) {
    init_shim();
    var Mode = require_mode();
    function NumericData(data) {
      this.mode = Mode.NUMERIC;
      this.data = data.toString();
    }
    NumericData.getBitsLength = function getBitsLength(length2) {
      return 10 * Math.floor(length2 / 3) + (length2 % 3 ? length2 % 3 * 3 + 1 : 0);
    };
    NumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    NumericData.prototype.getBitsLength = function getBitsLength() {
      return NumericData.getBitsLength(this.data.length);
    };
    NumericData.prototype.write = function write(bitBuffer) {
      let i2, group, value;
      for (i2 = 0; i2 + 3 <= this.data.length; i2 += 3) {
        group = this.data.substr(i2, 3);
        value = parseInt(group, 10);
        bitBuffer.put(value, 10);
      }
      const remainingNum = this.data.length - i2;
      if (remainingNum > 0) {
        group = this.data.substr(i2);
        value = parseInt(group, 10);
        bitBuffer.put(value, remainingNum * 3 + 1);
      }
    };
    module2.exports = NumericData;
  }
});

// node_modules/qrcode/lib/core/alphanumeric-data.js
var require_alphanumeric_data = __commonJS({
  "node_modules/qrcode/lib/core/alphanumeric-data.js"(exports2, module2) {
    init_shim();
    var Mode = require_mode();
    var ALPHA_NUM_CHARS = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      " ",
      "$",
      "%",
      "*",
      "+",
      "-",
      ".",
      "/",
      ":"
    ];
    function AlphanumericData(data) {
      this.mode = Mode.ALPHANUMERIC;
      this.data = data;
    }
    AlphanumericData.getBitsLength = function getBitsLength(length2) {
      return 11 * Math.floor(length2 / 2) + 6 * (length2 % 2);
    };
    AlphanumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    AlphanumericData.prototype.getBitsLength = function getBitsLength() {
      return AlphanumericData.getBitsLength(this.data.length);
    };
    AlphanumericData.prototype.write = function write(bitBuffer) {
      let i2;
      for (i2 = 0; i2 + 2 <= this.data.length; i2 += 2) {
        let value = ALPHA_NUM_CHARS.indexOf(this.data[i2]) * 45;
        value += ALPHA_NUM_CHARS.indexOf(this.data[i2 + 1]);
        bitBuffer.put(value, 11);
      }
      if (this.data.length % 2) {
        bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i2]), 6);
      }
    };
    module2.exports = AlphanumericData;
  }
});

// node_modules/encode-utf8/index.js
var require_encode_utf8 = __commonJS({
  "node_modules/encode-utf8/index.js"(exports2, module2) {
    "use strict";
    init_shim();
    module2.exports = function encodeUtf8(input) {
      var result = [];
      var size = input.length;
      for (var index = 0; index < size; index++) {
        var point = input.charCodeAt(index);
        if (point >= 55296 && point <= 56319 && size > index + 1) {
          var second = input.charCodeAt(index + 1);
          if (second >= 56320 && second <= 57343) {
            point = (point - 55296) * 1024 + second - 56320 + 65536;
            index += 1;
          }
        }
        if (point < 128) {
          result.push(point);
          continue;
        }
        if (point < 2048) {
          result.push(point >> 6 | 192);
          result.push(point & 63 | 128);
          continue;
        }
        if (point < 55296 || point >= 57344 && point < 65536) {
          result.push(point >> 12 | 224);
          result.push(point >> 6 & 63 | 128);
          result.push(point & 63 | 128);
          continue;
        }
        if (point >= 65536 && point <= 1114111) {
          result.push(point >> 18 | 240);
          result.push(point >> 12 & 63 | 128);
          result.push(point >> 6 & 63 | 128);
          result.push(point & 63 | 128);
          continue;
        }
        result.push(239, 191, 189);
      }
      return new Uint8Array(result).buffer;
    };
  }
});

// node_modules/qrcode/lib/core/byte-data.js
var require_byte_data = __commonJS({
  "node_modules/qrcode/lib/core/byte-data.js"(exports2, module2) {
    init_shim();
    var encodeUtf8 = require_encode_utf8();
    var Mode = require_mode();
    function ByteData(data) {
      this.mode = Mode.BYTE;
      if (typeof data === "string") {
        data = encodeUtf8(data);
      }
      this.data = new Uint8Array(data);
    }
    ByteData.getBitsLength = function getBitsLength(length2) {
      return length2 * 8;
    };
    ByteData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    ByteData.prototype.getBitsLength = function getBitsLength() {
      return ByteData.getBitsLength(this.data.length);
    };
    ByteData.prototype.write = function(bitBuffer) {
      for (let i2 = 0, l4 = this.data.length; i2 < l4; i2++) {
        bitBuffer.put(this.data[i2], 8);
      }
    };
    module2.exports = ByteData;
  }
});

// node_modules/qrcode/lib/core/kanji-data.js
var require_kanji_data = __commonJS({
  "node_modules/qrcode/lib/core/kanji-data.js"(exports2, module2) {
    init_shim();
    var Mode = require_mode();
    var Utils = require_utils6();
    function KanjiData(data) {
      this.mode = Mode.KANJI;
      this.data = data;
    }
    KanjiData.getBitsLength = function getBitsLength(length2) {
      return length2 * 13;
    };
    KanjiData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    KanjiData.prototype.getBitsLength = function getBitsLength() {
      return KanjiData.getBitsLength(this.data.length);
    };
    KanjiData.prototype.write = function(bitBuffer) {
      let i2;
      for (i2 = 0; i2 < this.data.length; i2++) {
        let value = Utils.toSJIS(this.data[i2]);
        if (value >= 33088 && value <= 40956) {
          value -= 33088;
        } else if (value >= 57408 && value <= 60351) {
          value -= 49472;
        } else {
          throw new Error(
            "Invalid SJIS character: " + this.data[i2] + "\nMake sure your charset is UTF-8"
          );
        }
        value = (value >>> 8 & 255) * 192 + (value & 255);
        bitBuffer.put(value, 13);
      }
    };
    module2.exports = KanjiData;
  }
});

// node_modules/dijkstrajs/dijkstra.js
var require_dijkstra = __commonJS({
  "node_modules/dijkstrajs/dijkstra.js"(exports2, module2) {
    "use strict";
    init_shim();
    var dijkstra = {
      single_source_shortest_paths: function(graph, s2, d3) {
        var predecessors = {};
        var costs = {};
        costs[s2] = 0;
        var open = dijkstra.PriorityQueue.make();
        open.push(s2, 0);
        var closest, u3, v2, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
        while (!open.empty()) {
          closest = open.pop();
          u3 = closest.value;
          cost_of_s_to_u = closest.cost;
          adjacent_nodes = graph[u3] || {};
          for (v2 in adjacent_nodes) {
            if (adjacent_nodes.hasOwnProperty(v2)) {
              cost_of_e = adjacent_nodes[v2];
              cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
              cost_of_s_to_v = costs[v2];
              first_visit = typeof costs[v2] === "undefined";
              if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                costs[v2] = cost_of_s_to_u_plus_cost_of_e;
                open.push(v2, cost_of_s_to_u_plus_cost_of_e);
                predecessors[v2] = u3;
              }
            }
          }
        }
        if (typeof d3 !== "undefined" && typeof costs[d3] === "undefined") {
          var msg = ["Could not find a path from ", s2, " to ", d3, "."].join("");
          throw new Error(msg);
        }
        return predecessors;
      },
      extract_shortest_path_from_predecessor_list: function(predecessors, d3) {
        var nodes = [];
        var u3 = d3;
        var predecessor;
        while (u3) {
          nodes.push(u3);
          predecessor = predecessors[u3];
          u3 = predecessors[u3];
        }
        nodes.reverse();
        return nodes;
      },
      find_path: function(graph, s2, d3) {
        var predecessors = dijkstra.single_source_shortest_paths(graph, s2, d3);
        return dijkstra.extract_shortest_path_from_predecessor_list(
          predecessors,
          d3
        );
      },
      /**
       * A very naive priority queue implementation.
       */
      PriorityQueue: {
        make: function(opts) {
          var T2 = dijkstra.PriorityQueue, t = {}, key;
          opts = opts || {};
          for (key in T2) {
            if (T2.hasOwnProperty(key)) {
              t[key] = T2[key];
            }
          }
          t.queue = [];
          t.sorter = opts.sorter || T2.default_sorter;
          return t;
        },
        default_sorter: function(a3, b4) {
          return a3.cost - b4.cost;
        },
        /**
         * Add a new item to the queue and ensure the highest priority element
         * is at the front of the queue.
         */
        push: function(value, cost) {
          var item = { value, cost };
          this.queue.push(item);
          this.queue.sort(this.sorter);
        },
        /**
         * Return the highest priority element in the queue.
         */
        pop: function() {
          return this.queue.shift();
        },
        empty: function() {
          return this.queue.length === 0;
        }
      }
    };
    if (typeof module2 !== "undefined") {
      module2.exports = dijkstra;
    }
  }
});

// node_modules/qrcode/lib/core/segments.js
var require_segments = __commonJS({
  "node_modules/qrcode/lib/core/segments.js"(exports2) {
    init_shim();
    var Mode = require_mode();
    var NumericData = require_numeric_data();
    var AlphanumericData = require_alphanumeric_data();
    var ByteData = require_byte_data();
    var KanjiData = require_kanji_data();
    var Regex = require_regex();
    var Utils = require_utils6();
    var dijkstra = require_dijkstra();
    function getStringByteLength(str) {
      return unescape(encodeURIComponent(str)).length;
    }
    function getSegments(regex, mode, str) {
      const segments = [];
      let result;
      while ((result = regex.exec(str)) !== null) {
        segments.push({
          data: result[0],
          index: result.index,
          mode,
          length: result[0].length
        });
      }
      return segments;
    }
    function getSegmentsFromString(dataStr) {
      const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
      const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
      let byteSegs;
      let kanjiSegs;
      if (Utils.isKanjiModeEnabled()) {
        byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
        kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
      } else {
        byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
        kanjiSegs = [];
      }
      const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
      return segs.sort(function(s1, s2) {
        return s1.index - s2.index;
      }).map(function(obj) {
        return {
          data: obj.data,
          mode: obj.mode,
          length: obj.length
        };
      });
    }
    function getSegmentBitsLength(length2, mode) {
      switch (mode) {
        case Mode.NUMERIC:
          return NumericData.getBitsLength(length2);
        case Mode.ALPHANUMERIC:
          return AlphanumericData.getBitsLength(length2);
        case Mode.KANJI:
          return KanjiData.getBitsLength(length2);
        case Mode.BYTE:
          return ByteData.getBitsLength(length2);
      }
    }
    function mergeSegments(segs) {
      return segs.reduce(function(acc, curr) {
        const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
        if (prevSeg && prevSeg.mode === curr.mode) {
          acc[acc.length - 1].data += curr.data;
          return acc;
        }
        acc.push(curr);
        return acc;
      }, []);
    }
    function buildNodes(segs) {
      const nodes = [];
      for (let i2 = 0; i2 < segs.length; i2++) {
        const seg = segs[i2];
        switch (seg.mode) {
          case Mode.NUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.ALPHANUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.KANJI:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
            break;
          case Mode.BYTE:
            nodes.push([
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
        }
      }
      return nodes;
    }
    function buildGraph(nodes, version2) {
      const table = {};
      const graph = { start: {} };
      let prevNodeIds = ["start"];
      for (let i2 = 0; i2 < nodes.length; i2++) {
        const nodeGroup = nodes[i2];
        const currentNodeIds = [];
        for (let j2 = 0; j2 < nodeGroup.length; j2++) {
          const node = nodeGroup[j2];
          const key = "" + i2 + j2;
          currentNodeIds.push(key);
          table[key] = { node, lastCount: 0 };
          graph[key] = {};
          for (let n3 = 0; n3 < prevNodeIds.length; n3++) {
            const prevNodeId = prevNodeIds[n3];
            if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
              graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
              table[prevNodeId].lastCount += node.length;
            } else {
              if (table[prevNodeId])
                table[prevNodeId].lastCount = node.length;
              graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version2);
            }
          }
        }
        prevNodeIds = currentNodeIds;
      }
      for (let n3 = 0; n3 < prevNodeIds.length; n3++) {
        graph[prevNodeIds[n3]].end = 0;
      }
      return { map: graph, table };
    }
    function buildSingleSegment(data, modesHint) {
      let mode;
      const bestMode = Mode.getBestModeForData(data);
      mode = Mode.from(modesHint, bestMode);
      if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
        throw new Error('"' + data + '" cannot be encoded with mode ' + Mode.toString(mode) + ".\n Suggested mode is: " + Mode.toString(bestMode));
      }
      if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
        mode = Mode.BYTE;
      }
      switch (mode) {
        case Mode.NUMERIC:
          return new NumericData(data);
        case Mode.ALPHANUMERIC:
          return new AlphanumericData(data);
        case Mode.KANJI:
          return new KanjiData(data);
        case Mode.BYTE:
          return new ByteData(data);
      }
    }
    exports2.fromArray = function fromArray(array) {
      return array.reduce(function(acc, seg) {
        if (typeof seg === "string") {
          acc.push(buildSingleSegment(seg, null));
        } else if (seg.data) {
          acc.push(buildSingleSegment(seg.data, seg.mode));
        }
        return acc;
      }, []);
    };
    exports2.fromString = function fromString3(data, version2) {
      const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());
      const nodes = buildNodes(segs);
      const graph = buildGraph(nodes, version2);
      const path = dijkstra.find_path(graph.map, "start", "end");
      const optimizedSegs = [];
      for (let i2 = 1; i2 < path.length - 1; i2++) {
        optimizedSegs.push(graph.table[path[i2]].node);
      }
      return exports2.fromArray(mergeSegments(optimizedSegs));
    };
    exports2.rawSplit = function rawSplit(data) {
      return exports2.fromArray(
        getSegmentsFromString(data, Utils.isKanjiModeEnabled())
      );
    };
  }
});

// node_modules/qrcode/lib/core/qrcode.js
var require_qrcode = __commonJS({
  "node_modules/qrcode/lib/core/qrcode.js"(exports2) {
    init_shim();
    var Utils = require_utils6();
    var ECLevel = require_error_correction_level();
    var BitBuffer = require_bit_buffer();
    var BitMatrix = require_bit_matrix();
    var AlignmentPattern = require_alignment_pattern();
    var FinderPattern = require_finder_pattern();
    var MaskPattern = require_mask_pattern();
    var ECCode = require_error_correction_code();
    var ReedSolomonEncoder = require_reed_solomon_encoder();
    var Version = require_version();
    var FormatInfo = require_format_info();
    var Mode = require_mode();
    var Segments = require_segments();
    function setupFinderPattern(matrix, version2) {
      const size = matrix.size;
      const pos = FinderPattern.getPositions(version2);
      for (let i2 = 0; i2 < pos.length; i2++) {
        const row = pos[i2][0];
        const col = pos[i2][1];
        for (let r = -1; r <= 7; r++) {
          if (row + r <= -1 || size <= row + r)
            continue;
          for (let c4 = -1; c4 <= 7; c4++) {
            if (col + c4 <= -1 || size <= col + c4)
              continue;
            if (r >= 0 && r <= 6 && (c4 === 0 || c4 === 6) || c4 >= 0 && c4 <= 6 && (r === 0 || r === 6) || r >= 2 && r <= 4 && c4 >= 2 && c4 <= 4) {
              matrix.set(row + r, col + c4, true, true);
            } else {
              matrix.set(row + r, col + c4, false, true);
            }
          }
        }
      }
    }
    function setupTimingPattern(matrix) {
      const size = matrix.size;
      for (let r = 8; r < size - 8; r++) {
        const value = r % 2 === 0;
        matrix.set(r, 6, value, true);
        matrix.set(6, r, value, true);
      }
    }
    function setupAlignmentPattern(matrix, version2) {
      const pos = AlignmentPattern.getPositions(version2);
      for (let i2 = 0; i2 < pos.length; i2++) {
        const row = pos[i2][0];
        const col = pos[i2][1];
        for (let r = -2; r <= 2; r++) {
          for (let c4 = -2; c4 <= 2; c4++) {
            if (r === -2 || r === 2 || c4 === -2 || c4 === 2 || r === 0 && c4 === 0) {
              matrix.set(row + r, col + c4, true, true);
            } else {
              matrix.set(row + r, col + c4, false, true);
            }
          }
        }
      }
    }
    function setupVersionInfo(matrix, version2) {
      const size = matrix.size;
      const bits = Version.getEncodedBits(version2);
      let row, col, mod2;
      for (let i2 = 0; i2 < 18; i2++) {
        row = Math.floor(i2 / 3);
        col = i2 % 3 + size - 8 - 3;
        mod2 = (bits >> i2 & 1) === 1;
        matrix.set(row, col, mod2, true);
        matrix.set(col, row, mod2, true);
      }
    }
    function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
      const size = matrix.size;
      const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
      let i2, mod2;
      for (i2 = 0; i2 < 15; i2++) {
        mod2 = (bits >> i2 & 1) === 1;
        if (i2 < 6) {
          matrix.set(i2, 8, mod2, true);
        } else if (i2 < 8) {
          matrix.set(i2 + 1, 8, mod2, true);
        } else {
          matrix.set(size - 15 + i2, 8, mod2, true);
        }
        if (i2 < 8) {
          matrix.set(8, size - i2 - 1, mod2, true);
        } else if (i2 < 9) {
          matrix.set(8, 15 - i2 - 1 + 1, mod2, true);
        } else {
          matrix.set(8, 15 - i2 - 1, mod2, true);
        }
      }
      matrix.set(size - 8, 8, 1, true);
    }
    function setupData(matrix, data) {
      const size = matrix.size;
      let inc = -1;
      let row = size - 1;
      let bitIndex = 7;
      let byteIndex = 0;
      for (let col = size - 1; col > 0; col -= 2) {
        if (col === 6)
          col--;
        while (true) {
          for (let c4 = 0; c4 < 2; c4++) {
            if (!matrix.isReserved(row, col - c4)) {
              let dark = false;
              if (byteIndex < data.length) {
                dark = (data[byteIndex] >>> bitIndex & 1) === 1;
              }
              matrix.set(row, col - c4, dark);
              bitIndex--;
              if (bitIndex === -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || size <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    }
    function createData(version2, errorCorrectionLevel, segments) {
      const buffer = new BitBuffer();
      segments.forEach(function(data) {
        buffer.put(data.mode.bit, 4);
        buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version2));
        data.write(buffer);
      });
      const totalCodewords = Utils.getSymbolTotalCodewords(version2);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
        buffer.put(0, 4);
      }
      while (buffer.getLengthInBits() % 8 !== 0) {
        buffer.putBit(0);
      }
      const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
      for (let i2 = 0; i2 < remainingByte; i2++) {
        buffer.put(i2 % 2 ? 17 : 236, 8);
      }
      return createCodewords(buffer, version2, errorCorrectionLevel);
    }
    function createCodewords(bitBuffer, version2, errorCorrectionLevel) {
      const totalCodewords = Utils.getSymbolTotalCodewords(version2);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel);
      const dataTotalCodewords = totalCodewords - ecTotalCodewords;
      const ecTotalBlocks = ECCode.getBlocksCount(version2, errorCorrectionLevel);
      const blocksInGroup2 = totalCodewords % ecTotalBlocks;
      const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
      const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
      const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
      const rs = new ReedSolomonEncoder(ecCount);
      let offset = 0;
      const dcData = new Array(ecTotalBlocks);
      const ecData = new Array(ecTotalBlocks);
      let maxDataSize = 0;
      const buffer = new Uint8Array(bitBuffer.buffer);
      for (let b4 = 0; b4 < ecTotalBlocks; b4++) {
        const dataSize = b4 < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
        dcData[b4] = buffer.slice(offset, offset + dataSize);
        ecData[b4] = rs.encode(dcData[b4]);
        offset += dataSize;
        maxDataSize = Math.max(maxDataSize, dataSize);
      }
      const data = new Uint8Array(totalCodewords);
      let index = 0;
      let i2, r;
      for (i2 = 0; i2 < maxDataSize; i2++) {
        for (r = 0; r < ecTotalBlocks; r++) {
          if (i2 < dcData[r].length) {
            data[index++] = dcData[r][i2];
          }
        }
      }
      for (i2 = 0; i2 < ecCount; i2++) {
        for (r = 0; r < ecTotalBlocks; r++) {
          data[index++] = ecData[r][i2];
        }
      }
      return data;
    }
    function createSymbol(data, version2, errorCorrectionLevel, maskPattern) {
      let segments;
      if (Array.isArray(data)) {
        segments = Segments.fromArray(data);
      } else if (typeof data === "string") {
        let estimatedVersion = version2;
        if (!estimatedVersion) {
          const rawSegments = Segments.rawSplit(data);
          estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);
        }
        segments = Segments.fromString(data, estimatedVersion || 40);
      } else {
        throw new Error("Invalid data");
      }
      const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);
      if (!bestVersion) {
        throw new Error("The amount of data is too big to be stored in a QR Code");
      }
      if (!version2) {
        version2 = bestVersion;
      } else if (version2 < bestVersion) {
        throw new Error(
          "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
        );
      }
      const dataBits = createData(version2, errorCorrectionLevel, segments);
      const moduleCount = Utils.getSymbolSize(version2);
      const modules = new BitMatrix(moduleCount);
      setupFinderPattern(modules, version2);
      setupTimingPattern(modules);
      setupAlignmentPattern(modules, version2);
      setupFormatInfo(modules, errorCorrectionLevel, 0);
      if (version2 >= 7) {
        setupVersionInfo(modules, version2);
      }
      setupData(modules, dataBits);
      if (isNaN(maskPattern)) {
        maskPattern = MaskPattern.getBestMask(
          modules,
          setupFormatInfo.bind(null, modules, errorCorrectionLevel)
        );
      }
      MaskPattern.applyMask(maskPattern, modules);
      setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
      return {
        modules,
        version: version2,
        errorCorrectionLevel,
        maskPattern,
        segments
      };
    }
    exports2.create = function create2(data, options) {
      if (typeof data === "undefined" || data === "") {
        throw new Error("No input text");
      }
      let errorCorrectionLevel = ECLevel.M;
      let version2;
      let mask;
      if (typeof options !== "undefined") {
        errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
        version2 = Version.from(options.version);
        mask = MaskPattern.from(options.maskPattern);
        if (options.toSJISFunc) {
          Utils.setToSJISFunction(options.toSJISFunc);
        }
      }
      return createSymbol(data, version2, errorCorrectionLevel, mask);
    };
  }
});

// node_modules/qrcode/lib/renderer/utils.js
var require_utils7 = __commonJS({
  "node_modules/qrcode/lib/renderer/utils.js"(exports2) {
    init_shim();
    function hex2rgba(hex) {
      if (typeof hex === "number") {
        hex = hex.toString();
      }
      if (typeof hex !== "string") {
        throw new Error("Color should be defined as hex string");
      }
      let hexCode = hex.slice().replace("#", "").split("");
      if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
        throw new Error("Invalid hex color: " + hex);
      }
      if (hexCode.length === 3 || hexCode.length === 4) {
        hexCode = Array.prototype.concat.apply([], hexCode.map(function(c4) {
          return [c4, c4];
        }));
      }
      if (hexCode.length === 6)
        hexCode.push("F", "F");
      const hexValue = parseInt(hexCode.join(""), 16);
      return {
        r: hexValue >> 24 & 255,
        g: hexValue >> 16 & 255,
        b: hexValue >> 8 & 255,
        a: hexValue & 255,
        hex: "#" + hexCode.slice(0, 6).join("")
      };
    }
    exports2.getOptions = function getOptions(options) {
      if (!options)
        options = {};
      if (!options.color)
        options.color = {};
      const margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
      const width = options.width && options.width >= 21 ? options.width : void 0;
      const scale = options.scale || 4;
      return {
        width,
        scale: width ? 4 : scale,
        margin,
        color: {
          dark: hex2rgba(options.color.dark || "#000000ff"),
          light: hex2rgba(options.color.light || "#ffffffff")
        },
        type: options.type,
        rendererOpts: options.rendererOpts || {}
      };
    };
    exports2.getScale = function getScale(qrSize, opts) {
      return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
    };
    exports2.getImageWidth = function getImageWidth(qrSize, opts) {
      const scale = exports2.getScale(qrSize, opts);
      return Math.floor((qrSize + opts.margin * 2) * scale);
    };
    exports2.qrToImageData = function qrToImageData(imgData, qr, opts) {
      const size = qr.modules.size;
      const data = qr.modules.data;
      const scale = exports2.getScale(size, opts);
      const symbolSize = Math.floor((size + opts.margin * 2) * scale);
      const scaledMargin = opts.margin * scale;
      const palette = [opts.color.light, opts.color.dark];
      for (let i2 = 0; i2 < symbolSize; i2++) {
        for (let j2 = 0; j2 < symbolSize; j2++) {
          let posDst = (i2 * symbolSize + j2) * 4;
          let pxColor = opts.color.light;
          if (i2 >= scaledMargin && j2 >= scaledMargin && i2 < symbolSize - scaledMargin && j2 < symbolSize - scaledMargin) {
            const iSrc = Math.floor((i2 - scaledMargin) / scale);
            const jSrc = Math.floor((j2 - scaledMargin) / scale);
            pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
          }
          imgData[posDst++] = pxColor.r;
          imgData[posDst++] = pxColor.g;
          imgData[posDst++] = pxColor.b;
          imgData[posDst] = pxColor.a;
        }
      }
    };
  }
});

// node_modules/qrcode/lib/renderer/canvas.js
var require_canvas = __commonJS({
  "node_modules/qrcode/lib/renderer/canvas.js"(exports2) {
    init_shim();
    var Utils = require_utils7();
    function clearCanvas(ctx, canvas, size) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!canvas.style)
        canvas.style = {};
      canvas.height = size;
      canvas.width = size;
      canvas.style.height = size + "px";
      canvas.style.width = size + "px";
    }
    function getCanvasElement() {
      try {
        return document.createElement("canvas");
      } catch (e2) {
        throw new Error("You need to specify a canvas element");
      }
    }
    exports2.render = function render(qrData, canvas, options) {
      let opts = options;
      let canvasEl = canvas;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!canvas) {
        canvasEl = getCanvasElement();
      }
      opts = Utils.getOptions(opts);
      const size = Utils.getImageWidth(qrData.modules.size, opts);
      const ctx = canvasEl.getContext("2d");
      const image = ctx.createImageData(size, size);
      Utils.qrToImageData(image.data, qrData, opts);
      clearCanvas(ctx, canvasEl, size);
      ctx.putImageData(image, 0, 0);
      return canvasEl;
    };
    exports2.renderToDataURL = function renderToDataURL(qrData, canvas, options) {
      let opts = options;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!opts)
        opts = {};
      const canvasEl = exports2.render(qrData, canvas, opts);
      const type = opts.type || "image/png";
      const rendererOpts = opts.rendererOpts || {};
      return canvasEl.toDataURL(type, rendererOpts.quality);
    };
  }
});

// node_modules/qrcode/lib/renderer/svg-tag.js
var require_svg_tag = __commonJS({
  "node_modules/qrcode/lib/renderer/svg-tag.js"(exports2) {
    init_shim();
    var Utils = require_utils7();
    function getColorAttrib(color, attrib) {
      const alpha = color.a / 255;
      const str = attrib + '="' + color.hex + '"';
      return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
    }
    function svgCmd(cmd, x3, y4) {
      let str = cmd + x3;
      if (typeof y4 !== "undefined")
        str += " " + y4;
      return str;
    }
    function qrToPath(data, size, margin) {
      let path = "";
      let moveBy = 0;
      let newRow = false;
      let lineLength = 0;
      for (let i2 = 0; i2 < data.length; i2++) {
        const col = Math.floor(i2 % size);
        const row = Math.floor(i2 / size);
        if (!col && !newRow)
          newRow = true;
        if (data[i2]) {
          lineLength++;
          if (!(i2 > 0 && col > 0 && data[i2 - 1])) {
            path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
            moveBy = 0;
            newRow = false;
          }
          if (!(col + 1 < size && data[i2 + 1])) {
            path += svgCmd("h", lineLength);
            lineLength = 0;
          }
        } else {
          moveBy++;
        }
      }
      return path;
    }
    exports2.render = function render(qrData, options, cb) {
      const opts = Utils.getOptions(options);
      const size = qrData.modules.size;
      const data = qrData.modules.data;
      const qrcodesize = size + opts.margin * 2;
      const bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
      const path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data, size, opts.margin) + '"/>';
      const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
      const width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
      const svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
      if (typeof cb === "function") {
        cb(null, svgTag);
      }
      return svgTag;
    };
  }
});

// node_modules/qrcode/lib/browser.js
var require_browser7 = __commonJS({
  "node_modules/qrcode/lib/browser.js"(exports2) {
    init_shim();
    var canPromise = require_can_promise();
    var QRCode2 = require_qrcode();
    var CanvasRenderer = require_canvas();
    var SvgRenderer = require_svg_tag();
    function renderCanvas(renderFunc, canvas, text, opts, cb) {
      const args = [].slice.call(arguments, 1);
      const argsNum = args.length;
      const isLastArgCb = typeof args[argsNum - 1] === "function";
      if (!isLastArgCb && !canPromise()) {
        throw new Error("Callback required as last argument");
      }
      if (isLastArgCb) {
        if (argsNum < 2) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 2) {
          cb = text;
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 3) {
          if (canvas.getContext && typeof cb === "undefined") {
            cb = opts;
            opts = void 0;
          } else {
            cb = opts;
            opts = text;
            text = canvas;
            canvas = void 0;
          }
        }
      } else {
        if (argsNum < 1) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 1) {
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 2 && !canvas.getContext) {
          opts = text;
          text = canvas;
          canvas = void 0;
        }
        return new Promise(function(resolve, reject) {
          try {
            const data = QRCode2.create(text, opts);
            resolve(renderFunc(data, canvas, opts));
          } catch (e2) {
            reject(e2);
          }
        });
      }
      try {
        const data = QRCode2.create(text, opts);
        cb(null, renderFunc(data, canvas, opts));
      } catch (e2) {
        cb(e2);
      }
    }
    exports2.create = QRCode2.create;
    exports2.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
    exports2.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
    exports2.toString = renderCanvas.bind(null, function(data, _4, opts) {
      return SvgRenderer.render(data, opts);
    });
  }
});

// node_modules/@multiversx/sdk-web-wallet-provider/out/index.js
var require_out2 = __commonJS({
  "node_modules/@multiversx/sdk-web-wallet-provider/out/index.js"(exports2) {
    "use strict";
    init_shim();
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m3[k4];
      } });
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m3[k4];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m3, exports3) {
      for (var p3 in m3)
        if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p3))
          __createBinding2(exports3, m3, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_walletProvider(), exports2);
    __exportStar2(require_constants7(), exports2);
  }
});

// src/elven.ts
init_shim();
var import_tokens = __toESM(require_tokens(), 1);
var import_tokenOperations = __toESM(require_tokenOperations(), 1);
var import_transactionsFactories = __toESM(require_transactionsFactories(), 1);
var import_transactionsOutcomeParsers = __toESM(require_transactionsOutcomeParsers(), 1);
var import_address4 = __toESM(require_address(), 1);
var import_account4 = __toESM(require_account(), 1);
var import_transaction3 = __toESM(require_transaction(), 1);
var import_transactionComputer = __toESM(require_transactionComputer(), 1);
var import_message = __toESM(require_message(), 1);
var import_transactionWatcher2 = __toESM(require_transactionWatcher(), 1);
var import_signableMessage2 = __toESM(require_signableMessage(), 1);
var import_bytes7 = __toESM(require_bytes(), 1);
var import_numerical = __toESM(require_numerical(), 1);
var import_boolean = __toESM(require_boolean(), 1);
var import_address5 = __toESM(require_address2(), 1);
var import_interface = __toESM(require_interface(), 1);
var import_contractQueryResponse2 = __toESM(require_contractQueryResponse(), 1);

// src/main.ts
init_shim();

// src/auth/init-extension-provider.ts
init_shim();
var import_extensionProvider = __toESM(require_extensionProvider(), 1);

// src/utils/ls-helpers.ts
init_shim();

// src/utils/constants.ts
init_shim();
var LOCAL_STORAGE_KEY = "elvenjs_state";
var defaultApiEndpoint = "https://devnet-api.multiversx.com";
var DAPP_INIT_ROUTE = "/dapp/init";
var defaultChainTypeConfig = "devnet";
var walletConnectDeepLink = "https://maiar.page.link/?apn=com.elrond.maiar.wallet&isi=1519405832&ibi=com.elrond.maiar.wallet&link=https://xportal.com/";
var defaultWalletConnectV2RelayAddresses = [
  "wss://relay.walletconnect.com"
];
var networkConfig = {
  devnet: {
    id: "devnet",
    shortId: "D",
    name: "Devnet",
    egldLabel: "xEGLD",
    egldDenomination: "18",
    decimals: "4",
    gasPerDataByte: "1500",
    walletAddress: "https://devnet-wallet.multiversx.com",
    xAliasAddress: "https://devnet.xalias.com",
    apiAddress: "https://devnet-api.multiversx.com",
    explorerAddress: "https://devnet-explorer.multiversx.com",
    apiTimeout: 1e4
  },
  testnet: {
    id: "testnet",
    shortId: "T",
    name: "Testnet",
    egldLabel: "xEGLD",
    egldDenomination: "18",
    decimals: "4",
    gasPerDataByte: "1500",
    walletAddress: "https://testnet-wallet.multiversx.com",
    xAliasAddress: "https://testnet.xalias.com",
    apiAddress: "https://testnet-api.multiversx.com",
    explorerAddress: "https://testnet-explorer.multiversx.com",
    apiTimeout: 1e4
  },
  mainnet: {
    id: "mainnet",
    shortId: "1",
    name: "Mainnet",
    egldLabel: "EGLD",
    egldDenomination: "18",
    decimals: "4",
    gasPerDataByte: "1500",
    walletAddress: "https://wallet.multiversx.com",
    xAliasAddress: "https://xalias.com",
    apiAddress: "https://api.multiversx.com",
    explorerAddress: "https://explorer.multiversx.com",
    apiTimeout: 1e4
  }
};

// src/utils/ls-helpers.ts
var ls = {
  get(key) {
    const state = localStorage.getItem(LOCAL_STORAGE_KEY);
    if (!state)
      return {};
    const parsedState = JSON.parse(state);
    if (key) {
      return parsedState[key];
    }
    return parsedState;
  },
  set(key, value) {
    const currentState = this.get();
    currentState[key] = value;
    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(currentState));
  },
  clear() {
    localStorage.removeItem(LOCAL_STORAGE_KEY);
  }
};

// src/auth/init-extension-provider.ts
var initExtensionProvider = async () => {
  const dappProvider = import_extensionProvider.ExtensionProvider.getInstance();
  try {
    const isSuccessfullyInitialized = await dappProvider.init();
    const currentState = ls.get();
    if (currentState?.address) {
      dappProvider.setAddress(currentState.address);
    }
    if (!isSuccessfullyInitialized) {
      console.warn(
        "Something went wrong when trying to initialize the ExtensionProvider.."
      );
      return;
    }
    return dappProvider;
  } catch (e2) {
    console.warn("Can't initialize the Dapp Provider!");
  }
};

// src/main.ts
var import_extensionProvider2 = __toESM(require_extensionProvider(), 1);
var import_walletConnectV2Provider4 = __toESM(require_walletConnectV2Provider(), 1);
var import_walletProvider4 = __toESM(require_walletProvider(), 1);
var import_native_auth2 = __toESM(require_native_auth_client(), 1);
var import_signableMessage = __toESM(require_signableMessage(), 1);

// src/auth/init-mobile-provider.ts
init_shim();
var import_walletConnectV2Provider = __toESM(require_walletConnectV2Provider(), 1);

// src/auth/logout.ts
init_shim();

// src/events-store.ts
init_shim();
var EventsStore = class {
  static set(name2, fn) {
    if (!name2)
      return;
    const eventsObj = { ...this.events, [name2]: fn };
    this.events = eventsObj;
  }
  static get(name2) {
    if (!name2 || !this.events)
      return;
    return this.events[name2];
  }
  static run(name2, ...args) {
    if (!name2 || !this.events)
      return;
    this.events[name2]?.(...args);
  }
  static clear() {
    this.events = void 0;
  }
};

// src/types.ts
init_shim();
var EventStoreEvents = /* @__PURE__ */ ((EventStoreEvents2) => {
  EventStoreEvents2["onLoginStart"] = "onLoginStart";
  EventStoreEvents2["onLoginSuccess"] = "onLoginSuccess";
  EventStoreEvents2["onLoginFailure"] = "onLoginFailure";
  EventStoreEvents2["onLogoutStart"] = "onLogoutStart";
  EventStoreEvents2["onLogoutSuccess"] = "onLogoutSuccess";
  EventStoreEvents2["onLogoutFailure"] = "onLogoutFailure";
  EventStoreEvents2["onQrPending"] = "onQrPending";
  EventStoreEvents2["onQrLoaded"] = "onQrLoaded";
  EventStoreEvents2["onTxStart"] = "onTxStart";
  EventStoreEvents2["onTxSent"] = "onTxSent";
  EventStoreEvents2["onTxFinalized"] = "onTxFinalized";
  EventStoreEvents2["onTxFailure"] = "onTxFailure";
  EventStoreEvents2["onSignMsgStart"] = "onSignMsgStart";
  EventStoreEvents2["onSignMsgFinalized"] = "onSignMsgFinalized";
  EventStoreEvents2["onSignMsgFailure"] = "onSignMsgFailure";
  EventStoreEvents2["onQueryStart"] = "onQueryStart";
  EventStoreEvents2["onQueryFinalized"] = "onQueryFinalized";
  EventStoreEvents2["onQueryFailure"] = "onQueryFailure";
  return EventStoreEvents2;
})(EventStoreEvents || {});
var LoginMethodsEnum = /* @__PURE__ */ ((LoginMethodsEnum2) => {
  LoginMethodsEnum2["ledger"] = "ledger";
  LoginMethodsEnum2["mobile"] = "mobile";
  LoginMethodsEnum2["webWallet"] = "web-wallet";
  LoginMethodsEnum2["browserExtension"] = "browser-extension";
  LoginMethodsEnum2["xAlias"] = "x-alias";
  LoginMethodsEnum2["xPortalHub"] = "x-portal-hub";
  return LoginMethodsEnum2;
})(LoginMethodsEnum || {});
var DappCoreWCV2CustomMethodsEnum = /* @__PURE__ */ ((DappCoreWCV2CustomMethodsEnum2) => {
  DappCoreWCV2CustomMethodsEnum2["mvx_cancelAction"] = "mvx_cancelAction";
  DappCoreWCV2CustomMethodsEnum2["mvx_signNativeAuthToken"] = "mvx_signNativeAuthToken";
  return DappCoreWCV2CustomMethodsEnum2;
})(DappCoreWCV2CustomMethodsEnum || {});
var WebWalletUrlParamsEnum = /* @__PURE__ */ ((WebWalletUrlParamsEnum2) => {
  WebWalletUrlParamsEnum2["hasWebWalletGuardianSign"] = "hasWebWalletGuardianSign";
  return WebWalletUrlParamsEnum2;
})(WebWalletUrlParamsEnum || {});

// src/utils/error-parse.ts
init_shim();
var errorParse = (err) => {
  if (typeof err === "string") {
    return err.toUpperCase();
  } else if (err instanceof Error) {
    return err.message;
  }
  return JSON.stringify(err);
};

// src/auth/logout.ts
var logout = async (elven) => {
  if (!elven.dappProvider) {
    throw new Error("Logout failed: There is no active session!");
  }
  EventsStore.run("onLogoutStart" /* onLogoutStart */);
  try {
    const isLoggedOut = await elven.dappProvider.logout();
    if (isLoggedOut) {
      ls.clear();
      EventsStore.run("onLogoutSuccess" /* onLogoutSuccess */);
    }
    return isLoggedOut;
  } catch (e2) {
    const err = errorParse(e2);
    console.warn(`Something went wrong trying to logout the user: ${err}`);
    EventsStore.run("onLogoutFailure" /* onLogoutFailure */, err);
  }
};

// src/utils/get-random-address-from-network.ts
init_shim();
function getRandomAddressFromNetwork(addresses) {
  return addresses[Math.floor(Math.random() * addresses.length)];
}

// src/auth/init-mobile-provider.ts
var initMobileProvider = async (elven) => {
  if (!elven.initOptions.walletConnectV2ProjectId || !elven.initOptions.chainType) {
    return void 0;
  }
  const providerHandlers = {
    onClientLogin: () => {
    },
    onClientLogout: () => logout(elven),
    onClientEvent: (event) => {
      console.log("wc2 session event: ", event);
    }
  };
  const relayAddress = getRandomAddressFromNetwork(
    elven.initOptions.walletConnectV2RelayAddresses
  );
  const dappProviderInstance = new import_walletConnectV2Provider.WalletConnectV2Provider(
    providerHandlers,
    networkConfig[elven.initOptions.chainType].shortId,
    relayAddress,
    elven.initOptions.walletConnectV2ProjectId
  );
  try {
    await dappProviderInstance.init();
    return dappProviderInstance;
  } catch {
    console.warn("Can't initialize the Dapp Provider!");
  }
};

// src/network-provider.ts
init_shim();
var import_address = __toESM(require_address(), 1);
var import_transactionStatus = __toESM(require_transactionStatus(), 1);
var import_transactionReceipt = __toESM(require_transactionReceipt(), 1);
var import_transactionLogs = __toESM(require_transactionLogs(), 1);
var import_contractResults = __toESM(require_contractResults(), 1);
var import_contractQueryResponse = __toESM(require_contractQueryResponse(), 1);
var import_contractQueryRequest = __toESM(require_contractQueryRequest(), 1);
var import_query = __toESM(require_query(), 1);
var ApiNetworkProvider = class {
  constructor({ apiUrl, chainType, apiTimeout }) {
    this.chainType = chainType || defaultChainTypeConfig;
    this.apiUrl = apiUrl || networkConfig[this.chainType]?.apiAddress;
    this.apiTimeout = apiTimeout || networkConfig[this.chainType]?.apiTimeout;
  }
  async apiGet(endpoint, options) {
    if (typeof fetch !== "undefined") {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), this.apiTimeout);
      const defaultOptions = {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json"
        },
        signal: controller.signal
      };
      try {
        const response = await fetch(
          this.apiUrl + "/" + endpoint,
          Object.assign(defaultOptions, options || {})
        );
        const result = await response.json();
        if (!response.ok) {
          const error = result?.error || response.status;
          clearTimeout(timeoutId);
          return Promise.reject(error);
        }
        clearTimeout(timeoutId);
        return result;
      } catch (e2) {
        this.handleApiError(e2, endpoint);
      }
    }
  }
  async apiPost(endpoint, payload, options) {
    if (typeof fetch !== "undefined") {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), this.apiTimeout);
      const defaultOptions = {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json"
        },
        body: JSON.stringify(payload || {}),
        signal: controller.signal
      };
      try {
        const response = await fetch(
          this.apiUrl + "/" + endpoint,
          Object.assign(defaultOptions, options || {})
        );
        const result = await response.json();
        if (!response.ok) {
          const error = result?.error || response.status;
          clearTimeout(timeoutId);
          return Promise.reject(error);
        }
        clearTimeout(timeoutId);
        return result;
      } catch (e2) {
        this.handleApiError(e2, endpoint);
      }
    }
  }
  handleApiError(error, resourceUrl) {
    if (!error.response) {
      throw new Error(
        `Request error on url [${resourceUrl}]: [${error.toString()}]`
      );
    }
    const errorData = error.response.data;
    const originalErrorMessage = errorData.error || errorData.message || JSON.stringify(errorData);
    throw new Error(originalErrorMessage);
  }
  async sendTransaction(tx) {
    const response = await this.apiPost("transactions", tx.toSendable());
    return response.txHash;
  }
  async getAccount(address) {
    const responsePayload = await this.apiGet(`accounts/${address.bech32()}`);
    const account = {
      address: new import_address.Address(responsePayload?.address || ""),
      nonce: Number(responsePayload?.nonce || 0),
      balance: BigInt(responsePayload?.balance || 0),
      code: responsePayload?.code || "",
      userName: responsePayload?.username || ""
    };
    return account;
  }
  async getGuardianData(address) {
    const response = await this.apiGet(
      `address/${address.bech32()}/guardian-data`
    );
    const accountGuardian = {
      guarded: response?.data?.guardianData?.guarded || false,
      activeGuardian: response?.data?.guardianData?.activeGuardian,
      pendingGuardian: response?.data?.guardianData?.pendingGuardian
    };
    return accountGuardian;
  }
  async getTransaction(txHash) {
    const payload = await this.apiGet(`transactions/${txHash}`);
    const status = new import_transactionStatus.TransactionStatus(payload.status);
    const transaction = {
      hash: txHash,
      type: payload.type || "",
      nonce: payload.nonce || 0,
      round: payload.round,
      epoch: payload.epoch || 0,
      value: (payload.value || 0).toString(),
      sender: new import_address.Address(payload.sender),
      receiver: new import_address.Address(payload.receiver),
      gasPrice: payload.gasPrice || 0,
      gasLimit: payload.gasLimit || 0,
      data: import_buffer.Buffer.from(payload.data || "", "base64"),
      status,
      timestamp: payload.timestamp || 0,
      blockNonce: payload.blockNonce || 0,
      hyperblockNonce: payload.hyperblockNonce || 0,
      hyperblockHash: payload.hyperblockHash || "",
      receipt: import_transactionReceipt.TransactionReceipt.fromHttpResponse(payload.receipt || {}),
      logs: import_transactionLogs.TransactionLogs.fromHttpResponse(payload.logs || {}),
      contractResults: import_contractResults.ContractResults.fromApiHttpResponse(
        payload.results || []
      ),
      isCompleted: !status.isPending()
    };
    return transaction;
  }
  async queryContract({
    address,
    func,
    args,
    value,
    caller
  }) {
    try {
      const query = new import_query.Query({
        address,
        func,
        args,
        value,
        caller
      });
      const request = new import_contractQueryRequest.ContractQueryRequest(query).toHttpRequest();
      const response = await this.apiPost("query", request);
      return import_contractQueryResponse.ContractQueryResponse.fromHttpResponse(response);
    } catch (e2) {
      this.handleApiError(e2, "query");
    }
  }
};

// src/auth/login-with-extension.ts
init_shim();

// src/auth/expires-at.ts
init_shim();
var getNewLoginExpiresTimestamp = () => {
  return (/* @__PURE__ */ new Date()).setHours((/* @__PURE__ */ new Date()).getHours() + 24);
};
var isLoginExpired = (expirationTimestamp) => {
  return Date.now() > expirationTimestamp;
};

// src/auth/account-sync.ts
init_shim();
var import_address2 = __toESM(require_address(), 1);
var import_account = __toESM(require_account(), 1);
var accountSync = async (elven) => {
  const address = ls.get("address");
  const loginExpires = ls.get("expires");
  const loginExpired = loginExpires && isLoginExpired(loginExpires);
  if (!loginExpired && address && elven.networkProvider) {
    const userAddressInstance = new import_address2.Address(address);
    const userAccountInstance = new import_account.Account(userAddressInstance);
    try {
      const userAccountOnNetwork = await elven.networkProvider.getAccount(userAddressInstance);
      const userGuardianOnNetwork = await elven.networkProvider.getGuardianData(userAddressInstance);
      ls.set("address", address);
      ls.set(
        "activeGuardian",
        userGuardianOnNetwork.guarded && userGuardianOnNetwork.activeGuardian?.address ? userGuardianOnNetwork.activeGuardian.address : ""
      );
      ls.set("nonce", userAccountOnNetwork.nonce.valueOf());
      ls.set("balance", userAccountOnNetwork.balance.toString());
      userAccountInstance.update(userAccountOnNetwork);
    } catch (e2) {
      const err = errorParse(e2);
      console.warn(
        `Something went wrong trying to synchronize the user account: ${err}`
      );
    }
  }
};

// src/auth/login-with-extension.ts
var loginWithExtension = async (elven, loginToken, nativeAuthClient, callbackRoute = "/") => {
  const dappProvider = await initExtensionProvider();
  const callbackUrl = encodeURIComponent(
    `${window.location.origin}${callbackRoute}`
  );
  const providerLoginData = {
    callbackUrl,
    token: loginToken
  };
  try {
    if (dappProvider) {
      const address = await dappProvider.login(providerLoginData);
      if (!address) {
        throw new Error("There were problems while logging in!");
      }
    }
  } catch (e2) {
    const err = errorParse(e2);
    throw new Error(err);
  }
  if (!dappProvider) {
    throw new Error("There were problems with auth provider initialization!");
  }
  const { signature } = dappProvider.account;
  ls.set("loginToken", loginToken);
  if (signature) {
    ls.set("signature", signature);
  }
  if (elven.networkProvider && signature) {
    try {
      const address = await dappProvider.getAddress();
      if (!address) {
        throw new Error("Canceled!");
      }
      ls.set("address", address);
      ls.set("loginMethod", "browser-extension" /* browserExtension */);
      ls.set("expires", getNewLoginExpiresTimestamp());
      await accountSync(elven);
      const accessToken = nativeAuthClient.getToken(
        address,
        loginToken,
        signature
      );
      ls.set("accessToken", accessToken);
      EventsStore.run("onLoginSuccess" /* onLoginSuccess */);
      return dappProvider;
    } catch (e2) {
      throw new Error(
        `Something went wrong trying to synchronize the user account: ${e2?.message}`
      );
    }
  }
};

// src/auth/login-with-mobile.ts
init_shim();

// src/auth/qr-code-and-pairings-builder.ts
init_shim();
var import_qrcode = __toESM(require_browser7(), 1);
var import_walletConnectV2Provider2 = __toESM(require_walletConnectV2Provider(), 1);
var htmlStringToElement = (htmlString) => {
  const template = document.createElement("template");
  template.innerHTML = htmlString.trim();
  return template.content.firstChild?.cloneNode(true);
};
var buildDeepLink = (walletConnectUri) => {
  const hrefVal = `${walletConnectDeepLink}?wallet-connect=${encodeURIComponent(
    walletConnectUri
  )}`;
  const aElem = document.createElement("a");
  aElem.setAttribute("href", hrefVal);
  aElem.setAttribute("rel", "noopener noreferrer nofollow");
  aElem.setAttribute("target", "_blank");
  aElem.textContent = "xPortal login";
  aElem.classList.add("elven-qr-code-deep-link");
  return aElem;
};
var buildPairingsContainer = () => {
  const container = document.createElement("div");
  container.classList.add("elven-wc-pairings");
  return container;
};
var buildPairingsHeader = () => {
  const headerElem = document.createElement("div");
  headerElem.textContent = "Existing WalletConnect pairings:";
  headerElem.classList.add("elven-wc-pairings-header");
  return headerElem;
};
var pairingRemoveControllers = {};
var buildPairingsRemoveButton = (pairing, removeExistingPairing) => {
  const btn = document.createElement("button");
  btn.classList.add("elven-wc-pairings-remove-btn");
  btn.textContent = "\u2716";
  pairingRemoveControllers[pairing.topic] = new AbortController();
  btn.addEventListener(
    "click",
    (e2) => {
      e2.stopImmediatePropagation();
      removeExistingPairing(pairing.topic);
    },
    {
      signal: pairingRemoveControllers[pairing.topic].signal
    }
  );
  return btn;
};
var pairingLoginControllers = {};
var buildPairingItem = (pairing, removeExistingPairing, loginThroughExistingPairing) => {
  const itemElem = document.createElement("div");
  const itemTextWrapper = document.createElement("div");
  itemElem.classList.add("elven-wc-pairing-item");
  itemElem.setAttribute("id", pairing.topic);
  itemTextWrapper.classList.add("elven-wc-pairing-item-description");
  itemTextWrapper.textContent = `${pairing.peerMetadata?.description} (${pairing.peerMetadata?.url})`;
  itemElem.appendChild(itemTextWrapper);
  const button = buildPairingsRemoveButton(pairing, removeExistingPairing);
  itemElem.appendChild(button);
  pairingLoginControllers[pairing.topic] = new AbortController();
  itemElem.addEventListener(
    "click",
    () => loginThroughExistingPairing(pairing.topic),
    { signal: pairingLoginControllers[pairing.topic].signal }
  );
  return itemElem;
};
var buildPairingItemConfirmMessage = () => {
  const itemElem = document.createElement("div");
  itemElem.classList.add("elven-wc-pairing-item-confirm-msessage");
  itemElem.setAttribute("id", "elven-wc-pairing-item-confirm-msessage");
  itemElem.innerText = "Confirm on xPortal app!";
  return itemElem;
};
var removePairingItem = (topic) => {
  if (!topic)
    return;
  const pairingElement = document.getElementById(topic);
  pairingElement?.remove();
};
var isMobile = () => /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
  navigator.userAgent
);
var generateQRCode = async (walletConnectUri) => {
  if (!walletConnectUri) {
    return;
  }
  const svg = await import_qrcode.default.toString(walletConnectUri, {
    type: "svg"
  });
  return svg;
};
var qrCodeAndPairingsBuilder = async (qrCodeContainer, walletConnectUri, dappProvider, token) => {
  if (!qrCodeContainer)
    throw new Error(
      "Please provide the QR Code and WalletConnect Pairings container id!"
    );
  let containerElem = null;
  if (typeof qrCodeContainer === "string") {
    containerElem = document.getElementById(qrCodeContainer);
  } else if (qrCodeContainer instanceof HTMLElement) {
    containerElem = qrCodeContainer;
  }
  const qrCodeElementString = await generateQRCode(walletConnectUri);
  let qrCodeSvg;
  if (qrCodeElementString) {
    qrCodeSvg = htmlStringToElement(qrCodeElementString);
  }
  if (containerElem && qrCodeSvg) {
    containerElem.replaceChildren();
    containerElem.appendChild(qrCodeSvg);
    if (isMobile()) {
      containerElem.appendChild(buildDeepLink(walletConnectUri));
    }
  }
  if (containerElem && dappProvider instanceof import_walletConnectV2Provider2.WalletConnectV2Provider) {
    const wcPairings = dappProvider.pairings;
    const removeExistingPairing = async (topic) => {
      try {
        if (topic) {
          await dappProvider.logout({
            topic
          });
          removePairingItem(topic);
        }
      } catch (e2) {
        const err = errorParse(e2);
        console.warn(
          `Something went wrong trying to remove the existing pairing: ${err}`
        );
      } finally {
        pairingLoginControllers[topic].abort();
      }
    };
    const loginThroughExistingPairing = async (topic) => {
      try {
        const { approval } = await dappProvider.connect({
          topic,
          methods: [
            "mvx_cancelAction" /* mvx_cancelAction */,
            "mvx_signNativeAuthToken" /* mvx_signNativeAuthToken */
          ]
        });
        const pairingItemConfirmation = document.getElementById(
          "elven-wc-pairing-item-confirm-msessage"
        );
        if (!pairingItemConfirmation) {
          const pairingItemElement = document.getElementById(topic);
          pairingItemElement?.after(buildPairingItemConfirmMessage());
        }
        await dappProvider.login({
          approval,
          token
        });
      } catch (e2) {
        const err = errorParse(e2);
        console.warn(`Something went wrong trying to login the user: ${err}`);
      } finally {
        for (const abortController of Object.values(pairingLoginControllers)) {
          abortController?.abort();
        }
        for (const abortController of Object.values(pairingRemoveControllers)) {
          abortController?.abort();
        }
      }
    };
    if (wcPairings && wcPairings.length > 0) {
      const container = buildPairingsContainer();
      containerElem.appendChild(container);
      const headerElem = buildPairingsHeader();
      container.appendChild(headerElem);
      for (const pairing of wcPairings) {
        const itemElem = buildPairingItem(
          pairing,
          removeExistingPairing,
          loginThroughExistingPairing
        );
        container.appendChild(itemElem);
      }
    }
  }
  return containerElem;
};

// src/auth/login-with-mobile.ts
var import_walletConnectV2Provider3 = __toESM(require_walletConnectV2Provider(), 1);
var loginWithMobile = async (elven, loginToken, nativeAuthClient, qrCodeContainer) => {
  if (!qrCodeContainer) {
    throw new Error(
      "You haven't provided the QR code container DOM element id"
    );
  }
  const relayAddress = getRandomAddressFromNetwork(
    elven.initOptions.walletConnectV2RelayAddresses
  );
  if (!relayAddress || !elven.networkProvider) {
    throw new Error(
      "Something wen't wrong with the initialization (ApiNetworkProvider or Wallet Connect Bridge address), plese try to refresh the page!"
    );
  }
  if (!elven.initOptions.walletConnectV2ProjectId) {
    throw new Error(
      "Please provide your WalletConnect project id. You can get it here: https://cloud.walletconnect.com)"
    );
  }
  if (!elven.initOptions.chainType) {
    throw new Error("Please provide the chain type in ElvenJS.init function!");
  }
  let qrCodeElement;
  const providerHandlers = {
    onClientLogin: async () => {
      if (elven.dappProvider instanceof import_walletConnectV2Provider3.WalletConnectV2Provider) {
        const address = await elven.dappProvider.getAddress();
        const signature = await elven.dappProvider.getSignature();
        ls.set("address", address);
        ls.set("loginMethod", "mobile" /* mobile */);
        ls.set("expires", getNewLoginExpiresTimestamp());
        await accountSync(elven);
        if (signature) {
          ls.set("signature", signature);
        }
        ls.set("loginToken", loginToken);
        const accessToken = nativeAuthClient.getToken(
          address,
          loginToken,
          signature
        );
        ls.set("accessToken", accessToken);
        EventsStore.run("onLoginSuccess" /* onLoginSuccess */);
        qrCodeElement?.replaceChildren();
      }
    },
    onClientLogout: async () => {
      if (elven.dappProvider instanceof import_walletConnectV2Provider3.WalletConnectV2Provider) {
        await logout(elven);
      }
    },
    onClientEvent: (event) => {
      console.log("wc2 session event: ", event);
    }
  };
  const dappProvider = new import_walletConnectV2Provider3.WalletConnectV2Provider(
    providerHandlers,
    networkConfig[elven.initOptions.chainType].shortId,
    relayAddress,
    elven.initOptions.walletConnectV2ProjectId
  );
  try {
    if (dappProvider) {
      elven.dappProvider = dappProvider;
      EventsStore.run("onQrPending" /* onQrPending */);
      await dappProvider.init();
      const { uri: walletConnectUri, approval } = await dappProvider.connect({
        methods: [
          "mvx_cancelAction" /* mvx_cancelAction */,
          "mvx_signNativeAuthToken" /* mvx_signNativeAuthToken */
        ]
      });
      const wCUri = loginToken ? `${walletConnectUri}&token=${loginToken}` : walletConnectUri;
      if (qrCodeContainer && wCUri) {
        qrCodeElement = await qrCodeAndPairingsBuilder(
          qrCodeContainer,
          wCUri,
          dappProvider,
          loginToken
        );
        EventsStore.run("onQrLoaded" /* onQrLoaded */);
      }
      await dappProvider.login({
        approval,
        token: loginToken
      });
      return dappProvider;
    }
  } catch (e2) {
    const err = errorParse(e2);
    console.warn(`Something went wrong trying to login the user: ${err}`);
    EventsStore.run("onLoginFailure" /* onLoginFailure */, err);
  }
};

// src/auth/login-with-web-wallet.ts
init_shim();
var import_walletProvider = __toESM(require_walletProvider(), 1);
var loginWithWebWallet = async (urlAddress, loginToken, chainType, callbackRoute) => {
  const dappProvider = new import_walletProvider.WalletProvider(`${urlAddress}${DAPP_INIT_ROUTE}`);
  const callbackUrl = typeof window !== "undefined" ? encodeURIComponent(`${window.location.origin}${callbackRoute || "/"}`) : "/";
  const providerLoginData = {
    callbackUrl,
    token: loginToken
  };
  try {
    ls.set(
      "loginMethod",
      networkConfig[chainType].xAliasAddress === urlAddress ? "x-alias" /* xAlias */ : "web-wallet" /* webWallet */
    );
    await dappProvider.login(providerLoginData);
    ls.set("expires", getNewLoginExpiresTimestamp());
    ls.set("loginToken", loginToken);
    return dappProvider;
  } catch (e2) {
    const err = errorParse(e2);
    console.warn(`Something went wrong trying to login the user: ${err}`);
    ls.set("loginMethod", "");
    EventsStore.run("onLoginFailure" /* onLoginFailure */, err);
  }
};

// src/utils/get-param-from-url.ts
init_shim();
var getParamFromUrl = (paramName) => {
  if (typeof window !== "undefined") {
    const url = new URL(window.location.href);
    const params = new URLSearchParams(url.search);
    return params.get(paramName);
  }
};

// src/auth/init-web-wallet-provider.ts
init_shim();
var import_walletProvider2 = __toESM(require_walletProvider(), 1);
var import_native_auth = __toESM(require_native_auth_client(), 1);
var initWebWalletProvider = async (webWalletAddress, apiUrl) => {
  const signature = getParamFromUrl("signature");
  const urlAddress = getParamFromUrl("address");
  const lsAddress = ls.get("address");
  const loginToken = ls.get("loginToken");
  if (signature) {
    ls.set("signature", signature);
  }
  if (urlAddress || lsAddress) {
    if (urlAddress) {
      ls.set("address", urlAddress);
      window.history.replaceState(null, "", window.location.pathname);
    }
    const dappProvider = new import_walletProvider2.WalletProvider(
      `${webWalletAddress}${DAPP_INIT_ROUTE}`
    );
    if (signature && apiUrl && urlAddress) {
      const nativeAuthClient = new import_native_auth.NativeAuthClient({
        apiUrl,
        origin: window.location.origin
      });
      const accessToken = nativeAuthClient.getToken(
        urlAddress,
        loginToken,
        signature
      );
      ls.set("accessToken", accessToken);
    }
    return dappProvider;
  }
};

// src/interaction/post-send-tx.ts
init_shim();
var import_account2 = __toESM(require_account(), 1);
var import_transactionWatcher = __toESM(require_transactionWatcher(), 1);
var postSendTx = async (transaction, networkProvider) => {
  EventsStore.run("onTxSent" /* onTxSent */, transaction);
  const transactionWatcher = new import_transactionWatcher.TransactionWatcher(networkProvider);
  const transactionOnNetwork = await transactionWatcher.awaitCompleted(transaction);
  const sender = transactionOnNetwork.sender;
  const senderAccount = new import_account2.Account(sender);
  const userAccountOnNetwork = await networkProvider.getAccount(sender);
  senderAccount.update(userAccountOnNetwork);
  ls.set("address", senderAccount.address.bech32());
  ls.set("balance", senderAccount.balance.toString());
  EventsStore.run("onTxFinalized" /* onTxFinalized */, transactionOnNetwork);
};

// src/interaction/web-wallet-tx-finalize.ts
init_shim();
var import_out = __toESM(require_out2(), 1);
var import_transaction = __toESM(require_transaction(), 1);

// src/interaction/pre-send-tx.ts
init_shim();
var import_account3 = __toESM(require_account(), 1);
var preSendTx = (tx) => {
  const sender = tx.getSender();
  const senderAccount = new import_account3.Account(sender);
  const currentNonce = tx.nonce.valueOf();
  senderAccount.incrementNonce();
  ls.set("nonce", (currentNonce + 1n).toString());
};

// src/interaction/web-wallet-tx-finalize.ts
var webWalletTxFinalize = async (dappProvider, networkProvider, urlAddress, nonce) => {
  const walletProviderStatus = getParamFromUrl(import_out.WALLET_PROVIDER_CALLBACK_PARAM);
  if (walletProviderStatus === import_out.WALLET_PROVIDER_CALLBACK_PARAM_TX_SIGNED && dappProvider && networkProvider) {
    const guardian = ls.get("activeGuardian");
    const loginMethod = ls.get("loginMethod");
    const hasWebWalletGuardianSign = getParamFromUrl(
      "hasWebWalletGuardianSign" /* hasWebWalletGuardianSign */
    );
    let transactionObj;
    if ("getTransactionsFromWalletUrl" in dappProvider) {
      const txs = dappProvider.getTransactionsFromWalletUrl();
      transactionObj = txs?.[0];
      if (!transactionObj)
        return;
      if (loginMethod === "web-wallet" /* webWallet */) {
        transactionObj.data = import_buffer.Buffer.from(transactionObj.data).toString(
          "base64"
        );
      }
    } else if (guardian && loginMethod !== "web-wallet" /* webWallet */ && loginMethod !== "x-alias" /* xAlias */ && hasWebWalletGuardianSign) {
      const webWalletProvider = new import_out.WalletProvider(
        `${urlAddress}${DAPP_INIT_ROUTE}`
      );
      const txs = webWalletProvider.getTransactionsFromWalletUrl();
      transactionObj = txs?.[0];
    }
    if (transactionObj) {
      const transaction = import_transaction.Transaction.fromPlainObject(transactionObj);
      transaction.nonce = BigInt(nonce);
      preSendTx(transaction);
      try {
        EventsStore.run("onTxStart" /* onTxStart */, transaction);
        await networkProvider.sendTransaction(transaction);
        await postSendTx(transaction, networkProvider);
      } catch (e2) {
        const err = errorParse(e2);
        const errMsg = `Getting transaction information failed! ${err}`;
        EventsStore.run("onTxFailure" /* onTxFailure */, transaction, errMsg);
        throw new Error(errMsg);
      } finally {
        window.history.replaceState(null, "", window.location.pathname);
      }
    }
    window.history.replaceState(null, "", window.location.pathname);
  }
};

// src/interaction/guardian-operations.ts
init_shim();
var import_networkParams = __toESM(require_networkParams(), 1);
var import_address3 = __toESM(require_address(), 1);
var import_walletProvider3 = __toESM(require_walletProvider(), 1);
var guardianPreSignTxOperations = (tx) => {
  const guardian = ls.get("activeGuardian");
  if (guardian) {
    const options = {
      guarded: true
    };
    tx.setVersion(import_networkParams.TransactionVersion.withTxOptions());
    tx.setOptions(import_networkParams.TransactionOptions.withOptions(options));
    tx.setGuardian(import_address3.Address.fromBech32(guardian));
  }
  return tx;
};
var sendTxToGuardian = async (signedTx, walletAddress) => {
  const webWalletProvider = new import_walletProvider3.WalletProvider(
    `${walletAddress}${DAPP_INIT_ROUTE}`
  );
  const currentUrl = window?.location.href;
  const alteredCallbackUrl = new URL(currentUrl);
  alteredCallbackUrl.searchParams.set(
    "hasWebWalletGuardianSign" /* hasWebWalletGuardianSign */,
    "true"
  );
  await webWalletProvider.guardTransactions([signedTx], {
    callbackUrl: encodeURIComponent(alteredCallbackUrl.toString())
  });
};
var checkNeedsGuardianSigning = (signedTx) => {
  const guardian = ls.get("activeGuardian");
  const address = ls.get("address");
  if (!address || !guardian) {
    return false;
  }
  if (signedTx.isGuardedTransaction()) {
    return false;
  }
  return true;
};

// src/interaction/web-wallet-sign-message-finalize.ts
init_shim();
var webWalletSignMessageFinalize = () => {
  const isNotTransaction = !getParamFromUrl("walletProviderStatus");
  const isSigned = getParamFromUrl("status") === "signed";
  const message = getParamFromUrl("message");
  const signature = getParamFromUrl("signature");
  if (isNotTransaction && isSigned && message && signature) {
    EventsStore.run("onSignMsgFinalized" /* onSignMsgFinalized */, message, signature);
    window.history.replaceState(null, "", window.location.pathname);
  }
};

// src/webview-provider/webview-provider.ts
init_shim();
var import_transaction2 = __toESM(require_transaction(), 1);

// src/webview-provider/types.ts
init_shim();
var WebViewProviderResponseBaseEnums = /* @__PURE__ */ ((WebViewProviderResponseBaseEnums2) => {
  WebViewProviderResponseBaseEnums2["reloginResponse"] = "RELOGIN_RESPONSE";
  return WebViewProviderResponseBaseEnums2;
})(WebViewProviderResponseBaseEnums || {});
var CrossWindowProviderResponseEnums = /* @__PURE__ */ ((CrossWindowProviderResponseEnums2) => {
  CrossWindowProviderResponseEnums2["handshakeResponse"] = "HANDSHAKE_RESPONSE";
  CrossWindowProviderResponseEnums2["loginResponse"] = "LOGIN_RESPONSE";
  CrossWindowProviderResponseEnums2["disconnectResponse"] = "DISCONNECT_RESPONSE";
  CrossWindowProviderResponseEnums2["cancelResponse"] = "CANCEL_RESPONSE";
  CrossWindowProviderResponseEnums2["signTransactionsResponse"] = "SIGN_TRANSACTIONS_RESPONSE";
  CrossWindowProviderResponseEnums2["signMessageResponse"] = "SIGN_MESSAGE_RESPONSE";
  CrossWindowProviderResponseEnums2["noneResponse"] = "NONE_RESPONSE";
  return CrossWindowProviderResponseEnums2;
})(CrossWindowProviderResponseEnums || {});
var WebViewProviderResponseEnums = {
  ...CrossWindowProviderResponseEnums,
  ...WebViewProviderResponseBaseEnums
};
var WebViewProviderRequestBaseEnums = /* @__PURE__ */ ((WebViewProviderRequestBaseEnums2) => {
  WebViewProviderRequestBaseEnums2["signTransactionsWithGuardianResponse"] = "SIGN_TRANSACTIONS_WITH_GUARDIAN_RESPONSE";
  WebViewProviderRequestBaseEnums2["reloginRequest"] = "RELOGIN_REQUEST";
  return WebViewProviderRequestBaseEnums2;
})(WebViewProviderRequestBaseEnums || {});
var CrossWindowProviderRequestEnums = /* @__PURE__ */ ((CrossWindowProviderRequestEnums2) => {
  CrossWindowProviderRequestEnums2["signTransactionsRequest"] = "SIGN_TRANSACTIONS_REQUEST";
  CrossWindowProviderRequestEnums2["signMessageRequest"] = "SIGN_MESSAGE_REQUEST";
  CrossWindowProviderRequestEnums2["loginRequest"] = "LOGIN_REQUEST";
  CrossWindowProviderRequestEnums2["logoutRequest"] = "LOGOUT_REQUEST";
  CrossWindowProviderRequestEnums2["cancelAction"] = "CANCEL_ACTION_REQUEST";
  CrossWindowProviderRequestEnums2["finalizeHandshakeRequest"] = "FINALIZE_HANDSHAKE_REQUEST";
  return CrossWindowProviderRequestEnums2;
})(CrossWindowProviderRequestEnums || {});
var WebViewProviderRequestEnums = {
  ...CrossWindowProviderRequestEnums,
  ...WebViewProviderRequestBaseEnums
};

// src/webview-provider/utils.ts
init_shim();
var safeWindow = typeof window !== "undefined" ? window : {};
var detectCurrentPlatform = () => {
  if (safeWindow.ReactNativeWebView) {
    return "reactNative" /* reactNative */;
  }
  if (safeWindow.webkit) {
    return "ios" /* ios */;
  }
  return "web" /* web */;
};
var getTargetOrigin = () => {
  return typeof window != "undefined" && typeof window?.location != "undefined" ? window?.parent?.origin ?? "*" : "*";
};
var isString = (x3) => {
  return Object.prototype.toString.call(x3) === "[object String]";
};

// src/webview-provider/request-methods.ts
init_shim();
var requestMethods = {
  signTransactions: {
    ["ios" /* ios */]: (transactions) => window.webkit.messageHandlers.signTransactions.postMessage(
      transactions,
      getTargetOrigin()
    ),
    ["reactNative" /* reactNative */]: (message) => window?.ReactNativeWebView.postMessage(
      JSON.stringify({
        type: WebViewProviderRequestEnums.signTransactionsRequest,
        message
      })
    ),
    ["web" /* web */]: (message) => window?.postMessage(
      JSON.stringify({
        type: WebViewProviderRequestEnums.signTransactionsRequest,
        message
      }),
      getTargetOrigin()
    )
  },
  signMessage: {
    ["ios" /* ios */]: (message) => window.webkit.messageHandlers.signMessage.postMessage(message),
    ["reactNative" /* reactNative */]: (message) => window?.ReactNativeWebView.postMessage(
      JSON.stringify({
        type: WebViewProviderRequestEnums.signMessageRequest,
        message
      })
    ),
    ["web" /* web */]: (message) => window?.postMessage(
      JSON.stringify({
        type: WebViewProviderRequestEnums.signMessageRequest,
        message
      }),
      getTargetOrigin()
    )
  },
  logout: {
    ["ios" /* ios */]: () => window.webkit.messageHandlers.logout.postMessage(),
    ["reactNative" /* reactNative */]: () => window?.ReactNativeWebView.postMessage(
      JSON.stringify({
        type: WebViewProviderRequestEnums.logoutRequest
      })
    ),
    ["web" /* web */]: () => window?.postMessage(
      JSON.stringify({
        type: WebViewProviderRequestEnums.logoutRequest
      }),
      getTargetOrigin()
    )
  }
};

// src/webview-provider/webview-provider.ts
var currentPlatform = detectCurrentPlatform();
var messageType = "message";
var handleWaitForMessage = (cb) => {
  const handleMessageReceived = (event) => {
    let eventData = event.data;
    if (event.target.origin != getTargetOrigin() && currentPlatform != "reactNative" /* reactNative */) {
      return;
    }
    try {
      eventData = JSON.parse(eventData);
      cb(eventData);
    } catch (err) {
      console.error("error parsing response");
    }
  };
  if (document) {
    document.addEventListener(messageType, handleMessageReceived);
  }
  if (window) {
    window.addEventListener(messageType, handleMessageReceived);
  }
};
var WebviewProvider = class {
  constructor() {
  }
  async logout() {
    requestMethods.logout[currentPlatform]();
    return new Promise((resolve) => {
      resolve(true);
    });
  }
  async signMessage(message) {
    try {
      requestMethods.signMessage[currentPlatform](message);
      const waitForSignedMessageResponse = new Promise(
        (resolve, reject) => {
          window.signMessageResponse = (signedMessage, error) => {
            if (error) {
              reject(error);
              window.signMessageResponse = null;
              return;
            }
            resolve(signedMessage);
            window.signMessageResponse = null;
          };
          function handleSignMessageResponse(eventData) {
            const { message: message2, type } = eventData;
            if (type === WebViewProviderResponseEnums.signMessageResponse && message2 != null) {
              const { signedMessage, error } = message2;
              if (!error) {
                resolve(signedMessage);
              } else {
                reject(error);
              }
            }
            document?.removeEventListener(
              messageType,
              handleSignMessageResponse
            );
          }
          handleWaitForMessage(handleSignMessageResponse);
        }
      );
      return await waitForSignedMessageResponse;
    } catch (err) {
      console.error("error sending transaction", err);
      throw err;
    }
  }
  async signTransactions(transactions) {
    try {
      const plainTransactions = transactions.map((tx) => tx.toPlainObject());
      requestMethods.signTransactions[currentPlatform](plainTransactions);
      const waitForSignedTransactionsResponse = new Promise((resolve, reject) => {
        window.transactionsSigned = (txs, error) => {
          txs = JSON.parse(txs);
          if (error) {
            reject(error);
            window.transactionsSigned = null;
            return;
          }
          resolve(txs.map((tx) => import_transaction2.Transaction.fromPlainObject(tx)));
          window.transactionsSigned = null;
        };
        function handleSignTransactionResponse(eventData) {
          const { message, type } = eventData;
          if (type === WebViewProviderResponseEnums.signTransactionsResponse) {
            const { transactions: transactions2, error } = message;
            try {
              if (!error) {
                resolve(
                  transactions2.map(
                    (tx) => import_transaction2.Transaction.fromPlainObject(tx)
                  )
                );
              } else {
                reject(error);
              }
            } catch (err) {
              reject("Unable to sign");
            }
          }
          if (document) {
            document.removeEventListener(
              messageType,
              handleSignTransactionResponse
            );
          }
        }
        handleWaitForMessage(handleSignTransactionResponse);
      });
      return await waitForSignedTransactionsResponse;
    } catch (err) {
      console.error("error sending transaction", err);
      throw err;
    }
  }
  async signTransaction(transaction) {
    const response = await this.signTransactions([transaction]);
    return response[0];
  }
};

// src/auth/login-with-native-auth-token.ts
init_shim();

// src/webview-provider/decode-native-auth-token.ts
init_shim();

// src/webview-provider/base64-utils.ts
init_shim();
function isStringBase64(str) {
  try {
    const atobDecoded = atob(str);
    const btoaEncoded = btoa(atobDecoded);
    const bufferFromDecoded = import_buffer.Buffer.from(str, "base64").toString();
    const bufferFromEncoded = import_buffer.Buffer.from(bufferFromDecoded).toString("base64");
    const isEqualToInitialString = str === btoaEncoded && str === bufferFromEncoded;
    const isAtobEqualToBufferFrom = atobDecoded === bufferFromDecoded;
    if (isEqualToInitialString || isAtobEqualToBufferFrom) {
      return true;
    }
  } catch (e2) {
    return false;
  }
  return false;
}
function decodeBase64(string2) {
  if (!isStringBase64(string2)) {
    return string2;
  }
  return atob(string2);
}

// src/webview-provider/decode-login-token.ts
init_shim();
var decodeLoginToken = (loginToken) => {
  if (!loginToken || !isString(loginToken)) {
    return null;
  }
  const parts = loginToken.split(".");
  if (parts.length !== 4) {
    return null;
  }
  try {
    const [origin, blockHash, ttl, extraInfo] = parts;
    const parsedExtraInfo = JSON.parse(decodeBase64(extraInfo));
    const parsedOrigin = decodeBase64(origin);
    return {
      ttl: Number(ttl),
      extraInfo: parsedExtraInfo,
      origin: parsedOrigin,
      blockHash
    };
  } catch (e2) {
    console.error(`Error trying to decode ${loginToken}:`, e2);
    return null;
  }
};

// src/webview-provider/decode-native-auth-token.ts
var decodeNativeAuthToken = (accessToken) => {
  if (!accessToken || !isString(accessToken)) {
    return null;
  }
  const parts = accessToken.split(".");
  if (parts.length !== 3) {
    console.error(
      "Invalid nativeAuthToken. You may be trying to decode a loginToken. Try using decodeLoginToken method instead"
    );
    return null;
  }
  try {
    const [address, body, signature] = parts;
    const parsedAddress = decodeBase64(address);
    const parsedBody = decodeBase64(body);
    const parsedInitToken = decodeLoginToken(parsedBody);
    if (!parsedInitToken) {
      return {
        address: parsedAddress,
        body: parsedBody,
        signature,
        blockHash: "",
        origin: "",
        ttl: 0
      };
    }
    const result = {
      ...parsedInitToken,
      address: parsedAddress,
      body: parsedBody,
      signature
    };
    if (!parsedInitToken.extraInfo?.timestamp) {
      delete result.extraInfo;
    }
    return result;
  } catch (err) {
    return null;
  }
};

// src/auth/login-with-native-auth-token.ts
function loginWithNativeAuthToken(token, elven) {
  const nativeAuthInfo = decodeNativeAuthToken(token);
  if (nativeAuthInfo == null) {
    return;
  }
  const { signature, address, body } = nativeAuthInfo;
  if (signature && token && address) {
    ls.set("loginToken", body);
    ls.set("accessToken", token);
    ls.set("signature", signature);
    ls.set("address", address);
    ls.set("loginMethod", "x-portal-hub" /* xPortalHub */);
    elven.dappProvider = new WebviewProvider();
  }
}

// src/initialize-events-store.ts
init_shim();
var initializeEventsStore = (initOptions) => {
  if (initOptions.onLoginStart) {
    EventsStore.set("onLoginStart" /* onLoginStart */, initOptions.onLoginStart);
  }
  if (initOptions.onLoginSuccess) {
    EventsStore.set(
      "onLoginSuccess" /* onLoginSuccess */,
      initOptions.onLoginSuccess
    );
  }
  if (initOptions.onLoginFailure) {
    EventsStore.set(
      "onLoginFailure" /* onLoginFailure */,
      initOptions.onLoginFailure
    );
  }
  if (initOptions.onLogoutStart) {
    EventsStore.set("onLogoutStart" /* onLogoutStart */, initOptions.onLogoutStart);
  }
  if (initOptions.onLogoutSuccess) {
    EventsStore.set(
      "onLogoutSuccess" /* onLogoutSuccess */,
      initOptions.onLogoutSuccess
    );
  }
  if (initOptions.onLogoutFailure) {
    EventsStore.set(
      "onLogoutFailure" /* onLogoutFailure */,
      initOptions.onLogoutFailure
    );
  }
  if (initOptions.onQrPending) {
    EventsStore.set("onQrPending" /* onQrPending */, initOptions.onQrPending);
  }
  if (initOptions.onQrLoaded) {
    EventsStore.set("onQrLoaded" /* onQrLoaded */, initOptions.onQrLoaded);
  }
  if (initOptions.onTxStart) {
    EventsStore.set("onTxStart" /* onTxStart */, initOptions.onTxStart);
  }
  if (initOptions.onTxSent) {
    EventsStore.set("onTxSent" /* onTxSent */, initOptions.onTxSent);
  }
  if (initOptions.onTxFinalized) {
    EventsStore.set("onTxFinalized" /* onTxFinalized */, initOptions.onTxFinalized);
  }
  if (initOptions.onTxFailure) {
    EventsStore.set("onTxFailure" /* onTxFailure */, initOptions.onTxFailure);
  }
  if (initOptions.onSignMsgStart) {
    EventsStore.set(
      "onSignMsgStart" /* onSignMsgStart */,
      initOptions.onSignMsgStart
    );
  }
  if (initOptions.onSignMsgFinalized) {
    EventsStore.set(
      "onSignMsgFinalized" /* onSignMsgFinalized */,
      initOptions.onSignMsgFinalized
    );
  }
  if (initOptions.onSignMsgFailure) {
    EventsStore.set(
      "onSignMsgFailure" /* onSignMsgFailure */,
      initOptions.onSignMsgFailure
    );
  }
  if (initOptions.onQueryStart) {
    EventsStore.set("onQueryStart" /* onQueryStart */, initOptions.onQueryStart);
  }
  if (initOptions.onQueryFinalized) {
    EventsStore.set(
      "onQueryFinalized" /* onQueryFinalized */,
      initOptions.onQueryFinalized
    );
  }
  if (initOptions.onQueryFailure) {
    EventsStore.set(
      "onQueryFailure" /* onQueryFailure */,
      initOptions.onQueryFailure
    );
  }
};

// src/utils/with-login-events.ts
init_shim();
var withLoginEvents = async (fn) => {
  EventsStore.run("onLoginStart" /* onLoginStart */);
  try {
    await fn(() => {
      EventsStore.run("onLoginSuccess" /* onLoginSuccess */);
    });
  } catch (e2) {
    const err = errorParse(e2);
    console.warn(`Something went wrong trying to login the user: ${err}`);
    EventsStore.run("onLoginFailure" /* onLoginFailure */, err);
  }
};

// src/main.ts
var ElvenJS = class {
  /**
   * Initialization of the Elven.js
   */
  static async init(options) {
    const state = ls.get();
    if (state.expires && isLoginExpired(state.expires)) {
      ls.clear();
      this.dappProvider = void 0;
      return;
    }
    this.initOptions = {
      chainType: defaultChainTypeConfig,
      apiUrl: defaultApiEndpoint,
      apiTimeout: 1e4,
      walletConnectV2ProjectId: "",
      walletConnectV2RelayAddresses: defaultWalletConnectV2RelayAddresses,
      ...options
    };
    this.networkProvider = new ApiNetworkProvider(this.initOptions);
    initializeEventsStore(this.initOptions);
    const nativeAuthTokenFromUrl = getParamFromUrl("accessToken");
    if (nativeAuthTokenFromUrl) {
      await withLoginEvents(async (onLoginSuccess) => {
        loginWithNativeAuthToken(nativeAuthTokenFromUrl, this);
        await accountSync(this);
        onLoginSuccess();
      });
    }
    const isAddress = state?.address || (state.loginMethod === "web-wallet" /* webWallet */ || state.loginMethod === "x-alias" /* xAlias */) && getParamFromUrl("address");
    if (isAddress && state?.loginMethod) {
      await withLoginEvents(async (onLoginSuccess) => {
        if (state.loginMethod === "browser-extension" /* browserExtension */) {
          this.dappProvider = await initExtensionProvider();
        }
        if (state.loginMethod === "mobile" /* mobile */) {
          this.dappProvider = await initMobileProvider(this);
        }
        if (state.loginMethod === "x-portal-hub" /* xPortalHub */) {
          this.dappProvider = new WebviewProvider();
        }
        if (state.loginMethod === "web-wallet" /* webWallet */ && this.initOptions?.chainType) {
          this.dappProvider = await initWebWalletProvider(
            networkConfig[this.initOptions.chainType].walletAddress,
            this.initOptions.apiUrl
          );
        }
        if (state.loginMethod === "x-alias" /* xAlias */ && this.initOptions?.chainType) {
          this.dappProvider = await initWebWalletProvider(
            networkConfig[this.initOptions.chainType].xAliasAddress,
            this.initOptions.apiUrl
          );
        }
        await accountSync(this);
        onLoginSuccess();
      });
      if (this.initOptions?.chainType) {
        await webWalletTxFinalize(
          this.dappProvider,
          this.networkProvider,
          networkConfig[this.initOptions.chainType][state.loginMethod === "x-alias" /* xAlias */ ? "xAliasAddress" : "walletAddress"],
          state.nonce
        );
        webWalletSignMessageFinalize();
      }
    }
  }
  /**
   * Login function
   */
  static async login(loginMethod, options) {
    const isProperLoginMethod = Object.values(LoginMethodsEnum).includes(loginMethod);
    if (!isProperLoginMethod) {
      const error = "Wrong login method!";
      EventsStore.run("onLoginFailure" /* onLoginFailure */, error);
      throw new Error(error);
    }
    if (!this.networkProvider) {
      const error = "Login failed: Use ElvenJs.init() first!";
      EventsStore.run("onLoginFailure" /* onLoginFailure */, error);
      throw new Error(error);
    }
    await withLoginEvents(async () => {
      const nativeAuthClient = new import_native_auth2.NativeAuthClient({
        apiUrl: this.initOptions?.apiUrl,
        origin: window.location.origin
      });
      const loginToken = await nativeAuthClient.initialize();
      if (loginMethod === "browser-extension" /* browserExtension */) {
        const dappProvider = await loginWithExtension(
          this,
          loginToken,
          nativeAuthClient,
          options?.callbackRoute
        );
        this.dappProvider = dappProvider;
      }
      if (loginMethod === "mobile" /* mobile */) {
        const dappProvider = await loginWithMobile(
          this,
          loginToken,
          nativeAuthClient,
          options?.qrCodeContainer
        );
        this.dappProvider = dappProvider;
      }
      if (loginMethod === "web-wallet" /* webWallet */ && this.initOptions?.chainType) {
        const dappProvider = await loginWithWebWallet(
          networkConfig[this.initOptions.chainType].walletAddress,
          loginToken,
          this.initOptions?.chainType,
          options?.callbackRoute
        );
        this.dappProvider = dappProvider;
      }
      if (loginMethod === "x-alias" /* xAlias */ && this.initOptions?.chainType) {
        const dappProvider = await loginWithWebWallet(
          networkConfig[this.initOptions.chainType].xAliasAddress,
          loginToken,
          this.initOptions?.chainType,
          options?.callbackRoute
        );
        this.dappProvider = dappProvider;
      }
    });
  }
  /**
   * Logout function
   */
  static async logout() {
    try {
      const isLoggedOut = await logout(this);
      this.dappProvider = void 0;
      return isLoggedOut;
    } catch (e2) {
      const err = errorParse(e2);
      console.warn("Something went wrong when logging out: ", err);
    }
  }
  /**
   * Sign and send function
   */
  static async signAndSendTransaction(transaction) {
    if (!this.dappProvider) {
      const error = "Transaction signing failed: There is no active session!";
      EventsStore.run("onTxFailure" /* onTxFailure */, transaction, error);
      throw new Error(error);
    }
    if (!this.networkProvider) {
      const error = "Transaction signing failed: There is no active network provider!";
      EventsStore.run("onTxFailure" /* onTxFailure */, transaction, error);
      throw new Error(error);
    }
    let signedTx = guardianPreSignTxOperations(transaction);
    try {
      EventsStore.run("onTxStart" /* onTxStart */, transaction);
      const currentState = ls.get();
      transaction.nonce = currentState.nonce;
      if (this.dappProvider instanceof import_extensionProvider2.ExtensionProvider) {
        signedTx = await this.dappProvider.signTransaction(transaction);
      }
      if (this.dappProvider instanceof import_walletConnectV2Provider4.WalletConnectV2Provider) {
        signedTx = await this.dappProvider.signTransaction(transaction);
      }
      if (this.dappProvider instanceof WebviewProvider) {
        signedTx = await this.dappProvider.signTransaction(transaction);
      }
      if (this.dappProvider instanceof import_walletProvider4.WalletProvider) {
        await this.dappProvider.signTransaction(transaction);
      }
      if (currentState.loginMethod !== "web-wallet" /* webWallet */ && currentState.loginMethod !== "x-alias" /* xAlias */) {
        const needsGuardianSign = checkNeedsGuardianSigning(signedTx);
        if (!needsGuardianSign) {
          preSendTx(signedTx);
        }
        if (needsGuardianSign && this.initOptions?.chainType) {
          await sendTxToGuardian(
            signedTx,
            networkConfig[this.initOptions.chainType].walletAddress
          );
          return;
        }
        await this.networkProvider.sendTransaction(signedTx);
        await postSendTx(signedTx, this.networkProvider);
      }
    } catch (e2) {
      const err = errorParse(e2);
      EventsStore.run(
        "onTxFailure" /* onTxFailure */,
        signedTx,
        `Getting transaction information failed! ${err}`
      );
      throw new Error(`Getting transaction information failed! ${err}`);
    }
    return signedTx;
  }
  /**
   * Sign a single message
   */
  static async signMessage(message, options) {
    if (!this.dappProvider) {
      const error = "Message signing failed: There is no active session!";
      EventsStore.run("onSignMsgFailure" /* onSignMsgFailure */, message, error);
      throw new Error(error);
    }
    if (!this.networkProvider) {
      const error = "Message signing failed: There is no active network provider!";
      EventsStore.run("onSignMsgFailure" /* onSignMsgFailure */, message, error);
      throw new Error(error);
    }
    let messageSignature = "";
    try {
      EventsStore.run("onSignMsgStart" /* onSignMsgStart */, message);
      if (this.dappProvider instanceof import_extensionProvider2.ExtensionProvider) {
        const signedMessage = await this.dappProvider.signMessage(
          new import_signableMessage.SignableMessage({ message: import_buffer.Buffer.from(message) })
        );
        messageSignature = signedMessage.getSignature().toString("hex");
      }
      if (this.dappProvider instanceof import_walletConnectV2Provider4.WalletConnectV2Provider) {
        const signedMessage = await this.dappProvider.signMessage(
          new import_signableMessage.SignableMessage({ message: import_buffer.Buffer.from(message) })
        );
        messageSignature = signedMessage.getSignature().toString("hex");
      }
      if (this.dappProvider instanceof WebviewProvider) {
        messageSignature = await this.dappProvider.signMessage(message);
      }
      if (this.dappProvider instanceof import_walletProvider4.WalletProvider) {
        const encodeRFC3986URIComponent = (str) => {
          return encodeURIComponent(str).replace(
            /[!'()*]/g,
            (c4) => `%${c4.charCodeAt(0).toString(16).toUpperCase()}`
          );
        };
        const url = options?.callbackUrl || window.location.origin;
        await this.dappProvider.signMessage(
          new import_signableMessage.SignableMessage({ message: import_buffer.Buffer.from(message) }),
          {
            callbackUrl: encodeURIComponent(
              `${url}${url.includes("?") ? "&" : "?"}message=${encodeRFC3986URIComponent(message)}`
            )
          }
        );
      }
      const currentState = ls.get();
      if (currentState.loginMethod !== "web-wallet" /* webWallet */ && currentState.loginMethod !== "x-alias" /* xAlias */) {
        EventsStore.run(
          "onSignMsgFinalized" /* onSignMsgFinalized */,
          message,
          messageSignature
        );
      }
      return { message, messageSignature };
    } catch (e2) {
      const err = errorParse(e2);
      EventsStore.run("onSignMsgFailure" /* onSignMsgFailure */, message, err);
      throw new Error(`Message signing failed! ${err}`);
    }
  }
  /**
   * Query Smart Contracts
   */
  static async queryContract({
    address,
    func,
    args = [],
    value = 0,
    caller
  }) {
    if (!this.networkProvider) {
      throw new Error("Query failed: There is no active network provider!");
    }
    if (!address || !func) {
      throw new Error(
        "Query failed: The Query arguments are not valid! Address and func required"
      );
    }
    const queryArgs = {
      address,
      func,
      args,
      value,
      caller
    };
    try {
      EventsStore.run("onQueryStart" /* onQueryStart */, queryArgs);
      const response = await this.networkProvider.queryContract(queryArgs);
      EventsStore.run("onQueryFinalized" /* onQueryFinalized */, response);
      return response;
    } catch (e2) {
      const err = errorParse(e2);
      EventsStore.run("onQueryFinalized" /* onQueryFinalized */, queryArgs, err);
      throw new Error(`Smart contract query failed! ${err}`);
    }
  }
  static {
    /**
     * Main storage
     */
    this.storage = ls;
  }
  static {
    /**
     * Destroy and cleanup if needed
     */
    this.destroy = () => {
      this.networkProvider = void 0;
      this.dappProvider = void 0;
      this.initOptions = void 0;
      EventsStore.clear();
    };
  }
};

// src/utils/amount.ts
init_shim();

// node_modules/bignumber.js/bignumber.mjs
init_shim();
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i;
var mathceil = Math.ceil;
var mathfloor = Math.floor;
var bignumberError = "[BigNumber Error] ";
var tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ";
var BASE = 1e14;
var LOG_BASE = 14;
var MAX_SAFE_INTEGER = 9007199254740991;
var POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13];
var SQRT_BASE = 1e7;
var MAX = 1e9;
function clone(configObject) {
  var div, convertBase, parseNumeric, P2 = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "\xA0",
    // non-breaking space
    suffix: ""
  }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
  function BigNumber2(v2, b4) {
    var alphabet2, c4, caseChanged, e2, i2, isNum, len, str, x3 = this;
    if (!(x3 instanceof BigNumber2))
      return new BigNumber2(v2, b4);
    if (b4 == null) {
      if (v2 && v2._isBigNumber === true) {
        x3.s = v2.s;
        if (!v2.c || v2.e > MAX_EXP) {
          x3.c = x3.e = null;
        } else if (v2.e < MIN_EXP) {
          x3.c = [x3.e = 0];
        } else {
          x3.e = v2.e;
          x3.c = v2.c.slice();
        }
        return;
      }
      if ((isNum = typeof v2 == "number") && v2 * 0 == 0) {
        x3.s = 1 / v2 < 0 ? (v2 = -v2, -1) : 1;
        if (v2 === ~~v2) {
          for (e2 = 0, i2 = v2; i2 >= 10; i2 /= 10, e2++)
            ;
          if (e2 > MAX_EXP) {
            x3.c = x3.e = null;
          } else {
            x3.e = e2;
            x3.c = [v2];
          }
          return;
        }
        str = String(v2);
      } else {
        if (!isNumeric.test(str = String(v2)))
          return parseNumeric(x3, str, isNum);
        x3.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      }
      if ((e2 = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      if ((i2 = str.search(/e/i)) > 0) {
        if (e2 < 0)
          e2 = i2;
        e2 += +str.slice(i2 + 1);
        str = str.substring(0, i2);
      } else if (e2 < 0) {
        e2 = str.length;
      }
    } else {
      intCheck(b4, 2, ALPHABET.length, "Base");
      if (b4 == 10 && alphabetHasNormalDecimalDigits) {
        x3 = new BigNumber2(v2);
        return round(x3, DECIMAL_PLACES + x3.e + 1, ROUNDING_MODE);
      }
      str = String(v2);
      if (isNum = typeof v2 == "number") {
        if (v2 * 0 != 0)
          return parseNumeric(x3, str, isNum, b4);
        x3.s = 1 / v2 < 0 ? (str = str.slice(1), -1) : 1;
        if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
          throw Error(tooManyDigits + v2);
        }
      } else {
        x3.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }
      alphabet2 = ALPHABET.slice(0, b4);
      e2 = i2 = 0;
      for (len = str.length; i2 < len; i2++) {
        if (alphabet2.indexOf(c4 = str.charAt(i2)) < 0) {
          if (c4 == ".") {
            if (i2 > e2) {
              e2 = len;
              continue;
            }
          } else if (!caseChanged) {
            if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i2 = -1;
              e2 = 0;
              continue;
            }
          }
          return parseNumeric(x3, String(v2), isNum, b4);
        }
      }
      isNum = false;
      str = convertBase(str, b4, 10, x3.s);
      if ((e2 = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      else
        e2 = str.length;
    }
    for (i2 = 0; str.charCodeAt(i2) === 48; i2++)
      ;
    for (len = str.length; str.charCodeAt(--len) === 48; )
      ;
    if (str = str.slice(i2, ++len)) {
      len -= i2;
      if (isNum && BigNumber2.DEBUG && len > 15 && (v2 > MAX_SAFE_INTEGER || v2 !== mathfloor(v2))) {
        throw Error(tooManyDigits + x3.s * v2);
      }
      if ((e2 = e2 - i2 - 1) > MAX_EXP) {
        x3.c = x3.e = null;
      } else if (e2 < MIN_EXP) {
        x3.c = [x3.e = 0];
      } else {
        x3.e = e2;
        x3.c = [];
        i2 = (e2 + 1) % LOG_BASE;
        if (e2 < 0)
          i2 += LOG_BASE;
        if (i2 < len) {
          if (i2)
            x3.c.push(+str.slice(0, i2));
          for (len -= LOG_BASE; i2 < len; ) {
            x3.c.push(+str.slice(i2, i2 += LOG_BASE));
          }
          i2 = LOG_BASE - (str = str.slice(i2)).length;
        } else {
          i2 -= len;
        }
        for (; i2--; str += "0")
          ;
        x3.c.push(+str);
      }
    } else {
      x3.c = [x3.e = 0];
    }
  }
  BigNumber2.clone = clone;
  BigNumber2.ROUND_UP = 0;
  BigNumber2.ROUND_DOWN = 1;
  BigNumber2.ROUND_CEIL = 2;
  BigNumber2.ROUND_FLOOR = 3;
  BigNumber2.ROUND_HALF_UP = 4;
  BigNumber2.ROUND_HALF_DOWN = 5;
  BigNumber2.ROUND_HALF_EVEN = 6;
  BigNumber2.ROUND_HALF_CEIL = 7;
  BigNumber2.ROUND_HALF_FLOOR = 8;
  BigNumber2.EUCLID = 9;
  BigNumber2.config = BigNumber2.set = function(obj) {
    var p3, v2;
    if (obj != null) {
      if (typeof obj == "object") {
        if (obj.hasOwnProperty(p3 = "DECIMAL_PLACES")) {
          v2 = obj[p3];
          intCheck(v2, 0, MAX, p3);
          DECIMAL_PLACES = v2;
        }
        if (obj.hasOwnProperty(p3 = "ROUNDING_MODE")) {
          v2 = obj[p3];
          intCheck(v2, 0, 8, p3);
          ROUNDING_MODE = v2;
        }
        if (obj.hasOwnProperty(p3 = "EXPONENTIAL_AT")) {
          v2 = obj[p3];
          if (v2 && v2.pop) {
            intCheck(v2[0], -MAX, 0, p3);
            intCheck(v2[1], 0, MAX, p3);
            TO_EXP_NEG = v2[0];
            TO_EXP_POS = v2[1];
          } else {
            intCheck(v2, -MAX, MAX, p3);
            TO_EXP_NEG = -(TO_EXP_POS = v2 < 0 ? -v2 : v2);
          }
        }
        if (obj.hasOwnProperty(p3 = "RANGE")) {
          v2 = obj[p3];
          if (v2 && v2.pop) {
            intCheck(v2[0], -MAX, -1, p3);
            intCheck(v2[1], 1, MAX, p3);
            MIN_EXP = v2[0];
            MAX_EXP = v2[1];
          } else {
            intCheck(v2, -MAX, MAX, p3);
            if (v2) {
              MIN_EXP = -(MAX_EXP = v2 < 0 ? -v2 : v2);
            } else {
              throw Error(bignumberError + p3 + " cannot be zero: " + v2);
            }
          }
        }
        if (obj.hasOwnProperty(p3 = "CRYPTO")) {
          v2 = obj[p3];
          if (v2 === !!v2) {
            if (v2) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v2;
              } else {
                CRYPTO = !v2;
                throw Error(bignumberError + "crypto unavailable");
              }
            } else {
              CRYPTO = v2;
            }
          } else {
            throw Error(bignumberError + p3 + " not true or false: " + v2);
          }
        }
        if (obj.hasOwnProperty(p3 = "MODULO_MODE")) {
          v2 = obj[p3];
          intCheck(v2, 0, 9, p3);
          MODULO_MODE = v2;
        }
        if (obj.hasOwnProperty(p3 = "POW_PRECISION")) {
          v2 = obj[p3];
          intCheck(v2, 0, MAX, p3);
          POW_PRECISION = v2;
        }
        if (obj.hasOwnProperty(p3 = "FORMAT")) {
          v2 = obj[p3];
          if (typeof v2 == "object")
            FORMAT = v2;
          else
            throw Error(bignumberError + p3 + " not an object: " + v2);
        }
        if (obj.hasOwnProperty(p3 = "ALPHABET")) {
          v2 = obj[p3];
          if (typeof v2 == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v2)) {
            alphabetHasNormalDecimalDigits = v2.slice(0, 10) == "0123456789";
            ALPHABET = v2;
          } else {
            throw Error(bignumberError + p3 + " invalid: " + v2);
          }
        }
      } else {
        throw Error(bignumberError + "Object expected: " + obj);
      }
    }
    return {
      DECIMAL_PLACES,
      ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO,
      MODULO_MODE,
      POW_PRECISION,
      FORMAT,
      ALPHABET
    };
  };
  BigNumber2.isBigNumber = function(v2) {
    if (!v2 || v2._isBigNumber !== true)
      return false;
    if (!BigNumber2.DEBUG)
      return true;
    var i2, n3, c4 = v2.c, e2 = v2.e, s2 = v2.s;
    out:
      if ({}.toString.call(c4) == "[object Array]") {
        if ((s2 === 1 || s2 === -1) && e2 >= -MAX && e2 <= MAX && e2 === mathfloor(e2)) {
          if (c4[0] === 0) {
            if (e2 === 0 && c4.length === 1)
              return true;
            break out;
          }
          i2 = (e2 + 1) % LOG_BASE;
          if (i2 < 1)
            i2 += LOG_BASE;
          if (String(c4[0]).length == i2) {
            for (i2 = 0; i2 < c4.length; i2++) {
              n3 = c4[i2];
              if (n3 < 0 || n3 >= BASE || n3 !== mathfloor(n3))
                break out;
            }
            if (n3 !== 0)
              return true;
          }
        }
      } else if (c4 === null && e2 === null && (s2 === null || s2 === 1 || s2 === -1)) {
        return true;
      }
    throw Error(bignumberError + "Invalid BigNumber: " + v2);
  };
  BigNumber2.maximum = BigNumber2.max = function() {
    return maxOrMin(arguments, -1);
  };
  BigNumber2.minimum = BigNumber2.min = function() {
    return maxOrMin(arguments, 1);
  };
  BigNumber2.random = function() {
    var pow2_53 = 9007199254740992;
    var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
      return mathfloor(Math.random() * pow2_53);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(dp) {
      var a3, b4, e2, k4, v2, i2 = 0, c4 = [], rand = new BigNumber2(ONE);
      if (dp == null)
        dp = DECIMAL_PLACES;
      else
        intCheck(dp, 0, MAX);
      k4 = mathceil(dp / LOG_BASE);
      if (CRYPTO) {
        if (crypto.getRandomValues) {
          a3 = crypto.getRandomValues(new Uint32Array(k4 *= 2));
          for (; i2 < k4; ) {
            v2 = a3[i2] * 131072 + (a3[i2 + 1] >>> 11);
            if (v2 >= 9e15) {
              b4 = crypto.getRandomValues(new Uint32Array(2));
              a3[i2] = b4[0];
              a3[i2 + 1] = b4[1];
            } else {
              c4.push(v2 % 1e14);
              i2 += 2;
            }
          }
          i2 = k4 / 2;
        } else if (crypto.randomBytes) {
          a3 = crypto.randomBytes(k4 *= 7);
          for (; i2 < k4; ) {
            v2 = (a3[i2] & 31) * 281474976710656 + a3[i2 + 1] * 1099511627776 + a3[i2 + 2] * 4294967296 + a3[i2 + 3] * 16777216 + (a3[i2 + 4] << 16) + (a3[i2 + 5] << 8) + a3[i2 + 6];
            if (v2 >= 9e15) {
              crypto.randomBytes(7).copy(a3, i2);
            } else {
              c4.push(v2 % 1e14);
              i2 += 7;
            }
          }
          i2 = k4 / 7;
        } else {
          CRYPTO = false;
          throw Error(bignumberError + "crypto unavailable");
        }
      }
      if (!CRYPTO) {
        for (; i2 < k4; ) {
          v2 = random53bitInt();
          if (v2 < 9e15)
            c4[i2++] = v2 % 1e14;
        }
      }
      k4 = c4[--i2];
      dp %= LOG_BASE;
      if (k4 && dp) {
        v2 = POWS_TEN[LOG_BASE - dp];
        c4[i2] = mathfloor(k4 / v2) * v2;
      }
      for (; c4[i2] === 0; c4.pop(), i2--)
        ;
      if (i2 < 0) {
        c4 = [e2 = 0];
      } else {
        for (e2 = -1; c4[0] === 0; c4.splice(0, 1), e2 -= LOG_BASE)
          ;
        for (i2 = 1, v2 = c4[0]; v2 >= 10; v2 /= 10, i2++)
          ;
        if (i2 < LOG_BASE)
          e2 -= LOG_BASE - i2;
      }
      rand.e = e2;
      rand.c = c4;
      return rand;
    };
  }();
  BigNumber2.sum = function() {
    var i2 = 1, args = arguments, sum = new BigNumber2(args[0]);
    for (; i2 < args.length; )
      sum = sum.plus(args[i2++]);
    return sum;
  };
  convertBase = /* @__PURE__ */ function() {
    var decimal = "0123456789";
    function toBaseOut(str, baseIn, baseOut, alphabet2) {
      var j2, arr = [0], arrL, i2 = 0, len = str.length;
      for (; i2 < len; ) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
          ;
        arr[0] += alphabet2.indexOf(str.charAt(i2++));
        for (j2 = 0; j2 < arr.length; j2++) {
          if (arr[j2] > baseOut - 1) {
            if (arr[j2 + 1] == null)
              arr[j2 + 1] = 0;
            arr[j2 + 1] += arr[j2] / baseOut | 0;
            arr[j2] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    return function(str, baseIn, baseOut, sign2, callerIsToString) {
      var alphabet2, d3, e2, k4, r, x3, xc, y4, i2 = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
      if (i2 >= 0) {
        k4 = POW_PRECISION;
        POW_PRECISION = 0;
        str = str.replace(".", "");
        y4 = new BigNumber2(baseIn);
        x3 = y4.pow(str.length - i2);
        POW_PRECISION = k4;
        y4.c = toBaseOut(
          toFixedPoint(coeffToString(x3.c), x3.e, "0"),
          10,
          baseOut,
          decimal
        );
        y4.e = y4.c.length;
      }
      xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet2 = ALPHABET, decimal) : (alphabet2 = decimal, ALPHABET));
      e2 = k4 = xc.length;
      for (; xc[--k4] == 0; xc.pop())
        ;
      if (!xc[0])
        return alphabet2.charAt(0);
      if (i2 < 0) {
        --e2;
      } else {
        x3.c = xc;
        x3.e = e2;
        x3.s = sign2;
        x3 = div(x3, y4, dp, rm, baseOut);
        xc = x3.c;
        r = x3.r;
        e2 = x3.e;
      }
      d3 = e2 + dp + 1;
      i2 = xc[d3];
      k4 = baseOut / 2;
      r = r || d3 < 0 || xc[d3 + 1] != null;
      r = rm < 4 ? (i2 != null || r) && (rm == 0 || rm == (x3.s < 0 ? 3 : 2)) : i2 > k4 || i2 == k4 && (rm == 4 || r || rm == 6 && xc[d3 - 1] & 1 || rm == (x3.s < 0 ? 8 : 7));
      if (d3 < 1 || !xc[0]) {
        str = r ? toFixedPoint(alphabet2.charAt(1), -dp, alphabet2.charAt(0)) : alphabet2.charAt(0);
      } else {
        xc.length = d3;
        if (r) {
          for (--baseOut; ++xc[--d3] > baseOut; ) {
            xc[d3] = 0;
            if (!d3) {
              ++e2;
              xc = [1].concat(xc);
            }
          }
        }
        for (k4 = xc.length; !xc[--k4]; )
          ;
        for (i2 = 0, str = ""; i2 <= k4; str += alphabet2.charAt(xc[i2++]))
          ;
        str = toFixedPoint(str, e2, alphabet2.charAt(0));
      }
      return str;
    };
  }();
  div = /* @__PURE__ */ function() {
    function multiply(x3, k4, base3) {
      var m3, temp, xlo, xhi, carry = 0, i2 = x3.length, klo = k4 % SQRT_BASE, khi = k4 / SQRT_BASE | 0;
      for (x3 = x3.slice(); i2--; ) {
        xlo = x3[i2] % SQRT_BASE;
        xhi = x3[i2] / SQRT_BASE | 0;
        m3 = khi * xlo + xhi * klo;
        temp = klo * xlo + m3 % SQRT_BASE * SQRT_BASE + carry;
        carry = (temp / base3 | 0) + (m3 / SQRT_BASE | 0) + khi * xhi;
        x3[i2] = temp % base3;
      }
      if (carry)
        x3 = [carry].concat(x3);
      return x3;
    }
    function compare3(a3, b4, aL, bL) {
      var i2, cmp;
      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {
        for (i2 = cmp = 0; i2 < aL; i2++) {
          if (a3[i2] != b4[i2]) {
            cmp = a3[i2] > b4[i2] ? 1 : -1;
            break;
          }
        }
      }
      return cmp;
    }
    function subtract(a3, b4, aL, base3) {
      var i2 = 0;
      for (; aL--; ) {
        a3[aL] -= i2;
        i2 = a3[aL] < b4[aL] ? 1 : 0;
        a3[aL] = i2 * base3 + a3[aL] - b4[aL];
      }
      for (; !a3[0] && a3.length > 1; a3.splice(0, 1))
        ;
    }
    return function(x3, y4, dp, rm, base3) {
      var cmp, e2, i2, more, n3, prod, prodL, q2, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s2 = x3.s == y4.s ? 1 : -1, xc = x3.c, yc = y4.c;
      if (!xc || !xc[0] || !yc || !yc[0]) {
        return new BigNumber2(
          // Return NaN if either NaN, or both Infinity or 0.
          !x3.s || !y4.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            xc && xc[0] == 0 || !yc ? s2 * 0 : s2 / 0
          )
        );
      }
      q2 = new BigNumber2(s2);
      qc = q2.c = [];
      e2 = x3.e - y4.e;
      s2 = dp + e2 + 1;
      if (!base3) {
        base3 = BASE;
        e2 = bitFloor(x3.e / LOG_BASE) - bitFloor(y4.e / LOG_BASE);
        s2 = s2 / LOG_BASE | 0;
      }
      for (i2 = 0; yc[i2] == (xc[i2] || 0); i2++)
        ;
      if (yc[i2] > (xc[i2] || 0))
        e2--;
      if (s2 < 0) {
        qc.push(1);
        more = true;
      } else {
        xL = xc.length;
        yL = yc.length;
        i2 = 0;
        s2 += 2;
        n3 = mathfloor(base3 / (yc[0] + 1));
        if (n3 > 1) {
          yc = multiply(yc, n3, base3);
          xc = multiply(xc, n3, base3);
          yL = yc.length;
          xL = xc.length;
        }
        xi = yL;
        rem = xc.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; rem[remL++] = 0)
          ;
        yz = yc.slice();
        yz = [0].concat(yz);
        yc0 = yc[0];
        if (yc[1] >= base3 / 2)
          yc0++;
        do {
          n3 = 0;
          cmp = compare3(yc, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base3 + (rem[1] || 0);
            n3 = mathfloor(rem0 / yc0);
            if (n3 > 1) {
              if (n3 >= base3)
                n3 = base3 - 1;
              prod = multiply(yc, n3, base3);
              prodL = prod.length;
              remL = rem.length;
              while (compare3(prod, rem, prodL, remL) == 1) {
                n3--;
                subtract(prod, yL < prodL ? yz : yc, prodL, base3);
                prodL = prod.length;
                cmp = 1;
              }
            } else {
              if (n3 == 0) {
                cmp = n3 = 1;
              }
              prod = yc.slice();
              prodL = prod.length;
            }
            if (prodL < remL)
              prod = [0].concat(prod);
            subtract(rem, prod, remL, base3);
            remL = rem.length;
            if (cmp == -1) {
              while (compare3(yc, rem, yL, remL) < 1) {
                n3++;
                subtract(rem, yL < remL ? yz : yc, remL, base3);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n3++;
            rem = [0];
          }
          qc[i2++] = n3;
          if (rem[0]) {
            rem[remL++] = xc[xi] || 0;
          } else {
            rem = [xc[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] != null) && s2--);
        more = rem[0] != null;
        if (!qc[0])
          qc.splice(0, 1);
      }
      if (base3 == BASE) {
        for (i2 = 1, s2 = qc[0]; s2 >= 10; s2 /= 10, i2++)
          ;
        round(q2, dp + (q2.e = i2 + e2 * LOG_BASE - 1) + 1, rm, more);
      } else {
        q2.e = e2;
        q2.r = +more;
      }
      return q2;
    };
  }();
  function format(n3, i2, rm, id) {
    var c0, e2, ne, len, str;
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    if (!n3.c)
      return n3.toString();
    c0 = n3.c[0];
    ne = n3.e;
    if (i2 == null) {
      str = coeffToString(n3.c);
      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
    } else {
      n3 = round(new BigNumber2(n3), i2, rm);
      e2 = n3.e;
      str = coeffToString(n3.c);
      len = str.length;
      if (id == 1 || id == 2 && (i2 <= e2 || e2 <= TO_EXP_NEG)) {
        for (; len < i2; str += "0", len++)
          ;
        str = toExponential(str, e2);
      } else {
        i2 -= ne;
        str = toFixedPoint(str, e2, "0");
        if (e2 + 1 > len) {
          if (--i2 > 0)
            for (str += "."; i2--; str += "0")
              ;
        } else {
          i2 += e2 - len;
          if (i2 > 0) {
            if (e2 + 1 == len)
              str += ".";
            for (; i2--; str += "0")
              ;
          }
        }
      }
    }
    return n3.s < 0 && c0 ? "-" + str : str;
  }
  function maxOrMin(args, n3) {
    var k4, y4, i2 = 1, x3 = new BigNumber2(args[0]);
    for (; i2 < args.length; i2++) {
      y4 = new BigNumber2(args[i2]);
      if (!y4.s || (k4 = compare2(x3, y4)) === n3 || k4 === 0 && x3.s === n3) {
        x3 = y4;
      }
    }
    return x3;
  }
  function normalise(n3, c4, e2) {
    var i2 = 1, j2 = c4.length;
    for (; !c4[--j2]; c4.pop())
      ;
    for (j2 = c4[0]; j2 >= 10; j2 /= 10, i2++)
      ;
    if ((e2 = i2 + e2 * LOG_BASE - 1) > MAX_EXP) {
      n3.c = n3.e = null;
    } else if (e2 < MIN_EXP) {
      n3.c = [n3.e = 0];
    } else {
      n3.e = e2;
      n3.c = c4;
    }
    return n3;
  }
  parseNumeric = /* @__PURE__ */ function() {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(x3, str, isNum, b4) {
      var base3, s2 = isNum ? str : str.replace(whitespaceOrPlus, "");
      if (isInfinityOrNaN.test(s2)) {
        x3.s = isNaN(s2) ? null : s2 < 0 ? -1 : 1;
      } else {
        if (!isNum) {
          s2 = s2.replace(basePrefix, function(m3, p1, p22) {
            base3 = (p22 = p22.toLowerCase()) == "x" ? 16 : p22 == "b" ? 2 : 8;
            return !b4 || b4 == base3 ? p1 : m3;
          });
          if (b4) {
            base3 = b4;
            s2 = s2.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
          }
          if (str != s2)
            return new BigNumber2(s2, base3);
        }
        if (BigNumber2.DEBUG) {
          throw Error(bignumberError + "Not a" + (b4 ? " base " + b4 : "") + " number: " + str);
        }
        x3.s = null;
      }
      x3.c = x3.e = null;
    };
  }();
  function round(x3, sd, rm, r) {
    var d3, i2, j2, k4, n3, ni, rd, xc = x3.c, pows10 = POWS_TEN;
    if (xc) {
      out: {
        for (d3 = 1, k4 = xc[0]; k4 >= 10; k4 /= 10, d3++)
          ;
        i2 = sd - d3;
        if (i2 < 0) {
          i2 += LOG_BASE;
          j2 = sd;
          n3 = xc[ni = 0];
          rd = mathfloor(n3 / pows10[d3 - j2 - 1] % 10);
        } else {
          ni = mathceil((i2 + 1) / LOG_BASE);
          if (ni >= xc.length) {
            if (r) {
              for (; xc.length <= ni; xc.push(0))
                ;
              n3 = rd = 0;
              d3 = 1;
              i2 %= LOG_BASE;
              j2 = i2 - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n3 = k4 = xc[ni];
            for (d3 = 1; k4 >= 10; k4 /= 10, d3++)
              ;
            i2 %= LOG_BASE;
            j2 = i2 - LOG_BASE + d3;
            rd = j2 < 0 ? 0 : mathfloor(n3 / pows10[d3 - j2 - 1] % 10);
          }
        }
        r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        xc[ni + 1] != null || (j2 < 0 ? n3 : n3 % pows10[d3 - j2 - 1]);
        r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x3.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (i2 > 0 ? j2 > 0 ? n3 / pows10[d3 - j2] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x3.s < 0 ? 8 : 7));
        if (sd < 1 || !xc[0]) {
          xc.length = 0;
          if (r) {
            sd -= x3.e + 1;
            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x3.e = -sd || 0;
          } else {
            xc[0] = x3.e = 0;
          }
          return x3;
        }
        if (i2 == 0) {
          xc.length = ni;
          k4 = 1;
          ni--;
        } else {
          xc.length = ni + 1;
          k4 = pows10[LOG_BASE - i2];
          xc[ni] = j2 > 0 ? mathfloor(n3 / pows10[d3 - j2] % pows10[j2]) * k4 : 0;
        }
        if (r) {
          for (; ; ) {
            if (ni == 0) {
              for (i2 = 1, j2 = xc[0]; j2 >= 10; j2 /= 10, i2++)
                ;
              j2 = xc[0] += k4;
              for (k4 = 1; j2 >= 10; j2 /= 10, k4++)
                ;
              if (i2 != k4) {
                x3.e++;
                if (xc[0] == BASE)
                  xc[0] = 1;
              }
              break;
            } else {
              xc[ni] += k4;
              if (xc[ni] != BASE)
                break;
              xc[ni--] = 0;
              k4 = 1;
            }
          }
        }
        for (i2 = xc.length; xc[--i2] === 0; xc.pop())
          ;
      }
      if (x3.e > MAX_EXP) {
        x3.c = x3.e = null;
      } else if (x3.e < MIN_EXP) {
        x3.c = [x3.e = 0];
      }
    }
    return x3;
  }
  function valueOf(n3) {
    var str, e2 = n3.e;
    if (e2 === null)
      return n3.toString();
    str = coeffToString(n3.c);
    str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(str, e2) : toFixedPoint(str, e2, "0");
    return n3.s < 0 ? "-" + str : str;
  }
  P2.absoluteValue = P2.abs = function() {
    var x3 = new BigNumber2(this);
    if (x3.s < 0)
      x3.s = 1;
    return x3;
  };
  P2.comparedTo = function(y4, b4) {
    return compare2(this, new BigNumber2(y4, b4));
  };
  P2.decimalPlaces = P2.dp = function(dp, rm) {
    var c4, n3, v2, x3 = this;
    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(new BigNumber2(x3), dp + x3.e + 1, rm);
    }
    if (!(c4 = x3.c))
      return null;
    n3 = ((v2 = c4.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
    if (v2 = c4[v2])
      for (; v2 % 10 == 0; v2 /= 10, n3--)
        ;
    if (n3 < 0)
      n3 = 0;
    return n3;
  };
  P2.dividedBy = P2.div = function(y4, b4) {
    return div(this, new BigNumber2(y4, b4), DECIMAL_PLACES, ROUNDING_MODE);
  };
  P2.dividedToIntegerBy = P2.idiv = function(y4, b4) {
    return div(this, new BigNumber2(y4, b4), 0, 1);
  };
  P2.exponentiatedBy = P2.pow = function(n3, m3) {
    var half, isModExp, i2, k4, more, nIsBig, nIsNeg, nIsOdd, y4, x3 = this;
    n3 = new BigNumber2(n3);
    if (n3.c && !n3.isInteger()) {
      throw Error(bignumberError + "Exponent not an integer: " + valueOf(n3));
    }
    if (m3 != null)
      m3 = new BigNumber2(m3);
    nIsBig = n3.e > 14;
    if (!x3.c || !x3.c[0] || x3.c[0] == 1 && !x3.e && x3.c.length == 1 || !n3.c || !n3.c[0]) {
      y4 = new BigNumber2(Math.pow(+valueOf(x3), nIsBig ? n3.s * (2 - isOdd(n3)) : +valueOf(n3)));
      return m3 ? y4.mod(m3) : y4;
    }
    nIsNeg = n3.s < 0;
    if (m3) {
      if (m3.c ? !m3.c[0] : !m3.s)
        return new BigNumber2(NaN);
      isModExp = !nIsNeg && x3.isInteger() && m3.isInteger();
      if (isModExp)
        x3 = x3.mod(m3);
    } else if (n3.e > 9 && (x3.e > 0 || x3.e < -1 || (x3.e == 0 ? x3.c[0] > 1 || nIsBig && x3.c[1] >= 24e7 : x3.c[0] < 8e13 || nIsBig && x3.c[0] <= 9999975e7))) {
      k4 = x3.s < 0 && isOdd(n3) ? -0 : 0;
      if (x3.e > -1)
        k4 = 1 / k4;
      return new BigNumber2(nIsNeg ? 1 / k4 : k4);
    } else if (POW_PRECISION) {
      k4 = mathceil(POW_PRECISION / LOG_BASE + 2);
    }
    if (nIsBig) {
      half = new BigNumber2(0.5);
      if (nIsNeg)
        n3.s = 1;
      nIsOdd = isOdd(n3);
    } else {
      i2 = Math.abs(+valueOf(n3));
      nIsOdd = i2 % 2;
    }
    y4 = new BigNumber2(ONE);
    for (; ; ) {
      if (nIsOdd) {
        y4 = y4.times(x3);
        if (!y4.c)
          break;
        if (k4) {
          if (y4.c.length > k4)
            y4.c.length = k4;
        } else if (isModExp) {
          y4 = y4.mod(m3);
        }
      }
      if (i2) {
        i2 = mathfloor(i2 / 2);
        if (i2 === 0)
          break;
        nIsOdd = i2 % 2;
      } else {
        n3 = n3.times(half);
        round(n3, n3.e + 1, 1);
        if (n3.e > 14) {
          nIsOdd = isOdd(n3);
        } else {
          i2 = +valueOf(n3);
          if (i2 === 0)
            break;
          nIsOdd = i2 % 2;
        }
      }
      x3 = x3.times(x3);
      if (k4) {
        if (x3.c && x3.c.length > k4)
          x3.c.length = k4;
      } else if (isModExp) {
        x3 = x3.mod(m3);
      }
    }
    if (isModExp)
      return y4;
    if (nIsNeg)
      y4 = ONE.div(y4);
    return m3 ? y4.mod(m3) : k4 ? round(y4, POW_PRECISION, ROUNDING_MODE, more) : y4;
  };
  P2.integerValue = function(rm) {
    var n3 = new BigNumber2(this);
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    return round(n3, n3.e + 1, rm);
  };
  P2.isEqualTo = P2.eq = function(y4, b4) {
    return compare2(this, new BigNumber2(y4, b4)) === 0;
  };
  P2.isFinite = function() {
    return !!this.c;
  };
  P2.isGreaterThan = P2.gt = function(y4, b4) {
    return compare2(this, new BigNumber2(y4, b4)) > 0;
  };
  P2.isGreaterThanOrEqualTo = P2.gte = function(y4, b4) {
    return (b4 = compare2(this, new BigNumber2(y4, b4))) === 1 || b4 === 0;
  };
  P2.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };
  P2.isLessThan = P2.lt = function(y4, b4) {
    return compare2(this, new BigNumber2(y4, b4)) < 0;
  };
  P2.isLessThanOrEqualTo = P2.lte = function(y4, b4) {
    return (b4 = compare2(this, new BigNumber2(y4, b4))) === -1 || b4 === 0;
  };
  P2.isNaN = function() {
    return !this.s;
  };
  P2.isNegative = function() {
    return this.s < 0;
  };
  P2.isPositive = function() {
    return this.s > 0;
  };
  P2.isZero = function() {
    return !!this.c && this.c[0] == 0;
  };
  P2.minus = function(y4, b4) {
    var i2, j2, t, xLTy, x3 = this, a3 = x3.s;
    y4 = new BigNumber2(y4, b4);
    b4 = y4.s;
    if (!a3 || !b4)
      return new BigNumber2(NaN);
    if (a3 != b4) {
      y4.s = -b4;
      return x3.plus(y4);
    }
    var xe = x3.e / LOG_BASE, ye = y4.e / LOG_BASE, xc = x3.c, yc = y4.c;
    if (!xe || !ye) {
      if (!xc || !yc)
        return xc ? (y4.s = -b4, y4) : new BigNumber2(yc ? x3 : NaN);
      if (!xc[0] || !yc[0]) {
        return yc[0] ? (y4.s = -b4, y4) : new BigNumber2(xc[0] ? x3 : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ROUNDING_MODE == 3 ? -0 : 0
        ));
      }
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a3 = xe - ye) {
      if (xLTy = a3 < 0) {
        a3 = -a3;
        t = xc;
      } else {
        ye = xe;
        t = yc;
      }
      t.reverse();
      for (b4 = a3; b4--; t.push(0))
        ;
      t.reverse();
    } else {
      j2 = (xLTy = (a3 = xc.length) < (b4 = yc.length)) ? a3 : b4;
      for (a3 = b4 = 0; b4 < j2; b4++) {
        if (xc[b4] != yc[b4]) {
          xLTy = xc[b4] < yc[b4];
          break;
        }
      }
    }
    if (xLTy) {
      t = xc;
      xc = yc;
      yc = t;
      y4.s = -y4.s;
    }
    b4 = (j2 = yc.length) - (i2 = xc.length);
    if (b4 > 0)
      for (; b4--; xc[i2++] = 0)
        ;
    b4 = BASE - 1;
    for (; j2 > a3; ) {
      if (xc[--j2] < yc[j2]) {
        for (i2 = j2; i2 && !xc[--i2]; xc[i2] = b4)
          ;
        --xc[i2];
        xc[j2] += BASE;
      }
      xc[j2] -= yc[j2];
    }
    for (; xc[0] == 0; xc.splice(0, 1), --ye)
      ;
    if (!xc[0]) {
      y4.s = ROUNDING_MODE == 3 ? -1 : 1;
      y4.c = [y4.e = 0];
      return y4;
    }
    return normalise(y4, xc, ye);
  };
  P2.modulo = P2.mod = function(y4, b4) {
    var q2, s2, x3 = this;
    y4 = new BigNumber2(y4, b4);
    if (!x3.c || !y4.s || y4.c && !y4.c[0]) {
      return new BigNumber2(NaN);
    } else if (!y4.c || x3.c && !x3.c[0]) {
      return new BigNumber2(x3);
    }
    if (MODULO_MODE == 9) {
      s2 = y4.s;
      y4.s = 1;
      q2 = div(x3, y4, 0, 3);
      y4.s = s2;
      q2.s *= s2;
    } else {
      q2 = div(x3, y4, 0, MODULO_MODE);
    }
    y4 = x3.minus(q2.times(y4));
    if (!y4.c[0] && MODULO_MODE == 1)
      y4.s = x3.s;
    return y4;
  };
  P2.multipliedBy = P2.times = function(y4, b4) {
    var c4, e2, i2, j2, k4, m3, xcL, xlo, xhi, ycL, ylo, yhi, zc, base3, sqrtBase, x3 = this, xc = x3.c, yc = (y4 = new BigNumber2(y4, b4)).c;
    if (!xc || !yc || !xc[0] || !yc[0]) {
      if (!x3.s || !y4.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
        y4.c = y4.e = y4.s = null;
      } else {
        y4.s *= x3.s;
        if (!xc || !yc) {
          y4.c = y4.e = null;
        } else {
          y4.c = [0];
          y4.e = 0;
        }
      }
      return y4;
    }
    e2 = bitFloor(x3.e / LOG_BASE) + bitFloor(y4.e / LOG_BASE);
    y4.s *= x3.s;
    xcL = xc.length;
    ycL = yc.length;
    if (xcL < ycL) {
      zc = xc;
      xc = yc;
      yc = zc;
      i2 = xcL;
      xcL = ycL;
      ycL = i2;
    }
    for (i2 = xcL + ycL, zc = []; i2--; zc.push(0))
      ;
    base3 = BASE;
    sqrtBase = SQRT_BASE;
    for (i2 = ycL; --i2 >= 0; ) {
      c4 = 0;
      ylo = yc[i2] % sqrtBase;
      yhi = yc[i2] / sqrtBase | 0;
      for (k4 = xcL, j2 = i2 + k4; j2 > i2; ) {
        xlo = xc[--k4] % sqrtBase;
        xhi = xc[k4] / sqrtBase | 0;
        m3 = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + m3 % sqrtBase * sqrtBase + zc[j2] + c4;
        c4 = (xlo / base3 | 0) + (m3 / sqrtBase | 0) + yhi * xhi;
        zc[j2--] = xlo % base3;
      }
      zc[j2] = c4;
    }
    if (c4) {
      ++e2;
    } else {
      zc.splice(0, 1);
    }
    return normalise(y4, zc, e2);
  };
  P2.negated = function() {
    var x3 = new BigNumber2(this);
    x3.s = -x3.s || null;
    return x3;
  };
  P2.plus = function(y4, b4) {
    var t, x3 = this, a3 = x3.s;
    y4 = new BigNumber2(y4, b4);
    b4 = y4.s;
    if (!a3 || !b4)
      return new BigNumber2(NaN);
    if (a3 != b4) {
      y4.s = -b4;
      return x3.minus(y4);
    }
    var xe = x3.e / LOG_BASE, ye = y4.e / LOG_BASE, xc = x3.c, yc = y4.c;
    if (!xe || !ye) {
      if (!xc || !yc)
        return new BigNumber2(a3 / 0);
      if (!xc[0] || !yc[0])
        return yc[0] ? y4 : new BigNumber2(xc[0] ? x3 : a3 * 0);
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a3 = xe - ye) {
      if (a3 > 0) {
        ye = xe;
        t = yc;
      } else {
        a3 = -a3;
        t = xc;
      }
      t.reverse();
      for (; a3--; t.push(0))
        ;
      t.reverse();
    }
    a3 = xc.length;
    b4 = yc.length;
    if (a3 - b4 < 0) {
      t = yc;
      yc = xc;
      xc = t;
      b4 = a3;
    }
    for (a3 = 0; b4; ) {
      a3 = (xc[--b4] = xc[b4] + yc[b4] + a3) / BASE | 0;
      xc[b4] = BASE === xc[b4] ? 0 : xc[b4] % BASE;
    }
    if (a3) {
      xc = [a3].concat(xc);
      ++ye;
    }
    return normalise(y4, xc, ye);
  };
  P2.precision = P2.sd = function(sd, rm) {
    var c4, n3, v2, x3 = this;
    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(new BigNumber2(x3), sd, rm);
    }
    if (!(c4 = x3.c))
      return null;
    v2 = c4.length - 1;
    n3 = v2 * LOG_BASE + 1;
    if (v2 = c4[v2]) {
      for (; v2 % 10 == 0; v2 /= 10, n3--)
        ;
      for (v2 = c4[0]; v2 >= 10; v2 /= 10, n3++)
        ;
    }
    if (sd && x3.e + 1 > n3)
      n3 = x3.e + 1;
    return n3;
  };
  P2.shiftedBy = function(k4) {
    intCheck(k4, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times("1e" + k4);
  };
  P2.squareRoot = P2.sqrt = function() {
    var m3, n3, r, rep, t, x3 = this, c4 = x3.c, s2 = x3.s, e2 = x3.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
    if (s2 !== 1 || !c4 || !c4[0]) {
      return new BigNumber2(!s2 || s2 < 0 && (!c4 || c4[0]) ? NaN : c4 ? x3 : 1 / 0);
    }
    s2 = Math.sqrt(+valueOf(x3));
    if (s2 == 0 || s2 == 1 / 0) {
      n3 = coeffToString(c4);
      if ((n3.length + e2) % 2 == 0)
        n3 += "0";
      s2 = Math.sqrt(+n3);
      e2 = bitFloor((e2 + 1) / 2) - (e2 < 0 || e2 % 2);
      if (s2 == 1 / 0) {
        n3 = "5e" + e2;
      } else {
        n3 = s2.toExponential();
        n3 = n3.slice(0, n3.indexOf("e") + 1) + e2;
      }
      r = new BigNumber2(n3);
    } else {
      r = new BigNumber2(s2 + "");
    }
    if (r.c[0]) {
      e2 = r.e;
      s2 = e2 + dp;
      if (s2 < 3)
        s2 = 0;
      for (; ; ) {
        t = r;
        r = half.times(t.plus(div(x3, t, dp, 1)));
        if (coeffToString(t.c).slice(0, s2) === (n3 = coeffToString(r.c)).slice(0, s2)) {
          if (r.e < e2)
            --s2;
          n3 = n3.slice(s2 - 3, s2 + 1);
          if (n3 == "9999" || !rep && n3 == "4999") {
            if (!rep) {
              round(t, t.e + DECIMAL_PLACES + 2, 0);
              if (t.times(t).eq(x3)) {
                r = t;
                break;
              }
            }
            dp += 4;
            s2 += 4;
            rep = 1;
          } else {
            if (!+n3 || !+n3.slice(1) && n3.charAt(0) == "5") {
              round(r, r.e + DECIMAL_PLACES + 2, 1);
              m3 = !r.times(r).eq(x3);
            }
            break;
          }
        }
      }
    }
    return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m3);
  };
  P2.toExponential = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format(this, dp, rm, 1);
  };
  P2.toFixed = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format(this, dp, rm);
  };
  P2.toFormat = function(dp, rm, format2) {
    var str, x3 = this;
    if (format2 == null) {
      if (dp != null && rm && typeof rm == "object") {
        format2 = rm;
        rm = null;
      } else if (dp && typeof dp == "object") {
        format2 = dp;
        dp = rm = null;
      } else {
        format2 = FORMAT;
      }
    } else if (typeof format2 != "object") {
      throw Error(bignumberError + "Argument not an object: " + format2);
    }
    str = x3.toFixed(dp, rm);
    if (x3.c) {
      var i2, arr = str.split("."), g1 = +format2.groupSize, g22 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x3.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
      if (g22) {
        i2 = g1;
        g1 = g22;
        g22 = i2;
        len -= i2;
      }
      if (g1 > 0 && len > 0) {
        i2 = len % g1 || g1;
        intPart = intDigits.substr(0, i2);
        for (; i2 < len; i2 += g1)
          intPart += groupSeparator + intDigits.substr(i2, g1);
        if (g22 > 0)
          intPart += groupSeparator + intDigits.slice(i2);
        if (isNeg)
          intPart = "-" + intPart;
      }
      str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g22 = +format2.fractionGroupSize) ? fractionPart.replace(
        new RegExp("\\d{" + g22 + "}\\B", "g"),
        "$&" + (format2.fractionGroupSeparator || "")
      ) : fractionPart) : intPart;
    }
    return (format2.prefix || "") + str + (format2.suffix || "");
  };
  P2.toFraction = function(md) {
    var d3, d0, d1, d22, e2, exp, n3, n0, n1, q2, r, s2, x3 = this, xc = x3.c;
    if (md != null) {
      n3 = new BigNumber2(md);
      if (!n3.isInteger() && (n3.c || n3.s !== 1) || n3.lt(ONE)) {
        throw Error(bignumberError + "Argument " + (n3.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n3));
      }
    }
    if (!xc)
      return new BigNumber2(x3);
    d3 = new BigNumber2(ONE);
    n1 = d0 = new BigNumber2(ONE);
    d1 = n0 = new BigNumber2(ONE);
    s2 = coeffToString(xc);
    e2 = d3.e = s2.length - x3.e - 1;
    d3.c[0] = POWS_TEN[(exp = e2 % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
    md = !md || n3.comparedTo(d3) > 0 ? e2 > 0 ? d3 : n1 : n3;
    exp = MAX_EXP;
    MAX_EXP = 1 / 0;
    n3 = new BigNumber2(s2);
    n0.c[0] = 0;
    for (; ; ) {
      q2 = div(n3, d3, 0, 1);
      d22 = d0.plus(q2.times(d1));
      if (d22.comparedTo(md) == 1)
        break;
      d0 = d1;
      d1 = d22;
      n1 = n0.plus(q2.times(d22 = n1));
      n0 = d22;
      d3 = n3.minus(q2.times(d22 = d3));
      n3 = d22;
    }
    d22 = div(md.minus(d0), d1, 0, 1);
    n0 = n0.plus(d22.times(n1));
    d0 = d0.plus(d22.times(d1));
    n0.s = n1.s = x3.s;
    e2 = e2 * 2;
    r = div(n1, d1, e2, ROUNDING_MODE).minus(x3).abs().comparedTo(
      div(n0, d0, e2, ROUNDING_MODE).minus(x3).abs()
    ) < 1 ? [n1, d1] : [n0, d0];
    MAX_EXP = exp;
    return r;
  };
  P2.toNumber = function() {
    return +valueOf(this);
  };
  P2.toPrecision = function(sd, rm) {
    if (sd != null)
      intCheck(sd, 1, MAX);
    return format(this, sd, rm, 2);
  };
  P2.toString = function(b4) {
    var str, n3 = this, s2 = n3.s, e2 = n3.e;
    if (e2 === null) {
      if (s2) {
        str = "Infinity";
        if (s2 < 0)
          str = "-" + str;
      } else {
        str = "NaN";
      }
    } else {
      if (b4 == null) {
        str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(coeffToString(n3.c), e2) : toFixedPoint(coeffToString(n3.c), e2, "0");
      } else if (b4 === 10 && alphabetHasNormalDecimalDigits) {
        n3 = round(new BigNumber2(n3), DECIMAL_PLACES + e2 + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n3.c), n3.e, "0");
      } else {
        intCheck(b4, 2, ALPHABET.length, "Base");
        str = convertBase(toFixedPoint(coeffToString(n3.c), e2, "0"), 10, b4, s2, true);
      }
      if (s2 < 0 && n3.c[0])
        str = "-" + str;
    }
    return str;
  };
  P2.valueOf = P2.toJSON = function() {
    return valueOf(this);
  };
  P2._isBigNumber = true;
  P2[Symbol.toStringTag] = "BigNumber";
  P2[Symbol.for("nodejs.util.inspect.custom")] = P2.valueOf;
  if (configObject != null)
    BigNumber2.set(configObject);
  return BigNumber2;
}
function bitFloor(n3) {
  var i2 = n3 | 0;
  return n3 > 0 || n3 === i2 ? i2 : i2 - 1;
}
function coeffToString(a3) {
  var s2, z3, i2 = 1, j2 = a3.length, r = a3[0] + "";
  for (; i2 < j2; ) {
    s2 = a3[i2++] + "";
    z3 = LOG_BASE - s2.length;
    for (; z3--; s2 = "0" + s2)
      ;
    r += s2;
  }
  for (j2 = r.length; r.charCodeAt(--j2) === 48; )
    ;
  return r.slice(0, j2 + 1 || 1);
}
function compare2(x3, y4) {
  var a3, b4, xc = x3.c, yc = y4.c, i2 = x3.s, j2 = y4.s, k4 = x3.e, l4 = y4.e;
  if (!i2 || !j2)
    return null;
  a3 = xc && !xc[0];
  b4 = yc && !yc[0];
  if (a3 || b4)
    return a3 ? b4 ? 0 : -j2 : i2;
  if (i2 != j2)
    return i2;
  a3 = i2 < 0;
  b4 = k4 == l4;
  if (!xc || !yc)
    return b4 ? 0 : !xc ^ a3 ? 1 : -1;
  if (!b4)
    return k4 > l4 ^ a3 ? 1 : -1;
  j2 = (k4 = xc.length) < (l4 = yc.length) ? k4 : l4;
  for (i2 = 0; i2 < j2; i2++)
    if (xc[i2] != yc[i2])
      return xc[i2] > yc[i2] ^ a3 ? 1 : -1;
  return k4 == l4 ? 0 : k4 > l4 ^ a3 ? 1 : -1;
}
function intCheck(n3, min, max, name2) {
  if (n3 < min || n3 > max || n3 !== mathfloor(n3)) {
    throw Error(bignumberError + (name2 || "Argument") + (typeof n3 == "number" ? n3 < min || n3 > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n3));
  }
}
function isOdd(n3) {
  var k4 = n3.c.length - 1;
  return bitFloor(n3.e / LOG_BASE) == k4 && n3.c[k4] % 2 != 0;
}
function toExponential(str, e2) {
  return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e2 < 0 ? "e" : "e+") + e2;
}
function toFixedPoint(str, e2, z3) {
  var len, zs;
  if (e2 < 0) {
    for (zs = z3 + "."; ++e2; zs += z3)
      ;
    str = zs + str;
  } else {
    len = str.length;
    if (++e2 > len) {
      for (zs = z3, e2 -= len; --e2; zs += z3)
        ;
      str += zs;
    } else if (e2 < len) {
      str = str.slice(0, e2) + "." + str.slice(e2);
    }
  }
  return str;
}
var BigNumber = clone();
var bignumber_default = BigNumber;

// src/utils/amount.ts
bignumber_default.config({ ROUNDING_MODE: bignumber_default.ROUND_FLOOR });
var parseAmount = ({
  amount,
  decimals
}) => {
  if (decimals < 0)
    throw new Error("Decimal places shouldn't be negative number!");
  return BigInt(new bignumber_default(amount).shiftedBy(decimals).toFixed());
};
var formatAmount = ({
  amount,
  decimals,
  rounding = decimals
}) => {
  if (decimals < 0)
    throw new Error("Decimal places shouldn't be negative number!");
  return new bignumber_default(amount).shiftedBy(-decimals).decimalPlaces(rounding).toFixed();
};
var export_Account = import_account4.Account;
var export_Address = import_address4.Address;
var export_AddressType = import_address5.AddressType;
var export_AddressValue = import_address5.AddressValue;
var export_BigUIntType = import_numerical.BigUIntType;
var export_BigUIntValue = import_numerical.BigUIntValue;
var export_BooleanType = import_boolean.BooleanType;
var export_BooleanValue = import_boolean.BooleanValue;
var export_BytesType = import_bytes7.BytesType;
var export_BytesValue = import_bytes7.BytesValue;
var export_ContractQueryResponse = import_contractQueryResponse2.ContractQueryResponse;
var export_Message = import_message.Message;
var export_MessageComputer = import_message.MessageComputer;
var export_QueryArguments = import_interface.QueryArguments;
var export_SignableMessage = import_signableMessage2.SignableMessage;
var export_SmartContractTransactionsFactory = import_transactionsFactories.SmartContractTransactionsFactory;
var export_SmartContractTransactionsOutcomeParser = import_transactionsOutcomeParsers.SmartContractTransactionsOutcomeParser;
var export_Token = import_tokens.Token;
var export_TokenComputer = import_tokens.TokenComputer;
var export_TokenManagementTransactionsFactory = import_transactionsFactories.TokenManagementTransactionsFactory;
var export_TokenManagementTransactionsOutcomeParser = import_transactionsOutcomeParsers.TokenManagementTransactionsOutcomeParser;
var export_TokenOperationsFactory = import_tokenOperations.TokenOperationsFactory;
var export_TokenOperationsFactoryConfig = import_tokenOperations.TokenOperationsFactoryConfig;
var export_TokenOperationsOutcomeParser = import_tokenOperations.TokenOperationsOutcomeParser;
var export_TokenTransfer = import_tokens.TokenTransfer;
var export_Transaction = import_transaction3.Transaction;
var export_TransactionComputer = import_transactionComputer.TransactionComputer;
var export_TransactionEventsParser = import_transactionsOutcomeParsers.TransactionEventsParser;
var export_TransactionWatcher = import_transactionWatcher2.TransactionWatcher;
var export_TransactionsFactoryConfig = import_transactionsFactories.TransactionsFactoryConfig;
var export_TransferTransactionsFactory = import_transactionsFactories.TransferTransactionsFactory;
var export_U16Type = import_numerical.U16Type;
var export_U16Value = import_numerical.U16Value;
var export_U32Type = import_numerical.U32Type;
var export_U32Value = import_numerical.U32Value;
var export_U64Type = import_numerical.U64Type;
var export_U64Value = import_numerical.U64Value;
var export_U8Type = import_numerical.U8Type;
var export_U8Value = import_numerical.U8Value;
export {
  export_Account as Account,
  export_Address as Address,
  export_AddressType as AddressType,
  export_AddressValue as AddressValue,
  export_BigUIntType as BigUIntType,
  export_BigUIntValue as BigUIntValue,
  export_BooleanType as BooleanType,
  export_BooleanValue as BooleanValue,
  export_BytesType as BytesType,
  export_BytesValue as BytesValue,
  export_ContractQueryResponse as ContractQueryResponse,
  DappCoreWCV2CustomMethodsEnum,
  ElvenJS,
  EventStoreEvents,
  LoginMethodsEnum,
  export_Message as Message,
  export_MessageComputer as MessageComputer,
  export_QueryArguments as QueryArguments,
  export_SignableMessage as SignableMessage,
  export_SmartContractTransactionsFactory as SmartContractTransactionsFactory,
  export_SmartContractTransactionsOutcomeParser as SmartContractTransactionsOutcomeParser,
  export_Token as Token,
  export_TokenComputer as TokenComputer,
  export_TokenManagementTransactionsFactory as TokenManagementTransactionsFactory,
  export_TokenManagementTransactionsOutcomeParser as TokenManagementTransactionsOutcomeParser,
  export_TokenOperationsFactory as TokenOperationsFactory,
  export_TokenOperationsFactoryConfig as TokenOperationsFactoryConfig,
  export_TokenOperationsOutcomeParser as TokenOperationsOutcomeParser,
  export_TokenTransfer as TokenTransfer,
  export_Transaction as Transaction,
  export_TransactionComputer as TransactionComputer,
  export_TransactionEventsParser as TransactionEventsParser,
  export_TransactionWatcher as TransactionWatcher,
  export_TransactionsFactoryConfig as TransactionsFactoryConfig,
  export_TransferTransactionsFactory as TransferTransactionsFactory,
  export_U16Type as U16Type,
  export_U16Value as U16Value,
  export_U32Type as U32Type,
  export_U32Value as U32Value,
  export_U64Type as U64Type,
  export_U64Value as U64Value,
  export_U8Type as U8Type,
  export_U8Value as U8Value,
  WebWalletUrlParamsEnum,
  formatAmount,
  parseAmount
};
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@walletconnect/utils/dist/index.cjs.js:
  (**
  * [js-sha3]{@link https://github.com/emn178/js-sha3}
  *
  * @version 0.8.0
  * @author Chen, Yi-Cyuan [emn178@gmail.com]
  * @copyright Chen, Yi-Cyuan 2015-2018
  * @license MIT
  *)
*/
